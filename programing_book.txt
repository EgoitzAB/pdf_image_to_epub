 

 

FUNDAMENTOS
DE
PROGRAMACIÓN

José A. Cerrada Somolinos
Manuel E. Collado Machuca

 

(Qeitoria universitaria June

uu Ramón Areces
JOSÉ A. CERRADA SOMOLINOS
Catedrático de Lenguajes y Sistemas Informáticos (UNED)
MANUEL E. COLLADO MACHUCA
Catedrático de Lenguajes y Sistemas Informáticos (UPM)

FUNDAMENTOS
DE PROGRAMACIÓN

Q Editorial universitaria ES

s Ramón Areces

 

 
Índice

 

Introduce oe se e 1
1.1 Máquinas y programas . o 1
1.1.1 Máquinas programables o oooooooo o... 1

1.12 Concepto de cÓMpmto ¿ooo ooo. E

1.13 Concepto de computador. . » someras E
5

5

6

7

 

1.2. Programación e ingeniería de software
.2.1 Programación .... 2
1.2.2 Objetivos de la programación .
13 Lenguajes de programación . 0.00...
1.4 Compiladores e Intérpretes... . SES

 

   

 

 

 

  

 

 

 

9

1.5. Modelos abstractos de cómputo co El
15.1 Modelo funcional... 0... ... 12
1.5.2 Modelo de flujo de datos 13
1.5.3. Modelo de programación lógica . s 15
1.5.4 Modelo imperativo... .<oo.ocooooo.... ve 16

16 Elementos de la programación imperativa... 0... 19
1.6.1 Procesador, entorno, acciomes - . 002.0... 19
1.62. Acciones primitivas. Acciones compuestas - --. .. > 20
1.6.3. Esquemas de acciones - oo 2oooo cocos 21

1.7 Evolución de la programación .... sere as El
17.1 Evolución comparativa Hardware/Sofoware -. .... 072 21
1.7.2 Necesidad de metodología y buenas prácticas . . . . 22

 

 

E Elementos básicos de programación ...........
2.1 Lenguaje Ck ..... Sica E DS ¿ES
2.2 Notación BNF . LES ES
2,3. Valores Y tÍDOS ooo ooo ooo
2.4 Representación de valores constantes

2.4.1 Valores numéricos enteros

 

   

 
viii Fundamentos de programación

 

 

  

2.4.3 Caracteres 31
2.44 Cadenas de caracteres (strings) 31
2.5 Tipos predefinidos . pS 32
2.5.1 El tipo entero (int) .....-. 33
.5.2. El tipo real (Eloat) ..... > 35

  

2.5.3. El tipo carácter (char) .-.... squas pues de
2.6 Expresiones aritméticas... ..-.+ 39
2.7. Operaciones de escritura simples + . + - « a
2.7.1 El procedimiento printf -... oa 42

 

  
        

2.8 Estructura de un programa completo . 45
2.8.1 Uso de comentarios 46
2.8.2 Descripción formal de la estructura de un programa 46

2.9 Ejemplos de programas . 47

1 Escribir una fecha . 2 47
2.9.2. Suma de números consecutivos . h 48
2.9.3 Área y volumen de un cilindro ...-... a 49

 

E Constantes y Variableg

3.1 Identificadores . .
3.2 El vocabulario de CE .
3.3 Constantes... o
3.3.1 Concepto de constante. 0...
3.32. Declaración de constantes con nombre
>
3.4.1 Concepto de variable 00 02.
3.4.2. Declaración de variables >
3.43. Uso de variables. Inicialización - . . <>.
3.5 Sentencia de asignación - ooo ooooo.o...
3.5.1. Sentencias de autoincremento
3.52 Compatibilidad de tipos . 3.6 Operaciones de lectura simple...
3.6.1 El procedimiento scanf . .
3.62 Lectura interactiva... ..-3.7. Estructura de un programa con declaraciones —.... +++
3.8 Ejemplos de programas ESE EOS
3.8.1 Ejemplo; Conversión a boa, minutos Segundos
8.2 Ejemplo: Área y volumen de un cilindro .
3.8.3 Ejemplo: Realización de un recibo . . . . 
 

   

   

 

 

   
 

 

 

 

 

lí Metodología de Desarrollo de Programas (1)...
4.1 La programación como resolución de problemas.

 

 
Índice ix

 

 

 

 

 

   

 

4.2 Descomposición en subproblemas ........... oo. TA
4.3. Desarrollo por refinamientos sucesivos 00.0. 76
1. Desarrollo de un esquema secuencial... ... - 76

4.3.2 Ejemplo: Imprimir la silueta de una silla... 0. 79

4.4. Aspectos de estilo ...... z ; 80
4.4.1 Encolumnado , a 80
4.42 Comentarios. Documentación del refinamiento... .. . 81
4.4.3 Elccci de nombres . . VIE 85
4.44. Uso de letras mayúsculas y mintsculas AS
4.4.5 Constantes con mOmbre . oo 0.0 ooo o... 89

4.5 Ejemplos de programas ... . 9
4.51. Ejemplo: Imprimir la figura de un árbol de navidad 9

 

4.5.2. Ejemplo: Calcular el costo de las baldosas... . + 92

 

  

 

 

4.5.3. Ejemplo: Calcular los días entre dos fechas... 93

. - 97

5.1 Programación estructurada ooo ooo... ese 97
5.1.1 Representación de la estructura de un programa 98
5.1.2 Secuencia . . 99
5.1.3 Selección - 100
1.4 Tteración . 100
15. Estructuras anidadas. - 101

   

5.2 Expresiones condicionales . +... 0 00... oococoo coo... 101

 

 

  

5.3. Estructuras básicas en C£ - - 106
5.31. Secuencia - 106
DE Secada q enana os 1 - 106
5.3.3 Sentencia WHILE . 000000000. o. + - 109
5.34 Sentencia FOR ¿000 .0.. e - 10

5.4 Ejemplos de programas .... o... .... + 112

4.1 Ejemplo: Ordenar tres datos... 0.0... Z 112
5.4.2. Ejemplo: Escribir un triángulo de dígitos + 114
5.4.3. Ejemplo: Elaboración de tickets y resúmenes - 116

E Metodología de Desarrollo de Programas Ss YA

 

 

6.1. Desarrollo con esquemas de selección e iteración . - 19
6.1.1 Esquema de selección . . A
6.1.2 Esquema de iteración ooo ooo. 0.... 2.0 1D

6.2 Ejemplos de desarrollo con esquemas areas 1
6.21 Ejemplo: Imprimir el contorno de un triángulo .-... . 123
6.2.2 Ejemplo: Imprimir el triángulo de Floyd ooo 129

6.3 Verificación de programas... ooo ooo... - 135

 

 
x Fundamentos de programación

 

 

    

    

   

 

 

       

  

 

   

  

       

   

 

 

6.3.1 Notación lógico-matemática . . . + 136
6.3.2 Corrección parcial y total .... s - 136
63.3. Razonamiento sobre sentencias de asignación - . 187
6.34. Razonamiento sobre el esquema de selección «188
6.3.5 Razonamiento sobre el esquema de iteración:
terminación. ...... eS SET . 140
6.4 Eficiencia de programas. Comple + 142
6.4.1 Medidas de eficiencia + 142
6.4.2. Análisis de programas . - 143
6.4.3. Crecimiento asintótico . - 145
Ejercicios sin resolver - 1 . 147
[Funciones y Procedimiento: «151
7.1 Concepto de subprograma . 161
7.2. Funciones . + 164
7.21. Definición de funciones 154
7.22 Uso de funciones o ooooooooococ 156
7.2.3. Funciones predefinidas + 157
7.24 Funciones estándar . . 158
7.3. Procedimientos - 159
7.3.1 Definición de procedimientos . - 160
7.3.2. Uso de procedimientos . . - 161
7.33. Procedimientos estándar - 162
7.4 Paso de argumentos . 0.0.0... - 162
7.4.1. Paso de argumentos por valor , - 162
7.4.2. Paso de argumentos por referen - 163
7.5 Visibilidad. Estructura de bloques . - 165
7.6 Recursividad de subprogramas . . . - 167
7.7 Problemas en el uso de subprogramas - 168
7.1.1 Uso de variables globales. Efectos secundarios - 169
7.7.2. Redefinición de elementos . ML
7.7.3. Doble referencia... - 173
7.8 Ejemplos de programas . . o... 174
7.5.1 Ejemplo: Raíces de una ecuación de segundo grado... 174
7.82 Ejemplo: Ordenar tres valores a 0 - 176
7.83 Ejemplo: Perímetro de un triángulo . - 178
8 [Metodología de Desarrollo de Programas (II) ........ 181
sl mas abrizaciós % um ws 181
81.1 Especificación y realización . . . 182

  
Índice xi

 

8.1.2 Funciones. Argumentos uiv:e
8.1.3. Acciones abstractas. Procedimientos a e
8.2 Desarrollo usando abstracciones +... 0000... - + 188
8.2.1 Desarrollo descendente ...... sg 188
8.2.2 Ejemplo: Imprimir la figura de un árbol de navidad... . 189

   

186

 

 

 

 

   

 

 

   

       

       

   

 

  

 

  

8.2.3. Ejemplo: Imprimir una tabla de números primos . ..... . 196
8.2.4 Reutilización ....... ases - 199
825 Ejemplo: Tabular la serie de Fibonacci... 0... 200
8.2.6. Desarrollo para reutilización ..... coo 208
8.2.7 Desarrollo ascendente ooo ooo 22... 206
8.3 Programas robustos -...... 210
8.3.1 Programación a la defensiva. 210
8.3.2. Tratamiento de excepciones... ooo ooooo00 0... 213
Def ión de ti .... ........ 219
9.1 Tipos definidos ys o -- 219
9.2 Tipo emumerado poo es pu aes DL
9.2.1 Definición de tipos enumerados ..... ... . di 299
9.2.2. Uso de tipos enumerados ........ ace «22
9.3 Eltipo predefinido bool .....ooooocoooooo 0.2... 225
9.4 Tipos estructurados... 0... a 226
9.5 Tipo formación y su necesidad ooo 0.0... 0 187
9.0 Tipo vector UR 40) 7 05 9 usa DOS
9.6.1 Declaración de vectores e 229
9.62 Inicialización de un vector....... ss 281
9.6.3. Operaciones con elementos de vectores vas DL
9.6.4 Operaciones globales con vectores... 0.0.0.0... 282
9.6.5. Paso de argumentos de tipo vector... .. 0. 18
9.7. Vector de caracteres: Cadena (string) sue 288
9.8 Tipo tupla y su necesidad... ooooocooooocooo. +. 238
9.9 Tipo registro (struct) sa « 288
9.9.1 Definición de re: - 240
9.9.2 Variables de tipo registro y su ooo. 241
9.9.3. Uso de registros racer y Dd
9.10 Ejemplos de programas... . 243

   

9.10.1 Ejemplo: Cálculo del día de la semana de una fecha . . . 243
9.10.2 Frases palíndromas . po dem ez ue DAS
9.103 Ejemplo: Cálculos con fracciones ..... . - 250

10 Ampliación de estructuras de contro] .............. 255

10.1 Estructuras complementarias de iteración . ...... + 255

 

 

 

 

 

 

 
 

    

      

  

   

  

 

xi Fundamentos de programación
10.1.1 Repetición: Sentencia DO . se a. res ME

10.1.2 Sentencia CONTINUE -- 258

10.2 Estructuras complementarias de selección ++ 258
102.1 Sentencia SWITOH . «. 259

10.3 Equivalencia entre estructuras . +. - 263
10.3.1 Selección por casos. . - 263

10.3.2 Bucle con contador - 264

103.3 Repetición 265

10.4 Ejemplos de programas oa . 265
10.41 Ejemplo: Imprimir tickets de comedor - - << + - 265

10.42 Ejemplo: Gestión do tarjetas de embarque 268

10.4.3 Ejemplo: Calculadora ...... +... +... - 273
Ejercicios sin resolver - II o... .oooooooomooromoor.o. 281
. 285
11.1 Argumentos de tipo vector abierto. . ¿20 cooooooro oo: 289
11.1. Ejemplo: Contar letras y dígitos -- 287

11.2 Formaciones anidadas. Matrices so 288
11.21 Declaración de matrices y uso de sus elementos - 289

112.2 Operaciones con matrices - 290

11.2.3 Ejemplo: Contrastar una imagen . - 292

11.3 El esquema unión . 295

   

113.1 El tipo union y ERIN E, ERSESA
11.3.2 Registros con variantes 0000 oo cocoa coo 288

   

  

      

 

 

 

 

 

 

     

 

11.4 Esquemas de datos y esquemas de acciones . 299
11.5 Estructuras combinadas... +0. oooorororcorooos 300
11.5.1 Formas de combinación ... oo 0o0ococo.oo oo 301

115.2 Tablas . - 303

11.53 Ejemplo: Gestión de tarjetas de embarque + 305

2 Esquemas típicos de operación con formacionod ....... 315
12.1 Esquema de recorrido . .  - - - 316
12.1.1 Recorrido de matrices 318

12.12 Recorrido no lineal . . 319

12.2 Búsqueda secuencial... .. 321
12.3 Inserción me coooccrzos 322
12.4 Ordenación por inserción directa , 324
125 Búsqueda por dicotomía 3 osea e
12.6 Simplificación de las condiciones de contorno - ++ +++ <<... 328
12.6.1 Técnica del centinela. o 0200 0o0oooooo.o.- 328

 
Índice adi

 

12.6.2 Matrices orladas .. 0...
12.7 Ejemplos de programas . .

 

   

12.7.1 Ejemplo: Sopa de letras ........ 3
12.7.2 Ejempl Imprimir fechas en Orden... o... .o.o.o. 338
12.7.3 Ejemplo: Recortar una imagon .......... 345

 

 

 

 

[ES Punteros y variables dinámic:
13.1 Estructuras de datos no acotadas
13.2 La estructura secuencia... .....-.
13.3 Variablos dinámicas o... o...

13.3.1 Punteros 5%

13.3.2 Uso de variables dinámicas 13.4 Realización de secuencias mediante punteros .....

13.4.1 Operaciones con secuencias enlazadas

13.4.2 Ejemplo: Leer números y escribirlos en orden
13.5 Punteros y paso de argumentos +... 0... .

13.5.1 Paso de punteros como argumentos

13.5.2 Paso de argumentos mediante punteros

13,5.3 Ejemplo: Leer múmeros y escribirlos en orden .. . 13.6 Punteros y vectores on C y C++

13.6.1 Nombres de vectores Como punteros +. ....

13.6.2 Paso de vectores como punteros

13.6.3 Matrices y vectores de punteros

 

 

 

  

 

 

 

 

 

[LA Tipos abstractos de datod +... 0... ...o. oo EF
14.1 Concepto de tipo abstracto de datos (PAD) --..... 5 5 87%
14.2 Realización de tipos abstractos en CE . 379

 

14.2.1 Definición de tipos abstractos como tipos registro (struct)379

 

 

14.22 Ocultación .......... ses aurea se B08
142.3 Ejemplo: Imprimir fechas en orden... . . mona. 386

14.3 Metodología basada en abstracciones... 0... se a eos BDO
14.3.1 Desarrollo por refinamiento basado en abstracel 392

14.4 Ejemplo: Dibujar una Curva-C oo ooooococoocooo 0 395
[5 Mádul A A 401

 

 

   

 

   

 

 

 

10.1 Concepto de módulo. - - Ra % 401
15.1.1 Especificación y realización . . 4 +. 402
15.1.2 Compilación separada... o... .... eric 208
15.13 Descomposición modular <<<... us sra es 40d

15.2 Módulos en Ct 3 5 405
15,24 Proceso de compilación $ - 406

   

 

 
xiv Fundamentos de programación

 

   

  

 

 

  

 

 

 

 

 

  

 

    

 

      

 

    
 

 

 

152.2 Módulo principal . - 407
152.3 Módulos no principales. + + 407
152.4 Uso de módulos - 410
152.5 Declaración y definición de elementos públicos -- 411
152.6 Conflicto de nombres en el ámbito global. . y «412
15.2.7 Unidades de compilación en CE... .... sñ, Add,
1528 Compilación de programas modulares. Proyectos - . +. - 415

15.3 Desarrollo modular basado en abstracciones z s e de
15.3.1 Implementación de abstracciones como módulos ..... 417
15.3.2 Dependencias entre ficheros. Directivas . . . . 422
15.3.3 Datos encapsulados . << .0.<0..<.<<.. - 423
153.4 Reutilización de módulos . +... ++ 429
Ejercicios sin resolver - III... ooo 0.oooooooooor +... 433
[A Sintaxis de CE .J......... 435
A.1 Unidad de compilación . . . - 436
A.2 Directivas de programa . - . 436
A.3 Declaraciones globales . . . . + 436
A.4 Declaraciones de interfaz... + 437
A.5 Constantes > al
A. Tipos ales + 487
A.7 Variables... + 438
A.S Subprogramas . . - 488
A.9 Bloque de código .... 439
A.10Declaraciones de bloque . - 439
A.11 Sentencias ejecutables . . ... 439
A.12Expresiones . 440
A.13Elementos básicos . . ... + . 441
A.l4Índice de reglas BNF .... . 442
[E Manual de Estild 445
B.1 Aspectos generales . 446
B.1.1 Sintaxis . 446
B.12 Encolumnado - 446
B.1.3 Comentarios ....+ - + 446
B.1.4 Identificadores .... . «447

B.2 Declaraciones - 447
B.2.1 Constantes ... . . 448
B.2.2 Tipos de datos ... . 448
B.23 Variables + 450

  

 
 

B.2.4 Subprogramas .....-
B.25 ¡gos isacitadariós
B.3 Sentencias ....
B.4 Expresiones ...
B.5 Punteros
B.6 Módulos

C:1 Operadores numéricos . C.2 Operadores de comparación...
C.3 Operadores lógicos .......C.4 Colecciones... 0002022.
C.5 Cuantificadores
C.5 Expresiones condicionales

Bibliografía ....... PA RR a RA 461

     

455

 

 

    

     
Prólogo

Objetivos

El objetivo fundamental de este libro es introducir de manera progresiva y
sistemática na correcta metodología para la programación de computadores.
Las materias que se cubren son las que se necesitan conocer en un curso de
primer nivel de programación. Además, a lo largo del libro se van introduciendo de forma progresiva las estructuras y herramientas necesarias en cada
momento y que están disponibles en cualquicr lenguaje de programación de
propósito general. No se ha considerado adecuado presentar un lenguaje en
su totalidad dado que las estructuras no utilizadas quedan fuera del alcance
de este libro.

El contenido ha sido pensado como libro de texto para una asignatura de
Fundamentos de Programación del primer cuatrimestre del primer año de un
Grado en Informática o similares dentro del marco de la UNED. Por tanto, se
cuidan de manera espocial los aspectos específicos de la enseñanza a distancia.
Se trata de introducir los conceptos de manera progresiva, poco a poco, de
manera que el alumno pueda ir avanzando a su ritmo. Cada concepto que so
introduce se acompaña de las técnicas necesarias para su inmediata aplicación
y ejemplos ilustrativos.

En este libro se utiliza como vehículo para la enseñanza de la programación
el lenguaje C£ (lóaso C-más-menos) que está constituido por un subconjunto
del vocabulario de los lenguajes C y C++. Por lo tanto, cualquier programa
escrito en el lenguaje Ci se podrá editar, compilar y ejecutar en un entorno
de desarrollo para C/C++. Se considera muy importante usar un lenguaje
real para que el alumno acceda de manera natural e inmediata al computador.
Esto permite al alumno comprobar en la práctica que los ejemplos propuestos
funcionan.

 

 

 

Con la definición del lenguaje C2 se ha buscado la creación de un lenguaje
que facilite la enseñanza do la programación y que también se pueda utilizar
xvii Fundamentos de programación

 

en el desarrollo de cualquier aplicación real. Las ventajas del lenguaje Ct se
pueden concretar en las siguientes:

+ Es un lenguaje bien estructurado: que ha sido pensado para aplicar la
metodología de programación estructurada, en sentido amplio. Los lenguajes C/C++ son excesivamente complejos para un primer curso do
programación y en algunas ocasiones sus sentencias resultan complejas,
ambiguas y poco claras. En el lenguaje C£ no se incluyen todas las
sentencias de C/C++ y además se imponen ciertas restricciones metodológicas en las sentencias utilizadas.

+ El aprendizaje del lenguaje es relativamente sencillo dado que ha sido
diseñado para la enseñanza de programación.

+ Ct soporta la programación modular y tipos abstractos de datos: ambos paradigmas de programación se consideran muy importantes para
introducir al alumno en una buena metodología de diseño y desarrollo
de programas de cierta complejidad.

+ Las características antes mencionadas permiten que Cé se pueda utilizar
en cursos posteriores de programación. Por ejemplo, para presentar la.
programación orientada a objetos se debería incorporar a GE el concepto
de claso y las estructuras de programación que ya están disponible en
C++

En todo caso, el texto no se limita a enseñar un lenguaje, sino que trata que
el alumno adquiera desde un principio una correcta metodología de programación, independiente del lenguaje utilizado. Así, se considera muy importante
que el alumno adquiera una buena capacidad general de expresarse de manera
formal, con independencia del lenguaje empleado. En todo momento se insiste
en las técnicas de desarrollo por refinamiento progresivo.

 

 

Por otro lado, los desarrollos de grandes aplicaciones nunca los realiza un único
programador. En este texto se consideran fundamontal el empleo de buenas
prácticas de ingeniería de software aplicadas a la programación. Cualquier
empresa o equipo de desarrollo de software debe disponer antes del inicio de
cada desarrollo de un “Manual de Estilo” para lograr la adecuada claridad,
homogeneidad y mantenibilidad de los programas. El “Manual de Estilo” que
se propone en este texto recopila un conjunto de buenas prácticas de programación que el alumno deberá seguir incluso para la realización de programas
sencillos,

 
Prólogo xix

 

¿A quién va dirigido el texto?

En principio, se trata de un texto pensado para una asignatura de Fundamentos de Programación del primer curso de un Grado en Informática o similares;
por tanto va dirigido a los alumnos de primer año de estas carreras.

 

Sin embargo, podrá ser usado como texto de introducción a la programación
por cualquier otra persona interesada en este tema. Los requisitos que se
consideran necesarios para poder seguir adecuadamente el contenido del texto
son los siguientes;

+ Conocimientos generales de matemáticas, en especial de formalismos ale
gebraicos.

+ Capacidad para seguir un razonamiento lógico.

+ Capacidad de organización.

+ Aptitud para expresarse formalmente (dominio del lenguaje).

Metodología

Para un correcto aprovechamiento del contenido del curso es imprescindible
¿que el alumno tenga acceso a un computador con el compilador de CE. En el
Manual de Prácticas asociado a este libro se dan las pautas para que el alumno
pueda instalar y utilizar un entorno de programación configurado y adaptado
especialmente para verificar la sintaxis de C+ y que inmediatamente procede
a compilar el programa con un compilador de C++. Además, el entorno
de programación dispone de una herramienta para formatear el programa de
acuerdo con las recomendaciones del "manual de estilo” de esto libro.

 

Conviene que el alumno compruebo en el entorno de programación el correcto
funcionamiento de algunos los ejemplos descritos en cada capítulo para someterlos a crítica. Esto le permitirá adquirir una capacidad de análisis previa a
las tareas de diseño de sus propios programas. A continuación convendrá que
el alumno realice los ejercicios propuestos también en el computador, y que
compruebo igualmente su funcionamiento. En general no existe una solución
ánica para un mismo problema. La solución debe ser examinada a posterioTi para analizar además del correcto funcionamiento también los aspectos de
claridad y estilo.

 
Tema 1

Introducción

El objetivo de este tema es introducir los conceptos generales, y dar una panorámica de la programación que permita posteriormente situar en el contexto
adecuado las técnicas y metodologías que se expondrán en el resto del libro.

Especialmente importante es la presentación de diferentes modelos abstractos
de cómputo, para poner de manifiesto que la programación imperativa, aunque
sea la más extendida, no constituye la única manera de representar programas,
y que no hay que identificar el concepto de programa con el de secuencia de
órdenes.

1.1 Máquinas y programas

Intuitivamente podemos asociar el concepto de máquina a un dispositivo o
instrumento físico capaz de realizar un cierto trabajo u operación. El concepto
puede extenderse incluyendo máquinas que, aunque no existan físicamente,
pueden concebirse y describirse con precisión y predecir su comportamiento.
Estas máquinas se denominan máguinas virtuales.

1.1.1 Máquinas programables

En general, las máquinas operan a lo largo del tiempo, por lo que el concepto de
máquina lleva asociado el de un proceso de funcionamiento en el cual diferentes
operaciones se van realizando sucesiva o simultáneamente. Desde el punto de
vista del control de su funcionamiento, podemos clasificar las máquinas en
diferentes tipos.

 
 

2 Fundamentos de programación

 

Las máquinas no automáticas, o de control manual, son gobernadas por un
operador o agente externo que desencadena unas determinadas operaciones en
cada momento. Por ejemplo, una máquina de escribir imprime las letras o.
mueve el papel de acuerdo con las teclas pulsadas por el mecanógrafo.

Las máquinas automáticas actúan por sí solas, sin necesidad de operador, aunque pueden responder a estímulos externos. Por ejemplo, un ascensor automático gobierna por sí mismo los movimientos de subida y bajada incluyendo
cambios de velocidad, apertura y cierre de puertas, etc., de forma coordinada,
respondiendo a los estímulos de los botones de llamada o envío a un piso dado

El funcionamiento de una máquina automática puede depender de la forma
en que está construida, es decir, de los elomentos que la componen y la manera en que están conectados entre sí. En este caso el comportamiento de la
máquina será fijo, en el sentido de que a unos doterminados estímulos externos responderá siempre de la misma manera. Esto ocurre en el ejemplo del
ascensor.

Otras máquinas automáticas se denominan programables , y su comportamiento no es siempre el mismo. Una máquina programable (figura 1.1) se puede
concebir como una máquina base, de comportamiento fijo, que se completa
con una parte modificable que describe el funcionamiento de la máquina base.
Esta parte modificable se denomina programa.

 

 

>
Máquina Base
Componentes Máquina Completa

Figura 1.1 Componentes de una máquina programable.

Aunque habitualmente no se considero como tal, podemos analizar un reproductor de CD como una máquina programable, identificando el CD (reemplazable) con el programa. Incluso podemos establecer la siguiente seric de
ejemplos:

+ Piano: máquina manual de producir música,

+ Caja de música: máquina automática de producir música (fija).

+ Reproductor de CD: máquina programable de producir música (variable)
 

Introducción 4

Dependiendo de cuál sea el programa que gobierne su funcionamiento, una
máquina programable respondorá a los estímulos externos de una forma o
de otra. Una máquina programable se comporta, por tanto, como diferentes
máquinas particulares, en función del programa utilizado.

ul

y y

Programa A Programa B

  

Máquina Base| <= [Máquina Base] ==> | Máquina Base
Máquina A Máquina B
Figura 1.2 Una máquina programable puede comportarse como diferentes máquinas.

Cuando una máquina programable opera bajo control de un programa determinado, se dice que el programa se ejecuta en dicha máquina.

 

1.1.2 Concepto de cómputo

La palabra cómputo es sinónimo de cuenta o cálculo. Si consultamos un diccionario podemos encontrar una definición más elaborada:

 

Cómputo (del latín computum ). Determinación indirecta de una cantidad
mediante el cálculo de ciertos datos.

En esta definición se puede apreciar que un cómputo es una operación de
tratamiento de información. A partir de una información conocida se obtiene
otra nueva como resultado de unos cálculos. En informática y de una forma
genoral puede identificarse el concepto de cómputo con el de tratamiento de la
información.

Un cómputo puede expresarse de diferentes maneras. Por ejemplo, mediante
una fórmula o expresión matemática, tal como

34x5+8x7
Un cómputo se concibe también como un proceso a lo largo del cual se van
realizando operaciones o cálculos elementales hasta conseguir el resultado final.

En el ejemplo anterior se encuentra implícito dicho proceso. El resultado se
podría obtener mediante los siguientes cálculos elementales:

 
4 Fundamentos de programación

 

1. Producto de 34 por 5, obteniendo 170.
2. Producto de 8 por 7, obteniendo 56.
3. Suma de los resultados anteriores, obteniendo 226.

 

 

En la exprosión matemática usada como ejemplo están implícitos estos cálculos
elementales, así como el orden en que pueden ser realizados. Los cálculos 19
y 2 podrían realizarse en cualquier orden, pero el cáleulo 32 ha de realizarse
necesariamente después de los otros dos.

 

1.1.3. Concepto de computador

La máquina programable por excelencia es el computador. Un computador se
define como una máquina programable para tratamiento de la información, es
decir, un computador es (¡obviamente!) una máquina para realizar cómputos.

Un programa de computador es, por tanto, una descripción de un cómputo. Al
mismo tiempo nos encontramos con que un programa es también una descripción del comportamiento de una máquina, y podemos así considerarlo como
una máquina virtual cuando convenga.

Un computador, como máquina programable que es, posce unos elementos
fijos (máquina base) y otros modificables (programa). De forma simplificada
podemos asociar los elementos fijos a los dispositivos físicos del computador,
que constituyen el hardware, y los elementos modificables a las representaciones
de los programas en sentido amplio, que constituyen el software.

  

Los computadores actuales corresponden a un tipo particular de máquinas
programables que se denominan máquinas de programa almacenado. En estas
máquinas la modificación del programa no implica un cambio de componentes
físicos de la máquina, sino que estas máquinas poseen una memoria en la cual
se puede almacenar información de cualquier tipo, debidamente codificada, y
esta información incluye tanto los datos con los que opera la máquina como
la representación codificada del programa. El programa es, por tanto, pura
información, no algo material.

  

La estructura general de un computador se puedo representar como se mmuestra en la figura 1,3. La memoria almacena datos y programas. Los dispositivos de entrada/salida permiten intercambiar información con el exterior, y
el procesador es el elemento de control, que realiza operaciones elementales
de tratamiento de la información interna, u operaciones de entrada o salida
de información al exterior, de acuerdo con los códigos del programa que están
almacenados en la memoria.
 

 

Memoria

   

Datos
de entrada

 

> Resultados
Entrada/Salida [4 caros

Figura 1.3 Esquema gencral de wn computador.

1.2 Programación e ingeniería de software

De las explicaciones anteriores se deduce que una máquina programable, y
en particular un computador, es totalmente inútil si no dispone del programa
adecuado, Para realizar un determinado tratamiento de información con ayuda
de un computador habrá sido necesario:

(a) Construir el computador (hardware)

(b) Taear y desarrollar el programa (software).

(e) Ejecutar dicho programa en el computador.
Sólo la última fase (c) es habitualmente realizada por el usuario. Las dos
primeras corresponden a los profesionales de la informática: la fase (a) a los
fabricantes de hardware y la (b) a los de software. En los siguientes apartados
se analiza la actividad de desarrollo de software.

 

1.2.1 Programación

La labor de desarrollar programas se denomina en general programación. En
realidad este término se suele reservar para designar las tareas de desarrollo
de programas en pequeña escala, es decir, realizadas por una sola persona. El
desarrollo de programas complejos, que son la mayoría de los usados actualmento, exige un equipo más o menos numeroso de personas que debe trabajar
de manera organizada. Las técnicas para desarrollo de software a gran escala
constituyen la ingeniería de software.

 

Programación e ingeniería de software no son disciplinas independientes, sino
complementarias. El desarrollo de software en gran escala consiste esencialmente en descomponer el trabajo total de programación en partes independientes que pueden ser desarrolladas por miembros individuales del equipo.
La ingeniería de software se limita a añadir técnicas o estrategias organizativas a las técnicas básicas de programación. El trabajo en equipo es, on último
extremo, la suma de los trabajos realizados por los individuos.

 
0 Fundamentos de programación

 

1.2.2. Objetivos de la programación

La ingeniería de software excede del ámbito de este libro. En él nos centraremos sólo en la labor de programación, correspondiente a la preparación de
programas medianos o pequeños, realizables por una sola persona. No obstante, las técnicas de programación han de establecerse con el objetivo de ser una
base adecuada para la ingeniería de software. Entre los objetivos particulares
de la programación podemos reconocer los siguientes:

+ CORRECCIÓN: Es evidente que un programa debe realizar el tratamiento esperado, y no producir resultados erróneos. Esto tiene una
consecuencia inmediata que no siempre se considera evidente: antes de
desarrollar un programa debe especificarse con toda claridad cuál es el
funcionamiento esperado. Sin dicha especificación es inútil hablar de
funcionamiento correcto.

+ CLARIDAD: Prácticamente todos los programas han de ser modificados
después de haber sido desarrollados inicialmente. Por esta razón es fundamental que sus descripciones sean claras y fácilmente inteligibles por
otras personas distintas de su autor, o incluso por el mismo autor al cabo
de un cierto tiempo, cuando ya ha olvidado los detalles del programa.

+ EFICIENCIA: Una tarea de tratamiento de información puede ser programada de muy diferentes maneras sobre un computador determinado,
es decir, habrá muchos programas distintos que producirán los resultados descados. Algunos de estos programas serán más eficientes que otros.
Los programas eficientes aprovecharán mejor los recursos disponibles y,
por tanto, su empleo será más económico en algún sentido.

Estos y otros objetivos resultan a veces contrapuestos. Quizá el ejemplo más
intuitivo sea la dualidad entre claridad y eficiencia. Para ser claros los programas han de ser sencillos, pero para aprovechar los recursos de manera eficiente
en muchos casos hay que introducir complicacions que hacen el programa. más
difícil de entender.

Si so trata de establecer una importancia relativa entre los distintos objetivos,
habría que considerar como prioritaria la corrección. Piénsese, por ejemplo,
que un programa de contabilidad no es aceptable si no calcula correctamente
Jos saldos de las cuentas.

A continuación debe perseguirse la claridad, que como ya se ha indicado es
necesaria para poder realizar modificaciones, o simplemente para poder certificar que el programa es correcto. En realidad el objetivo de claridad va ligado
al de corrección. Es prácticamente imposible asegurar que un programa es
correcto si no puede ser entendido claramente por la persona que lo examina.

 
Introducción 7

 

Tal como se ha dicho antes, la claridad facilita la tarea de realizar modificaciones cuando las necesidades así lo exijan. Puede afirmarse que esto ocurre
siempre con todos los programas que tienen un cierto interés.

Finalmente ha de atenderse a la eficiencia. Este objetivo, aunque importante,
sólo suele ser decisivo en determinados casos. En muchas situaciones el anmento de capacidad de los computadores a medida que avanza la tecnología va.
permitiendo utilizar de manera aceptable, desde el punto de vista económico,
programas relativamente menos eficientes.

1.3 Lenguajes de programación

Ya se ha explicado que un computador funciona bajo control de un programa
que ha de estar almacenado en la unidad do memoria. El programa contieno
una descripción codificada del comportamiento descado del computador.

Cada modelo de computador podrá utilizar una forma particular de codificación de programas, que no coincidirá con la de otros modelos. La forma de
codificar programas de una máquina en particular se dice que es su código de
máquina o lenguaje de máquina. La palabra “lenguaje” utilizada habitualmente en el vocabulario informático en español es, en realidad, una transcripción
directa del término inglós “language”, cuyo significado correcto es “idioma”.

  

Un programa codificado en el lenguaje de un modelo de máquina (figura 1.4)
no podrá ser ejecutado, en general, en otro distinto. Si queremos que un
programa funcione en diferentes máquinas tendremos que preparar versiones
particulares en el lenguaje de máquina de cada una de ellas. Evidentemente
¿con ello se multiplica el costo de desarrollo si cada versión se prepara de manera

independiente.
Programa Programa
11 Ea 12 :]
Y y
un 102
Máquina Base Máquina Base

Figura 1.4 Cada computador neccsita programas cn su lenguaje de máquina (LM)
particular.

Por otra parte, los programas en código de máquina son extraordinariamento
difíciles de leer por una persona. Normalmente contienen códigos numéricos
8 Fundamentos de programación

(figura 1.5) sin ningún sentido nemotécnico, y compuestos por millones de
operaciones elementales muy sencillas que en conjunto pueden realizar los
tratamientos complejos que vemos a diario.

 

 

88 94 50 FF 76 0A FF 76 08 9A BA CD 3A 16 BS 01
00 EB EB B8 88 94 50 28 CO 50 9A FA C5 3A 16 ER
ED B8 88 94 50 B8 01 00 FB EF B8 88 94 50 9A 48
D1 3A 16 EB D9 5D CA 0A 00 55 8B EC 83 EC 08 57
56 B8 01 00 50 9A 97 41 9 34 8B D8 8B 47 14 89

Figura 1.5 Fragmento de programa en código de máquina.

Para facilitar la tarea de programación resulta muy descable disponer de formas de representación de los programas que sean adecuadas para ser loídas o
escritas por personas. En particular los lenguajes de programación sirven precisamente para representar programas de manera simbólica, en forma do un
| texto (figura 1.6) que puede ser leído con relativa facilidad por una persona.
Además los lenguajes de programación son formas de representación prácticamente independientes de las máquinas particulares que se vayan a usar.

 

void PintarPlazas(const TipoPlazas P) (

print£Caia");
print£c" A BOC DOE RM;
for (int i = 0; 1 <NunFilas; i++) €
print£("X3q",1+1);
for (int j=0; j < AsientosFila; j++) 4
if (j= Pasillo ) 4
print;
y
i£ (P[i].AsientosOcupalj]
printe( (9%);
) else if (P[i].AsientosOcupa[j]
primtec (Ry;
) else if (P[i].AsientosOcupalj]
print (0%;
J
y
printe(w
,
print"

 

 

 

ocupado) £

 

reservado) 1

 

vacio) £

 

 

,
Figura 1.6 Fragmento de programa en lenguaje C2.
Introducción 9

 

La comparación de los fragmentos de programa de las Figuras 1.5 y 1.6 pone
de manifiesto sin necesidad de más explicaciones la ventaja de usar lenguajes
de programación simbólicos.

1.4 Compiladores e Intérpretes

Un programa escrito en un lenguaje de programación simbólico puede ser
ejecutado en máquinas muy diferentes. Pero para ello se necesita disponer de
los mecanismos adecuados para transformar ese programa simbólico (figura
17) en un programa en el lenguaje particular de cada máquina.

Programa
Le

100 Ry 10 ein
Programa Programa
pa 12
Máquina 1 Máquina 2

Figura 1.7 Un programa en un lenguaje de programación simbólico ha do adaptarse
al lenguaje de cada máquina.

Existen diferentes estrategias para conseguir ejecutar en una máquina determinada un programa escrito en un lenguaje de programación simbólico. Normalmente se basan en el uso de programas especiales que realizan un tratamiento
de la información en forma de texto que representa el programa en el lenguaje
de programación simbólico. Estos programas para manipular representaciones
de programas los denominaremos procesadores de lenguajes.

Un compilador es un programa que traduce programas de un lenguajo de programación simbólico a código de máquina. A la representación del programa
en lenguaje simbólico se le llama programa fuente, y su representación en código de máquina se le llama programa objeto. Análogamente al lenguaje simbólico y al lenguaje máquina se les llama también lenguaje fuente y lenguaje
objeto, respectivamente.

La ejecución del programa mediante compilador exige al menos dos ctapas
separadas, tal como se indica en la figura 1.8. En la primera de ellas se traduce
el programa simbólico a código de máquina mediante el programa compilador.
10 Fundamentos de programación

 

En la segunda etapa se ejecuta ya directamente el programa en código de
máquina, y se procesan los datos y resultados particulares. La compilación
del programa ha de hacerse sólo una vez, quedando el programa en código de
máquina disponible para ser utilizado de forma inmediata tantas veces como
se desee.

Compilador

    

Prog. Fuente|—4» |. Máquina Base
19

|» | Prog. Objeto |
19

   
 

Prog. Objeto
Er”
Máquina Base | 4»

 
  

 

 

Figura L.8 Proceso de un programa en lenguaje fuente (LF) mediante compilador.

Un intérprete es un programa que analiza directamente la descripción simbólica del programa fuente y realiza las operaciones oportunas. El intérprete debe
contener dentro de él los fragmentos de código de máquina de todas las operaciones posibles que se puedan usar en el lenguaje de programación simbólico.
Puede decirse que el intérprete es (o simula) una máguina virtual (Agura 1.9)
cuyo lenguaje de máquina coincide con el lenguaje fuente.

LE
Intérprete
1u
10 Máquina Base
Máquina Base

 

 

Méguina Virtual

Figura 1.9 Un intérprete se comporta como wma máquina virtual cuyo lenguaje es el
lenguaje fuente.

El proceso de un programa mediante intérprete (figura 1.10) se limita a ejecutar directamente el programa on la máquina virtual, es decir, sobre el intérpreto.
Introducción 1

 

 

Figura 1.10 Proceso de un programa en lenguaje fuente (LF) mediante intérprete.

El proceso mediante intérprete es más sencillo, en conjunto, que mediante
compilador, ya que no hay que realizar dos fases separadas. Su principal
inconveniente es que la velocidad de ejecución es más lenta, ya que al tiempo
que se van tratando los datos de la aplicación hay que ir haciendo el análisis
e interpretación de las operaciones descritas en el programa fuente.

1.5 Modelos abstractos de cómputo

Los lenguajes de programación permiten describir programas o cómputos de
manera formal, y por tanto simbólica y rigurosa. La descripción se hace,
naturalmente, basándose en determinados elementos básicos y formas de combinación de estos elementos simples para construir programas tan complicados
como sea necesario.

Existen muchísimos lenguajes de programación distintos que unas veces difieren en aspectos generales y otras simplemente en detalles. Si analizamos estos
lenguajes podremos observar que muchos de ellos utilizan elementos básicos y
formas de combinación similares, aunque representándolos con símbolos diforentes.

Si de un conjunto de lenguajes de programación basados en elementos computacionales similares extraemos los conceptos comunes, obtendremos un modelo
abstracto de cómputo. Este modelo abstracto recoge los elementos básicos y
formas de combinación de una manera abstracta, prescindiendo de la notación
concreta usada en cada lenguaje de programación para representarlos.

Existen diversos modelos abstractos de cómputo, o modelos de programación,
que subyacen en los lenguajes do programación actuales. Entre ellos están la
programación funcional, programación lógica, programación imperativa, modelo de flujo de datos, programación orientada a objetos, etc. Todos estos
modelos son modelos universales, en el sentido de que pueden utilizarse para
describir cualquier cómputo intuitivamente posible,

 
12 Fundamentos de programación

 

Quizá el aspecto más interesante a destacar en este análisis de modelos abstractos de cómputo es que un programa que permita resolver un determinado
problema puede adoptar formas muy diferentes, dependiendo del modelo de
cómputo que se utilico para desarrollarlo. El modelo de programación imperativa es el más extendido, y eso induce a quienes empiezan a estudiar
informática a identificar el concepto de programa con el de socuencia o lista
de órdenes. Sin embargo, como veremos a continuación, existen otras formas
igualmente válidas de representar un programa.

 

1.5.1 Modelo funcional

El modelo de programación funcional se basa casi exclusivamente en el empleo
de funciones. El concepto de función se corresponde aquí de manera bastante
precisa con el concepto de función en matemáticas. Una función os una aplicación, que hace corresponder un clemento de un conjunto de destino (resultado)
a cada elemento de un conjunto de partida (argumento) para el que la función
estó definida.

 

Por ejemplo, la operación de suma de números enteros es una función en que
el conjunto de partida es el de las parejas de números enteros y el de destino
es el conjunto de los números enteros. A cada pareja de enteros se le hace
corresponder un entero, que es su suma.

De forma convencional, representaremos como f(x) al resultado que se obten
drá al aplicar la función f al argumento 2. Por ejemplo, podemos suponer
definidas las funciones de suma, resta y producto de la forma:

Función Resultado

Suma( a, b) a+b

Diferencia a,b) a-b

Producto( a,b) axb
Para describir cómputos complejos, las funciones pueden combinarse unas con
otras, de manera que el resultado obtenido en una función se use como argumento para otra. De esta manera un cómputo tal como

BAX5+8XT
puede representarso de manera funcional de la forma
Sumn( Producto( 34, 5 ), Producto( 8, 7) )

Este es el aspecto que tiene un programa funcional, que será siempre en último
extremo una aplicación de una función a unos argumentos, para obtener un
resultado. El proceso de cómputo, llamado reducción, se basa en reemplazar
Introducción 13

 

progresivamente cada función por el resultado de la misma. Este sistema
de evaluación por sustitución os la base del llamado cáleulo-A. Aplicado al
ejemplo se tendría:

 

Cómputo parcial Expresión / Resultado
> Suma( Producto( 34, 5), Producto(
34x5 Suma( 170, Producto( 8, 7) )
8x7 Suma( 170, 56 )
170 + 56 226

Las explicaciones anteriores se reficren a cómputos en los que sólo intervienen
funciones primitivas, que son las que el computador o máquina abstracta que
ejecuta el programa puedo evaluar de forma directa. La programación funcional pormite la definición por parte del programador de nuevas funciones a
partir de las ya existentes. Utilizando de manera convencional el símbolo
para indicar definición, podremos crear una nueva función, Cuadrado, para
obtener cl cuadrado de un número basándose en el 1so del producto de dos
números.

 

 

Cuadrado( x ) ::

Cuando en un cómputo intervienen funciones definidas, la evaluación se sigue
haciendo por sustitución. El proceso, llamado reescritura, consiste en roemplazar una función por su definición, sustituyendo los argumentos simbólicos
en la definición por los argumentos reales en el cómputo. Por ejemplo, para
evaluar (5 +3)? tendremos:

Producto( x, x )

Cómputo parcial Expresión / Resultado
2 Cuadrado(Suma(5,3)) —

reducir Suma Cuadrado( 8 )

reescribir Cuadrado Producto( 8, 8)

reducir Producto 64

 

1.5.2. Modelo de flujo de datos

En este modelo de cómputo, un programa corresponde a una red de operadores interconectados entre sí. Cada operador lo representaremos gráficamente
mediante un cuadrado con entradas y salidas, y dentro de él el símbolo de la
operación que realiza. Un oporador espera hasta tener valores presentes en
sus cntradas, y entonces se activa él solo, consume los valores en las entradas,
calcula el resultado, y lo envía a la salida. Después de esto vuelve a esperar
que le lleguen nuevos valores por las entradas.

 
o

1 Fundamentos de programación

 

34-»]
x
5 -». PL
8
xp”
71
Figura 1.11 Red de flujo de datos.

 

 

 

 

 

 

 

 

 

Por ejemplo, la expresión 34 x 5 +8 x 7 puede ser calenlada por la red de la
figura LIL.

El cómputo so realiza durante la evolución de la red, tal como se indica en
la figura 1.12. Cuando la evolución termina, el resultado está presente en la
salida de la derecha.

 

y

x L170

Lar
1 Ho ¿pr

Paso 1 Paso 2
Figura 1.12 Evolución de la red de fijo de datos.

 

 

 

$

 

+b + [226

 

 

 

 

 

 

 

 

6

 

 

 

 

 

Una red de flujo de datos puede organizarse de manera que opere de forma
iterativa, obteniendo no ya un resultado sino una serio de ellos. Por ejemplo,
la red de la figura 1.13 produce la serie de números naturales, a base de reciclar
sobre sí mismo un operador de incremento. Las líneas verticales representan
operadores de duplicación o mezcla de valores.

 

+1
o 1234,

 

Figura 1.13 Generación de na serie de números.

Esta red no termina nunca de evolucionar. Añadiendo operadores especiales
de bifurcación se puede conseguir que se detenga al llegar a un resultado
adecuado,
Introducción 15

 

1.5.3. Modelo de programación lógica

Este modelo abstracto de cómputo corresponde plenamente a lo que se denomina programación declarativa. Un programa consiste en plantear de manera
formal un problema a base de declarar unn serie de elementos conocidos, y
luego preguntar por un resultado, dejando que sea la propia máquina la que
decida cómo obtenerlo.

En programación lógica los clementos conocidos que pueden declararse son
hechos y reglas. Un hecho es una relación entre objetos concretos. Una regla
es una relación general entre objetos que cumplen ciertas propiedades. Una
relación entre objetos la escribiremos poniendo el nombre de dicha rel:
luego los objetos relacionados entro paréntesis. Por ejemplo:

 

 

Hijo( Juan, Luis )

significaría que Juan es hijo de Luis. Si tenemos el árbol genealógico como el
de la figura 1.14

Luis Ana

Felipe Juan Sonia
Figura 1.14 Árbol genealógico.

podremos declarar (prescindiendo del sexo) los hechos siguientes:

Hechos.
Mijo( Felipe, Luis )
Hijo( Juan, Luis )
Hijo( Sonia, Luis )
Hijo( Felipe, Ana )
Hijo( Juan, Ana )
Hijo( Sonia, Ana )

Para realizar una consulta escribiremos el esquema de un hecho en que alguno
de los elementos sea desconocido. Esto lo indicaremos usando nombres de
incógnitas en minúscula, para distinguirlos de los nombres de elementos conocidos, que en este caso se habían escrito en mayúsculas (en lenguaje Prolog se
usa el convenio contrario). La consulta será respondida indicando todos los
valores posibles que puedan tomar las incógnitas. Por ejemplo:
16 Fundamentos de programación

 

Consulta Respuesta
Thijo(x, Ana) "x= Felipe —
x= Juan
x= Sonia

La verdadera potencia de la programación lógica aparece cuando declaramos
reglas. Al realizar consultas basadas en reglas la máquina realiza automáticamente las inferencias (deducciones) necesarias para responderla. Por ejemplo,
usando el símbolo “:—” para definir una regla, escribiremos:

 

 

Reglas
Hijo( y, x)
Hermano( x, y ) :- Hijo( x, z ), Hijo( y, 2 )

 

La primera regla se limita a nombrar la relación inversa de “hijo”. La segunda
expresa que dos personas son hermanas si son hijas de un mismo padre o
madre. Ahora pueden realizarse consultas como las siguientes:

 

 

 

Consulta Respuesta
Padre( x, Sonia ) Luis
x= Ana
Hermano( x, Felipe ) Felipe
x= Juan
Sonia

 

La sogunda consulta tiene una respuesta aparentemente errónea. Un análisis
detallado nos permite comprobar que el error está en la formulación de la
regla, ya que no se le ha informado a la máquina de que una persona no se
considera hermana do sí misma, Modificando la regla se obtendrá la respuesta
descada.

Reglas

 

Consulta Respuesta
Hormano( x, Felipe) x= Juan

 

1.5.4 Modelo imperativo

El modelo de programación imperativa responde a la estructura interna habitual de un computador, que se denomina arquitectura Von Neumann. Un
 

Introducción 17

 

programa en lenguaje de máquina aparece como una lista de instrucciones u
órdenes elementales que han de ejecutarso una tras otra, en el orden en que
aparecen en el programa. El nombre de programación imperativa deriva del
hecho de que un programa aparece como una lista de órdenes a cumplir.

El orden de ejecución puede alterarse en caso necesario mediante el uso de
instrucciones de control. Con ello se consigue ejecutar o no, o repotir, determinadas partes del programa dependiendo de ciertas condiciones en los datos.

Las instrucciones de un programa imperativo utilizan datos almacenados en
la memoria del computador. Esta capacidad de almacenamiento de valores se
representa en los programas imperativos mediante el uso de variables. Una
variable no tiene aquí el mismo significado que en matemáticas, sino que representa un dato almacenado bajo un nombre dado. Una variable contiene un
valor que puede ser usado o modificado tantas veces como se desee.

 

 

Un programa imperativo se plantea como el cáleulo o modíficación de sucesivos
valores intermedios hasta obtener el resultado £nal. Las instrucciones típicas
de un programa imperativo son las de asignación, que consisten en obtener un
resultado parcial mediante un cálculo elemental que puede ser realizado por la
máquina, y que sc almacena en una variable para ser utilizado posteriormente.

En los lenguajes de programación simbólicos las instrucciones 1 órdenes se
denominan sentencias. En Ct y otros lenguajes similares la sentencia de asi:
nación se representa de la forma

 

variable = expresión
La parte derecha de esta sentencia es una expresión aritmética que puedo
usar variables o valores constantes, así como operadores que estén definidos
en el lenguaje, tales como los correspondientes a las operaciones aritméticas
habituales: suma, resta, ete. Una sentencia de asignación representa una orden
de calcular el resultado de la expresión y luego almacenar dicho resultado como
nuevo valor de la variable.

Usando sólo expresiones simples y varinbles auxiliares, podremos expresar el
cálculo de

34x54+8x7
mediante las sentencias siguientes
La=34x5
2.b=8x7
3. a+b

 

que obtendrán el resultado final en la variable c.

 

 
18 Fundamentos de programación

 

En realidad los lenguajes de programación permiten escribir dircctamente expresiones complejas. El cálculo anterior podría haberse hecho con una sola
sentencia.

L.eo=34x54+8x7

Para mostrar cómo las variables en programación imperativa pueden ir modificando su valor paso a paso hasta obtener el resultado deseado, analizaremos el
siguiente fragmento de programa, que calcula el valor de 5! =1x2x3x4x5. En
este programa se ha supuesto que existen instrucciones REPETIR y HASTA
que permiten programar la repetición controlada de una parte del programa.

 

 

LÉ=t
2.k=1

3. REPETIR
d.k=k+1
5.f=fxk
6. HASTA k ==5

 

Este programa obtiene el resultado final en la variable f. La variable k se
utiliza para ir disponiendo de los sucesivos valores 2, 3, 4, etc. Las instrucciones
3. y 6. controlan la repetición de 4. y 5. La instrucción:

4. k=k+1

 

tiene el significado siguiente: Se calcula el resultado de la expresión k + 1,
usando el valor de k al iniciarse la ejocución de esa instrucción, y el valor
obtenido se almacena de nuevo en k reemplazando el valor anterior. La primera
vez que se ejecuta esa instrucción k tiene el valor 1, asignado inicialmente por
la instrucción 2. Al sumarle 1 se obtiene el valor 2, y la variable k pasa a
tener ahora este nuevo valor. Cada vez que se vuelva a ejecutar la instrucción
4. la variable k incrementará su valor en 1 unidad.

 

El análisis detallado del funcionamiento de un programa imperativo puede
hacerse mediante una traza en la que se van anotando las sentencias o instrucciones de asignación que se van ejecutando sucesivamente, y los valores que
toman las variables inicialmente y tras cada instrucción. En este ejemplo se
tendrá:
Introducción 19

 

 

 

Instrucción £
7

de ? 1
2 1 1
4. 2 1
8: 2 2
4. 3 z
de 3 6
4. 4 6
5. 4 24
4. 5 24
5. 5 120

El programa comienza con valores no definidos (?) para las variables. Termina
Cuando k ha tomado el valor 5, en cuyo caso finalizan las repeticiones y /tiene
el valor 120 = 5.

 

1.6 Elementos de la programación imperativa

La mayoría de los lenguajes de programación actualmente en uso siguen el modelo de programación imperativa. Por esta razón se ha optado en este primer
nivel de enseñanza de programación por seguir dicho modelo. El lenguaje de
programación Ct se utilizará en este libro como herramienta para desarrollar
las ideas generales en ejemplos prácticos realizables en máquina. C2 es un
subconjunto de los lenguajes C y C+-+ que se utilizan habitualmente en desarrollos reales. Además, Ct presenta importantes ventajas para la enseñanza,
por ser un lenguaje bien estructurado, permitir el uso de programación modular, permitir la implementación de tipos abstractos de datos, y ser un primer
paso hacia el uso de lenguajes más evolucionados (y más complicados) como
ocurre con los lenguajes C++, Ada o Java.

 

En el resto de este texto se irán desarrollando las ideas abstractas o generales
de programación, junto con su realización en lenguaje C£. Todo ello en el
marco de la programación imperativa, cuyos elementos abstractos se describen
a continuación.

1.6.1 Procesador, entorno, acciones

Al introducir el modelo de programación imperativa se ha definido un progra
ma, de manera intuitiva, como una lista de órdenes o instrucciones que han
de ir siendo ejecutadas por la máquina en el orden preciso que se indique

 
20 Fundamentos de programación

 

La idea abstracta correspondiente al concepto físico de máquina os el procesador. Defíniremos como procesador a todo agente capaz de entender las órdenes
del programa y ejecutarlas.

El procesador es esencialmente un elemento de control. Para ejecutar las instrucciones empleará los recursos necesarios, que formarán parte del sistema
en el cual se ejecute el programa. Por ejemplo, se necesitarán dispositivos de
almacenamiento para guardar datos que habrán de ser utilizados posteriormento, o dispositivos de entrada-salida que permitirán tomar datos de partida
del exterior y presentar los resultados dol programa. Todos estos elementos
disponibles para ser utilizados por el procesador constituyen su entorno.

 

Las órdenes o instrucciones del programa definen determinadas acciones que
deben ser realizadas por el procesador. Un programa imperativo aparece así
como la descripción de una serio de acciones a realizar en un orden preciso. Las
acciones son la idea abstracta equivalente a las instrucciones de un programa
real.

 

1.6.2 Acciones primitivas. Acciones compuestas

Las acciones que son directamente realizables por el procesador se denominan
acciones primitivas. Estas acciones suclen ser bastante sencillas, incluso on el
caso de programas descritos en lenguajes de programación simbólicos. Enten=
der un programa descrito enteramente a base de acciones primitivas suele ser
muy difícil, por el nivel de detalle con el que hay que analizar cada una de sus
partes, y todas ellas en conjunto.

 

El planteamiento razonable de un programa complejo debe pasar por usar
la idea de abstracción para limitar la complejidad de detalles al estudiar el
programa en su conjunto. Es muy útil usar la idea de acción compuesta como.
abstracción equivalente a un fragmento de programa más o menos largo que
realiza una operación bien definida.

La descripción de un programa en términos de nociones compuestas puede facilitar su comprensión. Por supuesto, al desarrollar el programa habrá sido
preciso describir o descomponer las acciones compuestas cn otras más sen
llas, hasta llegar finalmente a acciones primitivas, que son las que realmente
podrá ejecutar el procesador. Las acciones compuestas son un elemento de
descripción que facilita la comprensión del programa en su conjunto, o de
partes importantes de él, pero no roduce el tamaño total del programa, que
necesariamente deberá ser largo si se han de realizar operaciones complicadas.

   

 
Introducción 21

 

1.6.3. Esquemas de acciones

Una acción compuesta consistirá, tal como se ha indicado, en la ejecución
combinada de otras acciones más sencillas. La manera en la que varias acillas se combinan para realizar una acción complicada se denomina
esquema de la acción compuesta.

 

Una buena metodología de programación exige usar esquemas sencillos y fá
ciles de entender a la hora de desarrollar accionos compuestas. -A lo largo
de este libro se irán introduciendo los principales esquemas de programación
imperativa, junto con recomendaciones para su aplicación en el desarrollo de
programas.

En particular, la llamada programación estructurada sugiero el uso de tres
esquemas generales denominados secuencia, selección e iteración, con los cuales
(junto con la definición de operaciones abstractas) se puede llegar a desarrollar
de forma comprensible un programa tan complicado como sea necesario.

1.7 Evolución de la programación

Las ideas sobre cuál es la manera apropiada de desarrollar programas han
ido evolucionando con el tiempo. Ha habido diversos motivos para ello, que
pasaremos a analizar brevemente.

1.7.1 Evolución comparativa Hardware/Software

Los primeros computadores eran máquinas extraordinariamente costosas, y
con una capacidad que hoy día consideraríamos ridículamente limitada. Sin
embargo en su momento representaban el límite en ln capacidad de tratamiento de información, y hacían posibles determinados trabajos de cálculo
inabordables hasta entonces.

Como consecuencia de ello la finalidad principal de la programación era obtener el máximo rendimiento de los computadores. Los programas se escribían
directamente en el lenguaje de la máquina, o a lo sumo en un lenguaje ensamblador en que cada instrucción de máquina se representaba simbólicamente
mediante un código nemotécnico para facilitar la lectura del programa.

 

No existían ideas abstractas sobre el significado u objetivo preciso de un programa. Simplemente se consideraba que el mejor programa era el que realizaba
el trabajo en menos tiempo y usando el mínimo de recursos de la máquina.
La programación cra, por tanto, una labor artesana, basada en la habilidad

 
22 Fundamentos de programación

 

personal del programador para conseguir que el programa cumpliera con esos
objetivos de eficiencia, para lo cual era imprescindible conocer en detalle el
funcionamiento interno del computador, y poder así emplear ciertos “trucos”
de codificación que permitían ahorrar algunas instrucciones o usar menos elementos de memoria para almacenar datos intermedios.

El costo de desarrollo del software resultaba, en todo caso, muy inferior al
costo del equipo material (hardware), por lo que pocas personas se paraban a
considerar las posibilidades de reducir los costos de desarrollo de programas.
Por otra parte, y dada la limitación de capacidad de las máquinas, los programas eran necesariamente sencillos, en términos relativos, y se consideraba que
podían llegar a depurarse de errores mediante ensayos o pruebas en número
suficiente,

Los avances en la tecnología electrónica han ido suministrando computadores
cada vez más capaces y baratos, en términos relativos. La necesidad de preparar sistemáticamente programas muy eficientes ha ido disminuyendo, y poco
a poco se ha ido haciendo rentable utilizar programas no tan eficientes.

La mayor capacidad de los computadores ha permitido abordar aplicaciones
cada vez más complejas. En los primeros computadores el software de una
aplicación podía contener algunos cientos o quizá miles de instrucciones. En
la actualidad las aplicaciones consideradas sencillas tienen decenas de miles
de instrucciones, y en aplicaciones de gran envergadura el volumen del software desarrollado se cuenta por millones de instrucciones y en ellos trabajan
centenares de programadores,

Con estos volúmenes de programa el costo del desarrollo del software supera
ampliamente al costo de los equipos hardware utilizados. Ya no tiene sentido dedicar un gran esfuerzo a conseguir programas eficientes. Es más barato
desarrollar programas relativamente más simples, aunque no aprovechen muy
bien los recursos de la máquina, y comprar un computador de mayor potencia de proceso que compense esa posible falta de eficiencia, Los lenguajes
de programación simbólicos han facilitado extraordinariamente las tarcas de
programación, al poder invocar en un programa operaciones cada vez más
complejas como acciones primitivas. De esta manera se reduce el volumen
total del programa medido en número de instrucciones, que ahora pasan a ser
sentencias del lenguaje simbólico.

1.7.2 Necesidad de metodología y buenas prácticas

Los programas actuales son tan complicados que ya no es posible desarrollarlos de una manera artesanal. Es necesario aplicar técnicas de desarrollo muy
Introducción 2

 

precisas para controlar el producto obtenido. Ya se ha indicado que estas técnicas aplicables a proyectos desarrollados en equipo constituyen la ingeniería
de software.

A nivel individual hay que promover el empleo de una metodología de programación apropiada, que satisfaga los objetivos de corrección y claridad mencionados anteriormente. Para aplicaciones grandos la claridad se convierto en un
objetivo prioritario, ya que resulta imposible analizar y modificar un programa.
si no se comprende suficientemente su funcionamiento.

 

Para facilitar la obtención de programas correctos, sin fallos, se pueden emplear técnicas formales, que permitan en lo posible garantizar la corrección del
programa mediante demostraciones lógico-matemáticas, y no mediante ensayos en busca de posibles errores. La técnica de ensayos sólo resulta útil si
consigue descubrir fallos, pues así demuestra que el programa contiene errores
que hay que corregir, pero es más bien imútil si no se descubre ningún fallo,
porque eso no garantiza que el programa no contenga errores, los cuales pueden
manifestarse (y lamentablemente se manifiestan con harta frecuencia) cuando
el programa ya está en explotación y los usuarios lo emplean en multitud de
situaciones nuevas que no habían sido ensayadas nunca.

 

Lamentablemente las técnicas formales son tan complejas que sólo son utilizables en programas críticos de pequeño tamaño. Para grandes aplicaciones en
las que intervienen cientos de ingenieros es absolutamente necesario emplear
técnicas de ingeniería de software basadas en las buenas prácticas. Las buenas
prácticas son un conjunto de normas, basadas en la experiencia de desarrollos
anteriores, que se autoimponen todos los miembros de un equipo. El Manual de Estilo es el documento que compendia el conjunto de buenas prácticas
que todos los miembros del equipo deben utilizar de una manera disciplinada
durante el desarrollo de una aplicación compleja.

 
Tema 2

Elementos básicos de
programación

En este tema se presenta un conjunto mínimo de elementos de un lenguaje
de programación imperativo. Este conjunto se particulariza para cl lenguaje
Cx. Con los elementos presentados se podrán construir programas completos
aunque con una estructura muy simple, ya que sólo pueden estar formados por
una secuoncia de sentencias. Para que estos primeros programas produzcan
resultados, se introducen también varios mecanismos de escritura simple.

 

 

El objetivo que trata de alcanzar este tema es permitir el desarrollo de programas completos desde el principio. Estos programas se podrán realizar como.
prácticas con el computador de manera inmediata y directa utilizando un
compilador de C/C++.

2.1 Lenguaje Ct

El lenguaje de programación C£ (léase C-más-menos), que se utilizará a lo
largo de todo este libro para introducir los diferentes conceptos de programación, está constituido por un subconjunto del vocabulario de los lenguajes C'
y C++. Por lo tanto, cualquier programa escrito en el lenguaje C+ se podrá
editar, compilar y ejecutar en un entorno de desarrollo para C++ que incluya como subconjunto al lenguaje C. Conviene señalar que los ficheros fuente
que contengan los programas Ci deberán tener extensión .cpp como si fueran
programas en C++.
 

26 Fundamentos de programación

 

 

El objetivo fundamental de utilizar el lenguaje Ct es la introducción de los conccptos fundamentales de programación de una manera progresiva, sistemática
y sin ambigñiedades con el fin de que se adquiera una buena metodología de
programación. Lamentablemente C-o C++ no fueron diseñados para la formación de programadores y disponen de ciertas estructuras que conceptualmente
son poco rigurosas y que por ello no forman parte de C£.

  

 

El lenguaje Cé se irá presentando de manera simultánea a la introducción de
los conceptos según se avance en el curso. La presentación de cada nuevo
elemento de CE se realizará formalmente mediante la notación BNF (ver siguiente epígrafe de este tema). En el apéndice A de este libro se recopila la
descripción formal en BNF de la sintaxis completa del lenguaje C:

 

En cada tema sólo se utilizarán aquellos elemontos del lenguaje C£ que ya
hayan sido presentados. Dado el enfoque metodológico de la asignatura, cualquier programa o práctica que no se realice en el lenguaje C2 y siguiendo
las pautas marcadas a lo largo del libro se considerará incorrecto. Aunque
el exigir restricciones como éstas pueda parecer de carácter solo formativo o
estrictamente académico, el poner ciertas restricciones para la codificación en
determinados lenguajes de programación resulta una práctica bastante habitual en el desarrollo de software a nivel industrial.

Siguiendo las pautas de buenas prácticas de ingeniería de software, cualquier
empresa o equipo de desarrollo de software debo disponer antes del inicio de
cada desarrollo de un Manual de Estilo. Para lograr la adecuada claridad,
homogencidad y mantenibilidad de los programas, en el Manual de Estilo, se
establecen prohibiciones expresas de uso de algunas estructuras del lenguaje de
programación empleado, el formato de escritura de cada sentencia, recomendaciones de uso de los distintos elementos del lenguaje (constantes, variables,
tipos y subprogramas) y otros muchos aspectos. Para garantizar que todo el
desarrollo sigue estas pautas establecidas, una o varias personas del departamento de calidad son las encargadas del garantizar la calidad requerida de
todos los programas y para ello tienen la potestad de exigir las correcciones o
modificaciones que consideren necesarias a los programadores.

 

2.2 Notación BNF

Un lenguaje de programación sigue unas reglas gramaticales similares a las de
cualquier idioma humano, aunque más estrictas. Para la definición formal de
dichas reglas sintácticas utilizaremos la notación BNF (Backus-Naur Form)
basada en la descripción de cada elemento gramatical en función de otros más
Elementos básicos de programación 27

 

sencillos, según determinados esquemas o construcciones. Cada uno de estos
esquemas se define mediante una regla de producción.

Estas reglas sobre cómo han de escribirse los elementos del lenguaje en forma.
de símbolos utilizan a su vez otros símbolos, que se denominan metasímbolos.
Son los siguientes:

 

= Metasímbolo de definición. Indica que el elemento a su izquierda puedo
desarrollarse según el esquema de la derecha.

| metasímbolo de alternativa. Indica que puede elegirse uno y sólo uno de
los elementos separados por esto metasímbolo.

£ ) Metasímbolos de repetición. Indican que los elementos incluidos dentro
de ellos se pueden repetir cero o más veces.

[ ] Metasímbolos de opción. Indican que los elementos incluidos dentro de
ellos pueden ser utilizados o no.

( ) Metasímbolos de agrupación. Agrupan los elementos incluidos en su
interior.

Estos metasímbolos se escriben con el tipo de letra especial indicado para distínguirlos de los paréntesis, corchetes, etc. que forman parte del lenguaje C£.
También se emplearán distintos estilos de letra para distinguir los elementos
simbólicos siguientes:

Elemento_no_terminal Este estilo se emplea para escribir el nombre de un
elemento gramatical que habrá de ser definido por alguna regla. Cualquier elemento a la izquierda del metasímbolo 333 será no terminal y
aparecerá con este estilo.

Elenento_terminal Este estilo se emplea para representar los elementos que
forman parte del lenguaje Ci, es decir, que constituyen el texto de un
programa. Si aparecen en una regla deberán escribirse exactamente como
se indica.

2.3 Valores y tipos

El computador, como máquina de tratamiento de información, manipula diferentes datos. Un dato es un elemento de información que puede tomar un
valor entre varios posibles. Si un dato tiene siempre necesariamente un valor
fijo, diremos que es una constante.

 
28 Fundamentos de programación

 

Los valores de los datos pueden ser de diferentes clases. En general un dato
sólo puede tomar valores de una clase, Por ejemplo, la estatura de una persona
no puede tomar el valor “Felipe”, ni el nombre de una persona puede ser “175”,

En programación a las distintas clases de valores se les denomina tipos. Un
dato tiene asociado un tipo, que representa la clase de valores que puede tomar.
Por ejemplo, son tipos diferentes:

+ Los números enteros.
+ Los días de la semana.
+ Los meses del año.

+ Los títulos de libros.
lo

Es importante destacar que el concepto de tipo es algo abstracto, e independiente de los símbolos concretos que se empleen para representar los valores.
Por ejemplo, aunque podemos representar los meses del año mediante números
enteros de 1 a 12, los meses no son números enteros, pues no tiene sentido,
por ejemplo, sumar Enero (1) y Marzo (3) para obtener Abril (4).

Con más precisión se habla de tipos abstractos de datos, que identifican tanto el conjunto de valores que pueden tomar los datos de ese tipo como las
operaciones significativas que pueden hacerse con dichos valores.

En la comunicación humana usamos habitualmente dos grandes clases de valores: los números y los tertos. Los lenguajes de programación llevan incluidas
formas de representación concretas de estas clascs de valores, que se traducen
en la existencia de tipos de datos predefinidos, ya incorporados al lenguaje,
y que pueden usarso, en su caso, para representar también valores de otros
nuevos tipos de datos definidos por el programador. Aunque en la práctica
los números han de escribirse externamente en forma de texto para poder ser
leídos por las personas, desde el punto de vista abstracto son valores de tipos
diferentes a los de los caracteres que los representan.

2.4 Representación de valores constantes

Uno de los objetivos de los lenguajes de programación es evitar las ambigiodades o imprecisiones que existen en los lenguajes humanos. Por ejemplo,
la representación de valores numéricos en los países anglosajones se realiza
separando por comas (,) los millares. Así, trescientos cuarenta y ocho mil
quinientos treinta y seis se representa de la siguiente manera:

348,536
Elementos básicos de programación 29

 

Sin embargo, nosotros utilizamos la coma para soparar la parte entera de la
parte decimal de un número no entero. Por lo tanto, la interpretación con esta
regla del número anterior sería: trescientos cuarenta y ocho con quinientas
treinta y sois milósimas.

A continuación se indican las reglas particulares de GE para la representación
de valores básicos, tanto numéricos como de texto.

2.4.1 Valores numéricos enteros

Los valores enteros representan un múmero exacto de unidades, y no pueden
tener parte fraccionaria. Un valor entero se escribe mediante una secuencia
de uno o más dígitos del 0 al 9 sin separadores de ninguna clase entre ellos y
precedidos opcionalmente de los símbolos más (+) o menos (=). Son enteros
válidos los siguientes:

 

 

2
+56

o
234567745
1000000000

Sin embargo, no son valores enteros válidos los siguientes:

123,234 No se pueden usar comas
22.56 Nose pueden nsar puntos
13E5 No se pueden usar letras

Usando la notación BNF podemos representar de manera precis:
para escribir estos valores:

 

las reglas

Valor_entero 333 [ + | - ] Secuencia_dígitos
Dígito [ Dígito y
Digito:izo|1l213l41s16]71319

 

Secuencia_dígitos

IE NOTA: El lenguaje C2 como derivado de C/C++ considera que cuando el valor
entero comienza por un primer dígito 0 se está escribiendo on base 8 (octal) en Ingar
de en base 10 (decimal). Así, el valor númerico 020 es un número octal que equivale a
16 en decimal. En este curso no se hace uso de los valores octales y carece de sentido
poner ceros a la izquierda de un valor numérico. En cualquier caso, ol compilador do
C/C++ da un error si al escribir un valor octal se utilizan los dígitos 86 9.
30 Fundamentos de programación

 

2.4.2 Valores numéricos reales

Los valores numéricos reales permiten expresar cualquier cantidad, incluyendo
fracciones de unidad. Se pueden representar de dos maneras distintas: en la
notación decimal habitual, o en la notación científica. En la notación decimal
habitual un valor real se escribe con una parte entera terminada siempre por
un punto (.), y seguida opcionalmente por una secuencia de dígitos que constituyen la parte fraccionaria decimal. De acuerdo con ello son valores reales
válidos los siguientes:

 

 

-0.78
+234.53
0.0000000034
1234.000

En la notación científica un número real se escribe como una mantisa, que es
un número real en la notación decimal habitual, seguida de un factor de escala
que se escribe como la letra E seguida del exponente entero de una potencia de
10 por la que se multiplica la mantisa. Son valores reales válidos en notación
científica:

 

-23.2E+12 equivalente a -23.2x10'2
14567.823E4 equivalente a 14567.823x10*
126.E-34 equivalente a 126x10-%

Sin embargo, no son valores reales válidos los siguientes:

4,78 No se pueden usar comas
56.7F-56 No se puede usar la letra F

A diferencia de los valores enteros, un mismo valor real puede tener muy diversas representaciones válidas. Por ejemplo, todas las representaciones siguientes
corresponden al mismo valor:

45.6 456.E-1 4.SGE*I  45.60E%0  456000.00E-4
Las reglas anteriores, expresadas en notación BNF son:

Valor_real 333 Valor_entero . [ Secuencia_dígitos ] [ Escala ]
Escala Valor_entero

 

 
 

Elementos básicos de programación 31

2.4.3 Caracteres

“Además de los valores numéricos enteros o reales, empleados para la realizaión de cálculos muméricos, los lenguajes de programación nos deben permitir
representar valores correspondientes a los caracteres de un texto, y que están
disponibles en cualquier teclado, pantalla o impresora.

Dentro del texto de un programa en Ci el valor de un carácter concreto se
escribe poniendo dicho carácter entre apóstrofos (*). Ejemplos de valores do
caracteres son los siguientes:

 

az
ars

  

Es interesante hacer las siguientes observaciones:

 

+ el espacio en blanco (* *) es un carácter válido como los de
+ hay que distinguir entre un valor entero de un dígito (p.ej. 7) y el carácter
correspondiente a dicho dígito (p.ej. *7")

La colección o juego de caracteres (charset) que pueden manipularse en un programa depende de la máquina que se esté usando. Sólo se pueden representar
de la forma indicada (escribiéndolos entre apóstrofos) aquellos caracteres que
tengan asociado un símbolo gráfico (letra, dígito, signo de puntuación, etc.)
que pueda introducirse en el texto del programa. Otros caracteres definidos,
tales como los caracteres de control, que no tienen símbolo gráfico, se representan mediante una secuencia de escape con la siguiente notación:

'Xn' - Salto al comienzo de una nueva línea de escritura
*Yr? Retorno al comienzo de la misma línea de escritura
*Nt'  Tabulación

"Y? Apóstrofo

"XV" Barra inclinada

'X£' Salto a una nueva página o borrado de pantalla

2.4.4 Cadenas de caracteres (strings)
Es frecuente que los caracteres no se utilicen de forma aislada, sino formando

palabras o frases. Una cadena de caracteres (en inglés string) se escribe como
una secuencia de caracteres incluidos entre comillas (*). Por ejemplo:
 

32 Fundamentos de programación
"Palabra"
“Este texto es una cadena de caracteres"
ge

 

"El resultado de A+B es:
"Incluir entre 'apóstrofos' el texto"
"Conteste A"SiX" o W"NoX""

“¿Año de fabricación?

 

Conviene observar que;

+ si una cadena incluye comillas en su interior se escribirá mediante Y"

+ no hay que confundir un valor de tipo carácter (*x') con una cadena del
mismo único carácter ("x"). La distinción se produce por el delimitador
utilizado comillas (“) para una cadena y apóstrolo (*) para un carácter

+ es posible definir una cadena vacía que no contenga ningún carácter,
como en el último ejemplo

 

Una cadena puede contener cualquier número de caracteres y puede incluir
cualquier carácter alfabético o de puntuación que sea representable dentro del
texto del programa. Aquí se aplican las mismas observaciones que se han
hecho antes respecto al juego de caracteres particular de cada máquina.

2.5 Tipos predefinidos

Las diferentes formas de representación de valores constantes presentadas en
los apartados anteriores distinguen ya varias clases de datos, pero que no llegan
aser tipos en sí mismos. En efecto, tal como vamos a ver a continuación, dentro
de una misma clase de valores pueden distinguirso varios tipos diferentes, tanto
a nivel de tipos predefinidos en el lenguaje, como de tipos definidos por cl
programador.

Recordaremos que un tipo de datos define:

1. Una colección de valores posibles
2. Las operaciones significativas sobre ellos

 

En el lenguaje Ct hay cuntro tipos de datos predefinidos, que se designan con
los nombres int, float, char, bool, así como mecanismos para definir nuevos
tipos a partir de ellos. En los lenguajes C y C++ hay tipos predefinidos
adicionales. En las secciones siguientes se describen los tipos predefinidos
fundamentales, excepto el tipo bo01, que se describe más adelante,
 

Elementos básicos de programación 33

 

2.5.1 El tipo entero (int)

Los valores de este tipo son los valores numéricos enteros positivos y negativos.
¡Como tipo abstracto su definición coincide con el concepto matemático de los
asímeros enteros. Sin embargo, dado el carácter físico de los computadores,
el rango de valores nunca podrá ser infinito como se establece en el concepto
matemático. En cada caso el rango de valores del tipo int depende de la
plataforma (combinación de: procesador, sistema operativo y compilador) que
se esté utilizando. En general se corresponde con el rango de valores que
pueden manipularse con instrucciones básicas del lenguaje de máquina y viene
2 ser simétrico en torno al valor cero. Dentro de dicho rango la representación
de cualquier valor es exacta. Son rangos comunes los siguientes:

 

 

 

 

 

Tamaño de palabra Rango de valores enteros

16 bits -32.768 ... 0... 32.767

32 bits -2.147.483.648 ... 0... 2.147.483.047
-9:223.372.036.854.775.808

64 bits Dis
9.223.372.036.854.775.807

 

 

 

 

Estos rangos obedecen a que los computadores suclen emplear la codificación
en base 2 de los valores enteros. Para el signo del número se utiliza un bit,
quedando, por tanto, 15, 31 ó 63 para el valor absoluto:

215 — 32.768

2 = 2.147.483.648
20% — 9,223.372.036.854.775.808

 

NOTA: Para facilitar la escritura de programas que tengan en cuenta la limitación
particular de rango existente en cada caso, C y C++ permiten hacer referencia al valor
mínimo mediante el nombre simbólico INI_MIN, y al valor máximo mediante INT_MAX
El rango admisible será, por tanto: INT-MIN ... 0 ... INT_MAX, Estos nombres están
definidos en el módulo limits de la librería estándar de C (cabecera <limits.h>).

 

Asociadas al tipo int están las operaciones que se pueden realizar con los
valores de esto tipo. Las operaciones predefinidas entre valores enteros son
las operaciones aritméticas básicas, que se realizan entre enteros y devuelven
como resultado valores enteros. Para invocar estas operaciones se dispone de
los siguientes símbolos de operación u operadores:
 

34 Fundamentos de programación

+ Suma de enteros a+b
- Resta de enteros a-b
* Multiplicación de enteros a*b
/ División de enteros a/b
% Resto de la división a%b
+ Identidad de un entero +a

Cambio de signo de un entero - a
Siguiendo la representación aritmética habitual, los símbolos + y = tienen un
doble significado, según se usen como operadores infijos entre 2 operandos o
como operadores prefijos con un único operando.

El operador / realiza la división entre dos números enteros y obtiene como
resultado el cociente entero truncado al valor más próximo a cero. Cuando el
divisor es cero se obtiene como resultado un error. Por ejempl

Operación Resultado

  

10/73 3
(20) / (7) 2
1) /4 3
17/(3 5
34/0 Error

El operador % obtiene el resto de la división de enteros realizada con /. Por
ejemplo:

Operación Resultado
10% 3 1
(20) % (-7) 6
15) % 4 3
17% (3) 2
34%0 Error

Entre los operadores / y % se cumple la regla aritmética habitual:

Dividendo = Divisor x Cociente + Resto

 

que en Ci se expresaría así

a = b* (a/b) + (ab)
Cuando se realiza una operación con enteros se debe tener en cuenta el rango
de valores disponible en la plataforma que se esta utilizando. Si se produce un
resultado fuera del rango disponible se producirá un error. En algunos casos
este tipo de errores no se indica y puede ser difícil su detección. Por ejemplo,
para enteros de 16 bits con un rango entre -32.768 y 32.767, se obtienen los
siguientes resultados:
Elementos básicos de programación 35

 

Operación Resultado
234 + 89 323
345 * 97 Error

214 * (-203) Error
15456 + 18678 Error
(-20) - 32750 Error

2.5.2 El tipo real (float)

Con el tipo float se trata de representar en el computador los valores numéri«os reales positivos y negativos. Sin embargo, al contrario que en caso del tipo
int, esta representación puede no ser exacta. Además, dado que la capacidad
de los computadores es limitada, la representación sólo se puede considerar
válida dontro de un rango, de forma semejante a como sucede con los enteros.

Tanto el rango como la precisión dependen de la plataforma concreta utilizada. Dentro de dicho rango para algunos valores concretos es posible una
zepresentación exacta. Sin embargo, dado el carácter discreto de los datos que
«siempre se manejan en un computador, nunca será posible una representación
exacta de valores tales como los valores irracionales 1 o e o, en general, de valores cuya precisión sea superior a la disponible en la plataforma que estemos
“utilizando. En estos casos se manejan valores aproximados.

Los valores reales se suelen representar internamente de forma equivalente a la
rotación científica, con una mantisa y un factor de escala. El rango de valores
sepresentables está limitado tanto para valores grandes como pequeños. Los
salores más pequeños que un límite dado se confunden con el cero. Al igual
¿que en el caso de los valores enteros, el rango y precisión de los valores reales
puede cambiar de una plataforma a otra. Algunos de los rangos habituales
son los siguientes;

 

a a Rango de valores reales
348438... 12-38
32 bits; 6 cifras decimales | 0

+1.28-38 ... +3-4E+38
-L.TEF308 ... -2.3E-308
64 bits; 15 cifras decimales | 0

+2.3E-308 ... +1.784-308

 

 

 

 

 

 

 

Estos rangos dependen del número concreto de bits y de la codificación que se
emplean para la mantisa y el exponente del valor £loat. En el caso de valores

 
36 Fundamentos de programación

 

representados con 32 bits no existe ningún valor intermedio entre —1,2x 10%
y el valor 0, ni tampoco entre U y 1,2 x 10% (y análogamente para valores
en 64 bits).

Asociadas al tipo float están las operaciones que se pueden realizar con él.
Las operaciones entre valores reales son las operaciones aritmóticas básicas,
ano se realizan entre reales y devuelven como resultado valores reales. Los
correspondientes operadores son los siguientes:

 

Suma de reales

Resta de reales
Multiplicación de reales
División de reales
Identidad de un real

- Cambio de signo de un real

+

 

+0.»
2
coo

Los símbolos empleados para estos operadores son los mismos que para. los
operadores entoros. Sin embargo, en todos los casos son operadores distintos
de los operadores enteros. Las operaciones entre reales dan como resultado un
real con la precisión de la plataforma. Así, para valores reales no se cumple
siempro exactamente la relación básica:

G/bD*b=a
Es importante tener en cuenta imprecisiones como ésta cuando los cálenlos

scan más complejos y se pnedan acumular errores. Ejemplos de operaciones
entre valores reales son las siguientes:

 

Operación Resultado
10.5 70.2 52.5

20.6 * 2.4 -49.44
-15.4E2 + 450.0 -1090.0

23.4 - 2E-1 23.2

La representación sólo aproximada de los valores reales se pone de manifiesto si
tratamos de expresar con más precisión de la realmente existente el resultado
de una operación. Por ejemplo:

 

Operación Resultado
10.0 / 3.0 -3333332538604736E+0

 

En este caso concreto el valor es inexacto a partir de la 7% cifra decimal. En
cada plataforma se podrá obtener un resultado ligeramente diferente.
Elementos básicos de programación 37

 

2.5.3. El tipo carácter (char)

Para comprender bien cl manejo de valores de tipo carácter en un computador
es necesario conocer cómo se definen y representan esos valores de caracteres. Cada carácter no se representa internamente como un dibujo (el glifo
del carácter), sino como un valor numérico entero que es su código. La colección concrota de caracteres y sus códigos numéricos se establecen en una
tabla (charset) que asocia a cada carácter el código numérico (codepoint) que
Je corresponde.

Dependiendo del número de bits reservado para representar el código de cada carácter podremos tener tablas más o menos amplias. Algunas tablas de
«caracteres de amplio uso son:

 

Tamaño
Tabla (charset) del Repertorio de caracteres
carácter

 

 

Lotras inglesas mayúsculas y
ASCH 7 bits minúsculas. Algunos signos de
puntuación y códigos de control.

 

 

 

un 210 Lo anterior, más letras con acentos y
lamibitn Latin) nuevos signos de puntuación
a a Inclnye además los alfabetos griego,
a 16 bits cirílico, Srabe, chino/japonés/coreano,
Plane) e signos matemáticos, ote.

Incluye la práctica totalidad de
UNICODE 32 bite | Uttacteres utilizados en cualquier
comploto idioma o notación textual existente en

muestro mundo actual

 

 

 

 

 

Las tablas mencionadas son compatibles entre sí en el sentido de que cada
na de ellas incluyo la anterior, manteniendo los códigos numéricos de los
caracteres. Lamentablemente la compatibilidad no se extiende a otras muchas
tablas de caracteres de amplio uso. Por ejemplo, otras tablas de caracteres de
8 bits muy conocidas son:

 

 
 

38 Fundamentos de programación

 

 

 

 

 

 

Tamaño
Tabla (charset) del Repertorio de caracteres
carácter
io ASCIT a
Os eme | Repertorio ASCII más el afabeio
griego
a sume | Repertorio Lati revisado, Incluye
el símbolo de Euro
e Repertorio ASCII más simbolos
fenelñalda 8 bits semigráficos y letras con acentos,
O pero con códigos distintos de Latin-1
MS-DOS)
TBM-PO-550 Casiel mismo repertorio de Lafin-T
(usado también — | 8bits | pero.con códigos diferentes, y
en MS-DOS) diferentes también de IBM-P0-437.

 

Windows 1252
(usado en los
sistemas operativos
MS-Windows)

Coincide con Latin-1 excepto en
8 bits un rango de 32 códigos de Latin-1
que repiten códigos de control

 

 

 

 

 

En Ch (como en C/C++, los valores del tipo char ocupan 8 bits e incluyen el
repertorio ASCIL, Además incluyen otros caracteres no-ASCII que dependen
de la tabla de caracteres establecida. En los ejemplos de este libro asumiremos
que se dispone de los caracteres comunes a Latin-1 y Windows-1252. Por
lo tanto la colección de valores del tipo char incluye caracteres alfabéticos,
numéricos, de puntuación y caracteres de control.

Como ya se ha dicho, en el texto de un programa se pueden escribir los valores
de los caracteres, bien directamente, o mediante una secuencia de escapo, p.ej.
para los caracteres de control. También se puede representar cualquier carácter
mediante la notación char(z) siendo x el código del carácter. Por ejemplo, en
ASCIL:

char(10) — Salto al comienzo de una nueva línea. Posición 10%
char(13) Retorno al comienzo de la misma línea. Posición 138
char(65) Letra A mayúscula. Posición 65%

En sentido inverso, el código numérico de un determinado carácter ese expresa
como int(c). Por ejemplo:

int(*A") 05 (65% posición de la tabla ASCII)

int(*Z*) 90 (90* posición de la tabla ASCII)

De forma inmediata se puede decir que, para cualquier carácter , cuyo código
sea x, se cumplirá que:
 
  
    
  
 
 
 
 
     
 
   
  
   
 
 
  
  
   

 

Elementos básicos de programación 39

 

char(int(c))
int(char(z))

 

 

z

 

Además conviene saber que la tabla ASCII posee las siguientes característi

+ Los caracteres correspondientes a las letras mayúsculas de la 'A' a la 2
están ordenados on posiciones consecutivas y crecientes según el orden
alfabético.

+ Los caracteres correspondientes a las letras minúsculas de la “4 a la Y
están ordenados en posiciones consecutivas y crecientes según el orden
alfabético.

+ Los caracteres correspondientes « los dígitos del
en posiciones consecutivas y crecientes.

Esto facilita el obtener por cáleulo el valor mumórico equivalente al carácter
de un dígito decimal, o la letra mayúscula correspondiente a una minúscula o
"ceversa.

En C (y en Ct) so puedo usar también el módulo de librería ctype (cabecera
-h>), que facilita el manejo de diferentes clases de caracteres. Este
incluye funciones tales como:

 

al “9 están ordenados

 
 

“isalpha( e ) Indica si ces una letra
isascii( c ) Indica si c es un carácter ASCI
isblank( c ) Indica si c es un carácter de espacio o tabulación
ásentri( e ) Indica si e es un carácter de control
Esdigit( e ) Indica si c es un dígito decimal (0-9)
islower( c ) Indica si c es una letra minúscula
isspace( c ) Indica sic es espacio en blanco o salto de línea o página
isupper( e ) Indica si e es una letra mayúscula
zolower( c ) Devuelve la minúscula correspondiente a €
towpper( c ) Devuelve la mayúscula correspondiente a e

concepto de función se introduce en el tema 7, y el de módulo en el tema

Expresiones aritméticas

expresión aritmética representa un cálculo a realizar con valores numéricos
¡adelante se verán expresiones que utilizan también valores de otros tipos).
expresión aritmética es una combinación de operandos y operadores.

 

 
40 Fundamentos de programación

 

Para indicar el orden en que se quieren realizar las operaciones parciales se
pueden utilizar paréntesis. Si no se utilizan paróntesis el orden de las operaciones depende de una jerarquía entre los operadores empleados, que para los
operadores numéricos os la siguiente;

1% Operadores mmultiplicativos: * / %
2% Operadores aditivos: +
Dentro del mismo nivel las operaciones se ejecutan en el orden en que están
escritas en la expresión aritmética de izquierda a derecha.

Si una expresión va precedida del signo más o menos, se entiende que solamente
le afecta al primer operando. Si sc quiere que afecte a toda la expresión, ésta
deberá incluirse entre paréntesis,

Ejemplos de expresiones entre datos enteros son las siguientos:

Expresión Resultado
CS
334 /6%4*5 15
-5* 10% 3/2 1

Cuando la complejidad de la expresión puede dar lugar a posibles errores de
interpretación, es preferible utilizar paréntesis para clarificar cuál es el cálculo
exacto que se quiere realizar. Así las expresiones anteriores son equivalentes a.
las siguientes:

(5 * 30) +5
((334 / 6) % 4) * 5
(05) * 10) % 3) /2

Igualmente, ejemplos de expresiones entre valores reales son las siguientes:

 

Expresión Hesul- Expresión equivalente
35.3 * 5.1 /7.6 - 4.5 19.18816 ((35.3*5.1)/7.6)-4.5

-23.1/6.2* 5.4 /2.4  -838306  (((-23.1)/6.2)*5.4)/2.4

Aunque se represente por los mismos símbolos, los operadores aritméticos para.
valores reales y enteros son en realidad diferentes. Así, si se mezclaran en una
misma expresión valores de tipos diferentes, las expresiones aritméticas son
completamente ambiguas. Por ejemplo en las siguientes operacion:

 

33.7 / 5 ¿La división a realizar es entera o real?
33 / 5.3 ¿La división a realizar es entera o real?
25 * 3.5 ¿La multiplicación a realizar es entera o real?
 
   
   

 

tos básicos de programación ar

 

:temente, los resultados serán diferentes según el tipo de operación que
realice. Además no queda claro si el resultado que se pretende obtener es
valor entero o real. Para poder realizar estas operaciones combinadas es
lo que previamente se realice una conversión de la representación de
datos al tipo adecuado. La representación real de un dato entero se indica
la siguiente manera:

 
      
 
   

 
   

      
  

float(45) Representa el valor numérico 45.0 con tipo float

forma similar la representación entera de un dato real (correspondiente a
¡parte entera, truncando el valor) se consigue de la siguiente forma:

    
     
   
       
       
     
       
       
   

int(34.7) Representa el valor numérico 34 con tipo int

tanto, si queremos obtener un resultado entero, las operaciones entre eny reales anteriormente indicadas se tienen que realizar de la siguiente

Expresión Resultado Tipo
ntG83.7) /5 6 int
33 / int(5.3) 6 int
25 * int(3.5) 75 int

el resultado deseado es un valor real, es necesario realizar previamente
conversiones a real de los operandos enteros y lógicamente obtendremos
los completamente distintos:

 

Expresión Tipo.
733.7 / float (5) float
float(33) /5.3 6:22642 float

float(25) * 3.5 87.5 float

    

lenguaje C£ permite la ambigúedad que supone la mezcla de tipos de dadiferentes en la misma expresión sin exigir una conversión explícita. Para
la amibigiledad, CE utiliza el convenio de C/C++ de convertir previa
de manera automática todos los valores de una misma expresión al tipo
valor con mayor rango y precisión. Por tanto, el resultado siempre se obtambién en el mayor rango y precisión utilizado en la expresión. El
imiento de esta regla implícita, puede dar lugar a que el resultado

sana expresión aritmética sea completamente inesperado. Para evitar esta
ión, en el Manual de Estilo para la realización de programas en esta
tura es obligatorio que se realice siempre una conversión explícita de
 

42 Fundamentos de programación

 

2.7 Operaciones de escritura simples

El objetivo de un programa es obtener unos resultados. Estos resultados deben
sor emitidos al exterior del computador a través de un dispositivo de salida
de datos: impresora, pantalla, trazador (plotter), línen de comunicaciones,
etc. Las acciones que envían resultados al exterior se llaman, en general,
operaciones de escritura, con independencia de que se trate de una impresión
en papel, o la simple visualización en pantalla, o la grabación de los datos en
un soporte donde queden registrados, o su envío a otro equipo remoto.

Existe una gran variedad de dispositivos periféricos, que se diferencian mucho
en los detalles de su manejo. Para simplificar la escritura de resultados los
Jenguajes de programación prevón sentencias de escritura apropiadas para ser
usadas con cualquier tipo de dispositivo, facilitando la taréa de programación
al especificar la escritura de resultados de una manera uniforme, con independencia de las particularidades del dispositivo físico que se utilice en cada
caso.

  

 

 

Al diseñar un lenguaje de programación se puede optar por usar sentencias o
instrucciones especiales para ordenar la escritura de resultados, o bien ordenar
la escritura del resultado con las mismas sentencias generales que se empleen
para invocar operaciones definidas por el usuario. Los primeros lenguajes
de programación solían emplear la primera altermativa. Los lenguajes más
modernos utilizan con preferencia la segunda, que simplifica la complejidad
del lenguaje en sí, a costa de permitir a veces una cierta variación en las
operaciones de escritura entre diferentes versiones del lenguaje.

 

 

El lenguaje C£ adopta también la segunda alternativa que es la utilizada en
C/C++. Las operaciones de escritura so definon como procedimientos (ver
tema 7), que se invocan escribiendo el nombre de la operación, seguido de una
ie de valores o argumentos entre paréntesis. Estos procedimientos están
definidos en módulos de librería (ver tema 14) disponibles de antemano.

 

 

seri

 

En todas las versiones de C/C++ deben estar disponibles ciertos módulos
estándar con la definición de operaciones de escritura normalizadas. En este
apartado describiremos una operación disponible en el módulo llamado stdio.

 

   

2.7.1 El procedimiento printf

Este procedimiento pertenece al módulo stdio (cabecera <stdio.h>). La
forma más sencilla de invocarlo es escribir:

print£( cadena-de-caracteres

 
Elementos básicos de programación 43

 

 

TA: Esta forma sencilla sólo es válida si la cadena de caractores a escribir no
sontiene el carácter X.

El procedimiento print£ escribe en la pantalla del computador la cadena de
caracteres. Por ejemplo, para cada una de las siguientes operaciones de escritara se obtiene el resultado que se muestra a su derecha. Para visualizar con
detalle el resultado se ha utilizado el símbolo “+” para representar el carácter
de espacio en blanco.

    

Operación de escritura Resultado en pantalla
print£f( "En un lugar de ") En-un- lugar -deprintf( "¿Año de nacimiento?" );  ¿Año-de-nacimiento?

Si lo que se quiere escribir es la representación como texto de una serie de
valores de cunlquier tipo de los vistos hasta el momento (enteros, reales, caracteres, etc.), habrá que usar la forma general de la orden printf:

 

print£( cadena-con-formatos, valor1, valor?, ... valorN );

Una cadena de caracteres con formatos deberá incluir en su interior una especificación de formato por cada valor que se quiera insertar. La forma más
simple de especificar un formato es mediante %z, es decir, usando el carácter
£jo % seguido de una letra de código que indica el tipo de formato a aplicar.
Algunos códigos de formato habituales son:

Código a Tipo de valor
a decimal entero
£ fízed point real
e exponential real con notación exponencial
E general real con/sin notación exponencial
€ character un carácter
s string una cadena de caracteres

Por ejemplo, para cada una de las siguientes operaciones de escritura se obtiene
el resultado que se muestra a su derecha:

Operación de escritura Resultado
primt£( “Xd”, 120 / 12 ); 10 —
print£( "Datos: %dH%d", 23*67, -50 ); Datos:1541%-50

print£( "Dato 1541-4--50

 

xd 4 xd", 23*67, -50 ); Datos

 

Como se puedo apreciar en los ejemplos estos formatos simples usan sólo el
número de caracteres estrictamente necesarios para escribir el valor de cada
dato, sin añadir espacios en blanco. Si se quiere separar con espacios unos
valores de otros, entonces hay que incluirlos en el formato.
 

44 Fundamentos de programación

   

Otra forma de conseguir espacios en los resultados es indicar explícitamente
cuántos caracteres debe ocupar el valor de cada dato escrito. Esto se hace
poniendo el número de caracteres entre el símbolo de % y el código del formato.
Ejemplos:

 

    

Operación de escritura Resultado
print£( "X5d", 120/12 +10
print£( "Datos:%7dR%5d", 23*6, -50 );  Datos:----138%---50

print£( "X3d", 1000*34 ); 34000

Cuando el número de caracteres indicado es insuficiente para representar completamente el valor, como ocurre en el último ejemplo, se utilizan tantos caracteres como sean necesarios para que el resultado aparezca completo,
Además, cuando se utiliza un formato £, e ó g se puede especificar también el
número de cifras decimales que se deben escribir después del punto decimal.
Por ejemplo:

 

Operación de escritura
print£( "X10.
print£( "X10.4e", 23.1%67.4 ); — 0.1557E+04
printf( "X15.38", -50.6E-6 ); +. +:-0.S06E-04

Salvo que se indique otra cosa, los resultados obtenidos mediante sucesivas
sentencias de escritura van apareciendo en el dispositivo de salida uno tras
otro en la misma línea de texto. Por ejemplo, las siguientes sentencias de
escritura:

  

 

 

printf( "Area =");
print£( "%10.4f", 24.45 );
print£( "Mi ciudad es Avila" );
print£( "Descuento: " );
print£f( "X5.2d", 12.5
print£( "0", 0%);

 

 

producen el resultado siguiente (se prescindo ya del símbolo *-* para representar un espacio en blanco):

 

Area = — 24.4500M1 ciudad es AvilaDescuento: 12.50%

 

Para escribir resultados en varias líneas de texto habrá que recordar que dentro
de una cadena se pueden incluir caracteres especiales mediante secuencias
de escape. Más concretamente, si queremos dar por terminada una línea de
resultados y pasar a escribir en la siguiente bastará con incluir en el punto
adecuado la secuencia de escapo An. Por ejemplo, si se modifican ligeramente
las anteriores operaciones de escritura:

 

 
Elementos básicos de programación 45

 

print£( "Area = " );

print£( "%10.4fn", 24.45 );
print£( "Mi ciudad es Avila" );
print£f( "Descuento: " );

print£( "X5.2d", 12.5 );

printe( "XA", 060);

 

 

 

se obtendrá como resultado:

 

[Area 24.4500
(Ni ciudad es Avila
|Descuento: 12.50%

 

2.8 Estructura de un programa completo

Con los elementos introducidos hasta este momento pueden formarse ya programas completos. Sólo falta indicar cuál es la estructura global del programa.

Un programa en Ct so engloba dentro de una estructura principal o main).
Un ejemplo de programa muy sencillo es el siguiente:

 

1/*= Programa: Hola */
1/* Este prograna escribe "Hola" =/

*include <stdio.h>

int main() €
print£( "Holarn" );
p

 

Podemos observar que en el texto del programa aparece una línea precedida
del símbolo 4. Con este símbolo comienzan lo que se llaman directivas para el
compilador. En conereto con la directiva finclude se indica al compilador que
utilice el módulo de librería stdio (cabecera <stdio.h>) para las operaciones
de escritura que se realizarán en el programa. De hecho la directiva finclude
será la única que se usará en C£,

El cuerpo del programa contiene las sentencias ejecutables correspondientes
a las acciones a realizar, escritas entre los símbolos [ de comienzo y ? final.
Cada sentencia dol programa termina con un punto y coma (5),

Es conveniente recordar que todos los programas en GE se deben guardar en
un fichero con el nombre del programa y la extensión .cpp. Así, el nombre
del fichero fuente de este programa deberá ser: hola.cpp.

 

 
 

46 Fundamentos de programación

Una vez compilado y ejecutado este programa de ejemplo produce, como es
de esperar, el siguiente resultado:

 

Hola

En el anterior ejemplo de programa aparece también un nuevo elemento no
mencionado hasta el momento, y que se explica a continuación.

2.8.1 Uso de comentarios

El código de un programa en un lenguaje de programación tal como O, C++
o Ct puede no ser suficiente, en muchos casos, para comprender el sentido del
programa. Casi siempro es conveniente alguna aclaración adicional que explique el significado exacto de los elementos usados para desarrollar el programa.
Estas aclaraciones facilitan la labor de una posible modificación posterior del
programa por nosotros mismos u otros programadores.

Todos los lenguajes permiten incluir dentro del texto del programa comentarios
que faciliten su comprensión. Estos comentarios sirven sólo como documentación del programa fuente, y son ignorados por el compilador, en el sentido de
que no pasan a formar parte del código objeto al que se traducirá el programa.

  

 

En Ct los comentarios se incluyen dentro de los símbolos /* y */ . Por ejemplo:
/* ¡Ojo!. Esto es un comentario */

2.8.2 Descripción formal de la estructura de un programa

La descripción formal de la estructura (simplificada) de un programa es la

  

L Include Y int main() Bloque
'include <Nombre_módulo.h>

Cada directiva debe ocupar una línea del programa ella sola. En los lenguajes
C y C++ hay una gran variedad de directivas, pero en Cé se utilizará casi
exclusivamente la directiva Kinclude, que sirve para indicar que el programa
utilizará un determinado módulo de librería. El parámetro Nombre_módulo
corresponde en realidad al nombre del fichero de cabecera (header) del módulo.

El resto del código del programa se podría repartir en líneas de código como se
deseo, aunque en el Manual de Estilo de C2 se exigirá un estilo de presentación
uniforme, tal como se irá indicando a medida que se introduzcan los elementos
del lenguaje.
Elementos básicos de programación 47

 

La estructura de un bloque solamente puede indicarse de momento de forma
simplificada, ya que sólo se han visto los elementos mínimos necesarios para
escribir un programa. Por ahora diremos que un bloque puede contener una

secuencia de sentencias:
Bloque 33= 4 Parte_ejecutiva Y

£ Sentencia Y

La única sentencia que se ha descrito hasta el momento es la orden de escritura
printf. Más adelante se irán introduciendo nuevas sentencias de Ct.

 

 

Parte_ ejecutiva

2.9 Ejemplos de programas

En este npartado se muestran programas completos que pueden ser compilados
y ejecutados de manera directa e inmediata. Aunquo estos ejemplos son de
una gran sencillez, permiten ilustrar los conceptos introducidos en este tema.

2.9.1 Escribir una fecha

En este ejemplo se escribe una fecha, El día y el año se escriben como valores
muméricos, y el mes como un texto.

 

/** Programa: EscribirFecha */
/* Escribe la fecha del descubrimiento de América */

include <stdio.h>

int mainO £
print£( "X2d", 12 );
print£( " de Octubre de"
print£( "XSdwn", 1492 );
+

 

 

La ejecución del programa produce el siguiente resultado (usando el símbolo
*-* para representar el espacio en blanco):

 

 

12-de-Octubre-de-1492

Obsérvese cómo se han incluido los espacios en blanco en las sentencias de
escritura.

 
 

 

48 Fundamentos de programación

 

2.9.2 Suma de números consecutivos

Con este programa se trata de obtener la suma de una serie de números consecutivos, desde uno inicial a otro final. Para su obtención utilizaremos la
fórmula de la suma de una progresión aritmética. Si n es el número de términos, a el primer término, y ón el último, la fórmula general de la suma
es:

  

Fiz
ax
= 2
Y para una serio de números enteros consecutivos se cumple que:
a, aj+1

 

El listado del programa es el siguiente:

 

/** Programa: SumarNumeros */
/* Este programa calcula e imprime la suna
de los números correlativos desde 4 hasta 45

El algoritmo empleado es el utilizado para

calcular la suma de una progresión aritmética:

Suna = (Final - Inicial + 1) * (Inicial + Final) / 2
EA
Hinclude <stdio.h>

int mainO (
print£( "La suna de los núneros desde 4 hasta 45m" );
print£( "es igual a: "
print£( "%5dWn",(45 - 4 +1) * (45 +4) /2);

 

,

 

La ejecución del programa produce el siguiente resultado:

 

 

La-suna-de-10s-múneros. desde-4-hasta-45
es-igual-a: --1029

 

Es interesante analizar la manera en que se evalúa la expresión aritmética,
dado que / trunca el resultado, Si se hubiera escrito la expresión de la forma
uo sugiere la fórmula de la suma de la progresión aritmética, tal como se ha
presentado anteriormente:

(45 -4+1) * ((45+4)/2)

se obtendría un resultado erróneo igual a 1008, al producirso el trancamiento
de la división por 2 antes de multiplicar,
 

Elementos básicos de programación 49

2.9.3 Área y volumen de un cilindro
En este tercer programa sencillo se obtienen el área y el volumen de un cilindro
a partir de su radio R y su altura A:
área = 25R2+21RA = 27R(R+ A)
volumen = TRA
El listado del programa es el siguiente:

 

¡/** Programa: Cilindro */
'/* Cálculo del área y el volumen de un cilindro */

'tinclude <stdio.h>

'ánt main) 1
print£( "%sin", "Dado un cilindro de dimensiones: "

 

 

   

print£( "Xsin", "radio = 1,5 y altura = 5,6" );
print£( "Xs", "su area es igual a: " );
print£( "%gin", 2.0*3.141592*1.5*(1.5+5.6) );

print£( "%s”, "y su volumen es igual az" );
print£( "%20.8£1n", 3.141592*1.5*1.5*5.6 );
y

 

La ejecución del programa produce el siguiente resultado:

 

¡Dado un cilindro de dimensiones:
radio = 1,5 y altura = 5,6

¡su área es igual a: 66.9159

y su volumen es igual

 

39.58405920

En este ejemplo se ha renunciado a marcar expresamente los espacios en blanco
impresos por el programa, para facilitar la lectura de los resultados.
 

Tema 3

Constantes y Variables

Este tema complementa el anterior con nuevos elementos que permiten construir programas algo más realistas.

Primeramente se indica el interés que tiene dar nombre a las constantes que
se manejan en los programas. A continuación se introduce el concepto de
variable. Este concepto es muy importante y una gran parte del tema está
organizada en torno a él. De hecho la existencia de variables constituye el
elemento diferenciador del paradigma de la programación imperativa respecto
a los demás.

tema se completa con la presentación de varias sentencias de lectura simple.
Estas sentencias permiten construir programas en los que se pueden introducir
valores para ser usados durante su ejecución,

3.1 Identificadores

 

La manera de hacer referencia a los diferentes elementos que intervienen en
un programa es darles un nombre particular a cada uno. En programación se
llaman identificadores a los nombres usados para identificar cada elemento del
programa.

En el tema anterior ya se han utilizado identificadores para dar nombre a
elementos tales como los tipos de datos, las operaciones de escritura, etc.,
que se suministran ya con un significado determinado. Ahora se inventarán
nombres para designar variables y constantes en el programa.

En Ct los identificadores son una palabra formada con caracteres alfabéticos
o numéricos seguidos, sin espacios en blanco ni signos de puntuación inter
 
 

52 Fundamentos de programación

 

calados, y que debe comenzar por una letra. Pueden usarse las 52 letras
mayúsculas y minúsculas del alfabeto inglés, el guión bajo (_), y los dígitos
decimales del 0 al 9.
Ejemplos de identificadores válidos son los siguientes:

Indice diaDelMes Nombre_Apellido

js Eje_3 IdentificadorMuyyyyyyLargo
No serían válidos los signientes identificadores:

3 Eje No puede comenzar por un dígito
4508 No se pueden usar los caracteres: 4 y $
dia Del Mes No se pueden intercalar blancos

Año No se puede utilizar la letra ñ

Es importante resaltar que las letras ño Ñ o las vocales acentuadas no están
incluidas en cl alfabeto de la mayoría de los lenguajes de programación, y
por supuesto tampoco en C+, por lo que no pueden formar parte de ningún
identificador. Sin embargo, estas letras sí pueden scr utilizadas como valores
de tipo char o formando parte de una cadena.

 

Cz distingue las letras mayúsculas de las minúsculas. Así, son identificadores
distintos los siguientes:

DiaSemana Diasemana diaSemana DIASEMANA
En general, se debo tener cuidado al utilizar identificadores que difieran en
pocas letras y en particular que difieran sólo en el uso de las letras mayúsculas
o minúsculas para distinguir identificadores diferentes. En estos casos, es difícil

distinguir entre un cambio de alguna letra por error y una utilización correcta
de identificadores distintos.

Las reglas exactas para la formación de identificadores en C+ son las siguientes:
Identificador :3= LetraÍ Letra | Guión | Dígito )

 

 

 

 

zlr]oln le 31x]1]1m1

s|rlu "lx Ylz|

elslg 21313 i3lxl11m1

ele lolals sltlulvlulxlylz
Guión

  

w=ol1l2131415l6l713819

A la hora de inventar nombres conviene seguir unas reglas de estilo uniformes
que faciliten la lectura del programa. En el Manual de Estilo de Ct se sugieren,
entre otras, las siguientes:

Dígito
antes y Variables 53

 

+ Por defecto, escribir todo en minúsculas:
indice nombre apellidos area
« Escribir en mayúsculas o empezando por mayúsculas los nombres de
constantes que sean globales o que sean parámetros generales del programa:
Pi NULO MAXIMO
+ Usar guiones o mayúsculas intermedias para los nombres compuestos:
diaDelMes ANCHO_MAXIMO dia_del_mes

3.2 El vocabulario de Ct

“Además de los identificadores usados para nombrar diferentes elementos, en un
programa podemos encontrar otras palabras que siguen las mismas reglas de
Sormación que los identificadores pero que realmente no son nombros. Se trata
de las palabras clave, que sirven para delimitar determinadas construcciones
del lenguaje de programación.

 

Las palabras clave son elementos fijos del lenguaje. También son elementos
fijos del lenguaje los nombres de los tipos fundamentales y los de algunas
Funciones especiales incorporadas en el propio lenguaje. Este conjunto de
elementos fijos se denominan palabras reservadas, y no pueden ser redefinidas
por el programador para utilizarlas con otros fines. Las palabras reservadas
en el subconjunto Ci son las siguientes:

bool break case catch char const default
delete do else enum extern false float
for if int new private return struct

switch true try typedef union void while

Aunque en C+ sólo usaremos las palabras reservadas que se han indicado, para.
poder compilar los programas con compiladores de C++ deberemos considerar
también como palabras reservadas todas las del lenguaje completo, y no sólo el
subconjunto empleado en este libro. La lista completa de palabras reservadas
e

 
54 Fundamentos de programación

and andeg  asm auto bitand — bitor
boo1 break case catch char class
compl const const_cast continue default
delete do double — dynamic cast else
enum explicit extern — false float for
friend — goto if inline int long
mutable — namespace new not not_eq operator
or or_eq private protected public register
reinterpret_cast return short signed sizeof
static static_cast struct switch template
this throw true uy typedef — typeid
typename union unsigned using virtual void
volatile wchart while xor xor_eq

Además de las palabras de la lista anterior hay algunos identificadores que
sin estar reservados en C++ tienen un significado preciso en cada programa.
en el que aparezcan. Por lo tanto tampoco deberían ser redefínidos por el
programador para otros fines. Por ejemplo:

main NULL std string

En Ci se considerarán también estos identificadores como palabras reservadas,
y por lo tanto será un error redefinirlos.

3.3 Constantes

En primer lugar se introduce el concepto de constante y a continuación se
explica cómo se manejan las constantes en Ct.

3.3.1 Concepto de constante

Una. constante es un valor fijo que se utiliza en un programa. El valor debe
ser siempre el mismo para cualquier ejecución del programa, es decir, el valor
no puede cambiar de una ejecución a otra. Son ejemplos de constantes el
número de meses del año, el número de días de una semana, las constantes
matemáticas tales como el número 7, los factores de conversión de unidades
físicas de medida, ete.

Hasta el momento se ha visto la manera de representar valores constantes en un
programa escribiéndolos explícitamente, en forma de constantes literales, como
se las denomina en programación. Otra posibilidad es definir estos valores
como constantes simbólicas o constantes con nombre.
  

Declaración de constantes con nombre

   
   
  
 

declaración de un valor constante con nombre consiste en asociar un idena dicho valor constante. La declaración de la constante especifica su
'aembre y tipo y el valor asociado. Si queremos declarar el valor de la constante
'ado al nombre Pi escribiremos:

float Pi = 3.14159265;

   
   
  
 
 
   
 
  
 
 
   
   
 
 
 
   
   
 
 
  

"La declaración se inicia con la palabra clave const, y a continuación se escriben
sl tipo y nombre simbólico de la constante, seguidos del signo igual y el valor
asociado.

Las constantes con nombre han de ser declaradas en el programa antes de ser
“atilizadas. Una vez definida la constante se puede utilizar su nombre exacta»
«mente igual que si fuera su valor explícito. Por ejemplo, serán equivalentes la
dos expresiones siguientes:

2 * 3.14159265*R y  2*Pi*R

Algunos ejemplos de declaración de constantes son los siguientes:

¡const int largo = 34;
¡const int ancho = 78;
¡const char dospuntos = *
¡const float NuneroE = 2.718281828459;
¡const char Pregunta[] = "¿Código postal?
¡const float radio = 1.5;

 

 

Como puede verse, el tipo de valor de una constante se declara explícitamente,
y no viene forzado por el valor constante literal que se le asocia. En el caso
de la constante Pregunta su tipo es cadena de caracteres y la forma en que se
declara es utilizando los símbolos [] a continuación del nombre de la constante,
La siguientes constantes tienen tipos diferentes, aunque se use el mismo valor
literal para ambas:

const int  minimaTemperatura = -50;

const float temperaturaMinima = -50;

Una posibilidad interesante es poder declarar el valor de una constante en
forma de expresión. En C£ sólo se permite hacer esto si la expresión puede
ser evaluada por el compilador en el momento de traducir el programa fuente
a programa objeto. Para ello es necesario que todos los operandos que intervengan en la expresión sean valores constantes, y que las operaciones entre
ellos sean operadores fijos del lenguaje o funciones predefinidas (que tienen
56 Fundamentos de programación

 

identificadores predefinidos). En esto caso la expresión se denomina expresión
constante. Los operandos constantes pueden ser valores explícitos o constantes
con nombre declaradas en algún punto anterior del programa.

Por ejemplo, tras las declaraciones de los ejemplos anteriores se podría añadir:

const float diametro = 2*radio;

const int constanteRara= (23 * 5) / ((7 - 4) Xx 2);
const int area = largo * ancho;

[const int — perinetro = 2*(Largo + ancho);

Todas estas constantes con nombre se pueden utilizar exactamente igual que
el valor literal que representan. Por ejemplo, el resultado de las siguientes
operaciones de escritura sería;

   

Operación de escritura Resultado
printE( "Xs ”, Pregunta ¿Código-postal?
print£( "x9.2dfX5d", radio, area ); — -==-==1.508-2652

 

print£f( "%c", dospuntos ); z

En la primera de estas operaciones de escritura se hace uso del código de
formato Xs para la escritura de una cadena de caracteres con el procedimiento
printf.
Las reglas precisas que han de seguir las declaraciones de constantes con nombre son las siguientes:
Declaración. de_constante
const Tipo Nombre = Expresión constante ;
Tipo 33= Identificador
Nombre 33= Identificador
Una expresión constante incluyo, como caso particular, un único término que
sea un valor explícito.

 

3.4 Variables

En este apartado se introduce el concepto de variable y a continuación se
explica cómo se declaran y utilizan las variables en C£.

3.4.1 Concepto de variable

El concepto de variable en programación imperativa es diferente del concepto

de variable algebraica. Cuando esc

  

¡mos expresiones algebraicas usamos
Constantes y Variables 57

 

variables para representar un valor indefinido, pero fijo. Por ejemplo, cuando
escribimos la igualdad:

(a+b?= a+ ab +

queremos indicar que dicha igualdad se cumple asociando a y b con valores
cualesquiera, pero siempre los mismos. No tiene sentido pretender que a tenga
un valor en una parte de la expresión y otro diferente en otra parte.

Algo similar ocurre cuando escribimos fórmulas matemáticas o leyes físicas,
que ligan diversas magnitudes. Por ejemplo, la fórmula del volumen (V) de
un cilindro en función de su radio (12) y su altura (4) es:

V=5RA
Una vez asociadas las variables Ft y A con el radio y altura de un cilindro en

particular, la variable V debe tomar necesariamente el valor del volumen de
dicho cilindro.

 

Insistiendo en esta idea, consideremos un sistema de ecuaciones, tal como:

9
1

3x+5y
72 —5y

 

Las variables ze y, denominadas incógnitas, representan los valores, inicialmente desconocidos, que satisfacen dichas ecuaciones, y en concreto:

3 y=2

 

Con todo ello insistimos en que las variables algebraicas representan valores
simbólicos, bien valores cualesquiera, o bien valores desconocidos, pero de
manera que una vez asociada la variable a un valor determinado dicho valor
mo debe cambiarse.

En programación cl concepto de variable es diferente, y está directamente asociado a la memoria del computador. Esta memoria permite almacenar información para ser usada posteriormente. La función de la memoria es mantener
dicho valor todo el tiempo que sea necesario para usarlo tantas veces como so
necesite.

Los valores almacenados en la memoria pueden ser modificados cuantas veces
se desee, Al almacenar un valor en un elemento determinado de la memoria,
dicho valor se mantiene de ahí en adelante, pero sólo hasta que se almacene
¡en dicho elemento un nuevo valor diferente.

Las variables en los lenguajes de programación imperativos son el concepto
abstracto equivalente a la memoria física de la máquina, Una variable representa un valor almacenado que so puede conservar indefinidamente para ser

 
58 Fundamentos de programación

usado tantas vecos como se desee. El valor de una variable se puede modificar
en cualquier momento, y será el nuevo valor el que estará almacenado en ella
a partir de entonces

Las variables de un programa se designan mediante nombres o identificadores.
El identificador de una variable representa el valor almacenado en dicha variable. El programador puede elegir los nombres que considere más apropiados
para las variables que utilice en su programa.

3.4.2 Declaración de variables

Cada variable en un programa en C£ debe tener asociado un tipo de valor
determinado. Esto quiere decir que si una variable tiene asociado el tipo int,
por ejemplo, sólo podrá almacenar valores de este tipo, pero no valores de tipo
float u otro diferente.

Las variables han de ser declaradas en el programa antes de ser utilizadas.
La declaración simple de una variable especifica su nombre y el tipo de valor
asociado. Por ejemplo, para usar una variable que almacene la edad de una
persona como un número entero de años, podríamos declarar:

[int edad;

 

Podemos observar que la declaración consiste simplemente en escribir el tipo
y el nombre de la variable. La declaración termina con punto y coma (5).

Si varias variables tienen el mismo tipo, se pueden declarar todas conjuntamente, escribiendo sus nombres seguidos, separados por el carácter coma (,)
detrás del tipo común a todas ellas. Por ejemplo:

[int día, mes, anno;
La descripción BNF' (simplificada) de una declaración de variables es la siguiente:

Declaración _de_variable 335 Tipo NombreÍ , Nombre Y ;

 

Por el momento las posibilidades de especificación de tipos se limitan a los tipos
predefinidos presentados hasta ahora; más adelante se indicará la manera de
definir nuevos tipos.
 

¡Constantes y Variables 59

3.4.3 Uso de variables. Inicialización

El valor almacenado en una variable puede utilizarse usando la variable como
operando en una expresión aritmética. El tipo declarado para cada una de las
variables determina las operaciones que posteriormente se podrán realizar con
ella, de la misma forma que sucedía para los valores literales según se explicó
en el tema anterior.

Por ejemplo, si declaramos las variables:

int base, altura;
int saldo, meses, di.
float volumen, area, gastos;
¡char modelo, codigc

 

 

podremos escribir expresiones tales como:
base * altura

dias + int( codigo )
«volumen / area

pero sería inapropiado escribir
area / base

saldo + gastos
base + modelo

porque combinan operandos de tipos diferentes.

Si se usan correctamente los tipos de opcrandos para cada operación, en una
misma expresión pueden intervenir operandos de diferentes clases. Por ejemplo, pueden usarse a la vez variables, constantes con nombre y valores numéricos constantes. Con las declaraciones de constantes de la sección anterior y
las variables de los últimos ejemplos se podría escribir:

Pi * volumen * 5.7

base * altura / constanteRara

float( saldo ) + NumeroE

int( area ) / ancho % 5

 

Estos ejemplos de expresiones son formalmente correctos, de acuerdo con las
reglas de Ci, pero no se pretende que tengan ningún sentido intuitivo que se
ajuste al significado de los nombres empleados.

Con independencia de que las operaciones con variables sean consistentes con
los tipos de valores que almacenan, para que sea válido evaluar una expresión
aritmótica en la que intervengan variables es necesario que todas ellas tengan

 
 

60 Fundamentos de programación

 

un valor definido. Tal como se ha dicho anteriormente, los nombres de las
variables representan los valores almacenados en ellas. Si en una variable
no se ha almacenado todavía ningún valor, su uso conduce a un resultado
imprevisible,

Para usar una variable de manera correcta es necesario inicializarla antes do
usar su valor en ningún cálculo. /nicializar una variable es simplemente darle
un valor determinado por primera vez.

 

Para cvitar confusiones, en el Manual de Estilo de Ct sólo está permitido
especificar el valor inicial de una variable en una declaración individual para
esa variable. Por tanto, no está pormitido realizar inicializaciones de ninguna
variable cuando se declaran como una lista de variables del mismo tipo. Para
inicializar la variable, su nombre irá seguido del signo igual (=) y a contimu:
su valor inicial, de forma similar a una declaración de constante:

 

float gastos = 0.0;
char modelo = '?*;

 

Como no es obligatorio dar valor inicial a todas las variables, unas pueden
llevar valor inicial y otras no:

   

int base=0;
int altura=0;

float volunen, area, gastos;
char modelo="2";

char codigo;

La descripción BNF (corregida) de la declaración de variables, con valor inicial
opcional, es la siguiente:

 

Declaración_de_ variable 333 Variadle_simple | Lista_de variables ;

Variabl

   

e simple +32 Tipo Nombre [ = Expresión ]
Lista_de_varíables 33= Tipo Nombre Í[ , Nombre )
Tipo 35= Identificador

Nombre 33= Identificador

 

Si no se especifica el valor inicial al declarar la variable, entonces deberá ser
inicializada en el momento adecuado asignándole valor de alguna manera durante la ejecución del programa, antes de usar el valor almacenado para operar
con él.
Constantes y Variabl

 

61

 

3.5 Sentencia de asignación

Una forma de conseguir que una variable guarde un determinado valor es
mediante una sentencia de asignación. Esta sentencia es característica de
la programación imperativa, y permite inicializar una variable o modificar el
valor que tenía hasta el momento. Mediante asignaciones podremos dar valores
iniciales a las variables, o guardar en ellas los resultados intermedios o finales
de cualquier programa.

La estructura de una sentencia de asignación es la siguiente:

Asignación 333 Variable = Expresión ;

Variable 33= Identificador
Por el momento la única manera que se ha presentado de hacer referencia a
una variable es usando su nombro, Más adelante se indicarán otras formas

de hacer referencia a variables, especialmente en el caso de que la variable
designada sea parte de una estructura de datos.

El signo igual (=) es el operador de asignación. Este operador indica que el
resultado de la expresión a su derecha debe ser asignado a la variable cuyo
identificador está a su izquierda. Por ejemplo, la secuencia de asignaciones
siguiente:

 

base = 18;
area = 56.89;
¡codigo = "2";

sustituye los valores que tuvieran las variables base, area y codigo hasta ese
momento por los nuevos valores 18, 56,89 y la letra “2”, respectivamente.

Si intervienen variables en la expresión a la derecha de una sentencia de asignación, se usará el valor que tenga la variable en ese momento. Por ejemplo,
la siguiente secuencia de asignaciones:

 

meses = 2;
dias = meses;
meses = 7;

saldo = meses;

dejará finalmente almacenados en las variables meses, dias y saldo los valores
7,2 y 7, respectivamente.

Un caso especial, que requiere cierta atención, es aquél en que a una variable
se le asigna el valor de una expresión de la que forma parte la propia variable.
Por ejemplo:
 

62 Fundamentos de programación

 

|dias = dias + 30;

Esta asignación recuerda a una ecuación, pero su significado es completamente diferente. Esta sentencia es una orden de evaluar primero la expresión a
la derecha usando el valor que tenía la variable hasta ese momento, y Juego
modificar el valor de la variable almacenando en ella el resultado de la ex
presión. En este ejemplo, si la variable dias tenía el valor 16, esta sentencia
almacenará en ella el nuevo valor 46. En general, al ejecutar esta sentencia de
asignación, el valor de la variable dias se incrementará en 30 unidades.

3.5.1 Sentencias de autoincremento y autodecremento

Resulta bastante frecuente la necesidad de incrementar en uno el valor de una
variable. Para ello, empleando la sentencia de asignación so tiene que escribir:

[variable = variable + 1;

Para simplificar y aumentar la claridad del programa, en C£ se dispone de
una sentencia especial de autoincremento que utiliza el símbolo ++. Así, en
Iugar de la sentencia de asignación anterior se suele utilizar habitualmente la
sentencia de autoincremento de la siguiente manera:

|variable++;

De forma semejante cuando se necesita decrementar una variable en una unidad, C£ dispone de la sentencia especial de autodecremento que utiliza el
símbolo -- y que se escribe:

|variable-=5

Esta sentencia es equivalente a la sentencia de asignación:

[variable = variable - 1;

3.5.2 Compatibilidad de tipos

Una sentencia de asignación puede resultar confusa si el tipo de la variable
y el del resultado de la expresión son diferentes, de manera similar a lo que
ocurre con una operación aritmética entre operandos de tipos diferentes. El
lenguaje Cé no es fuertemente tipado y permite la ambigiiedad que supone la
asignación de un valor de un tipo a una variable de otro tipo. Para salvar la
ambigiledad, C2 utiliza el convenio de C/C++ de convertir previamente de
manera automática el valor a asignar al tipo del valor de la variable. De todas
Constantes y Variables 63

 

“maneras, para evitar confusiones, en el Manual de Estilo se establece que para
la realización de programas en C2 es obligatorio que se realice siempre una
conversión explícita de tipos en estos casos. Ejemplo:

int saldo;
float gastos;

saldo = intígastos);

Para finalizar este apartado se presenta una declaración de variables y luego
la traza de una secuencia de sentencias de asignación. En el lado izquierdo
se muestran los valores que guardan las variables inmediatamente antes de la
ejecución de cada sentencia. Nótese que las variables tienen un valor indefinido
hasta que son inicializadas asignándoles valor por primera vez.

Declaración:
'int posi, dato;
¡float ejeX, ejeY;

 

 

“Traza de ejecución:
ejeX_  ejeY dato posi Secuencia de sentencias
T Y 7 7 ejeX = 34.89;
3489? ? ? dato =
3489 ? 67 ? posi = int(ejeX) + dato;
34.89 + 67 101 dato = int(ejeY) + posi;
34s9 2? ? 101 ejeY = ejeX + float(posi);
34.89 135.89 ? 101 dato = posi / 5;
34.89 135.89 20 101 posi = posi % 5;
34.89 135.89 2 1 posi = posi * dato;
3489 13589 20 20 ejeY = ejeY/ejeX;
3489 38948 20 20 ejeX = ejeX/2.0;
1744 3.8948 20 20 posi = int(ejeY) - posi;
1744 3.8948 20 a7

Los datos representados con interrogación (?) significan valores imprevisibles,
debidos a variables no inicializadas cuyo contenido no puede conocerse con
seguridad. Obsérvese que la variable dato, después de tomar un valor definido
(67), vuelve a tomar un valor arbitrario al asignársele el resultado de una
expresión en la que participa la variable ejeY que todavía estaba sin inicializar.

 
64 Fundamentos de programación

 

3.6 Operaciones de lectura simple

Los programas presentados hasta el momento producen siempre el mismo rosultado cada vez que se mandan ejecutar. Por ejemplo, con los elementos
introducidos hasta ahora se podrían escribir programas para calcular la suma
de los números del 4 al 45 o imprimir la nómina de Febrero del Sr. González.
Programas que produzcan resultados fijos son poco habituales en la práctica.
Bastaría ejecutarlos una sola vez, guardar los resultados y reproducirlos tantas

veces como se necesiten, sin tener que repetir la ejecución del programa.

 

Los programas habituales suclon resolver problemas genéricos. Por ejemplo,
obtener la suma de WN números desde uno inicial a otro final, o calcular cada
mes la nómina de cada uno de los empleados de una empresa. Un programa
que produzca cada vez resultados diferentes deberá operar en cada caso a
partir de unos datos distintos, y dichos datos no pueden ser, por tanto, valores
constantes que formen parte del programa.

Para resolver cada vez el problema concreto que se plantea, el programa debe
loer como datos de entrada los valores concretos a partir de los cuales hay
que obtener el resultado. Por ejemplo, los valores inicial y final de la serie de
números a sumar, o el nombre del empleado cuya nómina se quiere calcular
y el mes al que corresponde. Por consiguiente, las operaciones de lectura son
fundamentales dentro de cualquier modelo de programación.

En Cz, los datos leídos han de ser guardados inmediatamente en variables
del programa. Por tanto, otra manera de asignar un valor a una variable
es almacenar en ella un valor introducido desde el exterior del computador
mediante el teclado u otro dispositivo de entrada de datos.

Las operaciones de lectura, al igual que las de escritura, pueden presentar
grandes diferencias dependiendo del dispositivo utilizado. Pero, también en
este caso, existe en C+ un conjunto de procedimientos generales para la lectura
de datos, que son invocados siempre de la misma manera, con independencia
del dispositivo de entrada utilizado. Por defecto, el dispositivo de entrada
suele estar asociado al teclado del terminal por el que sc accede al computador.
Estos procedimientos están incluidos también en el módulo de librería stdio.

Los datos a leer se suministran externamente on forma de texto, es decir, como
una serie de caracteres seguidos (o pulsaciones de teclas) que pueden incluir
saltos de línea de vez on cuando. En el teclado, el salto de línea corresponde a
la tecla marcada “INTRO” o “ENTRAR? (en teclados ingleses, “RETURN”
o “ENTER>).
 

Constantes y Variables 65

 

3.6.1 El procedimiento scanf

El procedimiento scanf pertenece al módulo de librería stdio. Para leer datos
de entrada y almacenarlos en determinadas variables se escribirá:

scan£( cadena-con-formatos, gvariablel, Evariable2, ... EvariableN );

Es importante observar que los nombres de las variables a leer van precedidos
del carácter ampersand (8).
“A continuación se presenta un ejemplo de uso de este procedimiento de lectura.
Declaración de variables int mes, dia; float saldo;
Datos de entrada 123 4.5 6
Orden de lectura scan£( "%d KE %d", mes, Esaldo, Edia );
Resultado nes = saldo = 4.5; dia = 6;
La cadena de caracteres con los formatos sigue las mismas reglas que la del
procedimiento printf del tema anterior. Debe contener un formato de conversión (Xx) por cada variable a leer. Al ejecutarse el procedimiento scanf
se van tomando caracteres del dispositivo de entrada, se ponen en corresponencia con los formatos indicados, y se extraon los valores correspondientes a
cada formato de conversión para asignarlos a cada variable de la lista, respeotivamente.

 

41 igual que en el procedimiento printf, la cadena con los formatos puede
incluir también otros fragmentos de texto entremezclados con los formatos de
conversión. La ejecución de scanf consiste en analizar uno a uno los elementos
de la cadena con formatos, y actuar en consecuencia, avanzando en el texto
de entrada:

1. Un formato numérico (Xd, k£, Kg, ...) hace que se salten los siguientes
caracteres de espacio en blanco en la entrada, si los hay. A continuación
se leen los caracteres no blancos que formen una representación válida
de un valor numérico del tipo correspondiente al formato, y el valor numérico obtenido se asigna al siguiente argumento de la lista do variables
a leer.

2. Un formato Xe haco que se lea exactamente el siguiente carácter de la
entrada, sea o no espacio en blanco, y se asigne a la siguiente variable a.
leer.

3. Un carácter de espacio en blanco en la cadena con formatos hace que
se salten los siguientes caracteres de espacio en blanco en el texto de
entrada, si los hay.

4. Un carácter no blanco en la cadena con formatos hace que se lea (y se
salte) el siguiente carácter de la entrada, que debe coincidir exactamente
con el carácter del formato,

 
66 Fundamentos de programación

 

Si alguna de las acciones anteriores no puede realizarse, porque el texto de
entrada no contiene los caracteres apropiados, la ejecución de scanf se interrumpe en ese momento, y no se lee más texto de entrada ni se asignan valores
a las variables que falten por leer.

Los formatos de conversión numéricos pueden incluir la especificación del tamaño del dato, de forma similar a como se dijo para printf. Pero a diferencia
de los formatos para printf, en que ese tamaño era el mínimo número de ca
  

 

racteres a escribir, en scanf significa el tamaño máximo del dato de entrada
a leer. Por ejemplo:
Datos Formato  Datoloído Datos restantes
12345xx %d 12345 xx
12345xx — %3d 123 45xx
12xx345 — %3d 12 10345

3.6.2 Lectura interactiva

Cuando un programa se comunica con el usuario mediante un terminal de
texto se suele programar cada operación de lectura inmediatamente después
de una escritura en la que se indica qué dato es el que se solicita en cada
momento. Por ejemplo:

float saldo

printf( "¿Cantidad Pendiente? " );
scanf( "%f", dsaldo );

 

Tras ejecutar la escritura del texto de petición, en la pantalla se verá:

 

[ecantidad Pendiente?

En ese momento se inicia la ejecución del procedimiento de lectura, El símbolo
(ma) se utiliza aquí para indicar la posición del cursor en la pantalla, en espera.
de la entrada del dato solicitado.

 

Cuando se introduce información por el teclado es ventajoso que se pueda
corregir el texto que se va tecleando en caso de cometer errores. Para ello la
lectura de teclado se suele hacer por líneas completas. Mientras se teclea el
texto de una línea se pueden hacer correcciones, y al pulsar la tecla de fin de
línea el texto se acepta y se procesa como dato de entrada. El texto aparece
en la pantalla al mismo tiempo que se va tecleando o corrigiendo. Todo esto
es automático, y se hace directamente al invocar el procedimiento de lectura
de C£.
¡Constantes y Variables 67

 

En el ejemplo anterior, se tecleará el dato acabando con la tecla de fin de línea,
"gue representaremos como [Int

 

 

 

 

 

 

 

¡tidad Pendiente? -45768/[Inro]

 

 

 

 

“42 pulsar [mo] el cursor pasará a la siguiente línea, se procesará el dato de
entrada, y a la variable saldo se le asignará el nuevo valor -45768.

 

 

 

Si se quiere introducir más de un valor con la misma pregunta y en la misma
lnea se puede utilizar como separador de datos el espacio en blanco. Por
ejemplo:

saldo, gastos

:t£( "¿Cantidad pendiente y Gastos? " );
("KEXE”, Esaldo, Egastos );

En la pantalla aparecerá el mensaje de petición, y luego se teclearán los datos
separados por uno o varios blancos y acabados con un [mua

  
  
 

 

 

 

 

 

 

fieras: pendiente y Gastos? -45768 10456. [ind]

“Al pulsar [ina] queda el cursor en la línea siguiente, la variable saldo toma
el valor -45768 y la variable gastos el valor 10456.5. En este caso el espacio
en blanco intermedio entre los datos hace que termino la lectura del primer
valor y se pase a leer el segundo, saltando automáticamente dicho espacio y
los siguientes si los hubiera.

 

El mismo resultado se obtendría programando cada lectura como una sentencia
separada, o introduciendo los datos en varias líneas.

¡float saldo, gastos

'print£( "¿Cantidad pendiente y Gastos? " );
scanf( "KE", fsaldo );

¡scanf "XE", Agastos );

 

 

[¿Cantidad pendiente y Gastos? -45768[muo] |
pe S[intro] |

Cualquier combinación es válida: una sentencia única para leer dos valores o
os sentencias para leer un valor cada una, e introducir los datos en una o dos
líneas, indistintamente.

 

 

 

 

 

 

 
 

68 Fundamentos de programación

 

3.7 Estructura de un programa con declaraciones

Antes de realizar nuevos programas es necesario sabor dónde se sitúan dentro
del programa los nuevos elementos introducidos en este tema, Las declaraciones de valores constantes y de las variables forman parte del bloque del
programa. Por tanto, ahora la estructura del bloque es la siguiente:

 

   

Bloque 33% £ Parte_declarativa Parte. ejecutiva Y
Parte_declarativa 33= [| Declaración Y

= ( Sentencia Y

 

 

Parte_ ejecutiva 3
Declaración 33=
Declaración de_constante | Declaración _de_variable | ...

Llamada_a_ procedimiento | Asignación | ...

 

Sentencia

El contenido de un bloque se organizará en dos partes. La primera de ollas
contendrá todas las declaraciones de constantes, variables, ete., y la segunda
incluirá las sentencias ejecutables correspondientes a las acciones a realizar.
Las declaraciones pueden hacerse en el orden que se quiera, con la limitación
de que cada nombre debe ser declarado antes de ser usado. Las sentencias
ejecutables deben escribirse exactamente en el orden en que han de sor ejecutadas.

NOTA: En C y C++ es posible mezclar las declaraciones con las sentencias ejecutables pero esto está absolutamente prohibido en C+ con una regla obligatoria del
Manual de Estilo y la sintaxis del lenguaje Ct que está recogida en el apéndice A. La:
separación de la parte declarativa y la parte ejecutiva de un Bloque está incorporada.
en la sintaxis de muchos lenguajes de programación (Pascal, Modula-2, Oberon, Ada,

Smalitalk et.) y además es una regla de etilo bastante habitual en proyecto reales
para evitar problemas de uso y aumentar la claridad do los programas.

3.8 Ejemplos de programas

A continuación se presentan varios programas con los nuevos conceptos introducidos.

3.8.1 Ejemplo: Conversión a horas, minutos y segundos

En este ejemplo se trata de convertir a horas, minutos y segundos una cierta
cantidad de tiempo expresada en segundos. La variable segundos se utilizará
para leer la cantidad total de segundos y posteriormente para ir guardando
 
  
  
 
  
  
  
  
  

tes y Variables 69

 

segundos restantes al descontar del total de segundos los que se hayan
ido a horas o minutos completos. El listado del programa es el siguiente:

 

Programa: HorasMinutosSegundos */
Conversión a Horas, Minutos y Segundos
de los segundos introducidos como dato */

lude <stdio.h>

main() (
int horas, minutos, segundos;

print£( "¿Segundos Totales? "
scan£( "Xd", segundos );
horas = segundos / 3600;
segundos = segundos % 3600;
minutos = segundos / 60;
segundos = segundos % 60;
print£( "Equivalen a %2d horas X2d min. y Xd seg.Wn",
horas, minutos, segundos );

   

 

La ejecución del programa introduciendo como dato 23459 segundos es la
siguiente:

 

  
   
   
   
 
 

¿Segundos Totales? 23459
Equivalen a 6 horas, 30 min. y 59 seg.

 

3.8.2 Ejemplo: Área y volumen de un cilindro

En este ejemplo se desarrolla un programa para el cálculo del árca y el volumen
de un cilindro genérico. Es decir, las dimensiones del cilindro scrán variables y
se lcorán como datos. Además se declara como constante el valor de 7 lo que
evita tener que escribirlo más de una vez en todo el programa. El programa así
realizado es más general y más fácil de comprender y modificar que la versión
presentada en el tema anterior. El listado del programa es el siguiente:

 

Va Programa: Cilindro2 */
/* Cálculo del área y el volumen de un cilindro */

[fncinón <stdio.h>
 

70 Fundamentos de programación

int main) 1
const float PI = 3.1415926:
float radio, altura, area, volumen;

 

print£( "¿Radio del cilindro? " );
scan£( "X£", radio );
print£( “¿Altura del cilindro? ”
scan£( "Xf”, altura );
area = 2.0 * PI * radio * (radio + altura);
volumen = PI * radio * radio * altura;
print£( "Area: X15gWnVolumen: %15g10", area, volumen
y

 

 

 

 

La ejecución del programa introduciendo como valor del radio 12,5 y como
altura 72,61 produce el siguiente resultado:

 

¿Radio del cilindro? 12.5
¿Altura del cilindro? 72.61
Area: 5684.52
Volumen: 35642.4

3.8.3. Ejemplo: Realización de un recibo

En este ejemplo se trata de confeccionar un recibo sencillo, correspondiente
a la compra de unos equipos. Como datos habrá que introducir el tipo de
equipo, indicado mediante un código de un carácter; la cantidad de equipos,
el precio unitario y el tipo de IVA aplicado. Los subtotales y totales se darán
en euros y céntimos.

El listado del programa completo es el siguiente.

 

/** Programa: Recibo */
/* Cálculo e impresión de un recibo */

include <stdio.h>

int main) (
int cantidad, IVA;
char codigo:
float precio, totalIVA, subtotal, total;

 
Constantes y Variables 7

print£( "¿Código del producto? " );
scan£( "%c”, Ecodigo
print£( "¿Cantidad?

  

  

 

, cantidad );
Precio unitario? " );
, precio );
print£( "¿IVA aplicable? " );
scanf( "Xd", BIVA );

subtotal = float(cantidad) * precio;

totalIVA = subtotal * float(1VA) / 100.0;

total = subtotal + totalIVA;

print£c " RECIBO de COMPRAN" );

print£( "Cantidad Concepto  Euros/unidad Total");

print£( "%5d Producto: Xc %12.28%12.2fnWn
cantidad, codigo, precio, subtotal );

print£( "X28d%% IVA %12.2£imn", IVA, totalIVA );

/* se ha codificado %% para imprimir literalmente un % */

primtfc TOTALX14.2£Xn", total );

 

 

A continuación se presenta un ejemplo de la ejecución del programa, mostrando
los datos leídos y los resultados escritos.

 

¿Código del producto? A
¿Cantidad? 12

¿Precio unitario? 2345
'¿IVA aplicable? 16

RECIBO de COMPRA

Cantidad Concepto  Euros/unidad Total
12 Producto: A 2345.00 28140.00
16% IVA 4502.40

TOTAL 32642.40

 
Tema 4

Metodología de Desarrollo de
Programas (I)

Aquí se tratan explícitamente los primeros conceptos metodológicos relacio
ados con la programación en general y con la programación imperativa en
particular. Se presenta el desarrollo por refinamiento sucesivos, aunque limitado al empleo de la estructura secuencial, por el momento.

Como elementos complementarios, se hace explicita la nocosidad de usar un
buen estilo de programación, que se concreta en sugerencias sobre el uso de
una notación apropiada para la representación de los elementos del programa.

y la presentación de su estructura de forma clara.

 

4.1 La programación como resolución de problemas

La labor de programación puede considerarse como un caso particular de la.
resolución de problemas. Resolver un problema consiste esencialmente en encontrar una estrategia a seguir para conseguir la solución. En la figura 4.1 se
plantea un problema sencillo.

Una estrategia se expresará como una colección de reglas o recomendaciones
que, si se siguen, conducirán a la solución. Por ejemplo, para resolver el
problema de obtener el área de un rectángulo del que se conocen las longitudes
de sus lados (base y altura), formularemos la estrategia:

multiplicar la base por la altura
 

74 Fundamentos de programación

 

Problema Solución
altura | ¿área? área = base x altura
base

 

Figura 4.1 Problema: Área de un rectángulo.

Un programa en el modelo de programación imperativa se expresa como una
sorie de instrucciones u órdenes que gobiernan el funcionamiento de una máquina. La máquina va ejecutando dichas instrucciones en el orden preciso que
se indique. La estrategia del ejemplo anterior se expresaría en C como:

 

area = base * altura
Todo programa puede considerarse, de alguna forma, como la solución de un
problema determinado, consistente en obtener una cierta información de salida
a partir de unos determinados datos de entrada, La tarea de desarrollar dicho
programa equivale, por tanto, a la de expresar la estrategia de resolución del
problema en los términos del lenguaje de programación utilizado.

4.2 Descomposición en subproblemas

Algunos problemas, como cl ejemplo anterior referente al área del rectángulo,
pueden resolverse o programarse de forma inmediata porque la estrategia se
puede expresar como una acción que se da por sabida, o como una sentencia en
el lenguaje de programación elegido. Los problemas resolubles de esta manera
serán, en general, problemas simples o triviales.

  

Cualquier problema de cierta complejidad necesitará una labor de desarrollo
para expresar la solución, El método más general de resolución de problemas
no triviales consiste en descomponer el problema original en subproblemas
más sencillos, continuando el proceso hasta llegar a subproblemas que puedan
ser resueltos de forma directa.

Lo que se busca aquí es una analogía con la labor de desarrollo de programas.
Puesto que el proceso de ejecución de un programa imperativo consiste en la
realización de las sucesivas acciones indicadas por las órdenes que constituyen
el programa, analizaremos la resolución de problemas en que la estrategia de
solución consiste en realizar acciones sucesivas.
Metodología de Desarrollo de Programas (1) 75

 

Según esta idea, para desarrollar la estrategia de resolución, habrá que ir
identificando subproblemas que se resolverán ejecutando acciones cada vez
más simples. Consideremos el siguiente problema:

Problema : Obtener una caja de madera barnizada

Para expresar la estrategia de solución de forma imperativa comenzamos por
formular la solución como una acción global que consigue el objetivo propuesto.
En muestro caso será:

0) Construir una caja de madera barnizada

En este primer nivel de formulación nos encontramos con una acción a realizar que es demasiado complicada para ejecutarla de forma inmediata, Será.
necesario descomponer el problema original en subproblemas más sencillos,
que puedan ser resueltos mediante acciones más simples. Un primer paso de
descomposición sel

1) Obtener las piezas de madera
2) Montar la caja
3) Barnizarla

     

El proceso de descomposición en subproblemas debe continuar hasta que los
subproblemas se puedan resolver mediante acciones consideradas directamente ejecutables por el agente que ha de proporcionar la solución. La expresión
final de la solución del problema debe tener en cuenta, por tanto, qué acciomes particulares so consideran realizables de forma directa. Tenemos así una
analogía con la tarea de programación, que exige redactar el programa con los
elementos particulares del lenguaje de programación elegido.

En nuestro ejemplo habrá que decidir si el subproblema 1) ha de considorarse
resoluble mediante una acción simple o compuesta. Si podemos adquirir las
piezas directamente en una tienda de “bricolaje”, podremos considerar que el
subproblema es resoluble con una acción simple que no necesita descomponer
se. Si en la tienda sólo podemos comprar un tablero de madera sin cortar,
tendremos que descomponer el problema de obtener las piezas en subproblemas más sencillos, tales como:

1.1) Obtener un tablero de madera

1.2) Dibujar sobre él la silueta de las piezas

1.3) Recortar el tablero siguiendo la silueta
De igual manera habría que proceder con los subproblemas planteados hasta
este momento: 1.1), 1.2), 1.3), 2) y 3), decidiendo si son resolubles de forma
inmediata o bien descomponiéndolos sucesivamente hasta llegar a acciones
simples.

 
76 Fundamentos de programación

 

4.3 Desarrollo por refinamientos sucesivos

La aplicación de las ideas antoriores a la construcción de programas conduce a la técnica de desarrollo mediante refinamientos sucesivos. Esta técnica
es parto de las recomendaciones de una metodología general de desarrollo de
programas denominada programación estructurada, que se estudiará con más
detalle en el tema siguiente, La técnica de refinamientos consiste en expresar
inicialmente el programa a desarrollar como una acción global, que si es necesario se irá descomponiendo en acciones más sencillas hasta llegar a nociones
simples que puedan ser expresadas directamente como sentencias del lenguaje
de programación.

 

Cada paso de refinamiento consiste en descomponer cada acción compleja en.
otras más simples. Esta descomposición exige:
+ Identificar las acciones componentes.
+ Identificar la manera de combinar las acciones componentes para conseguir el efecto global

La forma en que varias acciones se combinan en nna acción compuesta cons
tituye el esquema de la acción compuesta. La programación estructurada recomienda el uso de esquemas particularmente sencillos, que se indicarán más
adelante. Por el momento presentamos un primer esquema que denominaremos esquema secuencial, que consiste en realizar una acción compuesta a base
de realizar una tras otra, en secuencia, dos o más acciones componentes. Este
esquema secuencial es el que se ha utilizado en el ejemplo del problema de
construir la caja de madera

    

4.3.1 Desarrollo de un esquema secuencial

La metodología de refinamientos incluye el ir desarrollando a la vez las sen=
tencias del programa que realizan las acciones de la parte ejecutable, y la
definición de las variables necesarias para almacenar la información manipulada por dichas acciones, Para desarrollar una acción compuesta según un
esquema secuencial se necesitará

 

 

(a) Identificar las acciones componentes de la secuencia, Identificar las variables necesarias para disponer de la información adecuada al comienzo
de cada acción, y almacenar el resultado,

(0) Identificar el orden en que deben ejecutarse las acciones componentes.

Para ilustrar esta técnica consideraremos un caso simple, tal como el de obtener
la suma de dos números enteros. Los dos números se introducirán como datos y

 
Metodología de Desarrollo de Programas (1) 77

 

el programa suministrará como resultado su suma. Aungue resulte un ejemplo
trivial, sirve perfectamente para ilustrar la metodología de desarrollo.

Procediendo paso a paso, describiremos de manera informal cada elemento del
desarrollo, seguido de su codificación en C£ .

 

(a) Acciones component
+ Cálculos: obtener la suma

| suma = datol + dato2
+ Operaciones de entrada: leer datos

print£( "Dar dos números: " );
scanf( "Xd", ádatol );

seanf( "Xd", ádato2 );
print£( "a" );

    

+ Operaciones de salida: imprimir resultado
[print£( "La suna esk1081n", suna) ;
Variables necesarias : datos y resultado
[int datol, dato2. suma;

(b) Orden de ejecución:
1) Leor los datos
2) Calcular la suma
3) Imprimir el resultado

Si nos limitamos a describir la manera en que la acción global del programa.
se va descomponiendo en acciones cada vez más sencillas, podemos usar la
siguiente notación de refinamient

   

Acción compuesta —>
Acción 1
Acción 2
2 lO

 

En esta notación se utiliza una flecha (—>) para indicar que una acción
complicada se descompone o refina en otras más sencillas. Aplicando esta
notación al ejemplo anterior, hasta llegar a sentencias de C£, tendremos:

Obtener la suma de dos números —
Leer los datos
Calcular la suma
Imprimir el resultado

 
 

78 Fundamentos de programación

Leer los datos —>

 

print£( "Dar dos múneros:
scan£( "Xd", Adatol );
scanf "Xd", Edato2 );
print£( Ma" );

 

Calcular la suma —>

[suma = datol + dato2;

Imprimir el resultado —>
|print£( "La suma esk10din", suma );
Uniendo todos los fragmentos finales de código en el orden adecuado, y aña
ado las declaraciones de las variables necesarias, tendremos el programa
completo.

 

 

/** Programa: SumarDosNumeros */
/* Obtener la suma de dos núneros enteros */

*include <stdio.h>

int mainQ (
int datol, dato2, suma;

 

print£( "Dar dos núneros:
scanf( "Xd", ádatol );
scanf( "Xd", tdato2 );
print£( "wn" );

 

suma = datol + dato2;

print£( "La suma esfl0din", suma );

 

 

Un ejemplo de la ejecución de este programa serí

 

 

Dar dos números: 37 143

La suma es 180

 

 
 

Metodología de Desarrollo de Programas (1) 79

 

4.3.2 Ejemplo: Imprimir la silueta de una silla

Aplicaremos la técnica de refinamientos a un programa sencillo en C+ que imprima de forma esquemática la silueta de una silla usando caracteres normales
de escritura, por ejemplo ' de la siguiente forma:

 

 

 

 

oa

La parte ejecutable del programa se planteará inicialmente como una acción
única, que trataremos de describir con una frase sencilla; por ejemplo:

Imprimir la silueta de una silla

Puesto que no parece fácil programar esta acción con una única sentencia
de C£, la descompondremos en acciones más simples. De forma intuitiva
podemos:

(a) Asociar las acciones componentes a la impresión de diferentes partes de
Ja silla: asiento, patas y respaldo.

(b) Seguir el orden de ejecución impuesto por el hecho de que la impresora
ha de ir imprimiendo las líneas de arriba a abajo.

El primer paso de refinamiento será:

Imprimir la silucta de una silla —
Imprimir la. silueta del respaldo
Imprimir la silueta del asiento
Imprimir la silueta de las patas

Ahora hay que determinar si estas acciones intermedias son ya expresables
directamente como sentencias en C+ o necesitan nuevas descomposiciones. No
hay reglas fijas sobre cuándo una acción puede considerarse simple y pasar
a escribirla en el lenguaje de programación. En este ejemplo consideraremos
simple la escritura de una línca de texto.

 

De acuerdo con ello podremos considerar como acción simple la impresión del
asiento, y refinar:

Imprimir la silueta del asiento —>

| print£c

 

SA

La impresión del respaldo se refinaría en la forma:

 

 
80 Fundamentos de programación

 

Imprimir la silueta del respaldo —
Imprimir parte superior del respaldo
Imprimir parte inferior del respaldo

y cada una de estas partes conduciría a las mismas sentencias de Ct:
Imprimir parte superior o inferior del respaldo —>
[print£( "ln" y;

 

De forma similar se refinaría la impresión de las patas de la silla. Omitimos
este paso para no hacer el ejemplo demasiado prolijo. Finalmente todos estos
refinamiento han de ser combinados en un programa único. Reuniendo todas
las sentencias en una única secuencia tendremos:

print£
print£(
print£(
print£(
print£(

 

4.4 Aspectos de estilo

Una buena metodología de desarrollo de programas debe atender no sólo a
cómo se van refinando las sucesivas acciones, sino a cómo se expresan las
acciones finales en el lenguaje de programación. El estilo de redacción del
programa en su forma final es algo fundamental para conseguir que sea claro
y fácilmente comprensible por parte de quienes hayan de leerlo.

   

 

En los apartados que siguen se darán diversas recomendaciones sobre la manera.
de presentar adecuadamente un programa para facilitar su comprensión. Estas
recomendaciones forman parte del Manual de Estilo de C£.

4.4.1 Encolumnado

Un programa aparece como un texto. Dicho texto puede ser visto como un documento técnico, organizado de una manera muy precisa. El estilo de presen
tación de dicho texto o documento debe destacar claramente su organización
en partes.

 

Un recurso de estilo de presentación es el encolumnado o sangrado (indent).
Aumpliando el margen izquierdo para las partes internas del programa se puede
conseguir que el texto de un elemento compuesto ocupe una zona aproximadamente rectangular, y que el texto que representa cada uno de sus componentes
 
  
 
 
   
  
   
   
 
 
 
   
  
    

Metodología de Desarrollo de Programas (1) 8l

 

ocupe también una zona rectangular dentro de ella. Gráficamente podemos
ilustrar esta idea con el esquema de la figura 4.2 en la que se ha marcado el
espacio de cada parte como un rectángulo, y se indica con línea doble cuál es
el margen izquierdo en cada momento.

 

 

Figura 4.2 Encolumuado de elementos compuestos.

Si aplicamos este recurso de estilo al esquema global de un programa en Cé,
Begaremos a escribir, ya completo, el ejemplo anterior de la siguiente manera:

¡En este caso, la función principal int main() (...) es el único clemeno compuesto. Los elementos componentes son las sentencias de escritura
¡print£(....); que so encolumnan todas ellas dejando cierto margen en blanco
2 la izquierda. En próximos temas se ilustrará el encolumnado de componen“tes y subcomponentes cuando se empleen las sentencias estructuradas y los
«subprogramas,

4.4.2 Comentarios. Documentación del refinamiento

¡tro recurso utilizable para mejorar la claridad de un programa es el empleo de
seomentarios. Ya se ha indicado cómo el lenguaje Ct permite intercalar comentarios en el texto de un programa escribiéndolos entre la pareja de símbolos

y.
 

82 Fundamentos de programación

Aunque el lenguaje permite emplear comentarios con toda libertad, es aconsejable seguir ciertas pautas para facilitar la lectura del programa. Estas pautas
corresponden a diferentes clases de comentarios, cada una con un propósito
diferente. Entre ellas podemos mencionar:

 

   

+ Cabeceras de programa
+ Cabeceras de socción

+ Comentarios-orden

+ Comentarios al margen

La cabecera de programa tiene como finalidad documentar el programa como
un todo. Puede incluir datos de identificación, finalidad, descripción general,
ote. Suele presentarse como una “caja” al comienzo del texto del programa,
ocupando todo el ancho del listado. A continuación se presenta una posible
enbecera para el programa de ejemplo de imprimir la silucta de una silla.
parra

* Programa: Silla

* Autor: Fulano de Tal

* Descripción:
* Este programa imprime de forma esquemática la silueta

* de una silla usando caracteres normales de la impresora.
A

En este ejemplo la “caja” se ha delimitado con asteriscos, y se ha dejado
abierta en el lado derecho para facilitar la edición o modificación del texto de
la misma.

Las cabeceras de sección sirven para documentar partes importantes de un programa relativamente largo. Al igual que la cabecera del programa, se presentan
en forma de “caja” al comienzo de la sección correspondientes, ocupando todo
el ancho del listado. Un ejemplo trivial sería:

/

 

PARTE EJECUTABLE DEL PROGRAMA

 

 

 

7

En este ejemplo la “caja” se ha delimitado con signos “=” y se ha dejado
abierta a ambos lados.

Los comentarios-orden son un elemento metodológico fundamental, y sirven
para documentar los refinamientos empleados en el desarrollo del programa.
Si analizamos la redacción final del programa de ejemplo de la silla nos encontraremos con que las acciones intermedias que sc han ido identificando durante
Metodología de Desarrollo de Programas (1) 83

 

el proceso de desarrollo por refinamientos sucesivos no aparecen en ninguna
parto del texto del programa. Al hacerlo así se ha perdido una información de
gran importancia para realizar posteriormente modificaciones en el programa.

Para incluir la información de los pasos de refinamiento en el texto del programa se puede introducir un comentario con la descripción de cada acción
intermedia. Estos comentarios tienen, en cierta medida, la categoría de una
orden del programa imperativo; en efecto, si el lenguaje de programación lo
permitiese, el deseo del programador sería escribir una sentencia que ejecutara
dicha acción, pero como no es posible, la acción se descompone en otras más
sencillas que dan lugar finalmente a sentencias del programa. El comentarioorden se debe encolumnar tal como se haría con una sentencia del lenguajo
que ejecutara la acción deseada. El comentario-orden delimita una acción
compuesta, y las acciones componentes se escribirán dejando un mayor margen a la izquierda, tal como so indicó en la sección anterior. En CE la acción
compuesta puede escribirse entre llaves (J. Como ejemplo, se repite aquí la
parte ejecutable del programa de imprimir la silueta de la silla, documentando
las acciones principales con comentarios-orden y acciones compuestas.
'/*— Imprimir el respaldo —*/ £

print£( “IXa" );

print£( "ia";
Y
¡/*— Imprimir el asiento --*/ 4

print£( "s=====0" );

   

y
/*— Imprimir las patas --*/ 4
print£( 5
primt£( Mato;
y
En este ejemplo se han utilizado caracteres fácilmente visibles “--" para mar
car el principio y el final de los comentarios-orden y distinguirlos de comentarios de otro tipo.

Finalmente mencionaremos la posibilidad de emplear comentarios al margen.
Estos comentarios sirven para aclarar el significado de ciertas sentencias del
programa, que pueden ser difíciles de interpretar al leerlas tal como aparecen
escritas en el lenguaje de programación empleado. Una recomendación de
estilo es situar estos comentarios hacia la parte derecha del listado, en las
mismas líneas que las sentencias que se comentan, y alineados todos a partir
de una posición fija, hacia el comienzo del tercio final
 

 

E Fundamentos de programación

Los comentarios al margen se utilizan muchísimo para explicar el significado
de cada variable usada en un programa, poniéndolos en la misma línea en que
se declaran. Por ejemplo:

float base, altura; /* dimensiones en cm */

float area; /* área en cul */
int volumen; /* volumen en litros */
int dia; /* entre 1 y 31 */

Como resumen de todas las recomendaciones sobre empleo de comentarios,
se muestra a continuación el listado completo del programa de imprimir la
silueta de la silla, incluyendo comentarios de todos los tipos indicados. En un
programa tan sencillo como éste muchos de los comentarios resultan superfluos
y de hecho hacen el programa un tanto engorroso, pero se han incluido para
¡ustrar la manera de presentar cada clase de comentario.

 

AAA RARA
* Programa: Silla

* Descripción:

* Este programa imprime de forma esquemática la silueta

* — de una silla usando caracteres normales de la impresora.
Ae

 

$

DIRECTIVA DE COMPILACIÓN

 

*include <stdio.h>

/

 

PARTE EJECUTABLE DEL PROGRAMA

   

 

int main() (
/%-- Imprimir el respaldo -*/ £
print£( "1"
print£( "a" y;
,
/*-— Imprimir el asiento —*/ 4

  

  

 

primt£( ": $

J

/*— Imprimir las patas --*/ (
printf" y
printf" An

3

3

 
 

Metodología de Desarrollo de Programas (I) 85

4.4.3 Elección de nombres

Otro aspecto de estilo, fundamental para la claridad de un programa, es una
elección correcta de los nombres o identificadores utilizados para designar sus
diferentes elementos. Los nombres que tenga que inventar el programador
¡deben ser elegidos con un criterio nemotécnico, de manera que recuerden fá'cilmente el significado de los elementos nombrados.

Para evidenciar la importancia de usar nombres adecuados, compararemos
dos redacciones de un mismo programa. La primera, con nombres carentes de
«significado sería:

<stdio.h>

  
    

main() 1
ántx, y, 25

 

2=x*y;
print£( "Area = XL04" ,z );
y

La segunda redacción del programa, con nombres significativos, podría ser:
<stdio.h>

main) 4
int base, altura, area;

scan£( "Xd", ábase );

scanf( "Xd", Saltura );

area = base * altura;

print£( "Area = K10d",area );
y

 

Comparando ambas redacciones es muy fácil darse cuenta de la ventaja de
la segunda, cuyo significado puede adivinarso fácilmente incluso con la total
ausencia de comentarios explicativos en el programa.

Para que los nombres o identificadores resulten significativos hay que procuzar que tengan la categoría gramatical adecuada al elemento nombrado. En
concreto:
+ Los valores (constantes, variables, etc.) deben ser designados mediante
sustantivos.
+ Las acciones (procedimientos, etc.) deben ser designadas con verbos.
 

86 Fundamentos de programación

 

+ Los tipos deben ser designados mediante nombres genéricos.

En programas largos con muchos identificadores resulta a veces difícil inventar nombres significativos que distingan fácilmente entre valores y tipos. Un
recurso de estilo puede ser construir los identificadores de tipo usando sistemáticamente el prefijo Tipo o similar en todos ellos; por ejemplo TipoLongitud
o bien T_Longitud.

IENOTA: En los lenguajes C y C++ es también habitual usar sufijos en lugar de

prefijos para distinguir diferentes categorías de identificadores. En particular el sufijo

¿E para los nombres de tipos, incluso en algín tipo predeñnido como wehart en
ht.

 

Al usar verbos para nombrar acciones conviene emplearlos de manera uniforme
utilizando siempre el mismo tiempo gramatical. En inglós suelen aparecer en
imperativo. En español resulta quizá más natural emplear sistemáticamente el
infinitivo. De hecho en inglés el imperativo y el infinitivo coinciden en muchos
casos. Ejemplos:

  

Término inglés Imperativo Infinitivo
writeNumber escribeNumero  escribirNumero
read_date lee_fecha leer_fecha
go_to_origin ve_al_origen ir_al_ origen

A continuación se presenta un ejemplo de programa completo, incluyendo identificadores de diferentes clases elegidos según las recomendaciones anteriores.
En este ejemplo se ha supuesto que existe un módulo llamado Fechas que
define procedimientos para manipular datos de tipo fecha. El estilo seguido
para elegir los nombres inventados por el programador ha sido:

+ Los nombres de operaciones (procedimientos y programa principal) son
verbos en infinitivo:

CalcularDias LeerFecha EscribirFecha
+ Los nombres de valores ( funciones y variables ) son sustantivos:

DiasEntre Hoy  fechaCumple
fechaloy dias

+ Los nombres de tipo empiezan por el prefijo T_:

T_fecha
Metodología de Desarrollo de Programas (1) 87

 

 

FAA AAA
* Programa: CalcularDias

* Descripción:

* Este programa calcula los días que faltan para el

* cumpleaños de una persona.
AAA AAA ALEA

'sinclude <stdio.h>
¡*include "fechas.h"

Panas

En el módulo fechas.h están definidos.

 

 

T_fecha = Tipo de valor FECHA
LeerFecha = Procedimiento para leer una fecha
EscribirFecha = Procedimiento para escribir una fecha
DiasEntre = Función para calcular los dias que hay
entre dos fechas
hoy = Variable en la que se mantiene actualizada la
fecha de hoy

 

*/

 

Ant mainO £
Tfecha fechaCumple; /* cumpleaños */
T fecha fechaoy;  /* fecha de hoy */
int dias; /* días que faltan */

/*-- Obtener la fecha del cumpleaños --*/ (
print£( "¿Cuál es tu próximo cumpleaños? "
LeerFecha( fechaCumple );

3

/*-- Obtener la fecha de hoy --*/ 1
fechaloy = Hoy;

J

/*-- Calcular los días que faltan para el cumpleaños --*/ 1
dias = DiasEntre( fechalloy, fechaCumple );

J

/*-— Inprimir el resultado --*/ (
print£( "WnFaltankad”, dias);
print£( " días para tu cumpleaños” );

J

y

 

 
88 Fundamentos de programación

4.4.4 Uso de letras mayúsculas y minúsculas

Los lenguajes de programación que permiten distinguir entre letras mayúsculas
y mintísculas facilitan la construcción de nombres en programas largos, en que
es preciso inventar un gran número de ellos.

Por ejemplo, para marcar claramente a qué clase de elemento del programa se
está rofiriendo un nombre, se puede adoptar el criterio de que los identificadores
de ciertas clasos de elementos empiecen siempre con mayúscula, y otros siempre
con minúscula, o que algunos muy especiales so escriban todo en mayúsculas.
En el ejemplo del apartado anterior se han seguido las siguientes reglas de
estilo para escribir los identificadores inventados por el programador:

 

+ Los nombres de tipos, procedimientos y funciones empiezan por mayúscula:

CalcularDias Leerfecha EscribirFecha
DiasEntre Hoy

+ Los nombres de variables y constantes empiezan por minúscula:
fechaCumple fechaloy dias

+ Los nombres que son palabras compuestas usan mayúsculas intercaladas
al comienzo de cada siguiente palabra componente:

TipoLongitud TipoFecha  fechaHoy
CalcularDias LeerFecha  EscribirFecha
DiasEntre fechaCumple

En cualquier caso hay que limitar mucho el empleo de nombres escritos totalmente en mayúsculas, ya que en general hacen más pesada la lectura del texto
dol programa. Sólo deberían escribirse así elementos que han de destacar entre
los demás.

Compárese el siguiento programa, escrito todo en mayúsculas, con el ejemplo
correspondiente del apartado 4.4.3. La lectura resulta ahora mucho más difícil.
INCLUDE <STDIO.H>

INT MAINO (
INT BASE, ALTURA, AREA;

SCANEC"XD",áBASE) ;
SCANE("XD",SALTURA
AREA = BASE * ALTURA;

PRINTEC"AREA = %10D", AREA.

 

   
 

Metodología de Desarrollo de Programas (1) 89

ILNOTA: El programa anterior no es válido en CE ni ea Co C++, que requieren
iertas palabras en minúsculas, Se ha presentado sólo como ejemplo de la
Mrciiaa do lios qu conlóaL dl tos dla esla e inayiscil:

  

4.4.5 Constantes con nombre

 

La posibilidad de declarar constantes con nombres simbólicos puede aprove'charse para mejorar la claridad del programa. En lugar de usar directamente
valores muméricos en las expresiones de algunos cálculos, puede resultar ventaeso definir determinados coeficientes o factores de conversión con un nombre
simbólico que tenga un buen significado nemotécnico, y usar la constante con
se nombre en los cálculos. Por ejemplo, para transformar una longitud de
pulgadas a centímetros, en lugar de escribir:

JlongitudCn = longitudPul * 2.54

se podría poner
¡const float cnPorPulgada = 2.54;

JongitudCn = longitudPul * cnPorPulgada

Esta segunda forma resultará más significativa para los que no recuerden de
memoria ese factor de conversión. Además se tiene una ventaja adicional en
el caso de que un mismo valor constante se use en varios puntos del programa;
al definirlo como constante con nombre el valor numérico particular se escribe
sólo una vez, en la definición, en lugar de hacerlo tantas veces como se uso, y
así se reducen las posibilidades de cometer errores de escritura.

  

Otra forma ventajosa de usar el mecanismo de definición de constantes con
"nombre so da en el caso de que el comportamiento de un programa venga dado
en función de ciertos valores generales, fijos, pero que quizá fuera interesante
cambiarlos en el futuro. Este tipo de valores se denominan a veces parámetros
del programa, y es conveniento que su valor aparezca escrito sólo una vez en
un lugar destacado del programa. Por ejemplo, un programa para reformar un
texto antes de enviarlo a la impresora puede tener como parámetros generales
el ancho de la línea de escritura, o el tamaño de la página. Podríamos escribir,
al comienzo del programa:

y

 

 

PARAMETROS GENERALES

 

nd
const int ANCHO_LINEA
const int LINEAS_ PAGINA

 

 
90 Fundamentos de programación

De esta manera queda perfectamente destacada la parte del programa que hay
que modificar si se quieren cambiar las dimensiones útiles de la hoja impresa.

4.5 Ejemplos de programas

A continuación se desarrollan algunos programas sencillos mediante refinamientos sucesivos.

4.5.1 Ejemplo: Imprimir la figura de un árbol de navidad

Se trata de escribir un programa que imprima la silueta de un árbol de navidad
convencional, según aparece en el siguiente listado resultado de la impresi

 

 

Para estructurar el programa trataremos de identificar las diferentes partes
de la figura del árbol. Podemos reconocer la copa (formada por tres pisos
de ramas), el tronco y la base. Teniendo en cuenta que las distintas partes
han de imprimirse de arriba a abajo, organizaremos los primeros pasos de
refinamiento:

 

Imprimir arbol —
Imprisár copa
Imprimir tronco
Imprimir base

Imprimir copa —>
Imprimir primeras ramas
Imprimir segundas ramas
Imprimir terceras ramas
  
   

Metodología de Desarrollo de Programas (1) 91

La impresión de cada parte se consigue directamente con sentencias de escritusa sencillas, Podemos pasar ya a escribir el programa en CE, documentándolo
¡de acuerdo con las reglas de estilo propuestas. El programa completo aparece
2 continuación.

 

* Programa: Arbol

* Descripción:

'* Este programa imprime la silueta de un árbol

* de navidad, hecha con asteriscos

AAA AAA

'sinclude <stdio.h>

“int main() (
/*-- Imprimir copa --*/ 4

/*-- Imprimir primeras ramas --*/ (
printer A);
primt£( o ear
printE( o e

,

/*-- Imprimir segundas ramas --*/ 4
printer e);
print£( "+" y;
Printer ea);

,

/*-- Imprimir terceras ramas --*/ 1
printecoo een
Print£( "mee
Print£( "Htteren

,

J
/*— Imprimir tronco--*/ £
primer a);
primfc ro at);
printed;
z
/*-— Imprimir base -- */ 4
printf( " +");
y
y

 

 

 

  
 

92 Fundamentos de programación

4.5.2 Ejemplo: Calcular el costo de las baldosas

 

So trata de calcular el costo total de las baldosas necesarias para cubrir el suelo
de una habitación rectangular. Se supone que las baldosas son cuadradas.
El programa loe como dato el lado de las baldosas, en centímetros, y las
dimensiones de la habitación rectangular en metros. También se suministra
como dato el precio unitario de cada baldosa.

 

El programa caleula cuántas baldosas hay que colocar a lo largo de cada dimensión de la habitación, incluyendo contar una baldosa más si no es un número
entero y hay que romper algunas baldosas para cubrir exactamente hasta el
borde. A continuación se calcula el número total de baldosas y se multiplica
por el precio de cada una.

De forma abreviada, los primeros pasos de descomposición conducen ar

Calcular el costo de baldosas —>
Leer los datos
Calcular el número de baldosas
Caleular el coste total
Imprimir el resultado

Calcular el número de baldosas —>
Calcular las baldosas a lo largo
Calcular las baldosas a lo ancho
Calcular el número total de baldosas

El programa completo, debidamente documentado, apareco en el siguiente
listado:

 

AAA RARA
* Programa: Baldosas

* Descripe:
* Este prograna calcula el costo de las baldosas

necesarias para cubrir una habitación rectangular
RRA IAAARARR/

*include <stdio.h>

 

 

int mainQ) £
int largo, ancho; /* Dimensiones de la habitación en m */
int lado; /* Lado de la baldosa en cm */
int nLargo; /* Número de baldosas a lo largo */
int nAncho; /* Número de baldosas a lo ancho */
int baldosas; — /* Número total de baldosas */

float precio; /* Precio de cada baldosa */
 

Metodología de Desarrollo de Programas (1) 93

float coste; /* Coste total */

/*-- Leer los datos --*/
print£( "Dar el tamaño de la habitación, en min" );
print£( “¿Largo, ancho? * );
scan£( "Xd,%d",£largo, ancho);
print£C "¿Lado de la baldosa, en cm?
scanf( "Xd", lado );
print£( “¿Precio de cada baldosa, en euros? ");
scan "XE", áprecio );
/*--Calcular el minero de baldosas-*/ (
/*--Calcular las baldosas a lo largo, por exceso--*/ 4
nLargo = (largo*100 + lado - 1) / lado;
J
/*--Calcular las baldosas a lo ancho, por exceso--*/ 4
nancho = (ancho*100 + lado - 1) / lado;
y
/*Calcular el núnero total de baldosas--*/ 4
baldosas = nLargo * nAncho;
+
7
/*--Calcular el coste total--*/ 1
coste = baldosas * precio;
y
/*--Imprimir el resultado--*/ (
printf( "Total X5d baldosasin", baldosas );
print£( "Coste %8.2f eurosin", coste );
J
y
y

 

   

 

El resultado de una posible ejecución es el siguiente:

 

¡Dar el tamaño de la habitación, en m
'¿Largo, ancho? 4, 6

¿Lado de la baldosa, en cm? 30

¿Precio de cada baldosa, en euros? 0.56
Total — 280 baldosas

Coste — 156.80 euros

4.5.3. Ejemplo: Calcular los días entre dos fechas
Este ejemplo consiste en calcular la diferencia en días entre dos fechas. Para.

simplificar, el cálculo se hace de forma aproximada, contando todos los meses
a razón de 30 días cada nno, y los años completos siempre con 365 días.

 
 

 

94 Fundamentos de programación

El cálculo se hace en dos partes. Primero se calculan para cada fecha los
transcurridos desde el comienzo de su año. Luego se calcula la diferencia entre
fechas, pasando la diferencia en años a días y acumulando la diferencia en días
dentro del año. Los pasos de descomposición son relativamente sencillos:

 

las.

 

 

Calcular la diferencia de fechas —>
Leer las fechas
Calcular la diferencia
Imprimir el resultado
Calcular la diferencia —
Calcular los días desde principio de año
Calcular la diferencia total de días

El programa completo aparece en el siguiente listado:

 

 

PA A AREA
* Programa: DiferenciaEnDias

* Descripción:

* Este programa calcula los días entre dos

* fechas, de forma aproximada, contando todos

* meses de 30 días, y los años de 365

AAA

*include <stdio.h>

int main() £
int dial, mesl, annol; /* primera fecha */
int dia2, mes2, anno2; /* segunda fecha */

int diasFechal, diasFecha2; /* días desde inicio del año */
int diferenci: /* diferencia en días */

 

/*-- Leer las fechas =-*/ 4
print£( "¿Primera fecha (dd,mm,aaaa)? " );

 

 

 

scanf( "Xd,Xd,Xa", ádial, tmesl, fannol );
printf( "¿Segunda fecha (dd,mm,aaaa)? " );
scanf( "Xd,Xd,%d", ádia2, ámes2, fanno2 );

 

3
/*— Calcular la diferencia --*/ 1
/*—Calcular los días desde principio del año
diasFechal = (mesl - 1)*30 + dial
diasFecha2 = (mes2 - 1)*30 + dial
+
/*-—Calcular la diferencia total en días--*/ (
diferencia = (anno2 - anno1)*365
+ diasFecha2 - diasFechal;

   

A

 
 
  
 
 
 
    
  

lología de Desarrollo de Programas (1) 95

 

4

/*-—Imprimir el resultado--*/ €
printf( "Desde %2d/x2d/x4dyn", dial, mes1, annol )
printf( "hasta *2d/%2d/%4din", dia2, mes2, anno2 )
print£( "hay %5d díasta", diferencia);

3

 

 

resultado de una posible ejecución del programa es el siguiente:

 

:ra fecha (dd,mm, aaa)? 20,3,2009
fecha (dd,mm,aaaa)? 14,1,2011
le 20/ 3/2009
a 14/ 1/2011
664 días

 
   
  
    
    
   
  
   
   
     
    

ema 5

structuras Básicas de la
ogramación Imperativa

 

tema se dedica a introducir las estructuras básicas de la programación
-rativa: Secuencia, Selección e Iteración, indicando la manera de realizar
estructuras en Cf. Aunque existen otras estructuras, que Se introducen
temas posteriores, en esto tema se la preferido insistir fundamentalmente
los conceptos subyacentes en estas estructuras básicas, prescindiendo de los
os específicos de un lenguaje particular.

 

cialmente se presentan sólo las estructuras básicas IF-THEN-ELSE y
LE, y su codificación en Ct, Posteriormente se mencionan las estructuras
iculares IF-ELSIF-ELSE y FOR derivadas de las anteriores, justificándopor la comodidad de su uso.

1 Programación estructurada

programación estructurada es una metodología de programación que fundasente trata de construir programas que sean fácilmente comprensibles.
programa no solamente debe funcionar correctamente, sino que además
estar escrito de manera que se facilite su comprensión posterior.

sente on todos los programas se tienen que realizar algunas correco!
0 modificaciones después de trascurrido un cierto tiempo. En esc momento
'trata de ovitar lo que a veces llega a suceder, desgraciadamento: si el prono está claramente escrito, ni el mismo programador que construyó el
na es capaz de entender cómo funciona.

 
 

98 Fundamentos de programación

 

 

Esta metodología está basada en la técnica de desarrollo de programas por refi'namientos sucesivos, tal como se ha expuesto en el tema anterior. Inicialmente,
se plantea la operación global a realizar por el programa, y se descompone en
otras más sencillas. A su vez, estas últimas vuelven a ser descompuestas muevamente en otras todavía más elementales. Este proceso de descomposición
continúa hasta que todo se puedo oscribir utilizando las estructuras básicas
disponibles en el lenguaje de programación que se está empleando.

5.1.1 Representación de la estructura de un programa

La estructura de los programas imperativos se representa tradicionalmente mediante diagramas de flujo, llamados en inglés “flow-chart”. Estos diagramas
contienen dos elementos básicos, correspondientes a acciones y condiciones
(figura 5.1). Las acciones se representan mediante rectángulos, y las condiciones mediante rombos. Las condiciones equivalen a preguntas a las que se
puede responder “Sí” o “No”.

sr NO

Figura 5.1 Símbolos de acción y condición.

El flujo de control durante la ejecución del programa se refleja mediante líneas
o vías que van de un elemento a otro. Las acciones tienen una sola vía de
entrada o comienzo y una de terminación o salida. Las condiciones tienen una
vía de entrada, y dos vías de salida marcadas con “Sf” y “No”, Durante la
ejecución, cuando el flujo llega a la entrada de una acción, la acción se realiza
y el flujo so dirigo a su salida, Cuando se llega a la entrada de una condición,
la condición se evalúa, y si resulta ser cierta se continúa por la salida “Sí”,
mientras que si es falsa so continúa por la salida “No”. La figura 5.2 contiene
un ejemplo sencillo de diagrama de flujo. En esta figura se indica también
cómo un fragmento del diagrama, que tenga un solo punto de entrada y uno
de salida, puede ser visto globalmente como una acción única, pero compuesta.

  

La parte de diagrama de flujo en el interior de una acción compuesta constituye la estructura o esquema de dicha acción. La programación estructurada
recomienda descomponer las acciones usando las estructuras más sencillas posibles, Entre ellas se reconocen tres estructuras básicas, que son: Secuencia,

 
   
     
 
   
   
   

Estructuras Básicas de la Programación Imperativa 99

 

 

a)
Figura 5.2 Ejemplo de diagrama de flujo (a) y acción compuesta (b).

¡Selección o Iteración. Estas tres estructuras están disponibles en todos los
jjes modernos de programación imperativa en forma de sentencias del
je. Combinando unos esquemas con otros se pueden llegar a construir
con una estructura tan complicada como sea necesario.

.2 Secuencia
estructura más sencilla para emplear en la descomposición es utilizar una

cia de acciones o partes que se ejecutan de forma sucesiva. En la figu5.3 se muestra una secuencia de acciones.

Figura 5.3. Secuencia,

estructura secuencial ya ha sido utilizada en los ejemplos realizados en
temas anteriores. Todos ellos han sido resueltos como una secuencia de
as elementales del lenguaje.
100 Fundamentos de programación

5.1.3. Selección

La estructura de selección consiste en ejecutar una acción u otra, dependiendo
de una determinada condición que se analiza a la entrada de la estructura. En
la figura 5.4 so puede ver la estructura de selección. Si la condición analizada
<?> da como resultado “Sí” se realiza la acción A y si el resultado es “No”
so realiza la acción B. Como se puede observar sólo tiene una única entrada y
una única salida.

 

 

Figura 5.4 Selección.

5.1,4 Iteración

La iteración es la repetición de una acción mientras que se cumpla una determinada condición. La estructura de iteración más general es aquella en que la
condición se analiza n la entrada de la estructura y antes de iniciar cada nueva
repetición. En la figura 5.5 so muestra esta estructura de iteración. Cada vez
que se analiza la condición <?> se pueden dar dos resultados. Si el resultado
es “Sí” se ejecuta nuevamente la acción. Una vez ejecutada la acción se vuelve a analizar la condición <7>. En el momento que el resultado es “No” se
alcanza el punto final de la estructura. También en este caso sólo existe un
punto de entrada y un punto de salida.

  

 

Puesto que el fujo de ejecución vuelve hacia atrás siguiendo un camino cerrado,
la estructura de iteración se denomina también bucle.
Estructuras Básicas de la Programación Imperativa 101

 

 

Figura 5.5 Iteración.

5.1.5 Estructuras anidadas

Cualquier parte o acción del programa puede a su vez estar constituida por
cualquiera de las estructuras descritas. Por tanto, el anidamiento entro ellas
puede ser tan complejo como sen necesario.

 

Mediante la técnica de refinamientos sucesivos se definen inicialmente las estructuras más externas del programa y en los pasos sucesivos se va detallando
la estructura de cada acción compuesta. Este proceso finalmente da lugar a
«que todo el programa quede escrito utilizando las estructuras básicas descritas
en este apartado, anidadas unas dentro de otras.

 

5.2 Expresiones condicionales

Para poder utilizar las estructuras de selección e iteración es necesario expresar
las condiciones <?> que controlan ambas estructuras. Esto se realiza medianto
la construcción de exprosionos condicionales. Estas expresionos sólo pueden
dar como resultado dos valores: “Sí” (cierto), cuando so cumple la condición
de la expresión, y “No” (falso), en caso de que no so cumpla.

Una primera forma de construir expresiones condicionales es mediante el empleo de operadores de comparación en expresiones aritméticas. Estos operadores permiten realizar comparaciones entre dos valores del mismo tipo. Es
muy importante resaltar que en el Manual de Estilo de esta asignatura no so
permite la comparación entre elementos de distinto tipo (por ejemplo: enteros
con caracteres, reales con enteros, fechas con colores, cte.). Las operaciones
de comparación disponibles y sus operadores en C son las siguientes:

 
 

 

 

102 Fundamentos de programación

 

 

Comparación Símbolo matemático Operador Ct
Mayor que > A *
Mayor o igual que > >
Menor que < <
Menor o igual que s <=
Igual a Diferente a + l=

Los símbolos de operadores Ct con dos caracteres deben escribirse precisamente en esc orden, y sin espacio en blanco entre ellos.
Veamos un ejemplo. Sean las variables declaradas siguientes:

int largo, ancho;
float presion, temperatura;
char letra, modelo;

Con los operadores de comparación se pueden formar expresiones condicionales
tales como las siguientes:

 

 

largo > 5

ancho == largo
presion

modelo = 'Z*

letra != modelo
presion != temperatura

Con los operadores de comparación sólo es posible realizar una única comparación entro dos valores. Sin embargo, es bastante normal que las condiciones
sean más complejas. Pueden construirse condiciones que impliquen a más de
dos valores como condiciones compuestas de varias condiciones simples.

Las condiciones compuestas se construyen como ezpresiones lógicas. Cada término de una expresión lógica podrá sor una expresión condicional simple. Las
operaciones lógicas entre dos expresiones simples Ex, Ez y los correspondientes
operadores disponibles en Ct son los siguientes:

 

Operación lógica Símbolo matemático Operador Ct
Conjunción (E, y Ez) A E
Disyunción (E; o Ez) v "
Negación (no Ex) 2 !

 

La operación de conjunción El 88 E2 da resultado cierto si tanto El como
E2 son ciertos. En el lenguaje C£ para evaluar la operación de conjunción 88
siempre se empieza por evaluar la expresión simple El del primer operando, y
si su resultado es falso ya no se evalúa la expresión E2 del segundo operando.
Estructuras Básicas de la Programación Imperativa 103

Está claro que el resultado de la conjunción ya no depende del valor de E2 y
será siempre falso. Por este motivo se dice que el operador dk se ovalúa en
sortocireuito, Esta misma regla se aplica en el caso de realizar la conjunción de
mn expresiones El 88 E2 8£ E3 €£ ... 88 En y sólo se continuará evaluando
sana nueva expresión Ei cuando todas las anteriores hayan sido ciertas.

La operación de disyunción El || E2 da resultado cierto si una de las dos, El
o E2,o ambas, son ciertas. También el operador | | se evalúa en cortocircuito
y en la disyunción de n expresiones El || E2 || E3 || ... || Ensólose
¡continua evaluando una nuova expresión Ef cuando todas las anteriores hayan
sido falsas.

El operador 1 se aplica a un solo término y niega el resultado de dicho término.
Este operador unario se utiliza cuando una condición queda expresada de
manera más sencilla como complemento de otra. Por supuesto, el operador
sólo se puede utilizar para negar elementos de tipo Sí(cierto)/No(falso).

 

 

  

Con estos nuevos operadores es posible construir condiciones complejas tales
'como las siguientes:

argo > 5) 8%: (ancho < 7)

(modelo == 'A') || (modelo == *Z')

% (letra == 'Q")

(temperatura <= 123.7) £ (presion < 12.3)

 

Su significado se puede deducir fácilmente. La razón del empleo de paréntesis
es indicar el orden preciso de ejecución de las operaciones: primero las compaaciones y posteriormente las operaciones lógicas. El empleo de paréntesis en
«cualquier lenguaje de programación evita la ambigtiedad en las expresiones

Por el contrario, un uso excesivo de paréntesis para detallar el orden estricto
de ejecución puede llegar a resultar algo farragoso y disminuir la claridad del
programa.

Todos los lenguajes tienen definido un orden por defecto para la evaluación de
los operadores en las expresiones complejas. Así, como se verá a continuación,
sen el lenguaje Ct se realizan primero las operaciones de comparación y postosiormente las operaciones lógicas. Por tanto, en las expresiones anteriores se
podría prescindir de todos los paréntesis salvo para la negación de la tercera.

 

La complejidad de las expresiones puedo ser tan grando como sea necesario;
el número de términos lógicos que pueden combinarse es ilimitado. Además,
“cada valor numérico se puede obtener mediante una expresión aritmética. Por
«ejemplo, son expresiones condicionales válidas las siguientes:
 

104 Fundamentos de programación

(largo < 3) 8% (ancho < 9) 84 (largovancho < 25)
(letra == 'Q' || letra == '21))
(3.S*temperatura - presion/5.6) < 54.6

   

En la evaluación de estas expresiones complejas el orden por defecto que se
sigue viene fijado por el nivel de prioridad que tienen asignadas las distintas
operaciones. Es decir, cada operador tiene una prioridad determinada. Si no
se utilizan paréntesis, el orden de evaluación en el lenguaje Ci es el siguiente:

 

- Operadores Unarios: LES
. Operadores Multiplicativos: —* / %
.. Operadores Aditivos: .o

. Operadores de Comparación: > >= < <=
.. Operadores de Igualdad:

Operador de Conjunción: 88
. Operador de Di ción: Ú

 

Soren

 

Los operadores unarios + y - permiten indicar el signo del único operando al
que preceden y no se deben confundir con los operadores aditivos + y = que
necesitan dos operandos para calcular su suma o su resta respectivamente.

Dentro del mismo nivel de prioridad las operaciones se evalúan en el orden en
que están escritas en cada expresión concreta, de izquierda a derecha. Como
ejemplo escribiremos ahora sin paréntesis las anteriores expresione:

 

largo < 3 8% ancho < 9 88 largo*ancho < 25
Hetra == 'Q' || letra == 'Z*
3.5*temperatura - presion/5.6 < 54.6

Siguiendo los criterios de evaluación indicados, estas expresiones serían equivalentes a las que se indican a continuación, en las que se ha marcado con
paréntesis el orden de la evaluación por defecto:

(largo < 3) €£ (ancho < 9) té ((largo*ancho) < 25)

((Iletra) *0') 11 (Getra == '2')

((3.5*temperatura) - (presion/5.6)) < 54.6

 

Con estas expresiones sólo se trata de mostrar las reglas de evaluación por
defecto, dado que como se puede observar, la segunda expresión está mal
construida, ya que no tiene ningún sentido hacer la negación de un carácter
letra y después comparar el resultado con el carácter *Q*. Por otro lado, es
interesante resaltar que las expresiones primera y tercera son completamente
correctas y equivalentes a las expresiones sin ningún paréntesis o bien a las
expresiones originales con paréntesis para explicitar el orden de ejecución:
primero comparar y luego realizar las operaciones lógicas.

 

  

 
 
  
   
   
    
 
 
 
   
   
 
  
  
   
  
  
   
  
   
  
  

Estructuras Básicas de la Programación Imperativa 105

 

 
 

“Para formalizar estos conceptos, las reglas BNF que definen cómo se pueden
'escribir expresiones aritméticas, condicionales y lógicas en el lenguaje Ct son
Jas siguientes:

 

Expresión Expresión ORÁ Operador_OR Expresión _OR Y
Expresión OR 335 Enpresión_AND
L Operador_AND Expresión_AND Y
Expresión AND 33% Expresión igualdad
L Operador_ igualdad Expresión igualdad ]
Expresión igualdad 333 Expresión numérica
[ Operador_comparación Expresión numérica ]

 

 

Término Í Operador_sumador Término Y
Factor Í, Operador_multiplicador Factor Y
Factor 33% + Factor | - Factor | 1 Factor | Identificador_de_variable |
Identificador_de_constante | Valor_constante | (Expresión )
Operador_OR.
Operador_AND
Operador_igualdad *
Operador_comparaci
.dor_sumado
lDperador_multiplicador lrls

resumen de este apartado, dentro del Manual de Estilo que utilizaremos
asignatura se establecen las siguientes normas:

Expresión numérica 33

 

Término *

 

 

 

   
 

 

 

Es aconsejable utilizar paréntesis adicionales para evitar cualquier ambigiiedad o dificultad de interpretación de la expresión.

Es aconsejable utilizar paréntesis adicionales siempre que se mejore la.
claridad de la expresión.

No es aconsejable utilizar paréntesis adicionales en aquellas expresiones
que, aprovechando los niveles de prioridad por defecto del lenguaje, estén
- ampliamente consensuadas y no planteen ninguna duda en su interpretación

No están permitidas las comparaciones entre elementos de distintos tipos.
Los operadores lógicos ( 84 y || Jsólo se pueden utilizar con elementos
de tipo Sí(cierto)/No(falso)

 

 

 
 

 
 

106 Fundamentos de programación

 

5.3 Estructuras básicas en Ct

En este apartado se describen las sentencias de CE quo corresponden a las
estructuras básicas introducidas anteriormente. Además se mencionan algunas
posibilidades adicionales de estas sentencias, que permiten algunas variantes
de las estructuras básicas, y que simplifican la escritura de ciertos programas.

5.3.1 Secuencia

Esta estructura ya ha sido introducida en el toma 2 y utilizada on todos los
programas y ejemplos realizados hasta ahora. Para programar una secuencia
de acciones en C+ se escriben las sentencias que forman la secuencia de acciones
una tras otra. Así, la secuencia de la figura 5.3 se escribe simplemente de la
siguiente manera:

Acción A

Acción B

Formalmente, según se vio en el tema 2, la sintaxis de la estructura secuencia
es:

 

Secuencia_de_sentencias 333 É Sentencia Y

5.3.2 Sentencia IF

En Ct la estructura de selección de la figura 5.4 se programa como una sentencia 1F que tiene el siguiente formato:

i£ ( Condición ) 4
Acción A

 

 

La ejecución de la sentencia ¿£ consiste en evaluar la expresión de Condición,
y a continuación ejecutar o bien la Acción A (si se cumple la condición), o
bien la Acción B (si la condición no se cumple). Las palabras clave 1£ y else
separan las distintas partes de la sentencia. Por ejemplo:
if (largo > ancho) £

ladoMayor = largo;
) else [

ladoMayor = ancho;
+
 
  
   
 
  
 
 
    
  
 
   
   

icturas Básicas de la Programación Imperativa 107

 

 
 

ocasiones no es necesario ejecutar nada cuando la Condición no se cumple.
estructura en estos casos queda reducida a la que se muestra en la figura 5.6.

E

sI

Figura 5.6 Selección simple.

formato de la sentencia en Ci es ahora el siguiente:

€ Condición ) £
Acción

este caso se ejecuta la Acción cuando la expresión Condición se cumple y en
contrario no se ejecuta nada. Así, el ejemplo anterior se puede programar
ién como;

yor = ancho;

(largo > ancho) £

ladoMayor = largo;

bastante frecuente realizar selecciones que dan lugar a más de dos posibi- Por ejemplo, ciertas tarifas pueden ser diferentes según la edad:

Niños de 0 a 6 años Gratis
Jóvenes de 6 hasta 18 años 50%.
Adultos de 18 hasta 65 años 100 %

Jubilados de 65 años en adelante 25%

¡como se indicó anteriormente, es posible anidar varias estructuras de selecunas dentro de otras, Así, se podría realizar esta selección de la siguiente
108 Fundamentos de programación

if (edad < 6) £
tarifa = 0,0;

 

) else 1
if (edad < 18) £
tarifa = 0.5;
) else 1
i£ (edad < 65) £
tarifa = 1.0;
) else (
tarifa = 0.25;
3
Y
+

Si, como en este caso, la evaluación de las condiciones se hace en cascada,
atendiendo a una de ellas sólo si todas las anteriores han sido falsas, so puede
simplificar la escritura en CE de la sentencia IF eliminando las llaves £....)
de las ramas else para expresar directamente una cadena de selecciones. El
formato general se representa gráficamente cn la figura 5.7.

  

 

 

Figura 5.7 Selección en cascada.

El formato de la sentencia ¿£ para la selección en cascada es el siguiente:

A£ ( Condición 1) 4
Acción A

) else if ( Condición 2.) £
Acción B
Estructuras Básicas de la Programación Imperativa 109

 

') else if ( Condición N ) £
Acción J

) else (
Acción K

y

¿Con esta estructura la selección anterior se escribe en C+ de la siguiento manera:

df (edad < 6) 1

tarifa = 0.0;

) else if (edad < 18) £
tarifa = 0.5;

3 else if (edad < 65) £
tarifa = 1.0;

Y else £

tarifa = 0.25;
y

Este formato resulta ahora mucho más elegante y fácil de entender.
Todas las sentencias presentadas son variantes de una única sentencia IF de
Ct cuya sintaxis es la siguiente:
Sentencia_IF 33= 38 ( Condición )  Secuencia_de_sentencias +
else if ( Condición ) 1 Secuencia_de_sentencias 3 )
else ( Secuencia_de_sentencias 3 ]

    

5.3.3 Sentencia WHILE

En Ct la estructura de iteración de la figura 5.5 se consigue mediante la
sentencia WHILE, que tiene el siguiente formato:
imbrile ( Condición ) £

Acción

y

El significado es que mientras la expresión Condición resulta cierta, cuta
la Acción de forma repetitiva. Cuando el resultado es falso finaliza la ejecución
de la sentencia. Si la Condición resulta falsa en la primera evaluación, la
Acción no se ejecuta nunca. Por ejemplo, el factorial de un número n se puede
calcular mediante la fórmula habitual:

 

ni=1x2x3x4x..xn

Este cáleulo se puede programar en Cz utilizando una sentencia while de la
siguiente forma:

 
10 Fundamentos de programación

 

factorial = 1;

mhile (n> 1) (
factorial = factorial * n;
nm;

y

Así, con la sentencia de autodecremento la. variable n va disminuyendo su valor de uno en uno en cada repetición del bucle, al tiempo que esos valores se
van multiplicando sucesivamente, guardando el producto acumulado en fac=
torial, hasta que n se reduce a 1. Si inicialmente el valor de n es igual o
menor que 1, no se ejecutan nunca las sentencias dentro del bucle, por lo que
la variable factorial termina con el mismo valor inicial igual a 1.

 

 

 

5.3.4 Sentencia FOR

Existen muchas situaciones en las que las repeticiones del bucle se controlan
mediante una variable que va contando las veces que so ejecuta. La cuenta
puede ser en sentido creciente, o decreciente. La Condición de la iteración se
limita a comprobar si se ha alcanzado el límito correspondiente al número de
repeticiones previstas. Esto es lo que hemos hecho en el ejemplo del factorial
con la variable n. La variable n se decrementa en cada iteración y se comprueba
el número total de ejecuciones con la expresión condicional n > 1.

 

Debido a lo habitual de esta situación, en casi todos los lenguajes existen
sentencias que simplifican su construcción. En C+ se dispone de la sentencia
FOR, cuya forma para incremento creciente es la siguiente:
for (int Índice = Inicial ; Índice <= Final ; Índice ++) 4

Acción
J

El símbolo punto y coma (;) separa los distintos elementos de control de
la sentencia. La actualización del índice se hace mediante ln sentencia de
autoincremento.

La variable Índice sirve de contador para controlar el número de iteraciones a
realizar. Inicialmente la variable Índice toma el valor Inicial y se incrementa
«automáticamente en una unidad con cada nueva ejecución de Acción. La
Acción se ejecuta repetidamente hasta que la variable ndice alcanza el valor
Final.

Ambos valores, inicial y final, pueden ser expresiones aritmóticas. Estas ex
presiones se evalúan sólo una vez al comienzo de la sentencia FOR y no se
    
     
  

durante toda su ejecución. Si el valor inicial es mayor que el valor
la Acción no se ejecuta munca.

variablo Índico puedo ser utilizada dentro de Acción pero munca debe ser
la, pues se perdería el control automático de las repeticiones. Es«constituye una norma del Manual de Estilo que es obligatorio aplicar a
er sentencia FOR.
variable Índice se declara dentro del propio FOR, y sólo existe mientras
ejecuta. Al terminar la ejecución la variable Índice ya no es visible en las
sentes sentencias del programa.
se puede volver a escribir el cálculo del factorial de la siguiente manera:
torial
(int indice = 2; indice <= nm;
factorial = factorial * indice;

   

indice+) 4

fragmento de programa es más sencillo. Además, resulta evidente que
el cálculo del factorial se emplea un número de iteraciones conocido, que
depende de lo que se calcula con cada iteración. Como se puedo observar
del bucle se utiliza la variable indice con el valor que toma en cada
la y la variable n mantiene su valor inicial. Para valores de n inferiores a

les sentencias dentro del bucle no se ejecutan nunca.

    
  
   
  
  
  

sentencia FOR de Ct tiene una versión para decrementar el contador en
¡ón. En este caso el formato es el siguiente:

Cint Índice = Inicial ; Índice >= Final ; Índice 3
Acción

 

Ahora en cada iteración la variable Índice se decrementa en una unidad con
nueva ejecución de Acción mediante la sentencia de autodecremento. Por
iplo, se puede realizar el cálculo del factorial en sentido inverso de la
¿manera siguientes

 

'orial
(int indice = n; indice <= 2; indice--) £
factorial = factorial * indice;

La sintaxis completa de la sentencia FOR es, por tanto, la siguiente:

 

Sentencia FOR 233 For_creciente | For_decreciente

 
12 Fundamentos de programación

 

 

For_creciente 33= for ( int Variable_índice = Valor_ínicial ;
Variable _índice <= Valor_final ; Variable _índice ++ )
4 Secuencia_de_sentencias +

For_decreciente 33= for ( int Variable_índice = Valor _inicial ;
Variable _índice >= Valor_final ; Variable_índice =- )
4 Secuencia_de_sentencias Y

Variable_índice 333 Identificador

Valor_inicial Expresión
Valor_final

 

 

  

 

Expresión

5.4 Ejemplos de programas

En este apartado se muestran varios ejemplos de programas completos que
utilizan las sentencias presentadas en este tema.

 

5.4.1 Ejemplo: Ordenar tres datos

 

Se trata de realizar un programa que lea 3 valores enteros y los ordene de
menor a mayor en las mismas variables en que se leen: el valor menor quedará
en la primera variable y el mayor en la última.

 

La ordenación se realiza en dos pasos: la primera parte se dedica a ordenar los
dos primeros valores y en la segunda se ordenará el tercero comparándolo con
los ya ordenados. Se utiliza una variable auxiliar para realizar los intercambios
de valores entre las variables. El listado del programa completo esta recogido
a continuación.

 

 

Programa: Ordenar3

SS

Descripción:
Este programa ordena tres valores y
los guarda ordenados de menor a mayor
en las mismas variables que se leen
AAA AA

+include <stdio.h>
  
    
   
  
  
  
    
  
  
   
  
  
  
   
   
  
 
 
  

¡icturas Básicas de la Programación Imperativa 113

 

main() (
nt valUno, valDos, valTres, auxiliar;

/*— Leer los datos =-*/
print£( "¿Datos? " );
scanfí "%d Xd Xd", gvalUno, £valDos, fvalTres );

 

/*-- Primer Paso: Ordenar los dos primeros datos
Af (valuno > valDos) (

auxiliar = valUno;

valUno = valDo:
valDos = auxiliar;

 

 

J

/*— Segundo Paso: Situar el tercer dato --*/
áf (valTres < vallino) 4

auxiliar = valres;

valTres = valDos;

valDos = valUno;

valUno = auxiliar;

J else i£ (valTres < valDos) (

auxiliar = valDo:
valDos
valTres

  

+

/*-— Tercer Paso: Escribir el resultado --*/
printf( "Datos Ordenados = %Sd %5d XSdin", valUno, valDos, valTres);

 

ejecución del programa produce un resultado como el siguiente:

 

Ordenados = 89 123 567

 
114 Fundamentos de programación

5.4.2 Ejemplo: Escribir un triángulo de dígitos

Con este programa se trata de escribir un triángulo de múmeros entre el 1 y el
9. El nivel del triángulo se introducirá como dato. El resultado del programa
será semejante al mostrado a continuación:

 

¿Altura del triángulo? 9
1
mí
12321
1234321
123454321
12345654321
1234567654321
123456787654321
12345678987654321

Este es un problema típico en el que se pueden utilizar un número de iteraciones
conocidas:

 

+ Primeramente se necesita una iteración por cada línea de dígitos. El
número de líneas es un dato de partida que se introduce, por tanto, es
conocido.

+ Cada línea se puedo realizar en dos mitad

— 1% mitad: Una iteración creciente hasta el número de línea.
El número de iteraciones es conocido e igual al número de la
línea que se esta escribiendo. Por ejemplo para la sexta línea:

123456

— 2% mitad: Una iteración decreciente desde el número de lf
nea decrementada en uno, hasta uno. Por tanto, el número
de iteraciones es conocido. Por ejemplo para la sexta línea:

54321

La escritura del primer número so puede conseguir mediante otra iteración
ne escribe caracteres en blanco. Si el triángulo está centrado en centro, el
primer múmero se tiene que escribir tantas posiciones delante del centro como
el número de línea que se esta escribiendo. Hay que tener en cuenta que en
cada iteración, la altura del triángulo coincide con el número de línea que se
está escribiendo. El programa completo se muestra a continuación.

   

 

   

 
    
       
  

'uras Básicas de la Programación Imperativa

  
  

 

Programa: TrianguloDeNuneros

Descripción:
Este programa escribe un triángulo de digitos.
La altura se lee como dato y debe ser menor de 10
RARRARANA RARA RANIA RAR AARA ROA RICA ERIN ARRE

<stdio.h>

minO

const int centro = 35; /* Posición del eje del triángulo */
const int inicial /* Dígito inicial: superior y laterales */
int nivel;

 

| fr-- Leer los datos --*/ 4
print£( "¿Altura del triángulo? "
scanf( "Xd", ámivel );
,
/*— Una iteración por cada línea del triángulo --*/
for ( int altura = inicial; altura <= nivel; altura++) (£

 

 

 

/*-- Paso 1%: Situar primer número de cada línea --*/ 4
for (int indice = 1; indice <= centro-altura; indice++) (
print£(" ");
y
print£( "Xd", inicial );

 

 

- Paso 20: Primera mitad de la línea del triángulo
Escribir números consecutivos hasta altura —*/ (

for (int indice = inicial+l; indice <= altura; indices») 1
print£f( "%ld",indice );

y

y

/*— Paso 30: Segunda mitad de la línea del triángulo.

Escribir números decrecientes hasta Inicial —-*/ (

for (int indice = altura-1; indice >= inicial; indice--) £

print£( "Xld", indice )

 

 

 

 

y

y

/*— Paso 4%: Saltar a una nueva linea --*/ 1
print£( "a" );

3

3

 

 
 

116 Fundarentos de programación

5.4.3 Ejemplo: Elaboración de tickets y resúmenes

Este programa es un ejemplo simplificado del programa de una máquina de
expender tickets de entrada a un espectáculo. El precio del ticket dependerá
de la edad del espectador, según se indicó en el ejemplo del apartado 5.3.2,
agrupados en Niños, Jóvenes, Adultos y Jubilados. El programa acumulará
las entradas que se expenden y la cantidad total recaudada.

El programa dispondrá de un menú general para seleccionar la elaboración del
ticket, la elaboración del resumen o la finalización del programa. El programa
seguirá elaborando tickets hasta que el taquillero dé por finalizada su tarea.
En los resúmenes se mostrarán los datos acumulados de tickets expendidos y
el total recaudado. El listado del programa es el siguiento:

 

PA AAA
* Programa: Ticket

* Descripción:

* Este programa elabora el ticket de entrada y los

* resúmenes de recaudación de un espectáculo.

* El precio del ticket depende de la edad del

espectador (Niño, Joven, Adulto o Jubilado)
AAA A LAA

finclude <stdio.h>

int main() 1
const float PrecioBase = 6.0; /* Precio de la butaca */

  

 

int butacas = 0; /* Número de butacas vendidas */
int edad; /* Edad del cliente */

float totalEuros = 0.0; /* Total de euros recaudados */
float precio; /%* Precio de cada butaca */
char opcion =* * /* Opción del programa */

char tecla =' '; /* Tecla Si/No */

/*-- Bucle hasta opción F de fin —-*/
while (opcion != *F") (
print£( "Opción (Ticket, Resumen o Fin) ? " );
opcion =* *;
while (Copcion != 'T') 8% (opcion != 'R') 88 (opcion !
scanf( "Xe", gopcion );
y

 

ED) A
“Estructuras Básicas de la Programación Imperativa 17

 

7

 

Elaboración del Ticket

 

if (opcion
tecla = *S
mhile (tecla == 'S') 4
print£( "Edad? " );
scanf( "Xd", tedad );

   
   

 

butacas++
print£( * — Any
print£( "| TICKET DE ENTRADA Rat;
i£ (edad < 6) £ /* niño, gratis */

 

print£( "[Gratis ")
precio = 0.0;

) else if (edad < 18) [ /* joven, 50% */
print£( "[Joven —");
precio = PrecioBase / 2.0;

) else if (edad < 65) [ /* adulto, tarifa completa */
print£( "[adulto ");
precio = PrecioBase;

) else £ + jubilado, 25% */
print£( "|Jubilado" );
precio = PrecioBase / 4.0;

 

 

     
 

 

,
totalEuros = totalluros + precio;

printE( Precio: X4.2£lWm", precio );
print£( ara);
print£( "Otro Ticket(S/N)7

tecla =''

 

while ((tecla l= 'S') 48 (tecla !
scanf( "Xc”, átecla );

0) €

Y ma

 

   

Elaboración del Resumen de la recaudación

 

print£(
print£(
print£(
print£(

    

"44d Butacas An", butacas
'Total Recaudado = %10.2£imWn", totalEuros );

 

 

 
118 Fundamentos de programación.

 

Una ejecución simplificada del programa da como resultado el siguiente:

 

Opción (Ticket, Resumen o Fin) ? T
Edad? 13

 

1 TICKET DE ENTRADA 1
|Joven Precio: 3.001

    
 

Otro Ticket(S/N)? $
Edad? 67

 

1 TICKET DE ENTRADA 1
Jubilado 1.501

   

Otro Ticket(S/N)? N
Opción (Ticket, Resumen o Fin) ? R
RESUMEN DE VENTAS

2 Butacas
Total Recaudado = 4.50

Opción (Ticket, Resumen o Fin) ? F

 
  
  
 
 
 
   
  
   
 
 
  
   
   
 
   
  
   

ema 6

todología de Desarrollo de
ogramas (IT)

objetivo de este tema es múltiple. En primer lugar se amplía la técnica
refinamientos sucesivos presentada en el tema 4 con la posibilidad de usar
lesquemas de selección e iteraci

segundo lugar se introduce la idea de verificación formal de programas,
que de una manera muy simplificada, en forma de razonamientos intuitivos
las estructuras utilizadas hasta el momento.

 

 

¡jente se trata por primera vez el problema de la eficiencia, y se introduce
“de forma igualmente simplificada el concepto de complejidad algorítmica.

 

6.1 Desarrollo con esquemas de selección e iteración

¡En este apartado se ilustra cl emploo de la técnica de refinamientos sucesivos
la en el tema 4, ampliada ahora con la posibilidad de utilizar las nuevas
turas de selección o iteración. Con ello se tienen tres posibilidades a la
bora de refinar una acción compuesta:

 
 

 

+ Organizarla como secuencia de acciones.
+ Organizarla como selección entre acciones alternativas.
+ Organizarla como iteración de acciones.

En el tema 4 se ha presentado ya la metodología para desarrollar esquemas
“dle secuencia. A continuación se amplía la metodología con recomendaciones
"para desarrollar esquemas de selección e iteración.

 

 

 
 

120 Fundamentos de program:

 

6.1.1 Esquema de selección

Recordaremos que un esquema de selección consiste en plantear una acción
compuesta como la realización de una acción entre varias posibles, dependiendo
de ciertas condiciones. Es decir, se trata de elegir una sola entre varias posibles
alternativas.

Para desarrollar un esquema de selección debemos identificar sus elementos
componentes. Por tanto habrá que

 

(a) Identificar cada una de las alternativas del esquema, y las acciones co
rrespondientes.
(b) Identificar las condiciones para seleccionar una alternativa 1 otra.
Como ejemplo, aplicaremos estas recomendaciones al desarrollo de una acción
compuesta para calcular cuántos días tiene el mes de Febrero de un cierto año.
Reconoceremos que:
(a) Las alternativas son que tenga 28 días o que tenga 29. Las acciones serán
asignar dicho valor a una variable que almacene el número de días,
| días = 28
o bien
[dias = 29

(b) La condición para elegir una acción u otra es que el año sea bisiesto.
De forma simplificada (pero válida para años entre 1901 y 2099) expresaremos la condición como equivalente a que el año sea múltiplo de
cuatro.

Jano % 4 == 0

Colocando cada elemento identificado en el lugar correspondiente del esquema,
tendremos:

 

if (anno % 4 =0) (
dias = 29.

) else [
dias = 28;

y

De manera similar so pueden desarrollar esquemas de selección simplificados,
con sólo una acción condicionada, o esquemas de selección en cascada en que
haya un número más o menos grande de alternativas. Por ejemplo, el esquema
anterior podría replantearso realizando primero el tratamiento más común, es
decir, que Febrero tenga 28 días, y luego corrigiendo este valor si es necesario.
 
  
  
   
    
   
   
   
  
 
  
   
  

Metodología de Desarrollo de Programas (II) 121

 

Como ejemplo de selección en cascada, desarrollaremos el cálculo de los días
el mes, para cualquier mes del año. Las alternativas son:

 

31 días: Enero, Marzo, Mayo, Julio, Agosto, Octubre, Diciembre.
30 días: Abril, Junio, Septiembre, Noviembre

29 días: Febrero (año bisiesto).

28 días: — Febrero (año normal).

Para simplificar las expresiones de condición, dejaremos para la última alternativa aquella en que la condición sca más compleja. En este caso sería la de
os mesos de 31 días, que son los más numerosos. Las otras alternativas pode¡mos situarlas en un orden arbitrario. Al escribir las condiciones debemos tener
sen cuenta que si hay que evaluar una de ellas es porque todas las anteriores
han resultado falsas:

 
 
 
 
 

  

  

6.1.2 Esquema de iteración

Una iteración o bucle consiste en la repetición de una acción o grupo de ac¡ones hasta conseguir el resultado deseado. Para desarrollar un esquema de
eración dentro de un programa deberemos identificar cada uno de sus elemenos componentes. Al hacerlo hay que identificar simultáneamente las variables
adecuadas para almacenar la información necesaria.

 

En líneas generales so podría proceder de la siguiente manera:

(a) Identificar las acciones útiles a repetir, y las variables necesarias. Precisar el significado de estas variables al comienzo y final de cada repetición.

(b) Identificar cómo actualizar la información al pasar de cada iteración a
la siguiente, Puede ser necesario introducir nuevas variables.
122 Fundamentos de programación

 

(e) Identificar la condición de terminación. Puede ser necesario introducir
nuevas variables e incluso acciones adicionales para mantenerlas actualizadas.

(d) Identificar los valores iniciales de las variables, y si es necesaria alguna
acción para asignárselos antes de entrar en el bucle.

Además do los elementos anteriores, puede ser necesaria alguna acción adicional al comienzo o al final del bucle. Si son acciones muy simples, pueden
considerarse parte del esquema de iteración como tal. Si son algo complejas
será mejor considerarlas como acciones anteriores o posteriores, siguiendo un
esquema secuencial.

El método explicado corresponde al caso general. En bastantes casos el desarrollo de un bucle es mucho más sencillo. Esto ocurre en particular cuando
se programan bucles con contador, si las acciones a repetir pueden expresarse
directamente en función del contador del bucle. En este caso los pasos b), e) y
d) se refunden en uno sólo, consistente en determinar los valores inicial, final
y el incremento del contador del buelo.

 

Desarrollaremos con la técnica indicada un fragmento de programa que
prima los términos de la serie de Fibonacci. Cada término de esta serio se
obtieno sumando los dos anteriores. La serie comienza con los términos 0 y 1,
que se suponen ya impresos antes del bucle, Se trata de calcular e imprimir
tantos términos como sea posible,

 

Procediendo paso a paso, describiremos cada elemento del desarrollo de manera informal, seguido de su codificación en Cz.
(a) Acciones útiles a repetir: Imprimir un término.
|print£C'x108%0", termino);
Variables necesarias: El término a imprimir.
[int termino;
Valor al empezar la repetición: Ultimo término impreso hasta el momento.
(b) Actualizar las variables al pasar de una repetición a la siguiente: Antes
de imprimir, calcular el término actual a partir de los dos anteriores (se
necesita tener almacenado el penúltimo término)

aux = termino + anterior;
anterior = termino;
termino = aux;
 
  
 
   
   
 
 
 
 
   
 
    
 
   
  
  
 
 
  
   

lología de Desarrollo de Programas (11) 13

Variables adicionales: El penúltimo término, y una variable temporal.
int anterior;
int aux;

(e) Condición de terminación: El término siguiente excedería del rango de
los enteros. Hay que evaluar la condición sin calcular explícitamente el
valor de dicho término, porque se produciría “overflow”.

 

| INEM termino < anterior

(Obsérvese que esta expresión equivale en teoría a INTMAX < termino+anterior)
1d) Valores iniciales de las variables: Los dos primeros términos, O y 1.

 

anterior = 0;
termino =

 

bucle completo sería:

termino;
anterior;

(INT _MAX-termino >= anterior) (
aux = termino + anterior;
anterior = termino;

termino = aux;

print£C'X10dm", termino);

6.2 Ejemplos de desarrollo con esquemas

A continuación se ilustra la técnica de desarrollo por refinamientos utilizando
los esquemas de selección e iteración sobre algunos ejemplos típicos.

-6.2.1 Ejemplo: Imprimir el contorno de un triángulo

Se trata de imprimir con asteriscos el perímetro de un triángulo aproximada'mente equilátero, tal como se indica a continuación:

 

 
 

124 Fundamentos de programación

 

 

Como parámetro del problema se especificará la altura del triángulo. Si la
altura es N, habrá que imprimir NY líneas, cada una con la configuración de
asteriscos que corresponda. El triángulo anterior tiene altura 7. Se pretende
además que el triángulo aparezca ajustado a la izquierda; es decir, el primer asterisco de la línea inferior deberá empezar exactamente en la primera posición
de esa línea. Las otras líneas empezarán con el espacio en blanco apropiado,

El planteamiento inicial del programa será:
Imprimir el borde de un triángulo
El primer paso de refinamiento consistirá en decidir si esta acción compuesta
debe plantearse como una secuencia de acciones simples, o como selección
entre alternativas, o como bucle. Observando que hay tres clases de líncas a.
imprimir, según el número de asteriscos que contienen, elegiremos la primera
opción, y escribiremos:
Imprimir el borde de un triángulo —>
Imprimir el vértice superior
Imprimir los bordes laterales
Imprimir el borde inferior
El orden en que doben realizarse las acciones viene determinado por el hecho
de que la impresora va imprimiendo las líneas sucesivas de arriba a abajo.

A continuación refinaremos cada una de estas acciones. Para ello examinarexos con detalle los caracteres que hay que imprimir en cada línea, en función
de la altura del triángulo (en partienlar, los espacios en blanco intermedios).
Marcando con puntos los espacios en blanco, tendremos:

 

Línea 1 N-1 blancos

Línea 2 N-2 blancos, 1 blanco
Línea 3 N-3 blancos, 3 blancos
Línea k N-k blancos, 2k-3 blancos
Linea N N asteriscos espaciados

 

 

El refinamiento de la primera acción será en forma de secuenc

 
lología de Desarrollo de Programas (11)

Imprimir el vértice superior —>
Imprimir N-1 blancos
Imprimir un asterisco
Saltar a la línea siguiente

  
  

acción de imprimir los blancos será una iteración, que podemos escribir
'amente mediante un bucle con contador:

Imprimir N-1 blancos —>

for (int k = 1; k <= NL; k+9) (
print£("

 
 

acciones de imprimir un asterisco y saltar a la línca siguiento so escriben
inmediatamente:

 

Imprimir un asterisco —

[printec reto;

Saltar a la línea siguiente —

[orántecowa" y;

En Ct resulta más natural que estas acciones se agrupen en la misma sentencia:
Imprimir un asterisco y Saltar a la línea siguiente —>
[print vea";

En el siguiente paso de refinamiento detallaremos la impresión de los bordes laterales, Intuitivamente podemos establecer una estructura de iteración
mediante un bucle con contador:

 

Imprimir los bordes laterales —>

For (int k = 2; k <= NL; ke)
Imprimir los bordes de la línea k

 

Observaremos que la línea A-csima va precedida de N — k blancos, y tiene
2k — 3 blancos entre los bordes:
Imprimir los bordes de la línea k —

Imprimir N-k blancos

Imprimir un asterisco

Imprimir 2-3 blancos

Imprimir un asterisco

Saltar a la línea siguiente

 
126 Fundamentos de programación

Todas estas acciones han sido ya refinadas como sentencias de C£. Finalmente
falta por plantear la impresión del borde inferior. Podremos distinguir la
impresión del primer asterisco y la del resto, y escribir:
Imprimir el borde inferior —
Imprimir un asterisco
Imprimir N-1 asteriscos precedidos de blanco
Saltar a la línea siguiente

 

La acción central se escribirá como un bucle con contador:
Imprimir N-1 asteriscos precedidos de blanco —>

for (int k
print£(

k <= NLj ke) €
4

   

,

Reuniendo todos los fragmentos, añadiendo la parte declarativa necesaria, y
documentando cada elemento importante del programa, tendremos el programa completo, tal como se recoge en el listado de la versión inicial.

 

RRA
* Programa: Triangulo (Versión inicial)

* Descripción:

* Este programa escribe el borde de un triángulo

* — aproximadamente equilátero, usando asteriscos.
AAA AA AR ARRARAARARRAA/

include <stdio.h>

 

int main) (
const int N=7; /* altura del triángulo */

/*-— Escribir el vértice superior --*/

for (int k = 1; k <= N-1; ke*) (
print£(

J

print£( "a"

 

 

 

/*— Imprimir los bordes laterales --*/
for (int k = 2; k <= N-1; k+e+) £
for (dnt j= 1; j <= Nk; j+9) €
primer);
,
print£( "e

 
Metodología de Desarrollo de Programas (11) 127

 

for (int j = 1; j <= 2-3; je) (
print£(" ")
J
print£( "*n" );
y

/*— Imprimir el borde inferior --*/

print£( e")

for (int k = 1; k <= N-1 5 kee) 4
print£( o);

 

3
print£( “a” );
y

 

Este programa puede compilarse y ejecutarso, obteniendo el resultado puesto
anteriormente como ejemplo. Sin embargo no puede considerarse totalmente terminado. Una deficiencia es que la altura del triángulo aparece como
constante, cuando en realidad sería más razonable leerla como dato en cada
ejecución del programa. La solución será definir N como variable, y leer su
svalor al comienzo.

Otra deficiencia es que no se tienen en cuenta algunos casos especiales, en que
el triángulo degenera y no tiene todos los elementos identificados. Esto ocurre
¡cuando la altura del triángulo es 0, 1.62. En el primer caso se omiten todas las
líneas; en el segundo sólo existe el vértice superior, y en el tercero no existen
bordes laterales.

 

En esta versión inicial, para la altura igual a 2 no se obtienen resultados
erróneos, ya que el bucle de líncas de los bordes laterales tal como está escrito so
'ejecutaría () veces (pero esto se debe más a la casualidad que a un razonamiento
previo del comportamiento del programa). Por ejemplo, si cambiásemos el
parámetro de altura al valor 1:

eN = 1;

abtendríamos el resultado erróneo:

 

'este mismo resultado se obtiene para N = O . La solución general será convertir
en esquema de selección condicional la impresión del vértice superior y del
borde inferior:

  
128 Fundamentos de programación

Imprimir el vértice superior —>

i£ 090) (
Imprimir N-1 blancos
Imprimir un asterisco
Saltar a la lénea sigui
,

 

Imprimir el borde inferior —
af 061) (
Imprimir un asterisco

Imprimir N-1 asteriscos precedidos de blanco
J

   

)n corregida del programa aparece en el siguiente listad

 

a]

* Programa; Triangulo? (Versión corregida)
* Descripción:

* Este programa escribe el borde de un triángulo

* — aproximadamente equilátero, usando asteriscos.

* La altura del triángulo, en líneas de texto,

* se lee como dato

ARA AREA ARA

*include <stdio.h>

 

int mainO) (
int altura; /* altura del triángulo */

/*-- Leer altura deseada --*/
print£( "¿Altura? " );
scanf( "xd", taltura );

/*— Imprimir el vértice superior =-*/
if (altura > 0) £
for (int k = 1; k <= altura-1; k+) (
print£( "o";
,
printE( a" y
$
 

Metodología de Desarrollo de Programas (11) 129

 

/*-- Imprimir los bordes laterales --*/
for (int k k <= altura-1; k+1) (
for (int j=1; j <= altura-k; je) (
print£(
y
printfc te")
for (int j
print£(
y
print£( a");
y

 

29-35 jes) £

  

/*— Imprimir el borde inferior --*/
á£ (altura > 1) £

printE( 0")

for (int k

primt£ "oy;

y

printe( o"
y

 

altura-1 ; ke) £

 

 

e

 

Algunos ejemplos de ejecución serian los signientes:

 

¿Altura? 7

6.2.2 Ejemplo: Imprimir el triángulo de Floyd

Se trata de desarrollar un programa que imprima el llamado triángulo de Floyd.
Esto “triángulo” se forma imprimiendo los sucesivos números naturales 1, 2,
3, ... en filas sucesivas, colocando un número en la primera línea, dos cn la
segunda, tres en la tercera, ete. Si fijamos un límite arbitrario de la serie de
'múmeros (p. ej. 12), tendremos el triángulo:

 

 
 

130 Fundamentos de programación

 

 

6
9 10

nm z

Es fácil darse cuenta de que en general la línea k tieno k números, excepto
la última línea, que puede quedar incompleta. El programa de este ejemplo
deberá leer como dato el límite de la serie.

El primer paso de refinamiento será:

Imprimir el triángulo de Floyd —>
Leer el límite N de la serie
Imprimir el triángulo hasta N'

La primera acción puede desarrollarse en sentencias de C+ de forma inmediata:
Leer el límite N de la serie —>

printf( "Límite de la serie: " );
scanfí "%d",8N );

La parte principal del programa es la impresión del triángulo. Habremos de
refinarla en forma de un esquema de secuencia, selección o iteración. Puesto
que se trata de imprimir un número variable de líneas y valores, con acciones
similares para todos ellos, parece razonable usar un esquema de iteración. La
decisión a tomar será si plantear la iteración como bucle de números o de
líneas. Según la elección que hagamos tendremos dos esquemas de programa
diferentes, que desarrollaremos por separado.

 

6.2.2.1 Escritura mediante bucle de números
Elegiremos en primer lugar esta posibilidad, que facilita la codificación del
buele, ya que puede plantearse como un bucle con contador:

Imprimir el triángulo hasta N—

for (int k= 1; k <= N; ker) 4
Imprimir el número k

 

La impresión del número requiere acciones adicionales, ya que debe incluir el
saltar de línea al comienzo de cada nueva línea del triángulo. Puede plantearse
como secuencia de acciones, de la forma:
"Metodología de Desarrollo de Programas (11) 131

 

   
   
  
  
 
   
  
 
 
   
   
   
  
   
   
   
   
  
  
   

Imprimir el número k —

Saltar de línea, sí es necesario
print£( "X5d",k );

“En este planteamiento los saltos de línea no se producen en cuanto se llega al
Énal de la línea, sino cuando se va a escribir el siguiente valor. Esto quiere
¡decir que el último número impreso dentro del bucle no irá seguido de salto de
“línea, y que habrá que completar la última línea como acción de terminaci
nera del bucle; es decir, la escritura del triángulo terminará con una acción
“adicional:

Completar la última línea

 

 

'Refinaremos la acción de saltar de línea en forma de esquema de selección:

 

Saltar de línea, si es necesario —>

if (el número anterior fue el último de su línea) 4
print£( "a" );

  

El refinamiento de la condición va a exigir introducir nuevos elementos. Para
¡expresar dicha condición como una expresión en C+ necesitaremos mantener
“actualizada la indicación de cuál es el último valor de cada línea. En todo
¡aso necesitaremos conocer cuántos números han de imprimirse en la línea en
¡curso (recordemos que en la línea k habrá A números).

 

 

Usaremos una variable linea como contador de líneas y otra variable ultimo

para contener el último múmero de la línea, Estas variables habrán de actuali
“zarse cada vez que se cambie de línea. Reescribiremos el refinamiento anterior
la forma siguiente:

Saltar de línea, si es necesario —

á£ (k > ultimo) €
print£( "a" );
linea++;
ultimo = ultimo + linea;

3

Al mismo tiempo hay que ampliar la inicialización del bucle de escribir números
juyendo el dar valores iniciales a las nuevas variables, en concreto:

inicialización es la adecuada incluso en el caso de escribir O múmeros, ya
los valores corresponden al primer número que completa línea, tras el cual
“habrá que saltar de línea si se imprimen más números.

 

 
132 Fundamentos de programación

 

No hay que olvidar desarrollar la acción de saltar de línea al final de la última:

línea del triángulo. Esta acción será condicional si hemos de considerar el caso

de que se manden escribir O números, en cuyo caso no existe esa última línea.
Completar la última línea —>

if N>0)
print£( "1" )

 

+

Con todo ello podemos ya redactar el programa Floyd1 completo, tal como
aparece a continuación, docnmentándolo de la manera habitual.

 

 

PA

* Programa: Floydl

 

 

Descripción:
Este programa imprime el triángulo de Floyd
con los múneros correlativos de 1 a N
El valor de N se lee como dato
e

*tinclude <stdio.h>

int mainQ) (
int N; /* último múnero a imprimir */
int linea = 1; /* contador de líneas */
int ultimo /* último número de la línea */

 

/*— Leer límite de la serie —*/
print£( "¿Límite de la serie? " );
scanf "Xd", aN );

 

/*%-- Imprimir el triángulo mediante un bucle de números
for (int k= 1; k <= N; ke) £
/* saltar de línea, si es necesario --*/
if (k > ultimo) €
print£( "a" );
Tinea+ultimo = ultino+linea;

J

 

  

/* imprimir el minero k */
print£( "%5d", k );
,
 
  
   
   
 
  
  
   
   
 
   
  
       
  
 
   

Metodología de Desarrollo de Programas (11) 133

 

 

/*— Acabar la última línea
if N>0 4
print£( "Ya" );
y
y

dl

 

Un ejemplo de la ejecución del programa soría la siguiente:

 

ite de la serie? 12

Exanr

2.2. Escritura mediante bucle de líneas

 

segunda alternativa de diseño consiste en plantear la escritura del triángulo
un bucle de imprimir líncas do números, una tras otra. El refinamiento
pondiente será:

Imprimir el triángulo hasta N—>

while (quedan números) £
Imprimir la siguiente línea

y

ir imprimiendo cada línea necesitaremos conocer el rango de números
le corresponde a cada línea. Usaremos unas variables similares a las de
¡solución anterior para mantener el número de la línea, y el primer y último.
de esa línea. Al comienzo del bucle estas variables tendrán los valores
)ndientes a la última línea impresa. Así, los valores iniciales serán:

 

  
 

linea = 0;
primero = 0
ultimo = 0;
podemos refinar los elementos del bucle:
quedan números —>
[ultimo <N
Imprimir la siguiente línea —
Actualizar los límites
Imprimir los números

 
134 Fundamentos de programación

Actualizar los límites —>

 

Imprimir los números —>
for (int k = primero; k <= ultimo; k++) (
print£( "X54",k );
)
print£( “wn” );

Con esto se completa el programa; pero antes de presentarlo en su conjunto es.
preciso realizar alguna corrección. Dicha corrección es debida a que al calcular
los límites de una línea de números no se ha tenido en cuenta que la última
línea puede no estar completa. El último número de la línea no debe ser nunca
mayor que el último de la serie completa. Escribiremos, por tanto:
Actualizar los lómites —>

linea++;

primero = ultimo + 1;

ultimo = ultimo + linea;

if (ultino >N) (
ultimo =

 

,

Ahora sí se puede construir el programa Floyd2, y presentarlo debidamente
documentado tal como se hace en el siguiente listado. El resultado de la
ejecución de este programa es idéntico al de la variante anterior. Ambos
programas son equivalentes desde el punto de vista de su utilización,

 

AA
* Programa: Floyd?

* Descripción:

* Este programa imprime el triángulo de Floyd

* con los números correlativos de 1 a N

* El valor de N se lee como dato
AAA AAA

include <stdio.h>

  

int main) (
int N; /* último número a imprimir */
int linea = 0 /* contador de líneas */
int primero /* primer número de la línea */
int ultimo = /* último número de la línea */

 
 
  
 
   
 
   
 
 
 
   
  
  
  
   
  
    
   
  
  
  

Metodología de Desarrollo de Programas (II) 135

/*— Leer límite de la serie --*/
print£f( "¿Limite de la serie? " );
scanf( "Xd", EN );

/*-- Imprimir el triángulo mediante un bucle de líneas --*/
while (ultimo <N)

/*— actualizar los límites --*/

linea++;

primero = ultimo+1;

ultimo = ultimo+linea;

if (ultimo >N) 4

ultimo = N;

,

/*— imprimir los números --*/
k <= ultimo; ke+) (

 

 

3 Verificación de programas

se ha indicado que uno de los objetivos de la programación es la correoUn programa es correcto si produce siempre resultados de acuerdo con
especificación del programa. Evidentemente sólo tiene sentido hablar de
ión si antes de escribir el programa se ha escrito de manera precisa la
ificación del comportamiento que se espera que tenga.

 

la práctica, la verificación de un programa se hace muchas voces mediante
syos. Un ensayo (en inglés, testing) consiste en ejecutar el programa con
datos preparados de antemano y para los cuales se sabe cuál ha de ser
resultado a obtener. Si al ejecutar el programa no se obtienen los rosultaesperados, se sabrá que hay algún error, y el programa se examina para
inar la causa del error y eliminarla. Este proceso se llama depuración
inglés debugging).

la ejecución produce los resultados esperados, entonces el ensayo no sumininguna información acerca de la corrección del programa. Puede ser
el programa sea correcto, y no tenga errores, pero también puede ocurrir
 

136 Fundamentos de programación

 

que el programa contenga errores que sólo se pongan de manifiesto con otros
datos de ensayo diferentes.

La única manera de verificar con seguridad la corrección de un programa es,
demostrar formalmente que el programa cumplo con sus especificaciones. Para
ello es necesario escribir esas especificaciones con toda precisión en forma de
expresiones lógicas, y luego realizar una demostración lógico-matemática de:
que el programa las cumple, A continuación se exponen algunas ideas sobre
cómo puedo ser este proceso de demostración

 

De todas formas hay que comprender que la demostración formal de la corrección de un programa no significa necesariamente que el programa cumpla com
sus objetivos reales, ni que el resultado sen correcto desde el punto de vista
del usuario. Las técnicas de demostración formal que so introducen en este
tema sólo sirven para demostrar que el programa cumple con sus especificaciones, El que dichas especificaciones describan realmente el problema a resolver
es una cuestión aparte, mucho más difícil de asegurar, y que desde luego no
admite una demostración lógico-matemática.

No obstante, los mótodos formales de especificación, desarrollo y prueba de
programas han mostrado ser mucho más seguros que los basados en la intuición
de los desarrolladores o bien en ensayos con datos de prueba particulares.

6.3.1 Notación lógico-matemática

Las especificaciones formales utilizadas en este texto se basan en una notación
Jógico-matemática convencional, con ciertas adaptaciones. Por ejemplo, se
usa la notación de vectores de C+ en lugar de subíndices, y se generalizan los
operadores sobre conjuntos para usarlos también con otros tipos de colecciones.

En el apéndice C se incluye una descripción detallada de la notación empleada,
con sus particularidades.

6.3.2 Corrección parcial y total

Usando las expresiones y reglas de la lógica, y conociendo la semántica (significado) de las acciones, es posible demostrar si un programa es o no correcto
(respecto a uma determinada especificación). Para programas que siguen el
modelo imperativo el proceso de demostración se realiza en dos partes:

1. Corrección parcial : si el programa termina cl resultado es correcto.
2. Corrección total: lo anterior, y además para, todo dato de entrada válido
el programa termina
 
    
 
 
 
 
 
 
 
 
 
 
 
   
  
 
  
   
   
  
  
  
  
 
  
  
   

logía de Desarrollo de Programas (11)

base de la comprobación de corrección parcial es:

+ Anotar el comienzo y final del programa con aserciones o asertos (afirmaciones, formalizadas como expresiones lógicas) correspondientes a las
condiciones iniciales y al resultado deseado. La condición al comienzo se
suele donominar precondición, y la del final postcondición. La precondición y la postcondición, conjuntamente, constituyen la: especificación
formal del programa.

+ Anotar los puntos intermedios del programa con aserciones similares

respecto al estado del cómputo en ese punto.

Demostrar que si se cumple una aserción en un punto del programa y

se siguen cada una de las líneas de ejecución posibles hasta llegar a otro

punto con aserción, dicha aserción ha de cumplirso, según las reglas de
la lógica y de acuerdo con las acciones realizadas.

 

  

jn parcial se consigue al demostrar que al llegar al
del programa ha de cumplirso la aserción correspondiente al resultado

corrección total se consigue añadiendo la demostración de que todos los
del programa terminan tras un número finito de repeticiones. Para
rar la terminación se puede:

 

+ Asociar a cada buclo una función monótona (siempre estrictamente creciente o decreciento) llamada variante, y quo debe tener nn valor acotado
para que el bucle se repita.

esta manera tras un cierto número de repeticiones se alcanzará la cota o
de dicha función, y el bucle terminará.

 

diferentes notaciones para escribir las aserciones que se pueden asociar
punto importante del programa. En los ejemplos que siguen se usarán
¡ones lógico-matemáticas convencionales, encerradas entre comillas ti
¡cas «...» para distinguirlas del código del programa en C2. La notación
¡describe en el apéndice O.

 

 

Razonamiento sobre sentencias de asignación

analizar el comportamiento de un fragmento de programa correspondien'a una sentencia de asignación, comenzaremos por anotar delante de dicha
cia todas las condiciones que sabemos que se cumplen inmediatamen'antes de ejecutarla. A continuación anotaremos detrás de la sentencia las
iciones que podamos demostrar que se cumplen después de su ejecución,
serán las siguientos:

 

 

 

 
138 Fundamentos de programación

+ Las condiciones anteriores en las que no intervenga la variable asignada:
+ La condición de que la variable tiene el valor asignado.
Por ejemplo (asumiendo que es cierto lo que se indica al comienzo de esta
sentencia):
«ASERTO: (2>y)A(a>b)A(a> x)>
a = 36;
«ASERTO: (2>y)Ala

 

36)»

En la anotación final se han suprimido las condiciones iniciales (a > b) y
(a > 2), ya que en ellas interviene la variable a. Se ha conservado la condición.
(2 > y), ya que estas variables no son afectadas por la asignación, y se ha
añadido la nueva condición (a =36) impuesta por la ejecución de la sentencia
de asignación.

6.3.4 Razonamiento sobre el esquema de selección

Para analizar el comportamiento de un fragmento de programa correspondiente a un esquema de selección, comenzaremos por anotar delante de dicho
esquema las condiciones que sepamos que se cumplen inmediatamente antes
de examinar la condición.

 

D)

Figura 6.1 Razonamiento sobre un esquema de selección.

 

Puesto que la condición de selección decide la continuación por una u otra
vía de las dos posibles, deduciremos que al comienzo de la alternativa “Sí” se
cumplirán las condiciones iniciales y además la condición de selección, y que al
comienzo de la alternativa “No” se cumplirán las condiciones iniciales y no se
cumplirá la condición de selección. La figura 6.1(a) refleja gráficamente estas
anotaciones.

 
Metodología de Desarrollo de Programas (II) 139

 

   
  
 
   
  
  
 
 
 
  
 
 
 
    
  
   
   
  
 
    

 

En la parte de terminación del esquema anotaremos las condiciones que se de'duacan de la ejecución de cada alternativa en particular; y anotaremos como
'evudición a la salida que ha de cumplirse alguna do las condiciones de termión, correspondientes a las dos alternativas posibles, tal como se indica en
da figura 6.1(b).

licaremos esta técnica de razonamiento a un fragmento de programa que
en m el máximo de dos números a y b. Dicho fragmento podría ser:

(a>b 4

 

:ando las aserciones al comienzo, tendremos:

(a>b)1
«ASERTO: a>b»
2-a

else (
«ASERTO: a<b»
m-b;

 

¡ando sobre cada sentencia de asignación, de acuerdo con las propiedades
úáticas del máximo de dos valores, tendremos:

(a>b)(
«ASERTO: a>l»

«ASERTO: (a>0)A(m=a)» > «ASERTO: m= Maz(a,b)»
else (

«ASERTO: a<b»

2-b;

«ASERTO: (a<1)A(m=b)» > «ASERTO: m= Maz(o,bj»

'ha utilizado el símbolo > para indicar que la segunda aserción se deduce de
primera, aplicando las propiedades de las operaciones lógico-matemáticas.
se puede escribir la aserción final como unión de las dos alternativas
en este caso coinciden):

lfa> bt

 
 

a> bo

(a>8)A(m=a)» > «ASERTO: m= Maa(a,b)»

 
 

140 Fundamentos de programación

 

) else (
«ASERTO: a< bn
mb;
«ASERTO: (a<0)(m=b)» => «ASERTO: m= Maz(a,b)»

+
«ASERTO: m= Mar(a,b) Vm=Maz(a,b)» > «ASERTO: m= Maz(a,b)o

Con lo que queda demostrado el funcionamiento correcto.

6.3.5 Razonamiento sobre el esquema de iteración: invariante,
terminación.

Para analizar el comportamiento de un fragmento de programa correspondiente a un esquema de iteración habremos de identificar, por una parte, las
condiciones que deben cumplirse siempre inmediatamente antes de examinar
la condición de repetición, Estas condiciones constituyen el llamado invariante del bucle. En la figura 6.2 se representa el diagrama de flujo de un bucle
tipo WHILE, en que el invariante es la condición «p».

0)

ao

sr

Figura 6.2 Razonamiento sobre un esquema de iteración.

Razonando como en el esquema de selección, deduciremos que al comienzo
de cada repetición de la acción del bucle habrá de cumplirse el invariante y
adomás la condición de repetición; y que al terminar las repeticiones y salir
del bucle se cumplirá el invariante y además no se cumplirá la condición de
repetición.

    

 

La identificación del invariante puede ser complicada. No se trata simplemente de anotar todas las condiciones que sabemos que se cumplen al llegar.
al bucle por primera vez, sino precisamente aquellas que además se seguirán

 
lología de Desarrollo de Programas (11) 141

 

    
  
   
   
   
  
   
 

 
 
 

ipliendo después de cada repetición. La denominación de invariante res-ponde al hecho de que estas condiciones no cambian al ejecutar la acción del
de.

otra parte, para garantizar la terminación hay que identificar una función
ictamente monótona y acotada que vaya cambiando con cada repetición
"del bucle. Al ser acotada no podrá ir variando indefinidamente, y eso permite
“asegurar que el bucle terminará en un número finito de repeticiones. A esta
función se le denomina variante. Sin pérdida de generalidad se puede plantear
¿que esta función debe tomar valores positivos enteros decrecientes, con el valor
¡gero como cota inferior.

¡Como ejemplo, analizaremos un fragmento de programa para calcular en f el
'fsctorial de un número n (n! = 1x2 x3x xn). Para ello se usará un
'sontador k que vaya tomando los valores de 1 a

Eisaremos como invariante «(k < nm) A(f = kl)». Esto es válido para los
'gasos en que (n > 1). Como variante podremos usar la expresión n — k. Las
'aciones en el bucle serán:

=1
-1
INVARIANTE: (K<m)A(f=ki)» «VARIANTE: n—ko»
ile (k <m) (
«ASERTO: (k<n)n(f
ke+;

«ASERTO: (k<m)M(S=(*-1))>
f=-£*k

E «ASERTO: (k<n)A(S=K)»

 
   
 
   
   
   
   
  
 
 
  

 

a

'ERTO: (k<n)A(k>n)M$=K)» > «ASERTO: f=nb»

 
 

localización exacta del invariante (ver figura 6.2) no corresponde a un punto
'elaro en el código. En esto ejemplo se ha escrito delante del bucle, marcándola
"expresamente con el nombre INVARIANTE. Lamentablemente al ponerla on
lugar no queda del todo claro que debe cumplirse no sólo al entrar on
sel buele por primera vez, sino también tras cada ejecución del bucle. Quizá
an punto apropiado para esa anotación sería entre la palabra clave while y

 

 
142 Fundamentos de programación

 

la expresión de la condición (k < n), pero esto también puede resultar algo.
confuso:
mhile «(k< nm) A(f=K)» (k <m 4

La demostración de las anotaciones es relativamente sencilla, conociendo propiedades matemáticas tales como:

1 =1
(k<n) > (k4+1<m)
kl = (K—1)Ixk

 

(E<n)AE>n0) > k=n
El análisis anterior sólo es válido si (n > 1). Falta comprobar la corrección para.
el caso (n = 0), ya que para (n < 0) el factorial no está definido. Sabiendo
que 0! = 1, y comprobando que si (n = 0) el bucle no so ejecuta munca, y
la variable f conserva su valor inicial f = 1 = 0! tenemos la demostración
completa,

Los razonamientos anteriores corresponden sólo a la demostración de corrección parcial. Para demostrar la corrección total falta demostrar que la ex
presión variante debe tener valor positivo para que el bucle se repita, y que
decrece estrictamente con cada repetición. Y efectivamente, la expresión n—k
debe ser mayor que cero para que se cumpla la condición de repetición (k <
1), y además disminuye cada vez que se incrementa A dentro del bucle con la
sentencia ke.

6.4 Eficiencia de programas. Complejidad

Ya se ha dicho que el objetivo prioritario de la programación es la corrección.
La eficiencia sólo debe tenerse en cuenta si es un factor decisivo o importante
en cada caso. Aunque en la primera redacción de un programa no conviene
prestar excesiva atención a los aspectos de eficiencia, tampoco debe descuidarso totalmente este aspecto. Por esta razón se presentan a continuación los
elementos básicos de la eficiencia de programas, y una descripción informal de
algunas técnicas para analizar dicha eficiencia.

 

6.4.1 Medidas de eficiencia

La eficiencia de un programa se defino en función de la cantidad de recursos que
consume durante su ejecución. Un programa eficiente consume pocos recursos,
Metodología de Desarrollo de Programas (II) 143

 

mientras que un programa menos eficiente consumirá una mayor cantidad de
recursos. Esto quiere decir que establecer una medida de la eficiencia de los
programas equivale a establecer una medida de los recursos usados durante su
ejecución.
Las principales medidas de recursos empleados son:

+ El tiempo que tarda en ejecutarse un programa.

+ La cantidad de memoria usada para almacenar datos.

En muchos casos estos dos factores son mutuamente dependientes. Es decir, se
pueden desarrollar programas que obtengan los resultados en menos tiempo,
a costa de usar una mayor cantidad de memoria para almacenar datos, y
viceversa.

En lo que sigue atendoremos exclusivamento a la primera de las dos medidas
mencionadas. Un programa se considerará tanto más eficiente cuanto menos
tiempo tarde en ejecutarse. Los programas poco eficientes tardarán mucho
tiempo en dar los resultados. Hablaremos, por tanto, de la eficiencia en tiempo
de un programa.

El tiempo de ejecución de un programa depende, en la mayoría de los casos, de
los datos particulares con los que opera. Esto quiere decir que la eficiencia de
un programa debe establecerse no como una magnitud fija para cada programa,
sino como una función que nos dé el tiempo de ejecución para cada tamaño o
cantidad de los datos que deba procesar.

Esta idea nos lleva, por su parte, a la necesidad de establecer previamente una
medida dl tamaño de los datos o tamaño del problema, para, en función de
ella, establecer la medida de la eficiencia del programa que los procesa.

El tamaño del problema se puede expresar bien por la cantidad de datos a
tratar, o bien por los valores particulares de los datos. Por ejemplo, para
un programa que obtenga el valor medio o la suma de una serie de datos,
el múmero de datos a sumar o promediar es una buena medida del tamaño
del problema. En cambio, para un programa que calcule una potencia de un
“número, el tamaño significativo puede ser el valor del exponente.

La función que da el tiempo de ejecución según el tamaño del problema se dico
"que mide la complejidad algorítmica del programa.

6.4.2 Análisis de programas

determinación de la eficiencia (o complejidad) de un programa se hace
“analizando los siguientes elementos:

 
144 Fundamentos de programación:

 

 

1. Cuánto tarda en 1 básica del lenguaje utilizado:
2. Cuántas instrucciones de cada clase se realizan durante una ejecución:
del programa.

Para simplificar, consideraremos que cada operación elemental del lenguaje
de programación: suma, resta, lectura, escritura, asignación de valor, decisión
según condición, etc..., dura una unidad de tiempo. Con esta simplificación,
el análisis de la eficiencia de un programa se centra en establecer cuántas
instrucciones se ejecutan on total, dependiendo del tamaño o cantidad de los
datos a procesar.

   

Al realizar cl análisis mencionado nos encontraremos con que el número preciso
de instrucciones ejecutadas depende de los valores particulares de los datos,
incluso para un tamaño fijo del problema. En este caso se pueden adoptar al
menos dos criterios diferentes para realizar el análisis de eficiencia:

 

+ Analizar el comportamiento, en promedio.
+ Analizar el comportamiento en el peor caso.

Utilizaremos el segundo criterio, por ser el más sencillo de aplicar, para anal
algunos ejemplos de programas. Con este criterio el análisis de complejidad
(número de instrucciones ejecutadas) de los esquemas básicos de los programas
se basa en las siguientes reglas:

 

1. La complejidad de un esquema de secuencia es la suma de las complejidades de sus acciones componentes.

2. La complejidad de un esquema de selección equivale a la de la alternativa
más compleja, es decir, de ejecución más larga, más la complejidad de
la evalnación de la condición de selección.

3. La complejidad de un esquema de iteración se obtiene sumando la serie
correspondiente al número de instrucciones en las repeticiones sucesivas,

 

 

Veamos cómo es este análisis en algunos casos conerotos. “Tomemos como
ejemplo el siguiente fragmento de programa que obtiene el máximo de dos
números:

 

maximo = a;
if (a <b) 1

maximo = b;
+

El esquema global es una secuencia de dos acciones: una asignación, seguida
de un esquema de selección (i£). Anotaremos el programa con el número
de instrucciones correspondientes a cada sentencia, para lo cual contaremos el
número de operadores (+, =, *, <, =, ote.) y decisiones (if, else, while,

etc). Aplicando las reglas para los esquemas tendremos:

    
Metodología de Desarrollo de Programas (11) 145

 

 

Código Número de instrucciones ejecutadas
1
2
1 3 (Regla2)
Total = 4 (Regla1)

La complejidad en este caso es fija, y no depende de una medida de tamaño
del problema.
A continuación analizaremos de manera similar un bucle que obtiene en f el

factorial de un número n. Anotaremos el programa con el número de instruesiones de cada sentencia:

 

 

Código Número de instrucciones ejecutadas
k=1; 1
£=1; 1
while (k<»m (2
pe 1 5(n-1) — (Regla 3)
ba a (n-1) (Regla 3)
: Total 5n-3 — (Regla 1)

Para calcular el número de instrucciones del bucle se ha multiplicado el nú
'mero de instrucciones en cada repotición por el número de repeticiones. La
complejidad aparece expresada en función del valor de n, que en este caso
resulta una medida natural del tamaño del problema.

6.4.3 Crecimiento asintótico

 

En los análisis de eficiencia (o complejidad) se considera muy importante la
manera como la función de complejidad va aumentando con el tamaño del
problema. Lo que interesa es la forma de crecimiento del tiempo de ejecución,
yy no tanto el tiempo particular empleado.

Como ejemplo podemos comparar dos programas, uno que tarde un tiempo
100N en resolver un problema de tamaño , y otro que tarde un tiempo N?
La comparación puede hacerse escribiendo una tabla con los tiempos de cada
“amo para diferentes tamaños del problema.

  

Al principio de la tabla el primer programa parece menos eficiente que el se'gando, ya que tarda mucho más tiempo, pero a medida que aumenta el tamaño
del problema ambos programas llegan a tardar lo mismo (para tamaño 100),
146 Fundamentos de programación:

y a partir de ahí el segundo programa demuestra ser mucho menos eficiente
que el primero.

Tamaño 100N Nm
1 100 1
2 200 4
3 300 9
10 1.000 100
100 10.000 10.000

1000 100.000 1.000.000

La menor eficiencia del segundo programa para tamaños grandes del problema
no cambia por el hecho de que se modifique el coeficiente multiplicador. Si el
primer programa tardase 10 veces más (1000N en lugar de 100NV), acabaría
igualmente por resultar mejor que el segundo a partir de un cierto tamaño del
problema.

Lo que importa es la forma de la función, que en el primer caso es lineal, y
en el segundo es cuadrática. La forma en que crece la función para tamaños
grandes se dice que es su comportamiento asintótico, y se representa mediante
la notación:

Ols(n))

En dicha notación n indica el tamaño del problema, f la forma o función de
crecimiento asintótico, y O (que se lee O-grande) significa orden de crecimiento. Algunas formas de crecimiento típicas, y sus valoraciones habituales, son
las siguientes;

O(1) Complejidad constante. Ideal.

O(logn) Complejidad logarítmica. Muy eficiente.
O(n) Complejidad lineal. Muy eficiente.

O(n log n.) Complejidad lineal-logarítmica. Eficiente.
O(n2) Complejidad cuadrática. Menos eficiente,
O(n*) Complejidad polinómica. Poco eficiente
O(2") Complejidad exponencial. Muy poco eficiente.

Las valoraciones indicadas son, por supuesto, muy imprecisas. Hay muchos
problemas que sólo pueden resolverse mediante programas de complejidad elevada, poco eficientes según esta valoración, pero adecuados para esos problemas. Los problemas que sólo pueden resolverse con programas de complejidad
exponencial se consideran problemas intratables en la práctica para tamaños
grandes.

 
 
    
       
   

Ejercicios sin resolver - 1

Hasta este momento se han presentados los conceptos básicos de programa¡ción con diversos ejemplos completamente resueltos, Es aconsejable que estos
isjercicios ya resueltos sólo sean consultados como procedimiento de autocorrección, después de intentar una solución propia. En todo caso, a continuación
¡se enuncian varios ejercicios sin resolver semejantes a los ya resueltos. Todos
sellos se pueden realizar utilizando las herramientas y metodología ya explicadas. Es muy importante que la realización de los ejercicios se lleve a cabo en
Ídos etapas:

1. Plantear sobre el papel la solución del ejercicio, empleando la técnica de

refinamientos sucesivos ya explicada.
2. Comprobar en el computador la solución adoptada.

como no es necesario buscar una solución propia a todos los ejercicios
'sesueltos, tampoco es necesario resolver todos estos ejercicios propuestos. El
yjetivo de todos ellos es facilitar el aprendizaje de una buena metodología de
ramación,
enunciados de los ejercicios son los siguientes:

1. Realizar un programa que imprima la tabla de multiplicar por un número
leído como dato. Por ejemplo, si se quiere obtener la tabla de multiplicar
del 9 se tendría la siguiente hoja de resultados:

 
148

Fundamentos de programación

 

 

Numero? 9

Tabla de multiplicar por 9

 

 

 

9x 1= 9
9x2 18
9x3 27
9x4 36
9x5 45
9x6 54
9 x 7 63
9x8 72
9 x 9 81
9 x10 = 90

2. Realizar un programa para calcular el máximo común divisor de dos

números enteros. Por ejemplo:

 

Primer Numero? 655
Segundo Número? 1325

El máximo común divisor es: 5

3. Realizar un programa que escriba un rombo simétrico de asteriscos como

el que se muestra a continuación, tomando como dato el número
asteriscos que tiene el lado.

de

 

Lado? 4

 

 
  
  
   

icios sin resolver - 1 149

 

Realizar un programa que calcule el número e mediante el desarrollo en
sie:

 

con un error menor del introducido como dato. Por ejemplo:

Error ? 0.000001

Valor de e = 2.71828198

 

5. Realizar un programa que lea la longitud de los tres lados de un tri
y analico qué tipo de triángulo es. Los resultados posibles
siguientes:

+ No forman triángulo (un lado mayor que la suma de los otros dos).
ngulo equilátero (tres lados iguales).

+ Triángulo isósceles (dos lados iguales).

+ Triángulo escalono (tres lados distintos).

+ Triángulo rectángulo (sus lados cumplen el teorema de Pitágoras).

6. Realizar un programa que analice un texto terminado con un punto (+)
y contabilice los siguientes aspectos:

+ Número total de caracteres.
+ Número total de vocales utilizadas.

Total de veces utilizada la vocal “a” mayúscula o minúscula.

Total de veces utilizada la vocal “e? mayúscula o minúscula,

Total de veces utilizada la vocal “i” mayúscula o minúscula.

Total de veces utilizada la vocal “o” mayúscula o minúscula.

+ Total de veces utilizada la vocal “un” mayúscula o minúscula.

7. Realizar un programa que dado un número N, introducido como dato,
escriba todos los números comprendidos entre 1 y 10000 que cumplan
las dos reglas siguientes:

+ Regla 1: La suma de sus cifras debe ser un divisor de N.
+ Regla 2: El producto de sus cifras debe ser un múltiplo de N.

8. Realizar un programa que a partir del capital (C), el tanto por ciento
de interés anual (1) y los años de amortización (A) de un crédito, introducidos como datos, calcule la anualidad fija a pagar a lo largo de los A
años. La formula para este cálculo es la siguiento;

 

:gulo
rán los

 

 

 

 
150 Fundamentos de programación

Anualidad=C
 

El programa también debe calcular para todos los años la parte de la
anualidad dedicada al pago de intereses y la parte dedicada a la amortización de la deuda. Por ejemplo:

Capital? 1000000
Interés (%)? 15

Años? 3

Anmualidad: 437977

 

Año Intereses Amortización
1 150000 287977
2 106804 331173
3 57127 380850
Tema 7

Funciones y Procedimientos

El concepto de subprograma es fundamental para poder desarrollar programas
grandes. Este tema y el siguiente se dedican por entero a introducir dicho
«concepto.

Las dos formas clásicas de subprogramas, disponibles prácticamente en cual«quier lenguaje imperativo, son las funciones y los procedimientos. En este
tema se detalla cómo se definen y utilizan ambos tipos de subprogramas y las
diferencias que existen entre ellos.

El tema se complementa haciendo explícitas las principales dificultades de uso
que conlleva el empleo de subprogramas para los programadores principiantes,
y la necesidad de una adecuada disciplina de programación para soslayarlos.

7.1 Concepto de subprograma

Un subprograma, como su nombre indica, es una parte de un programa. Como
mecanismo de programación, un subprograma es una parte de un programa
¿que se desarrolla por separado y se utiliza invocándolo mediante un nombre
simbólico,

Desde el punto de vista de una buena metodología de programación, el mecanismo de subprograma debe utilizarse para fragmentos del programa. que
tengan un cierto sentido en sí mismos. Si se hace así, podríamos decir que, al
igual que un programa sirve para resolver un problema, un subprograma sirve
para resolver un subproblema.

El empleo de subprogramas, desarrollando por separado ciertas partes del
programa, resulta especialmente ventajoso en los casos siguientes:

 
 

152 Fundamentos de program

 

  
   
     

+ En programas complejos: Si el programa se escribe todo seguido resulta:
muy complicado de entender, porque se difumina la visión de su estruetura global entro la gran cantidad de operaciones que forman el có.
del programa (¡los árboles impiden ver el bosque!). Aislando ciertas par=
tes como subprogramas separados se reduce la complejidad de la visión:
global del programa.

+ Cuando se repiten operaciones análogas: Definiendo esa operación coma
subprograma separado, su código se escribirá sólo una vez, aunque luego
se use en muchos puntos del programa. El tamaño total del programa
será menor que si se escribiera el código completo de la operación cada
vez que se necesita.

  

La técnica de refinamientos sucesivos sugiere descomponer las operaciones
complejas de un programa en otras más simples. En sucesivos pasos de refinamiento, cada operación se vuelvo a descomponer hasta que todo ol programa.
se puede escribir utilizando las sentencias disponibles en el lenguaje empleado.
Hasta el momento hemos continuado los refinamiento hasta llegar a las sen=
tencias básicas de C£. Podemos ver ahora sobre un ejemplo cómo es el programa resultante si las operaciones intermedias se definen como subprogramas
en Ct,

Por ejemplo, consideremos un programa para calcular el perímetro del triángulo formado por tres puntos (A, B y C), según se muestra en la figura 7.1.

AS

e:
Figura 7.1 Perímetro de un triángulo.

Los primeros pasos del refinamiento serían los siguientes:

Calcular e imprimir el perímetro —
Leer las coordenadas de los vértices
Calcular el perímetro
Imprimir el perímetro

A su vez, la operación de lectura de los puntos se puede descomponer en una
secuencia de lecturas de las coordenadas de cada uno de los tres puntos:
 
  
 
   
      
   
  
   
    
   
   
 
 
   

Funciones y Procedimientos 153

 

Leer las coordenadas de los vértices —
Leer coordenadas del punto A
Leer coordenadas del punto B
Leer coordenadas del punto C

Definiendo cada subproblema como subprograma, el aspecto del programa, en

forma esquemática, sería el siguiente:

<stdio.h>

LeerVertices (:

LeerCoordenadas(

LeerCoordenadas(

LeerCoordenadas(

 

ImprimirPerimetro() (

main() (
LeerVertices();
CalcularPerimetro()
ImprimirPerimetro()

este esquema del ejemplo vemos cómo los subprogramas para leer los vórcalcular el perímetro e imprimir el perímetro aparecen descritos después
la directiva Kinclude y antes del inicio del programa principal indicado

lante int main(). En esta nueva zona del programa se deben describir
los subprogramas y el resto de olementos globales que se necesiten en el
lo del programa. Así, la estructura para describir un programa en CE,
completa que la presentada en el tema 2, sería la siguiente:

Programa 35= [ Include ) É Declaración_global Y
int mainQ) Bloque

 
 

 

Declaración _global 33= Declaración de_constante |
Declaración_de_variable | Declaración_de_tipo | Subprograma
Subprograma 333 Cabecera_subprograma Bloque

elementos globales de un programa completo en C£ se pueden declarar
tes y variables en la forma ya estudiada. También se podrán declarar

 

 
 
 
154 Fundamentos de programación

 

tipos como se verá en temas posteriores. Además y esto es lo importante en
este apartado, un programa completo en C+ es una colección de subprogramas
delimitados por su correspondiente cabecera. Cada subprograma está constituido por su propio Bloque de código de manera semejante a un programa
completo. En realidad un programa en Ci es el programa principal o “main”
cuya cabecera es int main().

A continuación se estudian las dos formas fundamentales de subprogramas en
programación imperativa: funciones y procedimientos, y su manejo utilizando
el lenguaje CE.

7.2 Funciones

Cuando se diseña y desarrolla un programa aparecen con frecuencia operaciones significativas que dan como resultado un valor simple y único en función
de ciertos parámetros. Por ejemplo:

Potencia: ze
Volumen de un cubo: lado?
Area de un triángulo: (base + altura)/2

Distancia entre dos puntos: — (11-32)? + (yl—y22) 2

Estas operaciones se pueden considerar subprogramas y más exactamente funciones. Una función es un tipo de subprograma que calcula como resultado
un valor único a partir de otros valores dados como argumentos. En líneas
generales, una función se asemeja bastante a la idea matemática de función
F(z,y,-..), con argumentos £, Y, ...

7.2.1 Definición de funciones

El primer paso en el manejo de una función es declarar su interfaz. Esta declaración incluye su nombre, los argumentos que necesita con el correspondiente
tipo para cada uno de ellos, y el tipo de resultado que proporciona. En C+

esto se realiza escribiendo una cabecera de función de la siguiente forma:

 

TipoResultado NombreFuncioní Tipo1 argumento, Tipo2 argumento?, .... )

 

La declaración se inicia con el tipo de resultado que proporciona la función y a.
continuación el nombre de la función, que debe ser un identificador. Seguidamente la lista de los argumentos, entre paréntesis, y separados por el carácter
coma (,). Las declaraciones de argumentos son similares a las declaraciones

 

 
 
  
    
  
  
  
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
  
  
   

Funciones y Procedimientos 155

 

de variables: por cada argumento se declaran su tipo y nombre, separados por
al menos un carácter blanco.

Las cabeceras de las funciones para los ejemplos anteriores serían las siguientes:
float Potencial float x, int n )

'int VolumenCubo( int lado )
¡float AreaTriangulo( float base, float altura )
¡float Distancia( float x1, float yl, float x2, float y2 )

Estas cabeceras representan la interfaz entre la definición de la función y su
utilización posterior. Los argumentos que aparecen en la cabecera son los argumentos formales. No son variables del programa, sino sólo nombres simbólicos
¿que sirven para formalizar la definición posterior de la función, permitiendo
hacer referencia a los argumentos en la definición de los cálculos.

La definición completa de una función se compone de una cabecera seguida de
un cuerpo de función que tiene la misma estructura que un Bloque de programa
completo. Este bloque comienza con una parte declarativa y continúa con
una parte ejecutiva. En la parte declarativa se pueden declarar constantes y
variables locales que sólo son visibles en el cuerpo de la función. La parte
ejecutiva estará constituida por una secuencia de sentencias.

En las sentencias que constituyen el cuerpo de la función se puede (y se debe) hacer uso de los argumentos formales declarados en su interfaz. Esto
permite parametrizar los cálculos de la función para los valores particulares
de los argumentos. Así, otra forma de ver las funciones es como expresiones
parametrizadas.

Por ejemplo, la definición completa de las funciones anteriores se realizaría de
la siguiente forma:

Potencial float x, int n ) (
float p = 1.0;

 

for (int k = 1; k <= nm; ke+) (
Pp...

VolumenCubo( int lado ) 4
return lado*lado*lado;
y

 
156. Fundamentos de programación:

 

float AreaTriangulo( float base, float altura ) (
return (base * altura) / 2.0;

y

float Distancia( float xl, float yl, float x2, float y2 ) (
float deltaX, deltaY;

deltaX = x2 - x1;

deltaY = y2 - yl;

return sqrt£f( deltaX*deltaX + deltaY*deltaY );
)

 

En estos ejemplos se observa la existencia de una nueva sentencia de CE,
iniciada con la palabra clave return. Esta sentencia sirve para devolver como.
valor de la función el resultado de los cálculos realizados. Esta sentencia tiene
la siguiente estructura:

 

return expresión;
y provoca la finalización inmediata de la ejecución de la función. El resultado
de la expresión debe ser un valor del tipo indicado en la declaración de la
función. Dicho valor es el que se devuelve como resultado de la funci

 

 

La sentencia return se puede insertar en cualquier punto de la parte ejecutable
de la función. Además, es posible utilizar más de una sentencia return en una
misma función. La ejecución de la función acaba cuando se ejecuta cualquiera
de las sentencias return.

A continuación se muestra la definición de una función con varias sentencias
de retorno.

int Maximo2(int x, int y) (
if (>= y) 1

 

7.2.2 Uso de funciones

Para usar una función en los cálculos de un programa se invoca dicha función
escribiendo su nombro y a continuación, entro paréntesis, los valores concretos
de los argumentos, separados por comas. Esta invocación de la función representa un valor del tipo de la función, que podrá ser usado como operando en

 
ciones y Procedimientos 157

 

expresión aritmótica, o en goneral en cualquier parto del programa on que
válido escribir una expresión de eso tipo.

 

¿Al invocar una función es obligatorio que los valores suministrados para los
jentos (los argumentos reales) correspondan en número y tipo con los
jentos en la definición (los argumentos formales). La correspondencia

tipo significa que el tipo del argumento en la invocación sea compatible en
ión con el tipo de argumento formal. Por ejemplo:
lumenCubo( ladoCubo ) > 27

'orPotencia = Potencial base, exponente );
= ArcaTriangulo( Distancia( XA, yA, xB, yB ), medidaáltura ) )

resultado del volumen del cubo es un valor entero y sc debe comparar con
¡a valor entero (27). La variable valorPotencia tendrá que ser de tipo real,

argumento base debe ser de tipo real y el argumento exponente debe ser
ide tipo entero.

resultado del cálculo de la distancia entre los puntos A y B es de tipo real.
En el cálculo del árca del triángulo, el argumento para la base debe ser de
ssipo real. Por tanto, el resultado de la distancia entre A y B se puede utilizar
¡somo base del triángulo. La variable medidadltura también debe ser de tipo
seal.

El efecto de la invocación de una función puede describirse de forma simplifi¡ada de la siguiente manera:

 

1. Se evalúan Ins expresiones de los valores de los argumentos.

2. Se asignan dichos valores a los correspondientes argumentos formales.

3. Se ejcenta el código do la definición de la función, hasta alcanzar uma
sentencia de retorno.

4. El valor retornado se usa en el punto donde se invocó la función.

¡Otros posibles efectos de la invocación de una función o procedimiento se
escriben más adelante.

7.2.3. Funciones predefinidas

Se consideran funciones predefinidas las que forman parte del propio lenguaje
de programación. Estas funciones están siempre disponibles en cualquier prorama. Algunos lenguajes de programación tienen un repertorio más o menos
amplio de estas funciones, en particular los que usan funciones con nombre
“como alternativa a operadores matemáticos para ovitar la proliferación de
símbolos especiales.

 
158 Fundamentos de programación

 

Los lenguajes C y C++ disponen de pocas funciones predefinidas (a cambio
ofrecen una gran variedad de operadores). Además estas funciones predefinidas
sólo resultan útiles en un uso avanzado del lenguaje. Por ejemplo:

int sizeo£( tipo ) Tamaño en bytes de un dato del tipo indicado

Las funciones predefinidas son, en general, seudofunciones. Esto es particularmente cierto para las funciones que usan tipos como argumentos o en las que
el tipo del argumento no está totalmente determinado (por ejemplo, admiten
cualquier tipo numérico).

En Ch se prescinde del uso de funciones predefinidas, por las consideraciones
indicadas anteriormente.

7.2.4 Funciones estándar

Al realizar programas en CE podremos utilizar funciones que estén definidas en
módulos ya redactados de antemano. Algunos módulos constituyen librerías
estándar y están disponibles en la mayoría de los compiladores de C/C++,
tal como ya se dijo al hablar de la operaciones de lectura y escritura o para el
manejo de caracteres.

Las funciones definidas en módulos estándar so denominan funciones estándar
y pueden ser utilizadas sin necesidad de escribir su definición, pero a diferencia
de las funciones predefinidas hay que indicar expresamente que se van a utilizar
dichos módulos de librería mediante la directiva tinclude del correspondiente
módulo que las contenga.

Por ejemplo, tal y como ya se comentó en el tema 2, mediante la directiva
*include <ctype.h> se pueden utilizar funciones que facilitan el manejo de
las diferentes clases de caracteres. Este módulo de librería incluye funciones
tales como:

Indica si e es una letra
Indica si c es un carácter ASCIL

Indica si e es un carácter de espacio o
tabulación

Indica si c es un dígito decimal (0-9)
Indica si e es una letra minúscula

Indica si e es espacio en blanco o salto de
línea o página

Indica si e es una letra mayúscula
Devuelve la minúscula correspondiente a e
Devuelve la mayúscula correspondiente a €

bool isalpha( char e
bool isascii( char e

bool isblank( char e

bool isdigit( char e
bool islower( char e

bool isspace( char e

bool isupper( char e
char tolower( char c
char toupper( char e

 
 
  
  
  
  
 
 
   
   
   
  
  
  
   
   
   

iones y Procedimientos 159

 

tipo de resultado bool sirve para indicar si un resultado es SI/NO y se
lucirá formalmente en el próximo tema 9.

lo referente a funciones matemáticas, se dispone del módulo estándar math.
utilizar sus funciones habrá que incluir la directiva Kinclude <nath.h> al
10 del programa. Este módulo dispone de un gran número de funciones
-máticas con nombres distintos dependiendo del tipo del argumento y el
de resultado, algunas de ollas son las signientes.

float

 

    

sqrt£( float x ) raía cuadrada de 2

float exp£( float x ) exponencial e

float log£( float x ) logaritmo neperiano de
float pow£( float x, float y ) potencia 2%

float sinf( float x ) sono de x

float cosf( float x ) coseno de q

float tanf( float x ) tangente de x

float atanf( float x ) arcotangente de 2

float round£( float x ) valor de x redondeado a entero

función sqrtf ya ha sido utilizada en este mismo tema para la definición
la función Distancia. Para los objetivos de esta asignatura es suficiente
conocer las funciones aquí relacionadas. En el caso de necesitar alguna
ión matemática adicional se deberá consultar el correspondiente manual
C/C++.

fuera del ámbito de este libro la enumeración de todos los módulos y
iones de librería existentes en C/C++. Algunas de ellas se irán presentado

el momento en que se introduzcan los correspondientes conecptos, Para
juier consulta adicional se debería hacer uso de un manual de C/C++.

  
   
  

3 Procedimientos

ln procedimiento es un subprograma que realiza una determinada acción
diferencia de las funciones, un procedimiento no tiene como objetivo, en
al, devolver un valor obtenido por cálculo.

   
 

procedimiento es una forma de subprograma que agrupa una sentencia o
“grupo de sentencias que realizan una acción, y permite darles un nombre por
¿que se las pueden identificar posteriormente. Estas sentencias, al igual que
“en las funciones, se pueden paramotrizar mediante una serie de argumentos.
“As, otra forma de ver a los procedimientos es como acciones parumetrizadas.

    

Por ejemplo, durante el desarrollo de un programa podemos identificar accio“mes talos como:
160 Fundamentos de programación

 

Trazar una línea de longitud dada
Imprimir el resultado

Ordenar dos valores

Leer las coordenadas de un punto

Si nos interesa, podremos definir estas acciones como procedimientos, y luego
invocarlas en el programa cuando se necesite,

7.3.1 Definición de procedimientos

La definición en C+ de un procedimiento es prácticamente igual a la de una
función:

void NombreProcedimiento( Tipo argum1, Tipo2 argum2, ... ) Bloque

 

La diferencia principal es que no se declara el tipo de valor del resultado, ya.
que no existe dicho valor. La palabra reservada void es la que indica que no
hay resultado de ningún tipo. Además, con cierta frecuencia interesa definir
procedimientos sin argumentos. En estos casos sólo es necesario dar el nombre,
y no habrá lista de argumentos entre los paréntesis.

 

Como ejemplo, podemos dar posibles definiciones de procedimientos que correspondan a las dos primeras acciones citadas anteriormente:

void Trazarlinea( int longitud ) (
for (int k = 1; k <= longitud; ke) £
print£( "-");
J
D

 

void Escribirkesultado() (
printf( "Resultado:K10£in", resultado );
7

En el primer caso se trata de un procedimiento para trazar una línea horizontal de cualquier longitud, a base de imprimir guiones. El resultado de este

procedimiento no es un valor determinado, sino la acción de trazado de la
línea, En el segundo caso el procedimiento se utiliza solamente para imprimir
con un formato concreto un resultado ya calculado.

 

Si se desea, en la definición de un procedimiento pueden usarse también sentencias de retorno, pero con un significado algo diferente que en el caso de las
funciones. La sentencia

return;

 
Procedimientos 161

 

    
  
 
    
 

escribe ahora simplemente así, sin ninguna expresión que la acompañe,
que no hay ningún valor que devolver. Esta sentencia sirve simplemente
terminar la ejecución del procedimiento en ese momento, y volver al
into siguiente a dondo so invocó. Por ejemplo, otra posible definición del
limiento de imprimir un resultado serís

d EscribirResultado() £

if (resultado < 0) (

printf( "Problema no resuelto" );
return;

   
  
  
 
    
  
 
   
   
   
   
  
  
   

3

printf( "Resultado:X10fn", resultado );

 

 
 

Da este caso si la condición de la sentencia 1£ resulta cierta la sentencia final
escritura no so ejecutará, ya que la sentencia de retorno termina ln acción
el procedimiento de forma inmediata.

3.2 Uso de procedimientos

a usar un procedimiento hay que invocarlo. Dicha invocación o llamada
astituye por sí sola una sentencia de Ct, cuyo formato es:

NombreProcedimiento( argumentol, argumento2, ... )5

puede observarse, un procedimiento se invoca escribiendo su nombre y
continuación, si los hay, los valores de los argumentos particulares en esa
mada, separados por comas. Los valores de los argumentos pueden darse,
general, mediante expresiones. Si no hay argumentos no se suprimen los
éntesis.

argumentos en la llamada (argumentos reales) deberán ser compatibles
a los indicados en la declaración (argumentos formales), tal como se dijo
las funciones. Por ejemplo, los procedimientos declarados anteriormente
drían invocarse de la forma:

 

la primera llamada se trazará una línca con el triple de la longitud del
do. Con la segunda llamada se escribirá el resultado según el formato prosamado en la definición de este procedimiento.

forma simplificada, la invocación de un procedimiento produce un efecto
ogo a la secuencia de acciones siguientes:

 
162 Fundamentos de programación

 

1. Se evalúan las expresiones de los valores de los argumentos.

2. Se asignan dichos valores a los correspondientes argumentos formales.

3. Se ejecuta el código de la definición del procedimiento, hasta alcanzar el
final del bloque o una sentencia de retorno.

4. El programa que invocó al procodimiento contimúa en el punto siguiente
a la sentencia de llamada.

 

 

7.3.3. Procedimientos estándar

Al igual que para las funciones, en los módulos estándar asociados a cada compilador de C/C++ se dispone de diversos procedimientos estándar que pueden
utilizarse sin más que hacer uso de la directiva *include del correspondiente
módulo.

En particular ya se han mencionado y utilizado los procedimientos estándar
de lectura de datos o escritura de resultados, que están disponibles tras incluir
la cabecera <stdio.h>. Otros procedimientos estándar se irán introduciendo
en los siguientes temas, o pueden consultarse en un manual de C/C++.

7.4 Paso de argumentos

La manera fundamental de comunicar información entre las sentencias de un
subprograma y el programa que lo utiliza es mediante los argumentos, En C£
existen dos formas distintas de realizar esta comunicación, que se denominan
paso de argumentos por valor y paso de argumentos por referencia, que se
describen a continuación.

7.4.1 Paso de argumentos por valor

Esta es la forma utilizada en los ejemplos que se han mencionado hasta el
momento. Los argumentos representan valores que se transmiten desde el
programa que llama hacia el subprograma. En el caso de las funciones hay
además un valor de retorno, que es el valor de la función que so transmite
desde el subprograma hacia el programa que lo llamó.

Los argumentos reales en la llamada al subprograma pueden darse en general en forma de expresiones, cuyos tipos de valor deben ser compatible en
asignación con los tipos de los argumentos formales.

El modo de paso por valor implica que los elementos usados como argumentos
en la llamada al subprograma no pueden ser modificados por la ejecución de
 
  
   
  
   
 
 
  
  
  

iones y Procedimientos 163

 

sentencias del subprograma. Esto es cierto incluso en el caso de que en el
"ama se ejecuten asignaciones a los argumentos formales, considerados
varinbles locales dentro del subprograma.

 
 

paso de argumentos por valor puede describirse de la siguiente manera:

1. Se evalúan las expresiones de los argumontos reales usados en la llamada.
2. Los valores obtenidos se copian en los argumentos formales,

3. Los argumentos formales se usan como variables dentro del subprograma.
Si a estas variables se les asignan nuevos valores, no se estará modificando
el argumento real, sino sólo la copia.

 

ejemplo, se puede modificar la definición de la función para el cálculo de
distancia entre dos puntos de la siguiente form:

Distancia( float xl, float yl, float x2, float y2 ) (

x= 2 - xd;

yl = y2 - y
return sqrt( x1*x1 + yl*yl

   
   
 
 
  
  

 

puede verse, dentro del procedimiento se asignan nuevos valores a algude los argumentos. Pese a ello, un fragmento de programa tal como:
12.3;
2.6;
anciaAB = Distancia( xA, yA, xB, yB

 

 

modifica las variables externas xA e yA usadas como argumentos, que man» los valores que tenían antes de la llamada.

 
   
 
   
   
    
   
    

'0 que la reasignación de valor a un argumento pasado por valor resulta
¡algo confusa, es preferible evitar esta circunstancia todo lo posible. Esta es
¡ama regla recomendable en el Manual de Estilo de esta asignatura.

 

7.4.2 Paso de argumentos por referencia

En ciertos casos es deseable que el subprograma pueda modificar las variables que se usen como argumentos. Esto permite producir simultáneamente
'sarios resultados y no sólo uno. El mecanismo de paso por valor no permite
'que el subprograma modifique directamente una variable pasada como argu'mento. Para conseguirlo hay que usar el otro modo de paso de argumentos,
¡denominado paso de argumentos por referencia.

 

“El paso de un argumento por referencia se indica en la cabecera del subprograza, anteponiendo el símbolo 4 al nombre del argumento formal, de la siguiente
“manera:

 
164 Fundamentos de programación

 

TipoResultado Nombre(. TipoArgumento € argumento, ... )

Si un argumento se pasa por referencia ya no será válido usar como argumento real una expresión. El argumento real usado en la llamada dobe ser
necesariamente una variable del mismo tipo. Esta variable será utilizada en
el subprograma como si fuera suya, es decir, la asignación de muevo valor al
argumento modifica realmente la variable externa pasada, como argumento.

 

 

El paso de argumentos por referencia puede describirse de la siguiente manera:
1. Se seleccionan las variables usadas como argumentos reales.
2. Se asocia cada variable con el argumento formal correspondiente.
3, Se ejecutan Ins sentencias del subprograma como si los argumentos formales fuesen los argumentos reales.
Ahora se pueden escribir las definiciones como subprograma de las restantes
acciones puestas como ejemplo al hablar de procedimientos en el apartado 7.3.
Ordenar dos valores
Leer las coordenadas de un punto
En ellas necesitamos utilizar argumentos pasados por referencia en los que se
puedan dejar los valores ordenados o las coordenadas leídas.

void OrdenarDos( int 8 y, int8z)(
int aux;

if (y>2D4

 

void LeerCoordenadas( char Punto, float £ x, float € y ) (
print£( "Punto Xen", Punto );
print£( "¿Coordenada X ?" );
scanf( "KE", dx);
print£( "¿Coordenada Y ?" );
scan£( "KE"
print£( "w
+

 

Un ejemplo de uso sería:

OrdenarDos( A, B-)
LeerCoordenadas( 'A', xA, yA

 
mes y Procedimientos

sotación £ usada en las cabeceras de subprogramas para indicar el paso
referencia cs una novedad de C++ respecto al lenguaje C, y evita tener
recurrir al uso explícito de punteros para permitir el paso por referenci
plificando así las invocacionos de los suprogramas.

cepcionalmonto, en los ejemplos de este libro se usan algunos subprogramas

tándar do C, en particular ol procedimiento predefinido de lectura scanf
ódulo stdio, que sí requieren el paso de punteros como argumentos.
vese que este caso hay que usar explícitamonto el operador 4 (que obtiene

dirección de una variable) cada vez que se invoca ese subprograma. Los
xos se introducirán en el tema 13 de este libro.

5 Visibilidad. Estructura de bloques

norma general, en un punto determinado de un programa se pueden
ar todos los elementos definidos con anterioridad. Podemos decir que
un punto del programa se pueden “ver” los elementos definidos hasta
momento. Esta regla sencilla de visibilidad se amplía con nuevas limitacuando so definen subprogramas. La definición de un subprograma está
nada por una cabecera o interfaz, y un bloque de código que es el cuerpo del
bprograma. Ese bloque de código constituye una barrera de visibilidad que
e que los elementos declarados en el interior del cuerpo de un subprograma
sean visibles desde el exterior.

 

decir, la definición de un subprograma construye un nuevo elemento, util

ble en el resto del código, y al mismo tiempo realiza una ocullación de sus

les de realización. Un programa que contenga subprogramas tiene, por

, una estructura de bloques que marcan ámbitos de visibilidad, tal como

muestra en el ejemplo de la figura 7.2, donde so han marcado los diferentes
¡ues y algunos puntos concretos dentro de ellos.

  

os elementos definidos en el ámbito más externo son elementos globales, mien
sas que los elementos definidos en el interior del bloque de un subprograma
¡son elementos locales a dicho subprograma. Cada bloquo cs completamente
“spaco desde el exterior y so puede considerar como una caja negra. Los ele“mentos locales de un bloque son invisibles desde el exterior del bloque y dejan
dde existir al finalizar la ejecución del bloque.

¡La cabecera de un subprograma se encuentra en la frontera entre el interior y
«el exterior de dicho subprograma, y es parcialmente visible desde el exterior
Desde el interior del subprograma la cabcera cs visible en todos sus detalles.
¡Desde el exterior es visible el nombre y tipo del subprograma, y el tipo de cada

      

 
 

166 Fundamentos de programación:

 

 

 

*include <stdio.h> — global —
const float Pi = 3.1416;

 

<A>
void Cambiar( int 4 vl, int 8 v2 ) 1 -—- Cambiar --——
int temp;

 

1
<B> 1
temp = vi; 1
vi = v2; 1
v2 = temp; 1
, A

 

int Factorial( int nunero ) ( — Factorial —int fac

 

For (int k=2; ke=numero; ke+) £ — for.
fac = fac * k;

,

return fac;

 

3

 

int main) £
float r;
<>
scanf( "RE", ro);
print£( "Area = Xf, Areac(r) );
,

 

 

Figura 7.2 Ejemplo de bloques en un programa en Cé,

argumento, pero no su nombre particular. La vista externa de la cabecera es.
realmente la interfaz del subprograma. El contenido lógico de la interfaz es lo
que se denomina signatura del subprograma, que es suficiente para comprobar.
si la invocaciones son consistentes con su definición:

Cabecera (código real) natura (vista lógica)
void Cambiar( int € vl, int 8 v2 ) void Cambiar( int £, int 4 )
int Factorial( int numero ) int Factorial( int )

 

Finalmente hay que mencionar el caso especial de la sentencia for de C+, En
ella se declara la variable contador del bucle en la misma sentencia, y establece
un ámbito local limitado en el cual es visible dicha variable contador. De hecho
al terminar la ejecución del bucle la variable contador desaparece.
 
   

jones y Procedimientos

   
    
   
 
 
 
 
   
   
    
  
   
     
     
    
  

resumen, y para ilustrar con un ejemplo concreto las reglas de visibilien la tabla siguiente so recogen las listas de elementos que son visibles en
concretos del programa de ejemplo de la Figura 7.2:

 

 

Punto Elementos visibles
A Pi
B Pi, Cambiar, vl, v2, temp
C Pi, Cambiar, Factorial, numoro, fac, k
D Pi, Cambiar, Factorial, numero, fac
E Pi, Cambiar, Factorial
F Pi, Cambiar, Factorial, main, r

6 Recursividad de subprogramas

caso especial que no ha sido considerado hasta este momento es la pos
de que en un subprograma se haga uso de ese mismo subprograma.
lo un subprograma hace una llamada a sí mismo se dice que es un sub¡2 recursivo. Un estudio más detallado y completo del concepto de
ividad queda fuera de los objetivos de este libro y sería objeto de estudio
un curso más avanzado,

ilustrar de manera sencilla la recursividad utilizaremos el algoritmo para.
cálculo del factorial de un número natural. En el tema 5 se decía que el
ial de un número n se puede calcular mediante la fórmula:

 

  

ni=1x2x3x4x..xn

 

cálculo se puede también expresar de manera recursiva mediante el sise algoritmo (para el caso general):
ni=nx(n-1)!
ejecución de un algoritmo recursivo debe terminar en algún momento. Paello hace falta que las llamadas recursivas, internas, del subprograma a sí
10 deben estar controladas en una estructura condicional. Se distinguen
¡tes casos en la invocación del subprograma dependiendo de los valores
os de los argumentos. En algunos casos, denominados casos minimala solución se obtiene directamente, sin necesidad de llamadas recursivas.
el resto de los casos, que denominaremos casos generales, se necesitan
jones recursivas para obtener la solución.

el cálculo del factorial los casos minimales corresponden a:

   
168 Fundamentos de program:

  

A continuación se muestra el listado de un programa recursivo para el cál
del factorial utilizando la función recursiva FactorialRecursivo.

 

 

 

AAA AAN RARA

* Programa: FactorialRecursivo

Descripción:
Este prograna calcula el factorial de los primeros
múneros naturales, de forma recursiva

include <stdio.h>

 

222/

int FactorialRecursivo( int n ) 1
if (m<1D4
return 1;
) else (
return n * FactorialRecursivo( n-1 );
3
Y

int mainO 1
for (int i=0; i <= 10; et) €
printf( "42d! vale:X10d%n", i, FactorialRecursivo( 1) );
y

 

3

 

La ejecución del programa produce el siguiente resultado:

 

 

or
1
2
3l
al
5!
6
7
8l
9
101

 

7.7 Problemas en el uso de subprogramas

   

El empleo de funciones y procedimientos, las dos formas de paso de argumontos, las reglas de visibilidad entre bloques, etc., ofrecen interesantes posibi
 
    
 

iones y Procedimientos 169

 

para el desarrollo de los programas. Sin embargo, un uso incorrecto
estas posibilidades puede dar lugar a ciertos problemas, En este apartado
analizan algunos de estos problemas y se dan las directrices para poderlos

7.1 Uso de variables globales. Efectos secundarios

   
  
   
 
   
  
   

se ha comentado que uno de los objetivos de la programación es la claridad
el código desarrollado, es decir, que sea fácil de entender. En el caso de los
bprogramas una cualidad deseable para ello es lo que se denomina Iranspaia referencial, que consiste en que el efecto de una llamada al subprograma
predecirse simplemente con la información contenida en el código de la
da. Dicho de otro modo, siempre que se invoque al subprograma con los
valores de los argumentos se debe obtener el mismo resultado,

 
 

transparencia referencial se garantiza si el código del subprograma utiliza
smente elementos mencionados en la lista de argumentos o definidos coelementos locales. La posibilidad de utilizar directamente por su nombre
bles globales, que no se mencionan en la lista de argumentos, permite
bir subprograma que carecen de transparencia referencial. Cuando un
bprograma modifica alguna varinblo externa, se dice que está produciendo
os secundarios o laterales (en inglés side efJects). El uso de subprogramas
efectos secundarios dobe hacerse con precaución.

 
 

 
  

transparencia referencial es descable tanto para las funciones como para.
procedimientos. Sin embargo, para las funciones es una cualidad casi imscindible. Resulta muy difícil de justificar y comprender que se produzcan

'os secundarios al utilizar una función dentro de una expresión. Idealmenademás todos los argumentos de las funciones deberían pasarse por valor,
do que el único resultado deseable de la función es devolver el valor de la
opia función. Una función que no produzca efectos laterales y todos sus
jentos se pasen por valor se dice que es una función pura.

 

    
   
 
    
  

acceso directo a variables globales puede suplantar el nso de argumentos,
manera que en un caso extremo podemos escribir subprogramas sin ningún
mento:

base, altura;

AreaRectangulo () £
return base * altura;

 
170 Fundamentos de programación

 

base = 3.
altura = 2.
print£( "%£

 

  

AreaRectangulo() );

En general es preferible mencionar expresamente en la lista de argumentos todos los elementos externos que intervienen en la operación de un subprograma.
El ejemplo anterior resulta mucho más natural si escribirmos:
float AreaRectangulo( float base, float altura ) [

return base * altura;
,

print£( "Xf”, AreaRectangulo( 3.0, 2.5) );

Aunque la transparencia referencial es claramente deseable, hay algunos casos
en que el uso directo de variables globales puede tener alguna ventaja. Esto ocurre, en general, si algunos de los argumentos son siempre los mismos
en prácticamente todas las llamadas al subprograma. Si esos argumentos se
almacenan en variables globales y se eliminan de la lista de argumentos, el código de las llamadas se simplifica, Como ejemplo plantearemos ir acumulando
una serie de valores. El código normal sería:

 

void Acumular( float 4 suma, float valor ) (
suma = suma + valor;

y
float total;
total = 0;

Acumular( total, 3.5
Acumular( total, 0.2
Acumular( total, 2.7
Acumular( total, 1.5

print£( "%d", total )

)
)
E
)

Usando una variable global las llamadas resultan algo más sencillas:
float total;

void Acumular( float valor ) 4
total = total + valor;
y

 

total = 0;
Acumular( 3.

sd
Acumular( 0.2 );
  
 
  
   
   
 
 
 
    
 
  
 
 
     
  
  
   
   
   
   
   
    
 
  

Funciones y Procedimientos 171

 

lar( 2.7 );
lar( 1.5);
int£( "Xd", total );

¡Conviene insistir en que el empleo de subprogramas con efectos laterales debe
"hacerse siempre con precaución, y limitarlo a casos especiales como el de este
“ejemplo, en el que el primer argumento del código normal, sin efcctos laterales,
¡sería siempre exactamente el mismo. Las siguientes secciones muestran con
.elaridad algunos peligros del uso directo de variables globales.

 

 

7.7.2 Redefinición de elementos

¡Dentro de cada bloque se pueden definir elementos locales dándoles el nombre
¡que se considere más adecuado en cada caso. Los nombres locales no afectan
sl código fuera del bloque, ya que no son visibles, Incluso es posible repetir el
:0 nombre para elementos diferentes definidos en distintos bloques. Por
¡plo, es habitual utilizar las variables de nombres 1, j, k, etc. para los
de las sentencias de iteración. Si estos nombres repetidos están en
tintos bloques no existe ningún problema pues en cada uno de ellos estas
iables tienen un carácter local que no afecta a las definiciones de los otros
ques.

 

embargo cuando en el interior de un bloque se define un elemento local
el mismo nombre que otro elemento global la situación es algo distinta.
acuerdo con las reglas de visibilidad, cualquier bloque tiene acceso a todos
elementos globales. Sin embargo, al dar un nombre ya utilizado como
a un nuevo elemento local del bloque se está redefiniendo dicho nombre,
automáticamente se pierde la posibilidad de acceso al elemento global del
nombre. Se dice que el nombre local oculta o “hace sombra” (en inglós
/01) al nombre global. Por ejemplo, en el siguiente programa:

 

Programa: Shadow */
Ejemplo de ocultación de nombres globales */
<stdio. ho

Global;
Exterior = 50;

InteriorQ £
const int Exterior = 30;

Global = Exterior*Exterior;

 
172 Fundamentos de programación

 

void SecundarioO) £
InteriorQ;
Exterior = Global/2;
3

void Primario( int £ Exterior, int £ Interior ) ([
Secundario();
Interior = Exterior F

 

int mainQ) £
int Interior = 40;

Primario( Interior, Interior );
printf( "xsdksdxsdin", Global, Exterior, Interior );
á

 

el cálculo de Global en el procedimiento Interior utiliza su constante local Exterior con valor igual a 30. El procedimiento Secundario utiliza el
procedimiento Interior y la variable global Exterior. Solamente dentro del
procedimiento Primario se tiene neceso a los argumentos Interior y Exterior del mismo, que están ocultando la variable global Exterior y el procedi
miento Interior. La variable Interior del programa principal inicializada a
40 oculta el procedimiento Interior y además se modifica en la llamada con
doble referencia al procedimiento Primario.

 

 

 

Aunque el programa es bastante extraño es completamente corre
ejercicio, resulta interesante hacer un análisis paso a paso de su ejj
la correspondiente comprobación, la ejecución del programa da el siguiente
resultado:

  

 

ES - 1

Es ovidento que el empleo de elementos diferentes con el mismo nombre aumenta la complejidad del programa y se dificulta mucho su comprensión. Por.
otro lado, se abre una vía de errores no siempre detectables en compilación.
Aunque se pretenda utilizar un símbolo como local, si se olvida que es un.
nombre redefinido se asumirá incorrectamente el significado dado como símbolo externo. Por tanto, salvo que sea imprescindiblo, no se debe utilizar la
redefinición de elementos.
    
  
  
   
   
   
  
  
 
  
    
  
 
     
   
    
  
  

Funcione

 

s y Procedimientos

 

 

 

7.7.3 Doble referencia

 
 

Se produce doble referencia (en inglés aliasing) cuando una misma variable se
referencia con dos nombres distintos, cosa que puede ocurrir en la invocación
dde subprogramas con argumentos pasados por referencia. Fundamentalmente
sesto puede ocurrir en dos situaciones muy concretas:

1. Cuando un subprograma utiliza una variable externa que también so le
pasa como argumonto.

2. Cuando para utilizar un subprograma se pasa la misma variable en dos

o más argumentos.

 
 
 

Habitualmente, un subprograma se escribe pensando que todos sus argumentos
¡son distintos y que nunca coincidirán con ninguna variable externa ya utilizada
dentro de él. La doble referencia produce resultados incomprensibles a primera
ssista. Consideremos, por ejemplo, el siguiente fragmento de programa:

global

Cuadrado( int 4 dato ) £
global = 5;
dato = dato * dato;

lobal.
'ado( global );

Después de la ejecución del procedimiento Cuadrado( global ) la variable
“global tiene un valor igual a 25. Esto es debido a que el procedimiento
Euadrado utiliza directamente como dato la variable global pasada por refo
ia. En el momento del cálculo del producto, el valor de dicha variable es
'5 y por tanto el producto por sí misma es 25.

   

¡Ena situación similar se puede producir con el siguiente procedimiento:
CuadradoCubo( int £ x, int 8 x2, int 4x3) (
xa

xx

'sespués de la ejecución de este fragmento, los valores de las variables son A
igual a 16 y Bigual a 4096,

 
 

174 Fundamentos de programación

Como conclusión se puede decir que no se debe utilizar la doble referencia.
salvo que el subprograma se diseñe pensando en esa posibilidad. Esto último
deberá quedar claro en los comentarios del subprograma,

7.8 Ejemplos de programas

Para finalizar este tema se muestran tres programas completos y sus correspondientes resultados. Estos programas utilizan algunas de las funciones y
procedimientos que han sido desarrollados a lo largo de todo este tema,

 

7.8.1 Ejemplo: Raíces de una ecuación de segundo grado

Con este programa se trata de calcular las raíces de una ecuación de segundo
grado:

ad+br+o=0
las raíces pueden ser reales o imaginarias. Los coeficientes a, b y c serán reales
y se leerán del teclado. El programa tendrá en cuenta los siguientes casos:
+ Sia, b y e son iguales a cero: Se considerará una ecuación no válida.
+ Sia y b son iguales a cero: La solución es imposible.
+ Si a es igual a cero: Una única raíz.
+ Sia, b y e son distintos de cero: Dos raíces reales o imaginarias.

En este último caso, el cálculo de las raíces se realiza mediante la fórmula:
—b+vb'4ac
2a

Para la lectura de los cocficientes conviene utilizar un procedimiento, y así se
pueden leer los 3 coeficientes de igual manera. En el siguiente programa está
recogido el listado completo.

raices

 

 

PA AR

Programa: Raices

 

Este prograna calcula las raíces de una
ecuación de segundo grado: ax* + bx +c

AAA ARA RARARERAAAAARAA/

Hinclude <stdio.h>

Hinclude <math.h>

* Descripción:
 
  
 
 
   
  
  
     
  

Funciones y Procedimientos 175

 

'/* Función para calcular el discriminante */

¡float Discriminante( float a, float b, float c ) (
return b*b - 4.0*a*c;

e

'* Procedimiento de lectura de un coeficiente */
LeerValor( int grado, float € valor ) (
print£( "¿Coeficiente de grado X1d? ", grado );
scanf( "%£",4valor );

 

1

Programa principal */

main() (

float valora, valorB, valorC; /* Coeficientes de la ecuación */
float parteUno, parteDos; /* Variables intermedias de cálculo */
float valorD; /* Discriminante de la ecuación */

LeerValor( 2, valora
LeerValor( 1, valorB
LeerValor( 0, valorC
A£ (valora == 0.0) £
if (valorB 0.0) £
if (valorC 0.0) £
print£( "Ecuación no válidaln" );
y else £
print£( "Solución imposiblein” );
J
J else €
print£( "Raiz única = X10.2fin", -valorC/valorB );
J
) else £
parteUno = - valorB/(2.0*valorA);
valorD = Discriminante( valora, valorB, valorC );
if (valorD >= 0.0) 4
parteDos = sqrt(valorD)/(2.0*valorA);
print£( "Raíces reales ¿Xa" );

 

 

 

 

 
 

print£( "x10.2f y An", parteUno+parteDos );
print£( "%10.2f An”, parteUno-parteDos );
) else (
parteDos = sqrt(-valorD)/(2.0*valora);
print£( "Raíces complejas :1n" );
print£( "Parte real = %10.2£ yin", parteUno );

 

print£( "Parte imaginaria = %10.2f 1", parteDos );
y
J

 
176 Fundamentos de programación

El resultado obtenido por el programa para la ecuación a? + 27 +2=0 es el
signiente:

 

¿Coeficiente de grado 2? 1.0
¿Coeficiente de grado 1? 2.0
¿Coeficiente de grado 0? 2.0
Raíces complejas :

Parte real 1.00 y
Parte imaginaria = 1.00

7.8.2 Ejemplo: Ordenar tres valores

Este programa es una versión mejorada del mostrado en el tema 5. En este caso
se ntiliza el procedimiento para la ordenación de dos datos que fue desarrollado
en el apartado 7.4 de este mismo tema, Además, so utiliza un procedimiento
para leer uno a uno los tros datos a ordenar. El programa permanece en un
bucle hasta que se indica que no se necesita ordenar más datos.

A continuación se recoge el listado completo.

 

 

A
* Programa: Ordenar3b
* Descripció!
* Este programa ordena 3 valores

tinclude <stdio.h>

*include <nath.h>

 

 

/** Procedimiento para ordenar dos datos */
void OrdenarDos( float £ y, float £:z ) 1
float aux;

if(y>D4
aux = y;

 

/** Procedimiento para leer un dato */
void LeerDato( int indice, float £ dato ) €
print£( "¿Dato XLd? ", indice );
scan£( "X£",8dato );
 
   
   
  
  
  
  
 
   
 
  
 
   

mes y Procedimientos

Programa principal */
main() (

float valorUno, valorDos, valorTres; — /* valores a ordenar */
char tecla; /* tecla de opcion */

tecla = 'S';

mbile (tecla l= 'N') (

/*— Leer los datos --*/ 4
LeerDato( 1, valorUno );
LeerDato( 2, valorDos )
LeerDato( 3, valorTres );

J

/*—- Ordenar los datos =-*/ (

OrdenarDos( valorUno, valorDos );
OrdenarDos( valorUno, valorTres );
OrdenarDos( valorDos, valorTres ):;

)

/*— Escribir resultados --*/ 4
print£C "WDatos Ordenados = Y" );
printf( "x7.2f %7.2f %7.2fin", valorUno, valorDos, valorTres );

,

/*— Comprobar si se continúa --*/ 4
tecla =' ';
print£( "W¿Desea continuar(S/N)? " );
while ((tecl: 'S') 84% (tecla NO) 4

scanf( "ke", tecla );

 

   

 

 

Los resultados obtenidos en dos ordenaciones consecutivas son los siguientes:

 

¿Dato 1? 12
¡¿Dato 2? 3
¿Dato 3? 89

¡Datos Ordenados =
3.00 12.00 89.00

'¿Desea continuar(S/N)? $
¿Dato 1? 9
¿Dato 2? 34
¿Dato 3? 2

 
    
   

178 Fundamentos de programación

 

Datos Ordenados =
2.00 9.00 34.00

¿Desea continuar(S/N)? N

7.8.3. Ejemplo: Perímetro de un triángulo

Este programa ha sido desarrollado casi completamente a lo largo de esto toma. En este apartado se trata solamente de mostrar su estructura global, en
la que se aprecia el uso de variables globales entre los distintos procedimientos y funciones y el programa principal. A continuación se recoge el
completo.

 

  

 

 

PA A
* Programa: Perimetro

* Descripción:

* Programa para calcular el perímetro de un

triángulo dado por sus tres vértices
AAA /

*include <stdio.h>
Kinclude <math.h>

 

02
Variables globales

e,

 

   

Vi %
float XA, yA, xB, yB, xC, yC; — /* Coordenadas de los puntos */
float perinetro; /* Valor del perinetro */

pu *l
Procedimiento para leer las coordenadas X e Y de un punto.
Para facilitar la identificación del punto, se tiene que
pasar la letra que lo identifica como argumento

 

 

Vaz as

 

- =+/
void LeerCoordenadas( char Punto, float £ x, float 4 y ) (
printf( "Punto %cin"”,Punto );

printf( "¿Coordenada X ? " );

scanf( "%£", 8x );

printf( "¿Coordenada Y ? " );

scant( "%f", dy
print£( "a"

  

   
  
  
   
  
  
  

Funciones y Procedimientos 179

 

Procedimiento para leer las coordenadas de los 3 vértices

 

ad

 

cd
Leervertices() (
LeerCoordenadas( 'A', xA, yA );
LeerCoordenadas( 'B", xB, yB )
LeerCoordenadas( 'C', xC, yC );

 
 
  
  

Función para calcular la distancia que hay
entre dos puntos (x1,y1) y (x2,p2)

pr mmm /
Distancia( float xl, float yl, float x2, float y2) £
float deltaX, deltaY;

    
    
  
  
 
      
   
 
 
  
     

deltaX = x2 - x1;
deltaY = y2 - yl;
return sqrt( deltaX*deltaX + deltaY*deltaY

 

»

 

yo. pais
Procedimiento para calcular el perímetro de un triágulo
NOTA: Se utilizan variables globales dado el excesivo
número de argumentos necesarios: Total 7 argumentos:
3 puntos x 2 coordenada = 6 argumentos por valor
Resultado en perimetro = 1 argumento por referencia
yo A
void CalcularPerimetro() (
float ladoAR, ladoAC, ladoBC;

 

 

 

 

 

 

ladoAB = Distancia( XA, yA, xB, yB );
ladoAC = Distancia( XA, yA, XC, yC )
ladoBC = Distancia( xB, yB, xC, yC )

  
 

perimetro = ladoaB + ladoAC + 1adoBC;
y

pra
Procedimiento para imprimir la variable global perímetro

y

¡void ImprimirPerimetro() £

| print£C "EL Perínetro es igual a X5.2£In", perinetro

p

  

|
|
|

 

 

Éd

 

 

 
 

 

 

180 Fundamentos de programación

 

mm

Programa principal

 

/

int mainQ £
Leervertices();
CalcularPerinetro();
ImprimirPerinetro();

J

 

Un ejemplo del resultado de su ejecución es el siguiente:
Punto A y
¿Coordenada X ? 3.0

¿Coordenada Y ? 0.0

Punto B
¿Coordenada X ? 0.0
¿Coordenada Y ? 0.0

Punto €
¿Coordenada X ? 0.0
¿Coordenada Y ? 4.0

El Perímetro es igual a 12.00
  
  
    
   
 
  
   
   
   
   

ema 8

etodología de Desarrollo de
ogramas (III)

tema completa el anterior, ampliando la metodología de desarrollo por
nientos sucesivos con la posibilidad de usar subprogramas como técnica
abstracción.

 

 

“A nivel metodológico, las funciones y procedimientos introducen la posibilidad
'de descomposición de un problema en subproblemas realmente independientes.
Por el momento se mantiene la visión del programa como una sola unidad de
compilación (un solo módulo). Más adelante, en el tema 15, se explicará
la manera de descomponer un programa en varios módulos compilables por
separado.

 

8.1 Operaciones abstractas

Los subprogramas constituyen un primer paso hacia la metodología de proaramación basada en abstracciones. Los subprogramas permiten definir opezaciones abstractas. El siguiente paso será la definición de tipos abstractos de
datos, que se introducirán brevemente más adelanto, en cl tema 14.

Una abstracción es nna visión simplificada de una cierta entidad, de la que
sólo consideramos sus elementos esenciales, prescidiendo en lo posible de los
detalles. Las entidades que podemos abstraer para materializarlas como subprogramas son, en general, operaciones. Con la palabra opernción englobamos
tanto la idea de acción como la de función.

 
 

182 Fundamentos de programación

8.1.1 Especificación y realización

Al plantear operaciones abstractas habremos de definir dos posibles visiones.
La visión abstracta o simplificada, y la visión detallada, completa. La visión
abstracta es la que permite usar dicha operación sin más que conocer qué
hace dicha operación. La visión detallada es la que define cómo se hace dicha
operación, y permite que el procesador la ejecute. La primera visión representa
el punto de vista de quienes han do utilizar la operación. Se dice que esa visión
abstracta es la especificación o interfaz de la operación. La visión detallada
representa el punto de vista de quien ha de ejecutar dicha acción, y se dice
que expresa su realización o implementación. Resumiendo:

   

Especificación: Qué hace la operación (punto de vista de quien la invoca).
Realización: Cómo se hace la operación (punto de vista de quien la ejecuta).

En su forma más sencilla la especificación o interfaz consiste simplemente en
indicar cuál es el nombre de la operación y cuáles son sus argumentos. En C4
la especificación puede ser simplemente una cabecera de subprograma.

Esa forma simplificada de especificación indica solamente cuál ha de ser la
sintaris o forma de uso de la operación. La especificación completa debe
establecer también cuál es la semántica o significado de la operación. Para
ello podemos añadir un comentario en que se indique qué relación hay entre
los argumentos y el resultado de la operación.

La realización, por su parte, debe suministrar toda la información necesari
para poder ejecutar la operación. En Ct la realización o implementación será
la definición completa del subprograma, en forma de bloque de código.

 

Tomemos como ejemplo una función que calcule el máximo de dos números:

 

int Maximo2( int a, int b)( Especificación: Sintaxis

 

 

!

- 
/* Maximo2(a, b) es el Máximo de a y b */ Especificación: Semántica |
if (a>b) 1 '
return a; '

) else [ Realización '
return b; !

y 1

y

 

Conociendo sólo la especificación podemos invocar la función, aunque no sepamos el detalle de cómo se realiza. Por ejemplo, podemos escribir:

|alturaTotal = Maximo2( altural, altura2

 
Metodología de Desarrollo de Programas (III) 183

Si ahora sustituimos la realización de la función Maximo2 por otra diferente,
tal como:

Maximo2( int a, int b) 1

la especificación de la función sigue siendo la misma. La sentencia anterior
¿que usaba la función sigue siendo correcta:

JalturaTotal = Maximo2( altural, altura2 );

Con ello se pone de manifiesto la idea de que la especificación es una visión
abstracta de qué hace la función, con independencia de los detalles de cómo lo
hace. Precisamente las reglas de visibilidad de C+ permiten usar subprogramas
como operaciones abstractas, con ocultación de los detalles de realización.

Es importante comprender que si describimos la semántica en lenguaje humano, impreciso, tendremos sólo una especificación informal. Si se necesita
mayor rigor se puede recurrir a expresiones lógico-matemáticas para especificar formalmente las condiciones que relacionan los datos de entrada y los
resultados. La especificación formal evita ambigiiedades, pero también suele
resultar más costosa de escribir y más difícil de leer. Por ello conviene que vaya
acompañada siempre de una especificación en lenguaje humano. En el apéndice C se describe la notación utilizada en este libro para las especificaciones
formales.
La especificación formal del máximo de dos valores podría ser:
ATA)

En esta especificación se ha usado una expresión condicional. El primer ejemplo de código de esta sección usa como realización una transcripción directa de
esta especificación formal. Podemos repetir ahora dicho ejemplo anotándolo
con la PRECONDICIÓN y POSCONDICIÓN correspondientes a su especificación formal ;
int Maximo2( int a, int b)(

«PRE: »

«POST: Mazimo2(a, b) es el Máximo de a y b»
«POST: Marimo2a,b) =(a>0= alb) »

 
   
  
  
  
   
     
 
    
     

184 Fundamentos de programación

 

if (a> 1) t
return a;
) else (
return b;
,
Y

La PRECONDICIÓN está vacía (se asume que siempre es cierta) porque no
hay restricciones en los valores aceptables de los argumentos. El valor del
máximo está definido para toda pareja de valores enteros. La POSTCONDECIÓN se ha escrito dos veces, primero en lenguaje natural, informal, y luego
de manera formal.

 

8.1.2 Funciones. Argumentos

En programación la idea de función surge al aplicar el concepto de abstracción
las expresiones aritmóticas. Una expresión representa un nuevo valor obtenido
por cálculo a partir de ciertos valores ya conocidos que se usan como operandos.

 

Por ejemplo, el cubo de un número Z se puede calcular multiplicando el número.
por sí mismo, de la forma Z x Z x Z. De esta manera se puede obtener, por
ejemplo, el volumen de un cubo escribiend

|volunen = lado * lado * lado;

 

La expresión lado * lado * lado suministra el valor del cubo del lado al
evaluarla. Esta expresión puede verse de manera abstracta como una función,
siendo lado el dato de partida y el cubo el resultado obtenido. La abstracción:
de dicha expresión tendrá asociado un nombre que podamos identificar con el
significado del cálculo, y que, obviamente, podría ser Cubo. Esto nos conduciría.
a la especificación:

 

 

float Cubo( float z ) Especificación: Sintaxis |

 

/* Cubo(z) = 2% */ Especificación: Semántica |

 

O bien, de manera formal:

float Cubo( float z )
«PRE: »
«POST: Cubo(z)

 

Con esta especificación, el cálculo del volumen se reescribiría como:
 
  
  
   
    
   
   
  

"Metodología de Desarrollo de Programas (LI) 185

jumen = Cubo( lado )
Esta visión abstracta prescinde de los detalles de cómo se calcula el resultado,

son tal de que sea correcto, es decir, que se obtenga el cubo del argumento.
'La realización puede scr tan sencilla como:

9 tan artificiosa como:

float c = 1.0;

for (int k = 1; k <= 3; ke) £
c=crz

 

Los operandos que intervienen en el cálculo del valor de la función y que
pueden cambiar de una vez a otra se especifican como argumentos de dicha
función. La función aparece así como una expresión parametrizada.

 
 
   
    
     
  
 

En el tema anterior se han mencionado ya las dos formas disponibles en C£
¡para el paso de los argumentos al subprograma que realiza el cálculo de la
función. Si buscamos que el concepto de función en programación se apro“xime al concepto matemático de función, el paso de argumentos debería ser
¡siempre por valor. El concepto matemático de función es una aplicación entre
'sonjuntos, cuyo cómputo se limita a suministrar un resultado, sin modificar el
salor de los argumento

“Aunque algunas veces, por razones de eficiencia, pueda ser aconsejable pasar
por referencia argumentos de funciones, seguirá siendo deseable, para mantener la máxima claridad en el programa, que la llamada a la función no
modifique el valor de los argumentos.

 

Desde cl punto de vista de claridad del programa, y con independencia de cuál
sea el mecanismo de paso de agumentos empleado, la cualidad más descable
al utilizar funciones es conseguir su transparencia referencial. Tal como se
mencionó anteriormente, la transparencia referencial significa que la función
devolverá siempre el mismo resultado cada vez que se la invoque con los mismos
“argumentos.

  
   

La transparencia referencial se garantiza si la realización de la función no
'ntiliza datos exteriores a ella. Es decir, si no emplea:

 
 

186 Fundamentos de programación

+ Variables externas al subprograma, a las que se accede directamente por
su nombre, de acuerdo con las reglas de visibilidad de bloques.

+ Datos procedentes del exterior, obtenidos con sentencias de lectura,

+ Llamadas a otras funciones o procedimientos que no posean transparencia referencial. Las sentencias de lectura son en realidad un caso
particular de éste,

Estas restricciones se cumplen en el ejemplo anterior del cálenlo del cubo de un
número. Las funciones que cumplen la cualidad de transparencia referencial y
que no producen efectos laterales o secundarios se denominan funciones puras.

8.1.3 Acciones abstractas. Procedimientos

De manera similar a como las funciones pueden ser consideradas como expresiones abstractas, parametrizadas, los procedimientos pueden ser considerados
como acciones abstractas, igualmente parametrizadas. Un procedimiento representa una acción, que se define por separado, y que se invoca por su nombre.

Como acciones abstractas, podemos tener dos visiones de un procedimiento.
La primera es la visión abstracta o especificación, formada por la cabecera del
procedimiento y una descripción de qué hace dicho procedimiento, y la segunda
es la realización, en que se detalla, codificada en el lenguaje de programación
elegido, cómo se hace la acción definida como procedimiento.

  

Como ejemplo, definiremos la acción abstracta de intercambiar los valores de
dos variables. La especificación podría ser:

void Intercambiar( int £ a, int £b) Especificación: Sintaxis

 

 

/* (a',b') = (b,a) */ Especificación: Semántica

Dei E,

 

 

Esta especificación es realmente formal, ya que oq
void Intercambiar( int € a, int£b)

«PRE: »
«POST: (a!, Y) =(b,a) »

Para escribir esta especificación hemos necesitado distinguir los valores de los
argumentos (pasados por referencia) en dos momentos diferentes: al comienzo y al final de la ejecución del procedimiento. Los nombres con prima (')
representan los valores finales, La expresión:

(a, Y) =(b,a)
    

ifica que la pareja de valores de los argumentos a y b, por este orden, al
inar la ejecución del subprograma, coincide con la pareja de valores de b
a, por este orden, al comienzo de la ejecución del subprograma.

   
  
 
 
 

:ndo la especificación podemos ya escribir algún fragmento de programa.
utilice este procedimiento, Si queremos ordenar dos valores de menor a
x, podríamos esci

_>ot
“Intercambiar( p, q );

 
 

  
 
 
  
 
 
 
  
   
 
 
 
  
  
   
  
   
   
   
 
 
  

 

escribir este fragmento de programa no hemos necesitado saber cuál es
realización del procedimiento de intercambiar. Por supuesto, para tener un
“ama completo, que se pueda ejecutar, necesitamos escribir una realización
ida. Por ejemplo:

Intercambiar( int € a, int 8 b)(
ánt aux;

 

aux = aj
a=b;
b= aux;

definir procedimientos no podemos limitarnos a usar sólo el paso de arguos por valor. En programación imperativa las acciones consisten habi'tmalmente en modificar los valores de determinadas variables. Por esta razón
considera normal que los procedimientos usen argumentos pasados por reIcia.

todas maneras conviene seguir una cierta disciplina para que los programas
lten claros y fáciles de entender. Para ello podemos recomendar que los
limientos se escriban siempre como procedimientos puros, entendiendo
ello que no produzcan efectos laterales o secundarios. Con esto se consigue
la acción que realiza un procedimiento se deduzca en forma inmediata de
“la invocación de dicha acción. Se garantiza que un procedimiento cumple con
jesta cualidad si su realización no utliza:

 
 
 
 
 
 
 

+ Variables externas al subprograma, a las que se accede directamente por
su nombre, de acuerdo con las reglas de visibilidad de bloques.

« Llamadas a otros subprogramas que no sean procedimientos o funciones
puras.

 
 

¡Comparando esta lista de restricciones con la que se estableció para las funcioes puras, se observa que hemos suprimido la exigencia de que el procedimiento

 
 

188 Fundamentos de programación

 

no lea datos del exterior. En general esta lectura puede considerarse como una.
asignación de valor, que puede quedar suficientemente bien reflejada en la lla=
mada, si los dispositivos o ficheros de entrada se mencionan explícitamente:
como argumentos.

Do todas maneras es difícil establecer una disciplina precisa con recomendaciones sobre la definición y uso de procedimientos. Hay muchas situaciones en
las que la claridad del programa aumenta, de hecho, si se usan procedimientos en los que se accodo a variables globales. Así es posible evitar que haya
que escribir repetidamente argumentos iguales en cada una de las llamadas
al procedimiento. En particular, algunos de los procedimientos de lectura (o
de escritura) del módulo stdio omiten pasar como argumento el fichero de
datos de entrada (o de salida), y asumen por defecto una entrada y una salida
principales de datos, predefinidas (teclado y pantalla, respectivamente).

8.2 Desarrollo usando abstracciones

La metodología de programación estructurada puede ampliarse con la posibili
dad de definir operaciones abstractas mediante subprogramas. A continuación
se describen dos estrategias de desarrollo diferentes, según qué se escriba prixmero, si la definición de los subprogramas, o el programa principal que los
utiliza.

8.2.1 Desarrollo descendente

La estrategia de desarrollo descendente (en inglés, Top-Down), es simplemente
el desarrollo por refinamientos sucesivos, teniendo en cuenta además la posibilidad de definir operaciones abstractas. En cada otapa de refinamiento de
una operación habrá que optar por una de las alternativas siguientes:

+ Considerar la operación como operación terminal, y codificarla mediante
sentencias del lenguaje de programación.

+ Considerar la operación como operación compleja, y descomponerla en.
otras más sencillas.

+ Considerar la operación como operación abstracta, y especificarla, escribiendo más adelante el subprograma que la realiza.

 

Para decidir si una operación debe refinarse como operación abstracta habrá
que analizar las ventajas que se obtengan, frente a la codificación directa o
descomposición de la operación en forma de un esquema desarrollado en ese
punto del programa.
Metodología de Desarrollo de Programas (111) 189

 

En genoral resultará ventajoso refinar una operación como operación abstraca, que se define en forma separada, si se consigue alguna de las ventajas
«siguientes.
+ Evitar mezclar en un determinado fragmento de programa operaciones
con un nivel de detalle muy diferente.
+ Evitar escribir repetidamente fragmentos de código que realicen operaciones análogas.

 

 

El beneficio obtenido es, como cabría esperar, una mejora en la claridad del
programa. Hay que decir que esto implica un costo ligeramente mayor en
términos de eficiencia, ya quo siempre se ejecuta más rápidamente una opera¡ se escriben directamente las sentencias que la realizan, que si se invoca
“an subprograma. que contiene dichas sentencias. La llamada al subprograma,
epresenta una acción adicional que consume un cierto tiempo de ejecución.

 

    

 

Por el contrario, hay nn anmento de eficiencia en ocupación de memoria si
se codifica como subprograma una operación que se invoca varias veces en
distintos puntos del programa. En este caso el código de la operación aparece
sólo una vez, mientras que si se escribiesen cada vez las sentencias equivalentes
el código aparecería repotido varias veces.

8.2.2 Ejemplo: Imprimir la figura de un árbol de navidad

Retomamos aquí el ejemplo desarrollado en el tema 4. El objetivo es imprimir
la silueta del árbol, tal como aparece a continuación

 

Los primeros pasos de refinamiento eran:

 
190 Fundamentos de programación

 

Imprimir árbol —>
Imprimir copa
Imprimir tronco
Imprimir base

Imprimir copa —>
Imprimir primeras ramas
Imprimir segundas ramas
Imprimir terceras ramas

Podemos observar la existencia de operaciones análogas, correspondientes a la
impresión de los distintos fragmentos. Es relativamente sencillo darse cuenta
de que cada una de las “ramas” de la copa del árbol es una figura trapezoidal.
Por ejemplo, las “segundas ramas” aparecen dibujadas así:

 

Esta figura geométrica es un trapecio simétrico. Lo mismo puede decirse
de las otras “ramas”. Puesto que cada vez se imprime una figura diferente,
podremos definir esta acción como parametrizada, dando como argumentos la
información necesaria para distinguir cada “rama” particular. Por ejemplo,
podemos decidir que el único parámetro necesario es la anchura de la base
superior, ya que todas las “ramas” tienen 3 líneas de altura, y cada una de
estas líneas añade siempre un asterisco más a cada lado.

La especificación la impresión de una “rama” como procedimiento se podrá

redactar de la forma:

y
Especificación Semántica: Procedimiento para
imprimir 3 líneas seguidas con:

ancho,
ancho + 2
y ancho + 4 asteriscos

 

 

 

 

ammm
¡void ImprimirRama( int ancho ) /* Especificación Sintáctica */

En cuanto a la impresión del tronco y la base, también cabe la posibilidad
de considerarlas como operaciones análogas, en ambos casos un rectángulo
de asteriscos. Los parámetros serían en este caso la anchura y altura del
rectángulo. La especificación sería:

 
191

 

  
 
   
  
  
 
 
   
 
   
   
   
 
   
  
    
   
     
  

Especificación Semántica: Procedimiento para
imprimir un rectángulo de ancho x alto asteriscos

 

ImprimirRectangulo( int ancho, int alto )
Especificación Sintáctica */

esto se podría escribir ya el programa principal, en el que podemos agrupar
impresión de las ramas en un esquema de buele.

Imprimir copa --*/

y ke 35 ke) €

ImprimirRama( rama );
rama = rama + 2;

 

Imprimir tronco --*/
cimirRectangulo( 1, 3 );

Imprimir base --*/
imirRectangulo( 5, 1);

ca falta escribir la realización de las operaciones abstractas especificadas
'eriormento. Forzando quizá un poco la idea de buscar operaciones análo,, se puedo establecer una relación entre la impresión de las “ramas” y las
tronco o la base. En efecto, un rectángulo puede considerarse como un
particular de un trapecio. Tanto la operación de ImprimirRama como la
ImprimirRectangulo se pueden apoyar en una operación común de TmimirTrapecio especificada de la forma siguiente:

 

  

Procedimiento para imprimir un trapecio de asteriscos
con la base superior "ancho", altura "alto" y "avance"
asteriscos más a cada lado en cada nueva línea

 

 

 

Y

 

ImprimirTrapecio( int ancho, int alto, int avance )

operación la desarrollaremos mediantes refinamientos:
Imprimir trapecio —>

for (int k = 1;k <= alto; kt) £
Imprimir una línea del trapecio

$

 
 

192 Fundamentos de programación

 

Imprimir una línea del trapecio —>
Imprimir los blancos iniciales
Imprimir los asteriscos

Para mantener la información del número de asteriscos en cada línea usaremos
una variable anchura, que tomará inicialmente el ancho de la línea superior,
y se irá incrementando después de imprimir cada línea. Los blancos iniciales
se calculan cada vez, fijando como parámetro constante la posición del centro
de la línea.

 

Al desarrollar este procedimiento se observa una analogía entre la operación de
escribir los espacios en blanco y la de escribir los asteriscos. Ambas operaciones
so rofinan como la operación abstracta de imprimir un mismo carácter un cierto
número de veces. Para ollo se especifica el pros
pa

Procedimiento para imprimir N veces seguidas el carácter

 

 

 

 

  

void ImprimirN( char c, int N )

El programa completo, incluyendo todos los procedimientos, es el siguiente:

 

 

 

JA

 

* Programa: ArbolDeNavidad

 

* Descripció
* Este programa imprime la silueta de un árbol
* — de Navidad, hecha con asteriscos.

*include <stdio.h>

  

   
 

Prem

Constante global

24
 
   
 
    
         
    
       
     
   
     
 
        
   
  

odología de Desarrollo de Programas (III) 193

 

Procedimiento para imprimir un trapecio de asteriscos
con la base superior "ancho", altura "alto" y "avance"
asteriscos más a cada lado en cada nueva línea

 

 

EE Y
ImprimirTrapecio( int ancho, int alto, int avance ) (

int anchura; /* número de asteriscos */

  

anchura = ancho;

for (int k = 1; k <= alto; ke*) (
ImprimirN( *' *, centro - anchura/2 );
ImprimirN( ***, anchura );
print£( "Ya" );
anchura = anchura + 2*avance;

,

Procedimiento para imprimir 3 líneas seguidas
con: ancho

ancho+2

y anchor4 — asteriscos

 

InprimirRama( int ancho ) £
ImprimirTrapecio( ancho, 3, 1);

    
  

Procedimiento para imprimir un rectángulo
de ancho x alto asteriscos

         
    
  
     
   

 

<= /
ImprimirRectangulo( int ancho, int alto ) £
ImprimirTrapecio( ancho, alto, 0 );

 

  

 

 

Programa principal
mainO £
int rana; /* Ancho de rama */

 

    
         
   
        

ya
rama
for (int k = 1; k <= 3; kes) (
ImprimirRama( rama );
rama = rama + 2;

 

Imprimir copa --*/

 
194 Fundamentos de program

 

)

/%-- Imprimir tronco --*/
ImprimirRectangulo( 1, 3);

/*-— Imprimir base --*/
Imprimirkectangulo( 5, 1);
+

 

   
 
 
  
 
 
 
 
 
  
   
  
   
 
  
 

Comparando esta redacción del programa con la que se había desarrollado en
el toma 4, so observa que el programa resulta ahora más largo, aunque cada!
parte separada del programa es más sencilla. En la versión anterior la parte
ejecutable del programa principal era más compleja que ahora.

Con esta nueva redacción se obtiene una ventaja adicional, que se ha producido como efecto de la labor de abstracción realizada para especificar los,
subprogramas. Operaciones que antes se consideraban por separado, ahora
se han refundido en una sola operación abstracta y parametrizada. La parametrización tiene la ventaja de que se facilita la modificación posterior del
programa.

En efecto, si quisiéramos cambiar el programa para imprimir una figura de
árbol algo diferente, en la versión inicial habría sido necesario cambiar casí
toda la parte ejecutable del programa, sentencia por sentencia. Alora la ma;
parte del programa está constituida por las definiciones de las operaciones
abstractas, que se pueden mantener sin cambios, y sólo hay que rectil
parte de código del programa principal, que es relativamente corta.

 

 

 

Por ejemplo, podemos modificar el código del programa principal para imprimir un árbol más grande, tal como se indica en el programa ArbolGrande,,
donde los cambios se han destacado con un recuadro [Xx].

 

 

 

 

Con la versión inicial del programa habríamos tenido que escribir de nuevo
menos unas 13 líneas del programa. Ahora no ha sido necesaria ninguna línea.
mueva y tan sólo hemos tenido que retocar 3, y sólo para modificar los val
de los tamaños.

 

AAA

* Programa: ArbolGrande de Navidad

PA A
/* Usa las mismas definiciones de procedimientos
que el programa anterior */

 
logía de Desarrollo de Programas (111)

    
  
   
   
   
   

rama; /* Ancho de rana */

Imprimir copa más alta-—*/
=-1

(int k = 1; k
ImprimirRama(rama);
ana = rama + 2;

 

 

ke) 4

 

/*— Imprimir tronco más grueso y alto --*/
“IsprimirRectangulo(3), [5);

 

 

/*— Imprimir base más ancha y alta --*/
ImprimirRectangulo(9], [25

 

 

 

 

 

 

 

  

resultado de la ejecución del programa ArbolGrande es el siguiente:

 

 
 

 

196 Fundamentos de programación

 

8.2.3. Ejemplo: Imprimir una tabla de números primos

En el ejemplo anterior se buscó de manera insistente la analogía entre operaciones, y su especificación como operaciones parametrizadas. En este ejemplo
se atenderá fundamentalmente a la limitación en el nivel de detalle,

El objetivo de este programa de ejemplo es imprimir una tabla con los números
primos hasta un límite dado, formando varias columnas do números a lo ancho
del listado. Si decidimos imprimir los números primos hasta 100, a cuatro
columnas de 15 caracteres de ancho cada una, el resultado deberá ser el que
aparece a continuación

 

 

1 2 3 5

7 n 13 Y
19 23 29 31
37 41 43 47
53 59 61 67
7 73 79 83
89 97

Los primeros pasos de refinamiento serán:
Imprimir la tabla de números primos de 1a N—>

for (int k = 1; k <= N; kee) (
Imprimir ks si es primo

 

 

Imprimir k, si es primo —>

Af ( kesprimo ) 1
Imprimir E, tabulando

 

 

Ahora decidimos limitar el nivel do detalle, y definir como operaciones abstractas las que faltan por refinar. Sus especificaciones serían:
po
Función para ver si un valor
bool EsPrimo( int k )
«PRE: k>0»
«POST: k no tiene divisores distintos de él mismo y la unidad »
«POST: EsPrimo(k) = vd € (2.k—1) e modulo(k,d) 40 »

 

   

es un núnero primo

 

 

*/
lología de Desarrollo de Programas (III)

  
  
 
  
  
 
   
  
  
  
  
  
   
 
   
 
 
 
   
 
    

  

Procedimiento para imprimir tabulando
2 4 columnas de 15 caracteres

  

ImprimirTabulando( int k )

'A: El tipo predefinido bool, que se introducirá en el próximo tema, sólo puede
dos valores posibles: true y false, que son los denominados hasta ahora
YO como posible resultado de una condic

  

función EsPrimo so especifica formalmente (y también informalmente, para
tar el comprender la expresión formal). Se omite la especificación formal
procedimiento ImprimirTabulando, ya que es más difícil de redactar. De
ifícil formalizar las operaciones de lectura y escritura, en general,

í :ar formalmente la representación externa de los datos

 

«continuación podemos desarrollar la realización de estos subprogramas, La.
n que determina si un número es primo puede realizarse sencillamente
lando su especificación formal, es decir, probando todos los divisores
bles. Esta realización es poco eficiente, pero muy sencilla de programar.
única optimización es que en cuanto se encuentra un divisor d ya no
ban otros, puesto que eso garantiza que el predicado Yd € ... no puedo
¡plirse.

 
 

Función para ver si un valor "k" es un múnero primo

aldea

 

 

EsPrimo( int k ) 4

/* d es un posible divisor */

 

for (int d = 2; d <= k-1; de+) (
if ((k % d) == 0) 4
return false;
y
)
return true;

?

 
 
 
 

Para desarrollar la realización del procedimiento de imprimir tabulando hay
'que analizar algunas cuestiones previas. La especificación se ha establecido pasando como argumento solamento cl número que hay que imprimir, reflejando
de esta manera la forma natural en que so ha descrito esta acción abstracta.
Sin embargo esta información es insuficiente para realizar la acci

 

 
198 Fundamentos de programación

es necesario saber qué columna toca imprimir para poder decidir si hay que
saltar de línea o no.
En este ejemplo se decide usar una variable global columa para mantener.
dicha información. La variable contendrá en cada momento el número de la
columna en que aparecería escrito el próximo número si previamente no se
saltase de línea.
El refinamiento de esta operación será el siguiente:
Imprimir k , tabulando —>
Saltar de línea, si es necesario
Imprimir k y actualizar la columna

Saltar de línea, si es necesario ——>

 

if (columa > 4) 4
columa = 1;
print£( "wn"

y

 

El programa completo, incluyendo la definición de todos los subprogramas
necesarios, es el siguiente:

 

ARA RRA
* Programa: Primos

* Descripción:

* Este programa imprime una tabla de números

* primos, tabulando a cuatro columnas

include <stdio.h>

 

 

pp
Constante global

 

 

   

Y
const int N = 100; '* rango de números */

 

pa

Variable global

 

 

int columa; /* columa a imprimir */
lología de Desarrollo de Programas (HI)

   

Función para ver si un valor
EsPrimo( int k ) (
for (int d d <= kl; des) €
if ((k % a) == 0) €
return false;

" es un minero primo

   
  
   
  

  

Procedimiento para imprimir tabulando
2 4 columas de 15 caracteres
ImprimirTabulando( int k ) £
if (columa > 4) (

columna = 1;
printf( "a" );

    

   
  
  
    
 
    
 

  

 

3
print£( "15d", ko);
columa++;

Programa principal
mainO) (
columna = 1;
for (int k ko<= Ni kes) €
if (EsPrino(o0) (
ImprimirTabulando( k );

 
  
  
 
  

 

*/

  

,

  
   
   
  
 

J
print£( "a" );

 

8.2.4 Reutilización

 

La realización de ciertas operaciones como subprogramas independientes facilita lo que se llama reutilización de software. Si la operación identificada
somo operación abstracta tiene un cierto sentido en sí misma, es muy posible
¿que resulte de utilidad en otros programas, además de en aquél para el cual
 

200 Fundamentos de programación

se ha desarrollado. La escritura de otros programas que util

 

operación resulta más sencilla, yn que se aprovecha el código de su definición,
que ya estaba escrito.

Aplicaremos esta idea a los subprogramas desarrollados para imprimir el árbol
de Navidad. Las operaciones abstractas definidas allí permiten imprimir con
bloques de asteriscos figuras trapezoidales, o simplemente rectangulares, de

dimensiones variables. Cualqui

  

¡gura que pueda descomponerse en secciones

de estas formas se podrá imprimir fácilmente usando los procedimientos ya
definidos.

Por ejemplo, podremos imprimir la figura de una casa de juguete, tal como la
siguiente:

 

 

Para ello sólo tendremos que escribir un fragmento de programa así:
int main() (

+

/%-- Imprimir chinonca--/
ImprimirRectangulo( 2, 2 );

 

/*— Imprimir tejado
ImprimirRama( 9 );

E

/*— Imprimir cuerpo de la casa
ImprimirRectangulo( 9, 3);

 

Por supuesto, tendremos que copiar en la parte de declaraciones las definicio
de los procedimientos ya desarrollados en el programa del árbol de Navidad.

A continuación se presentan más ejemplos, que aprovechan subprogr:
desarrollados de antemano.

8.2.5 Ejemplo: Tabular la serie de Fibonacci

El procedimiento de imprimir tabulando desarrollado en el ejemplo de im
mir la tabla de números primos, puede aprovecharse para imprimir en fo;
dología de Desarrollo de Programas (1II) 201

 

   
    
   
   
    
   
 
  
  
 
   
 

tabla otras series de valores. Por ejemplo, podemos tabular la serie de Fibo4, que ya se describió on el tema 6. Lo que necositamos ahora es sustituir
sentencias de escritura usadas en aquel ejemplo

EC "s10din", termino );

una llamada al procedimiento

vimirTabulando( termino );

 
 

falta copiar en la parte de declaraciones la definición del procedimiento
tabular y añadir al comienzo del programa la inicialización del contador de
mas. El programa completo aparece listado a continuación:

 

 

Programa: Fibonacci

Descripción

Este programa imprime todos los términos

de la serie de Fibonacci dentro del rango de
valores positivos del tipo int: (1 .. INTMAX)

Se imprime tabulando a cuatro columas
AAA RARARRARNARRRRNARRRRAA/

Variable global
pm /
columna;

 
  
 
   
   
  

/* columna a imprimir */

Procedimiento para imprimir tabulando
2 4 columas de 15 caracteres

Af (columna > 4) £
columna = 1;
print£c "a

3

print£( "X15d", k );

columna:

 
 

 

202 Fundamentos de programación

 

 

 

Somme

Programa principal

 

7
int mainQ (
int termino; /* término de la serie */
int anterior; /* término anterior */
int aux;
/*-- Iniciar la tabulación

   

columna = 1;

/*-- Generar el comienzo de la serie --*/
anterior = 0;

termino = 1;
ImprimirTabulando( anterior );
ImprimirTabulando( termino );

 

/*-— Generar el resto de la serie --*/
while (INT_MAX - termino >= anterior) (
aux = termino + anterior;
anterior = termino;
termino = aux;
ImprimirTabulando( termino );
,
print£( "Mn" );

 

 

El resultado de la ejecución en una máquina con números enteros de 32 bi
(INT_MAX = 2.147.483.647) es el siguiente:

 

o 1 1 2
3 5 8 13

2 34 55 89

144 233 377 610

987 1597 2584 4181

6765 10946 17711 28657
46368 75025 121393 196418
317811. 514229 832040 1346269
2178309 3524578 5702887 9227465
14930352 24157817 39088169 63245986
102334155 165580141 267914296 433494437

701408733 1134903170 1836311903
odología de Desarrollo de Programas (III) 203

 

    
   
      
   
    

6 Desarrollo para reutilización

aplicar de manera eficaz las técnicas de reutilización de software es preciso

en las posibles aplicaciones de un cierto subprograma cn el momento de

pecificarlo, con independencia de las necesidades particulares del programa
se está desarrollando en ese momento.

estrategia de desarrollo tiene ventajas e inconvenientes. La principal venes que se amplía el conjunto de aplicaciones en que se podrá reutilizar
adelante el subprograma que se está desarrollando ahora. Su principal
aveniente es que será más costoso hacer el desarrollo del subprograma
seado como operación de uso general, que planteado como operación parar, hecha a medida del programa que lo utiliza en este momento.

sel ejemplo del árbol de Navidad, nos encontramos con que al buscar analo
entre distintas operaciones para resolverlas con un subprograma común,

s generalizando al mismo tiempo dichas operaciones, estableciendo
metros que permitían particularizarla para cada caso.

  

el caso de subprogramas planteados simplemente con el fin de limitar el
el de detalle en nna sección determinada de un programa, no se siente esta

idad de generalizar, y es más facil plantear la operación particularizada
za las necesidades de ese momento.

el ejemplo de tabular las series de valores, se ha planteado de entrada la
ación de tabulación de manera que impone tanto el número de columnas
o el ancho de cada una. Si queremos escribir nn subprograma de tabulade resultados que sea realmente de uso general, convendría dejar libertad
ra fijar las características del listado como parámetros modificables, que se
n particularizar para cada caso.

esta manera se podría haber ampliado el campo de aplicación del subproa de tabular si el número de columnas y el ancho de cada una fuesen
setros variables. Además, para simplificar el uso del procedimiento de
ión se podrían agrupar todas las acciones de inicialización en una sola
abstracta, invocada como subprograma, en que se fijen los parámetros
-ulares del listado. La especificación de esta acción inicial podría ser:
Procedimiento para iniciar la tabulación
“gon los paránetros indicados

[rr pia)

IniciarTabulacion( int columas, int ancho )

  
   
    
  

ilustrar esta técnica, modificaremos el programa de tabular la serie de
¡ de acuerdo con lo expuesto, decidiendo el formato del listado (6 co
 
 

204 Fundamentos de programación

lumnas de 11 caracteres) desde el programa principal. El programa modificado
es ol siguiente:

 

A ARTRARRARRA

* Programa: Fibonacci2
* Descripción:

* Este programa imprime todos los términos

* de la serie de Fibonaci, dentro del rango de

* — valores positivos del tipo int: (1 .. INIMAX)
* Se imprime tabulando a siete columas

DA
include <stdio.h>

include <Limits.h>

 

 

e
Variables globales
2*/
int TABcoluma; /* columna a imprimir */
int TABultima; /* última columna */

int TaBanch /* ancho de cada columna */

 

po

 

Procedimiento para iniciar la tabulación
con los parámetros indicados

 

 

y
void IniciarTabulacion( int columas, int ancho ) £
TABultima = columnas;
TABancho — = ancho;
TABcolumna = 1;
y

 

    

Procedimiento para imprimir tabulando
a TABultima columnas
de TABancho caracteres

 

void ImprimirTabulando( int k ) (
i£ (TABcoluma > TABultima) (
TABcolumna = 1;
prim£( "wa" );
3
print£( "%*g”,TABancho, k );
TABColuma++;

 
lología do Desarrollo de Programas (11)

 

Programa principal

= a

main() (
int termino; /* término de la serie */
ánt anterior; /* término anterior */
Ant aux;

/*— Iniciar la tabulación --*/
IniciarTabulacion( 6, 11 );

/*-—- Generar el comienzo de la serie -—-*/
anterior = 0;

termino =

ImprimirTabulando( anterior );
ImprimirTabulando( termino );

/*-—- Generar el resto de la serie —-*/
while (INI_MAX - termino >= anterior) (
aux = termino + anterior;
anterior = termino;
termino = aux;
ImprimirTabulando( termino );
+
print£( a");

resultado de la ejecución es el siguiente:

 

o 1 1 2 3 5
8 13 21 34 55 89
144 233 377 610 987 1597
2584 4181 6765 10946 17711 28657
46368 75025 121393 196418 317811 514229
832040 1346269 2178309 3524578 5702887 9227465
14930352 24157817 39088169 63245086 102334155 165580141
114296 433494437 701408733 1134903170 1836311903

jene comentar algunos aspectos de estilo utilizados en esto ejemplo. Las
les globales para la tabulación se han nombrado empezando sus nombres

el prefijo TAB, para establecer que están todas ellas relacionadas y que
visibles desde todos los subprogramas. Sin embargo, las variables para
Jeálculo de la serio de Fibonacci están declaradas como locales al programa
ipal y sc pasan como argumentos al procedimiento de InprimirTabulan
 
  
   
     
   
     
   
  
     

206 Fundamentos de programación:

 

do separando así el cálculo de la serie y la reutilización de l
número cualquiera tabulando,

¡presión de

 

En realidad esto es un recurso artificioso para separar las distintas partes del
programa. Este recurso so utilizará más ampliamente y de manera natural
cuando se presenten los tipos abstractos de datos mediante módulos separados
en C2. Usando el mecanismo de módulos se pueden desarrollar subprogramas
reutilizables, escritos en forma realmente independiente, de una manera mucho
más sencilla y adecuada.

8.2.7 Desarrollo ascendente

La metodología do desarrollo ascendente (en inglés Bottom-Up) consiste en ir
creando subprogramas que realicen operaciones significativas de utilidad para
el programa que se intenta construir, hasta que finalmente sea posible escribir
el programa principal, de manera relativamente sencilla, apoyándose en los
subprogramas desarrollados hasta ese momento.

La técnica tiene una cierta analogía con el desarrollo de subprogramas pensan=
do en su reutilización posterior. Al hablar de desarrollo para reutilización se
ha dicho que los subprogramas podían surgir en el proceso de refinamiento de
un programa concreto, al identificar ciertas operaciones, pero debían definirse
pensando en futuras aplicaciones. En este caso se trata de que la identificación
de las operaciones no surja de un proceso de descomposición o refinamiento de
alguna acción en particular, sino simplemente pensando en el programa que
se desarrolla, casi como una más de las posibles aplicaciones futuras.

Como ejemplo desarrollaremos un programa que opere como una calculadora, pero con fracciones. Una fracción se compondrá de un numerador y un
denominador enteros. La calculadora podrá sumar, restar, multiplicar o di
vidir fracciones, y los resultados los presentará con la fracción simplificada,
dividiendo por los factores comunes al numerador y al denominador.

Con independencia de los detalles do operación de la calculadora, pueden desarrollarse inicialmente procedimientos útiles para esta aplicación; en particular
procedimientos para realizar cáleulos con fracciones, así como leerlas o imprimirlas. En el siguiente listado se presenta una colección apropiada de proce:
dimientos, sobre los cuales se podrá desarrollar luego el programa principal de
la calculadora.
 
  
 
    
   
   
 
   
  
     
    
   
  
 
 
   
     
  
  

Metodología de Desarrollo de Programas (111) 207

 

 

 

tm
Procedimiento para simplificar
la fracción n/d

 

 

m=*/
¡void ReducirFraccion( int € n, int 8 d ) (
int divisor =

 

mhile (divisor <= n) 88 (divisor <= d)) £

mhile ((n % divisor == 0) 84 (d % divisor == 0)) (
n / divisor;
d / divisor;

 

divisor;

 

Procedimiento para sumar fracciones
n3"/d3" = n1/d1 + n2/d2

 

 

”/

SumarFracciones( int nl, int dl, int n2, int d2,
int 6 n3, int 4 43) (

m3 = n1*d2 + n2*d1;

43 = d1*d2;

ReducirPraccion( n3, d3 );

 

Procedimiento para restar fracciones
n3"/d3" = n1/d1 - n2/d2

 

  

a 7
RestarFracciones( int nl, int dl, int n2, int d2,

int 8 n3, int 4 d3)(
SumarFracciones( nl, dl, -n2, d2, n3, d3 );

 

Procedimiento para multiplicar fracciones
n3"/d3" = n1/d1 * n2/d2

=> */

MultiplicarFracciones( ánt nl, int dl, ánt n2, int d2,

int 4 n3, int 4 d3) (

123 = n1*n2,

45 = di*a2;

¡cirFraccion( n3, 43 );

 
208 Fundamentos de programación

 

pa

Procedimiento para dividir fracciones
1m3/d3" =n1/d1 / n2/d2

 

si */
void DividirFracciones( int nl, int dl, int n2, int d2,
ánt 8 03, int 4d3)(

 

 

,

/a
Procedimiento que lee una
y la simplifica

  
   
 

void LeerFraccion( int £ n,
scanf( "Xd/%d", 8n, 8d );
ReducirFraccion( n, 4 );

,

fa

 

Procedimiento que escribe
una fracción como n/d

 

 

 

ie

void EscribirFraccion( int n, int d ) 4
print£( "%d/£Mo", m, d);

3

Contando con esos procedimientos se puede ahora: desarrollar el programa:
principal de la calculadora, que se presenta en el programa Fraccion. En este.
ejemplo se supone que cada operación se realiza entro un valor acumulado
y un nuevo operando. La operación se inicia con una tecla de operación, y
a continuación se introduce el valor del operando. Las operaciones previstas.
son +, =, *, /. Además habrá teclas de operación para imprimir el resultado
acumulado (=) y para iniciar una nueva serie de operaciones (N). La tecla E
marcará el fin del funcionamiento del programa.

  

 

PA RRA ARRIRA RIFA AER
Programa: Fracciones

Este programa es una calculadora que suma,
resta, multiplica y divide fracciones
A A ARA

* Descripción:

 
 
  
  
 
   
   

Metodología de Desarrollo de Programas (1H) 209

 

<stdio.h>
... definiciones de los procedimientos, omitidas ...*/

Programa principal

ánt nun /* Acumulador: Numerador */
int den /* Acumulador: Denominador */
int nn, de /* Nuevo operando a utilizar */

char operacion = * *; /* Tecla de operación a realizar */

  

while (operacion l= "F') £
printf( >");
scanf( " Xe", Soperacion );

 

i£ (operacion == "+') (
LeerFraccion( nn, dd );
SumarFracciones( num, den, nn, dd, num, den );

 

) else i£ (operacion == '-') (
LeerFraccion( nn, dd );
RestarFracciones( num, den, nn, dd, mum, den );

) else if (operacion
LeerFraccion( mn, dd
NultiplicarFracciones( num, den, nn, dd, nun, den );

 

ey

 

) else if (operacion =
LeerFraccion( mn, dd
DividirFracciones( num, den, nn, dd, num, den );

PE

 

 

) else if (operacion == 'N') £ /* Nuevos cálculos */
LeerFraccion( nun, den );

 

) else if (operacion
printE( i
EscribirFraccion( num, den

 

24

  

) else if (operacion l= 'F') [
print£( "Pulse +, Ly Ny =, 0 Fo");
3
3

 

 
  

210 Fundamentos de progr

 

Un posible ejemplo de la ejecución del programa es el siguiente:

 

>> N 5/20
>».

1/4
> + 3/5
>» - 2/4
»=

7/20
>> * 5/6
»
7/24
>» F

    
 

En esta aplicación de la técnica de desarrollo ascendente se puedo apreciar q:
el desarrollo inicial de procedimientos para realizar cálculos con fracciones
ha permitido disponer de una extensión del lenguaje Cz, equivalente a definir
el tipo FRACCIÓN. Podríamos decir que los procedimientos de cáleulo consti
tuyen en conjunto una máquina virtual de operar con fracciones, sobre la cual!
se ha desarrollado el programa de la calculadora. El desarrollo es ascendente
porque primero se han construído los subprogramas, de nivel inferior, y luego
el programa que los usa, de nivel superior.

8.3 Programas robustos

La corrección de un programa exige que los resultados sean los esperados,
siempre que el programa se ejecute con unos datos de entrada aceptables. La
cuestión que nos ocupa en este momento es: ¿cuál debe ser el comportamiento.
del programa sí los datos son incorrectos?.

Un programa se dice que es un programa robusto si su operación se mantiene
en condiciones controladas aunquo so lo suministren datos erróneos.

8.3.1 Programación a la defensiva

La postura más cómoda desde el punto de vista del programador cs declinar
toda responsabilidad en el caso de que los datos no sean válidos. Si los datos de
entrada no cumplen con los requisitos previstos, el programa puede entonces
hacer cualquier cosa. Es frecuente que un programa se escriba sin tener en
cuenta la posibilidad de que los datos no sean los esperados, pues con ello se
simplifica su desarrollo.
   
 
  
 
  
 
 
   
  
 
   
   
   
   
   
  
  
     
   
   
    
 
  
  
   
  

Metodología de Desarrollo de Programas (III) 211

 

Sin embargo esta postura no es admisible en la práctica. Como cualquier otra
actividad humana, la escritura y uso de programas está sujeta a errores, y es
importante conseguir que las consecuencias de esos errores no sean demasiado
'graves. Por ejemplo, un programa de gestión de un almacén deberá prever que
¡se notifique la retirada de más cantidad de un producto que la anotada como
'existencias. En este caso el programa deberá hacer algo “razonable”, tal como
“emitir un mensaje de aviso y obligar a repetir la operación, o simplomente
“asumir que el valor de las existencias estaba equivocado, y preguntar por el
real de las existencias, o alguna otra cosa similar. Lo que no parece
“razonable” es anotar un valor negativo para las existencias sin dar ningún
“aviso, o, en general, seguir operando con valores manifiestamente erróneos
podrían dar lugar más adelante a una parada indescada del programa
rto”) al intentar ejecutar alguna instrucción de máquina inadmisible con
valores.

ejemplo ilustrativo puede ser el de un programa para calcular el valor
lio de una serie de datos, dividiendo la suma de todos por el número de
introducidos. Cabe la posibilidad de que no se introduzca ningún dato,
cual dará lugar a un intento de realizar una división por cero, que en muchos
produce el “aborto” del programa. Si el cálculo de la media es lo único
hace el programa, el efecto no parece muy grave, pero si este cálculo es
de las operaciones que realiza, por ejemplo, el programa de control de
central nuclear, los resultados pueden conducir a una catástrofe mundial.
realmente importante es detectar los errores en cuanto so produzcan, y
así programar operaciones de corrección o tratamiento apropiadas para
situaciones excepcionales.

llamada programación a la defensiva (en inglés, defensive programming)
iste en que cada programa o subprograma esté escrito de manera que
0 sistemáticamente de los datos o argumentos con que se le invoca, y
va siempre como resultado:

;) El resultado correcto, si los datos son admisibles, o bien
)) Una indicación precisa de error, si los datos no son admisibles.

«que no debe hacer nunca el programa es devolver un resultado como si
normal, cuando en realidad es erróneo, ni “abortar”. Esto da lugar a una
¡ón de errores, que puede aumentar la gravedad de las consecuencias,
x que la identificación del fallo del programa resulte mucho más difícil,
que el efecto se puede manifestar sólo más adelante, en otra parte del
ya sin relación aparente con la que falló.

mejora de la robustez del programa tieno como contrapartida una cierta
la de eficiencia, al tener que hacer comprobaciones adicionales. Si la
     

 

    
   
    
  
 
   

212 Fundamentos de program:
oficiencia es un factor decisivo, algunas de estas comprobaciones pueden
minarse en la versión final del programa, cuando se determino con se;
que el programa no contiene errores.

Consideremos el caso de una función para calcular el factorial de un nú
ni=1x2x3x..xn
La especificación de dicha función podría ser:

int Factorial( int n );
«PRE: n>0»
«POST: Factorial(n) = (n=0= 1n x Factorial(n —1)»

Esta especificación nos indica que el factorial sólo está definido para valores
n positivos, incluido cero, cuyo factorial por convenio vale 0! = 1. El factori
de un número positivo no nulo se define a partir del anterior. Para val
negativos el factorial no está definido.

 

Una realización sencilla de la función podría ser:

int Factorial( int n) (
int f
 

 

Esta función no es robusta. Para valores negativos el factorial no está definido,
y sin embargo la función codificada de la forma anterior dovuelve resultado
que sólo sería cl resultado correcto correspondiente a 01 ó 11.

 

Lo que hace falta es devolver una indicación clara de error para argumentos!
negativos. Una forma de hacerlo podría ser devolver un resultado cero o
negativo en estos casos, ya que ese resultado no puede coincidir con el factorial:
de ningún número. La función se recodificaría como se indica a continuación.
Como vemos, el código evalúa explícitamente la precondición. Si no se cumple:
devuelve un resultado fuera de rango, como indicación de error, y si sc cumple:
devuelve el valor correcto:

 

int FactorialPositivo( int n ) (
int £;
 
   
   
   
   
 
   
 
 
 
  
  
   
  
   
   
  
  
 
   
  

idología de Desarrollo de Programas (111) 213

 

if (n<0) 1

f=0;

Y else £

f=1;

for (int k = 2; k <= n; ke) (
f=£*k

realidad la función sigue sin ser del todo robusta, ya que no se ha previsto
posibilidad de que el factorial que se intenta calcular exceda del rango adásible de valores del tipo int. Esto ocurre fácilmente incluso para valores reivamente pequeños del argumento (p.ej., 20! = 2.432.902.008.176.640.000).
la sección siguiente se presenta una versión más robusta de esta función.

.2 Tratamiento de excepciones

la posibilidad de errores en los datos con que se opera, hay que considerar
actividades diferentes:

1, Detección de la situación de error.
2. Corrección de la situacion de error.

una operación se ha escrito como subprograma, la programación a la deiva recomienda que la primera actividad (detección del posible error) se
dentro del subprograma, sin confiar en que quienes usen el subprograma
invoquen siempre con datos correctos.

isten varios esquemas de programación posibles para tratamiento de erroUn modelo recomendado es el modelo de terminación. En este modelo,
se detecta un error en una sección o bloque del programa, la acción de
miento del error reemplaza al resto de las acciones pendientes de dicha.
ión, con lo cual tras la acción correctora se da por terminado el bloque. En
os lenguajes de programación, tales como el lenguaje Ada, Java y C++,
len construcciones o sentencias adecuadas para programar este esquema.
estudio profundo de las construcciones y mecanismos para tratamiento de
:pciones quedan fuera de los objetivos de este libro.

nbién en Cz, como subconjunto de C++, existen sentencias especiales para.
manejo de excepciones. A continuación se muestra mediante un ejemplo
illo la utilidad básica de dichas sentencias y los distintos pasos para el

 

 

 

 
   
  
    
 
 
  
   
   
   

214 Fundamentos de programación

 

tratamiento de excoptiones. Un subprograma desarrollado siguiendo el modelo.
de terminación podría programarse en CE según el siguiente esquema:

void Operacion ( argumentos ) (
... acción] ...
if (errorl) 1
throw excepcion1 /* Terminación con excepción1 */
3
20. Acción? ...
i£( error ) 1
throw excepcion2 /* Terminación con excepción2 */
3

,
La sentencia throw provoca la terminación del subprograma de manera
jante a una sentencia return. Sin embargo, ambas terminaciones son dist
tas: con return se realiza una terminación normal y con throw se realiza
terminación por excepción. La sentencia throw puede devolver cualquier ti
de resultado en excepcion. Además, la sentencia throw es la encargada
indicar que se ha detectado una situación de error (actividad 1) y lanzar el
canismo de tratamiento de excepciones. Quien utiliza el subprograma será
encargado de realizar la corrección de la situación de error (actividad 2). Ay
caremos este esquema a una variante mejorada de la función para calcular
factorial de un número, detectando la situación de exceso de capacidad (
fow) lanzando una excepción con el valor del número enyo factorial pros
el overftow. Además, también se lanza una excepción con valor cero
se le pide a la función el factorial de un número negativo.

int FactorialRobusto(int n) (

 

int f =1;
if (n<0 1
throw 0;
Y
for (int k = 2; k <= nj ke) (
d£ (£ > INTMAX/K) (
throw k;
3
f=frk
J
return £;
logía de Desarrollo de Programas (111)

función opera de manera robusta sea cual sea el rango de enteros de la
ina. Si se sabe de antemano cuál es dicho rango, se podría aumentar
la eficiencia determinando por anticipado cuál es el mayor valor para el
se puede calcular el factorial, y detectando directamente si el valor del
¡to excede de dicho límite, definido como parámetro constante.

   
    
      
   
   
  

 

segunda actividad, sin embargo, no puede realizarso, en general, dentro

subprograma, ya que el tratamiento adecuado de la situación excepcional

á ser diferente en cada invocación. Lo que ha de hacer cl subprograma es

¡ver una indicación precisa del error, y dejar que sean los programas que
¡invocan quienes decidan cómo actuar frente al error en cada caso.

las herramientas convencionales de un lenguaje de programación, el estípico para el tratamiento de excepciones sería el siguiente:
no del Problema (inicio);
ionRobusta( argumentos )
(Excepcion) £
Tratamiento de la Excepción

del Problema (continución)

esquema tiene el inconveniente de que hay que insertar el tratamiento
la excepción en medio del código del algoritmo del problema que se está
iendo. Esta mozcla del código normal y el código excepcional disminuye
idad del programa. Las sentencias disponibles en C+ para el manejo de
ones permiten separar ambos códigos siguiendo el siguiente esquema;

Algoritmo del Problema (inic
Operación Robusta( argumentos )
Algoritmo del Problema (continuación);

(Excepción) 1
Tratamiento de la Excepción

sentencia try agrupa el bloque de código en el que se programa el algoritmo
problema a resolver sin tener en cuenta las posibles excepciones que se
iran producir. A continuación, la sentencia catch agrupa el código para
tratamiento de la Excepción que so declara entre parentesis. Dentro del
bloque try se pueden producir excepciones de distintos tipos para las
se tendrian que programar las correspondientes sentencias catch. En el
uma completo que figura a continuación se muestra como se programa el
¡ento de las excepciones que genera la función FactorialRobusto en el
que que la utiliza.

 
 
216 Fundamentos de programación

 

 

 

/** Programa: FactorialRobusto */

 

sinclude <stdio.h>
*include <limits.h>

int FactorialRobusto( int n ) (
int f =1;

if (m<04
throw 0;
y
for (int k = 2; k <= n; ke) 4
A£ (£ > INTMAX/K) (
throw k;

,
£=£*k

A
return £;
y

void EscribirFactorial( int mun ) (
ty (
print£( “X2d! vale:X104n", mun, FactorialRobusto(num) );
q
catch (int e) (
primt£( "X2d1 excepción: ", mum );
Af (e == 0) (
print£( "Factorial de número negativoWn" );
) else (
print£( "Superado límite al evaluar X2d!w", e);
3
J
y

int main O 4

for (int i=5; 1
EscribirFactorial(i );

J

print£( "a" );

for (int i=6; i <= 15; 14) (
EscribirFactorial( i );

y

 

 

)

 
   
    
   

  
 

procedimiento EscribirFactorial captura todas excepciones y el trata:to consiste en escribir el correspondiente mensaje do error. En este caso,
¡programa principal sólo se utiliza como programa de prueba. Los resultados
la ejección se muestran a continuación

 

vale: 120
24

excepción: Factorial de número negativo
: Factorial de número negativo

720
5040
40320

362880

3628800
39916800
vale: 479001600
Superado límite al evaluar 131
Superado límite al evaluar 131
Superado límite al evaluar 131

 
Tema 9
Definición de tipos

Después de haber sido introducidos todos los mecanismos fundamentales para
la construcción de programas, ahora so pasa a estudiar las estructuras de
datos. En este tema se indican las primeras formas en que el programador
puede definir sus propios tipos de datos

En primer lugar se estudian los tipos escalares simples definidos por enumeración y cómo se utilizan. Como caso especial de tipo enumerado ya predefinido
se hace especial mención del tipo boo1, precisando su importancia dentro de
la programación.

A continuación se estudia la definición de tipos estructurados y las dos formas
más importantes para la estructuración de datos: array o formación y struct
o registro. En este tema sólo se introducen los conceptos básicos de ambas
estructuras de datos. También en este tema y como ejemplo de formación se
estudian las cadenas o vectores de caracteres,

 

Para finalizar, se presentan varios ejemplos que emplean los tipos introduci
y muestran las posibilidades que ofrecen

9.1 Tipos definidos

Una de las ventajas fundamontalos de los lenguajes de alto nivel es la posibilidad que ofrecen al programador de definir sus propios tipos de datos. Los tipos
predefinidos: int, char y float, ya presentados en el tema 2, nos han permitido la elaboración de programas para la realización de cálculos o el manejo
de caracteres. Sin embargo, si se trata de realizar un programa para jugar al
ajedrez resulta mucho más adecuado utilizar datos que representen de manera

 
 

 

220 Fundamentos de programación

 

más directa a los peones, caballos, torres, alfiles, reyes y damas del tablero.
Razonamiento similares se pueden hacer si se quieren realizar programas que
manejen días de la semana, deportes, colores, alimentos, ete.

 

Mediante la definición de nuevos tipos de datos por el programador se consigue
quo cada información que maneja el computador tenga su sentido específico,
El tipo establece los posibles valores que puede tomar ese dato. Además, al
igual que sucedía con los tipos predefinidos, a cada muevo tipo que se define se
asocian un conjunto de operaciones que se pueden realizar con él. Por tanto,
la definición de tipos supone crear un nuevo nivel de abstracción dentro del
programa.

   

 

En Ck la declaración de los tipos se realiza, junto a la declaración de las
constantes y variables, dentro de las Declaraciones del programa principal o en
cualquiera de sus procedimientos o funciones. Asimismo, en C£ la declaración
de cada nuevo tipo siempre se inicia con la palabra clave typedef. Por ejemplo:
typedef int TipoEdad;

typedef char TipoSexo;

typedef float Tipoáltura;

En estas declaraciones se definen nuevos tipos dándoles un nombre o identifi
ador y haciéndolos equivalentes o sinónimos de otros tipos ya definidos (en
este caso, los predefinidos int, char y float). Quizá en estos ejemplos la
declaración de tipo no cubre todos los objetivos señalados anteriormente, pues
no establece ninguna especificidad. Esto es, convendría establecer que la edad
no puedo ser negativa ni superior a un valor determinado o que el sexo sólo
puede tomar determinados valores. En algunos lenguajes de programación,
tales como Pascal, Modula-2 o Ada, sc puede acotar el rango de valores de un
tipo de datos a partir de otro en el momento de la declaración. Lamentablemente, en Cz sólo es posible acotar el rango de valores de un dato haciendo
las correspondientes comprobaciones dentro del código del programa.

 

 

Es importante señalar que igual que se han utilizado los tipos predefinidos, en
la definición de un nuevo tipo se pueden utilizar (y normalmente se utilizan)
otros tipos definidos previamente, según veremos a lo largo de este tema,
Precisamente esta característica es la más importante de la posibilidad de
declarar nuevos tipos.

La definición de tipos es solamente una declaración de los esquemas de datos que se necesitan para organizar la información de un programa. Para
almacenar información es necesario declarar y utilizar varinbles de los correspondientes tipos, de la misma forma que se haco con los tipos predefinidos.

Por ejemplo, se podrían usar los tipos sinónimos anteriores de la forma:
   
    
     
  
  
 
   
  
  
 
   
   
 
    
  
 
  
 
   

tura altura;
edadl + 5;
vo;

a = 1.75;

"manera formal, la

 

intaxis de la declaración de tipos es la siguiente:

 

Declaración de. tipo 33= Tipo_sinónimo | Tipo_enumerado |
Tipo_array | Tipo_struct | Tipo_unión | Tipo_puntero

tipo sinónimo ya ha sido utilizado en los ejemplos anteriores para introducir
concepto de tipo de dato. Formalmente la declaración de un tipo sinónimo
la siguiente:

 

Tipo_sinónimo
typedef Identificador_de_tipo Identificador_de_tipo_nuevo ;

"E tipo sinónimo puede parecer trivial o meramente teórico, sin embargo, tiene

“ama utilidad bastante importante como mecanismo de paramotrización del

¡programa. Al igual que sucedía con las constantes con nombre, en nn programa

e pueden utilizar sólo tipos con nombres propios. Por ejemplo:

 

int entero;
:f char caracter;
float real;

Estos nuevos tipos entero, caracter y real sustituyen a los predefinidos
del lenguaje y son los únicos que se utilizarán en nuestro programa. Cuando
se cambia do compilador para transportar el programa a otra plataforma o.
se quiere cambiar la precisión de los cálculos sólo es necesario modificar en
estas sentencias de parametrización los tipos haciéndolos sinónimos de otros
diferentes.

 

En los apartados siguientes do este mismo tema se indica la manera de definir
los tipos enumerados, formación y tupla. En temas posteriores so oxplic
cómo se definen y para qué sirven los tipos unión y puntero.

 

 

9.2 Tipo enumerado

Aparte de los valores predefinidos básicos (números, caracteres, etc.) en C4 se
pueden definir y utilizar nuevos valores simbólicos de la manera que se indica
a continuación.

 
222 Fundamentos de programación

 

9.2.1 Definición de tipos enumerados

Una manera sencilla de definir un nuevo tipo de dato es enumerar todos los posibles valores que puedo tomar. En Ci el nuevo tipo enumerado se defino detrás
de la palabra clave enum mediante un identificador del tipo y a continuación
se detalla la lista con los valores separados por comas (,) y encerrados entre
llaves £...). Cada posible valor también se describe mediante un identificador. Estos identificadores al mismo tiempo quedan declarados como valores.
constantes. Por ejempl

 

   

typedef emun TipoDia (
Lunes, Martes, Miercoles, Jueves,
Viernes, Sabado, Domingo
1
typedef emun TipoMes (
Enero, Febrero, Marzo, Abril, Mayo,
Junio, Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre
h
typedef emun TipoEstadoCivil ( Casado, Soltero, Viudo, Divorciado );
typedef emun TipoColor [ Rojo, Amarillo, Azul
typedef enun TipoFrutas [ Pera, Manzana, Limon, Naranja, Kiwi );
typedef emun Tipo0rientacion [ Norte, Sur, Este, Oeste );
typedef enun TipoPieza ( Rey, Dama, Alfil, Caballo, Torre, Peon

 

 

La enumeración implica un orden que se establece entre los valores enumerados. En Ci este orden se define de forma implícita e impone que el primer
elemento de la lista ocupa la posición O, el siguiente la 1, y así sucesivamente
hasta el último, que ocupa la posición N-1, siendo N el número de elementos
enumerados. Los tipos de datos enumerados forman parte de una clase de tipos de C+ denominados tipos ordinales, a la cual pertenecen también los tipos
int y char, pero no el tipo £loat.

La sintaxis exacta de la declaración de los tipos enumerados es la siguiente:
Tipo_enumerado
£ Lista de

Lista_de_identificadores

 

 

typedef enun Identificador_de_ tipo_nuevo
identificadores Y;

Identificador Á , Identificador Y

 

 

9.2.2 Uso de tipos enumerados

Los tipos enumerados se emplean de manera similar a. los tipos predefinidos.
El identificador de tipo so puedo emplear para definir variables de ese tipo, y
 
  
 
 
 
 
 
 
   
   
   
  
  
   
   
  
   
   
    
   

Definición de tipos 223

 

los identificadores de los valores enumerados se emplean como las constantes
con nombre. Usando las definiciones anteriores podremos escribir:

poDia diaSemana;
'TipoColor colorCoche = Rojo;
les mes;

jemana
¡colorCoche
= Marzo;

 

¡Como se puede observar, en la misma definición de la variable colorCoche
se ha inicializado al valor Rojo, de forma semejante a cualquier otra variable,
Puesto que entre los valores enumerados existe un orden definido, podremos
emplear con ellos los operadores de comparación para programar sentencias
del tipo:

(mes >= Julio) £...+

 

(diaSemana < Sabado) £.

 

(colorCoche = Rojo) (...)

Al igual que para el resto de los tipos ordinales, con los tipos enumerados se
puede utilizar la notación int(e) para obtener la posición de un valor en la
Esta de valores del tipo. Por ejemplo, se cumple que:

que permita conocer qué valor enumerado ocupa una

¡determinada posición, se consigue mediante la notación inversa que hace uso

del identificador del tipo enumerado y que se invoca de la siguiente forma:
TipoEnumerado(N)

¡que devuelve el valor que ocupa la posición N en la colección de valores del

“tipo TipoEnumerado. En los ejemplos anteriores se cumple que:

ipoEstadoCivil(0) Casado

¡Frutas(4) == Kiwi

's(11) Diciembre

 

 

Hay tipos enumerados, tales como el TipoColor o el TipoFrutas, en que la
semumeración sólo sirve para reflejar los valores posibles sin que el orden de la
definición tenga ninguna relevancia. Sin embargo, como sucede en los casos

 
  

224 Fundamentos de program:

  
  
 
 
  
  
 
  

de TipoDia y TipoMes, el orden es muy importante y habitualmente se q.
utilizar en los programas para manejar los valores anteriores o posteriores.
Cuando se croa un nuevo elemento en un programa es responsabilidad
programador dotarle de todas las características y atributos que se conside
necesarios. Así, para disponer de las operaciones anterior /posterior de
muevo tipo que se defina es necesario programarlas y para ello siempre
aprovecharán las operaciones ya disponibles. Por ejemplo, para pasar al día.
siguiente de la semana y al mes anterior se podría programar de la siguiente
forma:

diaSemana = Jueves;

diaSemana ipoDia(int(diaSemana)+1);

mes = Marzo;

mes = TipoMes(int(mes)-1);

  

 

El resultado ser:

diaSemana == Viernes
mes == Febrero

 

Sin embargo estas operaciones no están completas. Si se hace esto mismo.
cuando el día de la semana es domingo:

diaSemana = Domingo;
diaSemana = TipoDia(int(diaSemana)+1);

 

se obtendrá un error, ya que no existe el día siguiente a Domingo. A continua
ción se resuelve este problema programando una función específica.

Un dato de tipo enumerado se puede pasar como argumento de procedimientos
/ funciones y puede ser el resultado de una función. Por ejemplo, si conocemos
el día de la semana de Hoy y queremos calcular qué día de la semana será dentro
de N días, podemos emplear la siguiente función:
TipoDia SumarDias(TipoDia Hoy, int N) (

const int DiasSenana =

int aux;

 

aux = (int(Hoy) + N) % DiasSemana;
return TipoDia(aux);
J

Como se puede observar, primero se calcula el ordinal del nuevo día entre 0 y 6,
según el orden establecido en la definición de TipoDia y finalmente se devuelve
este ordinal convertido al tipo correspondiente mediante TipoDia(aux). De
la misma manera habría que realizar la función para restar días y para sumar
y restar meses.

 
Definición de tipos 225
9.3 El tipo predefinido bool

Al introducir las estructuras de selección o iteración se han descrito sentencias
de Ct que utilizan expresiones lógicas o de condición. En ese momento se
dijo, de manera informal, que el valor de una condición podía ser cierto o
falso. De manera más precisa podemos indicar ahora que en Ct existe el tipo
predefinido bool que responde a la siguiente definición, análoga a la de un
tipo emumerado:

|rypedef enn bool ( false, true 3;

 

Esta definición no es necesario escribirla ya quo está implícita on el lenguaje.
El nombre bool es el identificador del tipo (abreviatura de booleano), y las
constantes simbólicas false y true corresponden a los valores de verdad falso
y cierto, respectivamente. Como tipo ordinal se cumple;

int(false) == 0

“int(true) 1

 

A partir del tipo predefinido bool, ahora es posible declarar variables de este
tipo y utilizarlas, de forma similar al resto de variables, para guardar resultados
de expresiones condicionales. Por ejemplo

1 bisiesto;
bisiesto = (anno % 4) = 0; /* válido entre 1901 y 2099 */

Asimismo, es posible realizar operaciones entre ellas. En concreto, entre opesrandos boolcanos (variables o no) es posible realizar las operaciones lógicas ya
indicadas en el tema 5 para formar expresiones lógicas y cuyos operadores son

dos siguientes:
Operación lógica Operador C£
Conjunción (A y B) 8
Disyunción (A o B) 1"

 

Negación (no A) !
Esto permite formar expresiones y sentencias tales como la siguiente:

/4F (bisiesto $8 (mes > Febrero) [
totalDias = totalDias + 1;

a

Los resultados de las expresiones lógicas para los distintos operandos y opeadores son los siguientes:

 

 
 

 

226 Fundamentos de programación

 

a b a 8% b alib la
true true true true false
true false — false true false
false true false true true
false false false false true

El tipo booleano, como cualquier otro tipo enumerado, se puede pasar como
argumento de un procedimiento o función y puede ser devuelto como resultado
de una función. De hecho es frecuente definir funciones cuyo resultado es un
valor booleano cuando se quiere realizar un test sobre los argumentos de la
función. Este tipo de funciones se denominan predicados. Un ejemplo de este
tipo de funciones son algunas de las introducidas en el tema 7 para el manejo
de caracteres y que se recuerdan a continuación:

 

Indica si e es una letra

bool isascii( char e ) | Indica si e es un carácter ASCIT

bool isblank( char e ) | Mdica si € es un carácter de espacio o
tabulación

bool isalpha( char c)
)
)
bool isdigit( char € ) | Indica si e es un dígito decimal (0-9)
)
)
)

 

 

 

 

bool islower( char €) | Indica si e es una letra minúscula
Indica si e es espacio en blanco o salto de
línea o página

Tndica si e cs una letra mayúscula

 

bool isspace( char c

 

 

 

 

bool isupper( char c

 

Conviene recordar que para poder usar estas funciones predicado es necesario
incluir la cabecera de librería <ctype.h> al comienzo del programa.

9.4 Tipos estructurados

Todos los tipos de datos presentados hasta este momento se denominan tipos
escalares, y son datos simples, cn el sentido de que no se pueden descomponer.
En general, no tiene sentido tratar de reconocer fragmentos de información
independientes dentro de un valor entero, o un carácter, o el valor simbólico.
de un día de la semana o el número de un día del mes.

En muchas aplicaciones resulta conveniente, o incluso necesario, manejar globalmente elementos de información que agrupan colecciones de datos. Por
ejemplo, puede ser apropiado manejar como un dato único el valor de una
fecha que incluye la información del día, el mes y el año como elementos componentes separados. Con este objetivo, los lenguajes de programación dan la
posibilidad de definir tipos de datos estructurados,
"Definición de tipos 227

Un tipo estructurado de datos, o estructura de datos, es un tipo cuyos valores
se construyen agrupando datos de otros tipos más sencillos, Los elementos de
“información que integran un valor estructurado se denominan componentes.
“Todos los tipos estructurados se definen, en último término, a partir de tipos
simples combinados.

En los próximos apartados se hace una primera introducción de los tipos estructurados formación y tupla.

9.5 Tipo formación y su necesidad

Las estructuras de datos de tipo formación son quizá las más básicas, o al
menos las que se introdujeron primero en los lenguajes de programación imperativos. Puede afirmarse que no hay ningún programa real interesante que
"mo use estructuras do esta clase.

En el tema 5 se realizó un programa para ordenar 3 datos. El interés de la
ordenación de cualquier tipo de dato (números, nombres, fechas, cto.) resulta
más evidente cuando la cantidad de datos a ordenar es do cientos o miles de
datos, el trabajo de ordenación resulta tedioso y es más adecuado realizarlo
utilizando un computador.

Si se quiere realizar un programa de ordenación con las estructuras de datos
presentadas hasta este momento sería necesario declarar tantas variables del
mismo tipo como datos se tratan de ordenar. En el programa del tema 5
se necesitaron tres variables: valorUno, valorDos y valorTres. Además
el tratamiento de cada variable se debe realizar por separado: dentro del
texto del programa se tienen que hacer las correspondientes comparaciones e
intercambios entre cada una do las parejas de variables. Por ejemplo, on el
mencionado programa so tenía el siguiente fragmento:
/*-—- Primer Paso: Ordenar 2 primeros datos --*/
if (valorUno > valorDos) (

auxiliar = valorUno;

valorUno = valorDos;

valorDos = auxiliar;

 

y
/*-- Segundo Paso: Situar el 3% dato --*/
if (valorTres < valorUno) £

auxiliar = valorTres;

valorTres = valorDos;

valorDos = valorUno;

valorUno = auxiliar;

  

 
 

228 Fundamentos de programación

 

) else if (valorTres < valorDos) £
auxiliar = valorDos;
valorDos = valorTres
valorTres = auxiliar;
b

   

Evidentemente esta forma de realizar el programa es imposible de generalizar
para la ordenación de un número cualquiera de datos. Además, este mismo
problema se reproduce en cualquier programa en el que sc trate de manejar una
cantidad razonable de datos, todos del mismo tipo. Si tenemos en cuenta que
uno de los primeros objetivos de los computadores fue precisamente manejar
grandes cantidades de información, se comprende fácilmente porqué ya en
los primeros lenguajes de programación se disponía de estructuras de datos
para resolver estos problemas, Estas estructuras se denominan genéricamente
formaciones (en inglés array), y permiten la generalización de la declaración,
roferencia y manipulación de colecciones de datos todos del mismo tipo. En
el siguiente apartado se estudian los vectores como la forma más clemental de
formación y sus características.

 

9.6 Tipo vector

Como se muestra en la figura 9.1, un vector está constituido por una serie de
valores, todos ellos del mismo tipo, a los que se les da un nombre común que
identifica a toda la estructura globalmente. Cada valor concreto dentro de la
estructura se distingue por su índice o número de orden que ocupa en la serie.
En la figura 9.1 se ha adoptado el convenio que se utiliza en C£ por el que el
índice del primer elemento siempre es el cero,

Nombre común: Vector
Indice: 0. 1 2 sa n3 n2 n1

Elementos:

 

Figura 9.1 Estructura vector.

Como se puede observar, esta estructura es análoga al concepto matemático
de vector, en el que el vector completo se identifica por un nombre único y
cada clomento particular mediante el correspondiente subíndice;

V = (Vo, Va; Va, Va, «o, Vi-a, Va-1)

 
Definición de tipos 229

 

En cuanto al aspecto de programación se puede establecer un paralelismo entre
la estructura de programación en la que se repito la misma acción un número
ide vecos determinado: sentencia for, y la estructura de datos vector en la que
también se repiten un número de veces determinado el mismo tipo de dato.
¡Como se verá posteriormente, la sentencia for es la que mejor se adecúa al
manejo de los vectores y en general de todo tipo de formaciones.

 

9.6.1 Declaración de vectores

En Ct, una estructura de tipo vector se declara de la siguiente forma:
typedef Tipolllemento Tipo Vector[ NumeroFlementos];

donde Tipo Vector es el nombre del nuevo tipo de vector que se declara y
'NumeroFlementos es un valor constante que indica el número do olementos que
«constituyen el vector. Por tanto, la variabilidad del índice de un vector siempre
estará comprendida entre 0 y NumeroFlementos-1. Finalmente TipoLllemento
corresponde al tipo do dato de cada uno de los elementos del vector y puede ser
¡cualquier tipo de dato predefinido del lenguaje o definido por el programador.
Indudablemento, cualquiera de los nuevos tipos do datos estructurados que se
vayan presentado en esto tema y los próximos, también podrán ser elementos
de un vector. Los siguientes ejemplos utilizan los tipos predefinidos y algunos
tipos definidos por enumeración
'typedef enum TipoDia (

Lunes, Martes, Miercoles, Jueves,

Viernes, Sabado, Domingo
+
typedef enum TipoColor £ Rojo, Amarillo, Azul $;
typedef float TipoMedidas[3]
typedef TipoColor TipoPaleta[5];
typedef char TipoCadena[30];
typedef TipoDia TipoAgenda[7.
¡typedef bool TipoEstados[8];
typedef int TipoVector[10];

 

 

 

 

 

En muchos casos el tamaño del vector es un parámetro del programa que
podría tener que cambiarse al adaptarlo a nuevas necesidades, Si es así, resulta aconsejable que la declaración del número de elementos se realice como
una constante con nombre. Por ejemplo, estas constantes podrían haber sido
declaradas previamente de la siguiente forma:

 
230 Fundamentos de programación

 

const int NuneroEstados = 8;
const int Longitudagenda = 7;
const int NuneroLetras = 30;
const int NuneroElementos = 10;

typedef char TipoCadena[NuneroLetras];
typedef TipoDia TipoAgenda[Longi tudagenda];
typedef bool TipoEstados[NumeroEstados];
typedef int TipoVector[NumeroElementos];

De esta manera, el programa queda parametrizado por dichas constantes. En.
las modificaciones posteriores, si se quiere adaptar el tamaño del vector sólo.
es nocesario modificar esta constante. Además, como se verá posteriormente,
es habitual utilizar el número de elementos del vector en las operaciones de
recorrido y búsqueda de los vectores, que se pueden entonces programar en
función de la misma constante,

Para poder utilizar los tipos declarados es necesario declarar a su vez, posteriormente, las correspondientes variables. Por ejemplo:

TipoAgenda agendaUno, agendaDos;

TipoCadena frase;

TipoEstados estadoMotor, estadoPanel;

TipoVector vectorUno, vectorDos;

Hay que recordar que en el lenguaje GE es obligatorio que todas las variables
se declaren precedidas del identificador de un tipo predefinido del lenguaje o
bien definido previamente en el programa, Tanto on la sintaxis de CH como en
el Manual de Estilo está expresamente prohibido la declaración de variables
de tipo anónimo. Se dice que una variable es de tipo anónimo cuando su estructura se detalla en la misma declaración de la variable, como si se estuviera.
declarando un tipo de datos anónimo para esta única variable.

NOTA: En C/C++ sí es posible declarar variables de tipo anónimo aunque también:

es bastante frecuente que se aconseje o incluso se obligue en el Manual de Estilo que
no se usen tipos anónimos para facilitar la comprensión del programa.

La sintaxis exacta de la declaración de los tipos formación es la siguiente:
Tipo_formación +3= typedef Identificador_de_tipo_elemento
Identificador_de_tipo_ formación Dimensiones

= Tamaño É Tamaño )

[ Número_de_ elementos ]

 

Dimensiones

 

Tamaño +

En esta sintaxis está incluida la posibilidad de declarar formaciones multidimensionales o matrices que se explicarán en el tema 11.
 

 
  
  
  
 
   
 
 
  

2 Inicialización de un vector

se explicó en el tema 3, en CE cuando se declara una única variable de
ier tipo siempre es posible darle un valor inicial. En el caso de un veotor
inicialización afecta a todos sus elementos y por tanto la notación es algo
ial y en ella se indica el valor inicial de todos los elementos agrupándolos
llaves £.. .) y separándolos por comas (,). A continuación se declaran
¡ente alguna de las variables anteriores incluyendo su inicialización.

 

 

¡enda agendaUno = €
Íunes, Viernes, Domingo, Martes,
Martes, Martes, Sabado

 
 
   
   
  
  
  
   
  
 
   
    
   

Estados estadoMotor = (
true, false, true, true, false,
false, false, true
Vector vectorUno = [ 12, 7, 34, -5, 0, 0, 4, 23, 9, 11);
Vector miVector = f 1, 1, 1, 1, 1, 0, 0, 0, 0, 0);

9.6.3. Operaciones con elementos de vectores

La mayoría de las operaciones interesantes con vectores hay que realizarlas
“operando con sus elementos uno por uno. La referencia a un elemento concreto
¡de un vector se hace mediante el nombre del vector seguido, entre corchetes,
del índice del clemento referenciado. Por ejemplo:

  
 

'vectorUno[0]
¡frase[13]
¡estadoMotor[5]
'miVector[3]

Un elemento de un vector puede formar parte de cualquier expresión con
constantes, variables u otros elementos. Paras estas expresiones se tendrá en
cuenta el tipo de los elementos del vector y las reglas de compatil
ejemplo:

 

 

imiVector[3] = 3*vectorUno[0] + 2*vectorDos[0];
frase[13] = 'A'
estadoMotor[5] = true;

Los elementos de los vectores miVector, vectorUno y vectorDos son todos

del mismo tipo int y por tanto, la primera de las expresiones anteriores es
totalmente correcta.
232 Fundamentos de programación

 

 

Como índice para designar un elemento de un vector se puede utilizar una
variable o expresión, siempre que sean de tipo entero. Por ejemplo:

¡const int Alarma = 0;

int á, 3;

|int origen, indice;

miVector[j] = 3*vectorUno[i] + 2*vectorDos[i+3];

frase[origen+indice] = * *;
estadoPanel [Alarma] = false;

La posibilidad de utilizar variables o expresiones para el cálculo del índice de
un vector es fundamental en cualquier programa que utilice vectores, como
se verá a lo largo de este y los próximos temas. Sin embargo, siempre se
debe comprobar exhaustivamente que no existe ninguna posibilidad de que
por error el índice calculado por la expresión o guardado en la variable se
salga fuera del rango entre O y NumeroElementos-1 para cada vector. No
obstante, si esto ocurre el resultado será totalmente impredecible dado que
estaremos haciendo referencia a un elemento del vector que no tiene existencia.
real. En esta situación, y dependiendo del compilador, se podrá producir un
error de ejecución y/o la parada del programa.

 

Es especialmente importante insistir en que al usar lenguajes como C, C++ 0,
Ci la comprobación de que el índice para acceder a un elemento de vector está
dentro del rango permitido es responsabilidad del programador. Muchos
ataques informáticos aprovechan la falta de provisión de esta comprobación
para alterar el funcionamiento normal de un programa suministrándole datos
de mayor tamaño que el previsto y provocar lo que se denomina en inglés
buffer overrun.

 

9.6.4 Operaciones globales con vectores

En lenguajes tales como Pascal, Modula-2, Ada, cto. existe la posibilidad de
realizar una asignación global de un vector a otro, siempre que estos sean compatibles entre sí. En cualquiera de estos lenguajes, para realizar una asignación
global basta escribir:

vectordos := vectorUno; (lenguaje Pascal]

     

El símbolo := es el operador de asignación, similar al operador = de Ct. Esta.
operación efectúa una copia de todos los clementos del vector vectorUno en.
el vector vectorDos
 
 
  
     
 
 
  
    
   
 
 
 
   
  
   
    
    

efinición de tipos 233

 

embargo, en C£ no existo esta posibilidad y la asignación so tiene que
'amar explícitamente mediante un bucle que realice la copia elemento a
nto, tal y como se recoge en el siguiente fragmento de programa:

int i = 0; i < NuneroElementos; 1++) £
vectorDos[i] = vectorUno[i];

se puede observar en el fragmento de programa anterior, se utiliza una
entencia for con condición de terminación i < NumeroElementos que no
la sintaxis de ninguna do las dos variantes presentadas en el tema 5.
formaciones resulta bastante habitual realizar, como en este caso, un
'pecorrido por todos sus elementos. Tal y como se ha dicho anteriormente,
“a una formación de N elementos, en Ct los índices siempre van desde O
sta N-1 y la forma más natural de expresar la condición de terminación del
orrido será indice < N. Para facilitar el trabajo con las formaciones, en C£
dispone de esta tercera variante de for. Así, la sintaxis completa de esta
entencia es la siguiente:

Sentencia_FOR 33% For_creciente | For_creciente_menor |
For_ decreciente

For_creciente 333 for ( int Variable_índice = Valor_imicial ;
Variable_índice <= Valor_final ; Variable_índice ++ )
1 Secuencia_de_sentencias Y

For_creciente menor *3= for ( int Variable_fndice = Valor_inicial ;
Variable_índice < Valor_final ; Variable_éndice ++ )
4 Secuencia_de_sentencias Y

For_decreciente 333 for ( int Variable_índice= Valor_inicial ;
Variable_índice >= Valor_final ; Variable_índice — )
4 Secuencia_de_sentencias Y

 

 

 

 

 

 

 

6.5 Paso de argumentos de tipo vector

Otra manera habitual de operar globalmente con los vectores es utilizarlos
omo argumentos de procedimientos o funciones. Por razones históricas y
gún se explicará en próximos tomas, el manejo de toda clase de formaciones
C y C++ tiene ciertas peculiaridades. Debido a que nuestro lenguaje Ct es
subconjunto de C++, también tiene algunas de esas mismas peculiaridades.
, en CE el modo por defecto de paso de argumentos de tipo formación, y
ss concretamente de tipo vector, es el paso por referencia. Por ejemplo, si
enemos las siguientes declaraciones:

   

 
 

   
  
 
 
 
  
   
 
  
  
 
   
 
 
     
   

234 Fundamentos de programación

 

¡void LeerVector( TipoVector w ) £...P
void ConocerEstado( TipoEstados e ) (...)

Cuando se invocan estos procedimientos, además de emplear en la llamada
argumentos reales que deben ser compatibles con el correspondiente argumento.
formal, hay que tener en cuenta que el argumento real puede ser modificado.
Por ejemplo, con la siguiente invocación de los procedimientos anteriores:
LeerVector( vectorUno );

ConocerEstado( estadoMotor );

las variables vectorUno y estadoMotor podrán quedar modificadas después de
ejecutar el correspondiente procedimiento. Es importante recordar que, según.

so explicó en el tema 7, para el resto de tipos de datos la opción por defecto
es que el paso de argumentos cs siempre por valor, los parámetros reales de
la llamada pueden ser expresiones y los parámetros reales nunca se modifican.
Por otro lado, también hay que recordar que en C*, exceptuando el caso de las
formaciones, cuando un argumento formal se quiere pasar por referencia debe.
ir precedido del símbolo € en la cabecera de declaración del subprograma.

 

 

Por el contrario, en CH, cuando se utilizan argumentos de tipo formación y.
no se quiere que se modifiquen los parámetros realos en la llamada al pro-,
cedimiento, los argumentos formales deben ir precedidos de la palabra clave:
const. Por ejemplo:

void EscribirVector( const TipoVector y ) (
void PintarEstado( const TipoEstados e ) t.

y

 

 

J

Con estas declaraciones, si se invocan los procedimientos anteriores con
siguientes sentencias:

 

EscribirVector( vectorDos );
PintarEstado( estadoPanel );

las variables vectorDos y estadoPanel permanecerán inalteradas después
ejecutar el correspondiente procedimiento. Por tanto, cuando declaramos
argumento de tipo formación o vector precedido de la palabra clave const
equivalente al paso de dicho argumento por valor.

Para sor exactos, esta forma de paso de argumentos es más restrictiva que
paso por valor. En realidad el vector se pasa por referencia, pero se prol
usar asignaciones a sus elementos en el cuerpo del subprograma. En el
por valor de otros tipos de datos el argumento formal se ve como vari
local dentro del subprograma, y de hecho es una copia que puede modific
 
  
 
 
   
   
  
   
 
    
 
  
   
  
   
  
    
  
 
   
  
 
 
 
 
 
 
  

ición de tipos 235

 

sin alterar el argumento real usado en la llamada. En cambio los argumentos de tipo vector declarados como const se ven como constantes dentro del
“subprograma, y sus elementos no pueden ser modificados en modo alguno.

En C y C++ la compatibilidad entre los argumentos formales y reales de tipo
sector so limita a que tengan el mismo tipo de los elementos. Así, en los ejemplos
“anteriores los procedimientos LeerVector y EscribirVector podrían ser llamados
'gon. vectores de elementos enteros, sca cual sea la forma en que se han declarado y su
ño. Esto introduce una clara inseguridad en el código. Por eso en Ci se exige que
argumento real sea exactamente del mismo tipo vector que el argumento formal,
jue esta restricción se suaviza, en parto, con el empleo de vectores abiertos, tal
se verá en el tema 11. Las cadenas de caracteres que se describen en el apartado
jente se tratan de hecho como vectores abiertos, y eso permite operar con cadenas
diferentes longitudes.

 

8.7 Vector de caracteres: Cadena (string)

ido asu uso tan frecuente, en el tema 2 ya fueron presentadas las constantes
tipo cadena (en inglés, string). Sin embargo, hasta ahora no hemos podido
variables de este tipo. Esto se debe a que en realidad las cadenas son
es de caracteres y los vectores no han sido estudiados hasta este tema.
embargo, en todos los lenguajes es habitual que las cadenas de caracteres
van ciertas peculiaridades que no tienen el resto de los vectores y por esta
1 son objeto de este apartado específico.

C2 cualquier tipo vector cuya declaración sea de la forma:
char Nombre[ N ]

considera una cadena o string, con independencia de su longitud particular,
es, del valor de N. Por tanto, el tipo definido en el apartado anterior
lena es una cadena. La característica peculiar de las cadenas es la
jente:

Una cadena de caracteres (en inglés string) es un vector en el que se pueden
almacenar textos de diferentes longitudes (si caben). Para distinguir
la longitud útil en cada momento se reserva siempre espacio para un
carácter más, y se hace que toda cadena termine con un carácter mulo
*10* situado al final.

tanto, para declarar una cadena de un máximo de veinte caracteres se

hacer de la siguiente forma:

char Cadena20[21];

declaración de variables de este tipo se hace de la forma habitual:

 
 

236 Fundamentos de program:

 

'TipoCadena idioma
Cadena20 nombre,
TipoCadena direccion = "Gran Vía 23";

    
   
     
 
   
  
  
 
   
    
    
 

En este caso la inicialización se hace mediante una cadena constante semej
a las utilizadas en el tema 2 y no clemento a elemento separados por cot
como para el resto de vectores. Como se puede observar, en la inicialización
es necesario asignar una cadena con los diecinueve, veinte o treinta caracte
Los caracteres asignados ocupan posiciones seguidas desde el principio, y
continuación del último se sitúa el carácter mulo *Y0* de final de cadena.
caráctor es especial y no se puede escribir. Lo que nunca se puede hacer
asignar más caracteres de los declarados pues se rebasarían los limites prev:
y se provocaría un error.

Como la utilización de cadenas de caracteres es bastante habitual, el len:
C (y C) dispone de la librería string (cabecera <string.h>) que facilita
manejo de las cadenas. Esta librería incluye una gran variedad de funciones
de ellas las más comunes son las siguientes:

 

strepy( cl, e2 ) | Copia c2 en cl

strcat( cl, c2 ) | Concatena c2 a continuación de cl
strien( cl) Devuelve la longitud de c1
Devuelve un resultado cero si cl y e2 son iguales;
menor que cero si el precede a e2 en orden
alfabético, y mayor que cero si c2 precede a cl en
orden alfabético

 

 

 

stremp( cl, c2 )

 

 

 

Al igual que con cualquier otro tipo de vector, no es posible roalizar asi
ciones globales entre cadenas. Por ejempl
apellido = "González"; — /* ERROR en C+ */
nombre = apellido; /% ERROR en C+ */

 

Para realizar esta operación usando el procedimiento general se program:
un for que copie elemento a elemento tal como so ha explicado en el apart:
anterior. Sin embargo, esta operación se puede realizar utilizando la funci
de librería strcpy tal y como se muestra a continuación:

strcpy( apellido, "González" );
strcpy( nombre, apellido );

Al igual que las constantes, también cualquier variable do tipo cadena se pu
utilizar como argumento de procedimientos o funciones. Más concretamen
Definición de tipos 287

 

sen el procedimiento de escritura printf se pueden utilizar constantes o variables de cadena empleando el formato de escritura Xs para string o cadena.
Por ejemplo:

Iprintf("Datos: %s — Xs : Ks Xsin", idioma, direccion, “Jos

 

apellido);

 

produce un resultado similar al siguiento:

 

Úbatos: inglés - Gran Vía 23 : José González

El procedimiento de escritura sólo escribe el contenido de la variable hasta el
primer carácter nulo *Y0*.

También es posible utilizar variables de tipo cadena con el procedimiento de
lectura scanf utilizando también el formato de lectura Xs para stringo cadena,
Por ejemplo, sea el siguiente fragmento de códig
¡printf("Nombre y Apellido?
scanf("%sk%s", £nombre, tapellido);

 

 

Un ejemplo de la ejecución (en pantalla) puede ser:

 

Íxombre y Apellido? José González

Con ello se guardan en las variables nombre y apellido las cadenas
y "González" introducidas por teclado. Hay que tener en cuenta que con
el formato %s para lectura, el carácter blanco sirve para separar las cadenas
introducidas por teclado. La comprobación del valor que tienen las variables
nombre y apellido os cl resultado del procedimiento de escritura anterior.

 

 

Para finalizar este apartado, a continuación se muestra un programa muy
sencillo que ilustra la utilización de las funciones anteriores para manejo de
cadenas.

 

/** Programa: Cadenas */
/* Ejemplo de manejo de cadenas de caracteres */

*include <stdio.h>
*include <string.h>

typedef char TipoCadena[20];

int main O 1
TipoCadena nombre, apellido;
typedef char TipoTexto[100];
TipoTexto texto;
int resul;

 

 

 
238 Fundamentos de progr:

printf( "Nombre y Apellido? " );
scanf( "%sXs", nombre, apellido );
print£( "Datos: %s - Xs Wn", nombre, apellido );
print£( "Longitudes: *4dx4din", strlen(nombre), strlen(apellido) );
strcpy( texto, nombre );
print£( "Texto copiado: sin", texto );
strcat( texto, apellido );
print£( "Texto concatenado: Xsin", texto );
resul = stremp( apellido, nombre );
if (resul —= 0) £
print£( "Nombre y Apellido igualesin" );
) else if (resul > 0) (
print£( "%s es anterior a Xsin", nombre, apellido );
A

  
   

,

 

Como se puede observar en el listado ha sido necesario incluir la cabecera de
librería <string.h> al comienzo del programa. El resultado de una posible
ejecución se muestra a continuaci

  

 

Nombre y Apellido? Sara Saramago
Datos: Sara - Saramago
Longitudes: 4 8

Texto copiado: Sara

Texto concatenado: SaraSaramago
Sara es anterior a Saramago

 

9.8 Tipo tupla y su necesidad

Otra forma de construir un dato estructurado consiste en agrupar elementos
de información usando el esquema de tupla o agregado. En este esquema el
dato estructurado está formado por una colección de componentes, cada uno
de los cuales puede ser de un tipo diferente.

Por ejemplo, una fecha se describe habitualmente como un dato compuesto
de los elementos día, mes y año. Un punto en el plano cartesiano se describe
mediante dos números, que son sus coordenadas. El nombre completo de una
persona es la colección formada por el nombre de pila y sus dos apellidos.
Como ejemplos concretos podemos poner:
Definición de tipos 239

 

 

Dato Valor.
Techa < 12, Octubre, 1992 >
punto <4,-2>
nombre_completo — < Fernando, Jiménez, Rodríguez >

  
 
   
   
   
   
   
  
   
 
 
  
  

En estos ejemplo se ha supuesto un orden implícito entre las componentes. En

fecha se ha escrito primero el día, luego el mes, y luego el año. Es impor
identificar claramente a qué componente corresponde cada elemento de
ión. El punto <4, -2> es distinto del punto <-2, 4>.

En realidad el orden es hasta cierto punto arbitrario. Normalmente cada
“somponente se identifica mediante un nombre simbólico. En los ejemplos
“anteriores podríamos nombrar las componentes de la forma:

 

Dato Valor
HToha día 12, mes: Octubre, año: 1992 >
punto <x 4 y 2>

< nombre: Fernando, apellidol: Jiménez,

  

pco capi!  ioR Rodlne

dentificando cada componente por su nombre, se pueden escribir en el orden
convenga:
Dato Valor.
fecha: < mes: Octubre, día: 12, año: 1992 >
punto <x 4 y -2>
< apellidol: Jiménez, apellido2: Rodríguez,
nombre: Fernando >

 

 

nombre_completo

s las consideraciones anteriores, podríamos dar una definición de este esde datos:

Tupla: Colección de elementos componentes, de diferentes tipos, cada uno de
los cuales se identifica por un nombre.

aspecto importante del empleo de datos estructurados corresponde al punde vista de abstracción. Una tupla, como cualquier otro dato compuesto,
e verse de forma abstracta como un todo, prescindiendo del detalle de sus
“eomponentes, La posibilidad de hacer referencia a toda la colección de elemenmediante un nombre único correspondiente al dato compuesto simplifica
muchos casos la escritura del programa que lo maneja.

9 Tipo registro (struct)

esquemas de tupla pueden usarse en programas en C£ definiéndolos como
:cturas del tipo regístro o struct. Un registro o struct es una estructura

 
240 Fundamentos de programación

 

de datos formada por una colección de elementos de información llamados
campos.

9.9.1 Definición de registros

La declaración de un tipo registro en Ci so hace utilizando la palabra clave:
struct de la siguiente la forma:
typedef struct Tipo-registro 4
Tipo-campo-1 nombre-campoTipo-campo-2 nombre-campo
 

 

Tipo-campo-N nombre-campo-N;

 

Cada una de las parejas Tipo-campo y nombre-campo, separadas por punto y
coma (5), define un campo o elemento componente y sn correspondiente tipo.
Además hay que tener en cuenta que la estructura acaba siempre con punto y
coma (5) Como ejemplos de definiciones tenemos:

typedef emu TipoNes £
Enero, Febrero, Marzo, Abril, Mayo,
Junio, Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre
%
typedef struct TipoFecha (
int dia;
TipoMes mes;
int anno;
de
typedef struct TipoPunto (
float x;
float y;
d

 

La sintaxis de la declaración de los tipos registro es la siguiente:
Tipo_registro 335 typedef struct Identificador_de_tipo_nuevo
4 Lista_de campos Y;
Lista_d +32 Campo ; [ Campo ; Y
Campo 3%= Identificador_de_tipo Identificador_de_campo

 

campos

   
 
  
  
   
    
  
   
  
   
  
 
 
  
  
    
    
   
   
   
   
  

Definición de tipos 241

 

9.9.2 Variables de tipo registro y su inicialización

¡Como siempre, para declarar variables de tipo registro es necesario haber
'ealizado previamente la definición del tipo del registro. Hay que recordar que
el Manual de Estilo de Ct no permite declarar variables de fipo anónimo. A
'sontinuación se detalla una declaración de variables:

Fecha ayer, ho)
Punto puntol, punto2;

 

bién estas variables se pueden inicializar en la declaración de una manera.
sejante a las formaciones agrupando los valores iniciales entre llaves (. ...+
separándolos por una coma (,), pero teniendo en cuenta el tipo de dato de

campo. A continuación se declaran nuevamente alguna de las variables
iores incluyendo su inicialización.

Fecha hoy = [ 12, Marzo, 2009 );
¡Punto puntol = f 12.5, -76.9 );

.3. Uso de registros

manejar datos estructurados de tipo registro se dispone de dos posibilidades:
con el dato completo, o bien operar con cada campo por separado. Las
ibilidades de operar con el dato completo son bastante limitadas. La única
ción admisible es la de asignación. El valor de un dato de tipo registro
asignarse directamente a una variable de su mismo tipo. Por ejemplo,
las definiciones anteriores es posible escribi

  

02 = puntol;

estas asignaciones debe cumplirse la compatibilidad de tipos. Dos estructu
son compatibles en asignación si son del mismo tipo, o de tipos sinónimos.

«es suficiente la llamada compatibilidad estructural; es decir, dos estructu
¡con los mismos campos no son compatibles si sus dofiniciones se hacen por
lo.

 

ón es posible pasar como argumento un dato de tipo registro a una
51 o procedimiento. Por ejemplo, podemos especificar los subprogramas
»ntes:

Leer el día, mes y año */

LeerFecha( TipoFecha € fecha ) £...)

Distancia entre pl y p2 */
Distancia( TipoPunto pl, TipoPunto p2 ) (...)

 
 

   
 
 
   
     
  

242 Fundamentos de programación

Las operaciones de tratamiento de estructuras registro consisten normalmente
en operar con sus campos por separado. La forma de hacer referencia a um
campo es mediante la notación:

registro. campo

Cada campo se puede usar como cualquier otro dato del correspondiente tipos.
es decir, se pueden usar los valores de los campos en expresiones aritméticas,
puede asignar valor a cada uno de los campos de una variable de tipo registro,
y se pueden pasar los campos como argumentos en llamadas a subprogramas.
Como ejemplo daremos una posible definición de los subprogramas anteriores:

/* Leer el día, mes y año */

void LeerFecha( TipoFecha € fecha ) (
int aux;

 

scanf( "Xd", faux

if ((aux> 0) 88 (aux <= 31 )) 1
fecha.dia = aux;

) else £
fecha.dia

)

LeerMes( fecha.mes );

scanf( "Xd", Saux );

fecha.anno = aux;

y

 

 

/* Distancia entre pl y p2 */
float Distancia( TipoPunto pl, TipoPunto p2 ) (
float dx, dy;

dx = p2.x - pl.x;

dy = p2.y - pl.y

return sqrt( dx*dx + dy*dy );
3

También es posible devolver como resultado un valor estructurado de
registro. Por ejemplo, es mucho más claro y natural escribir:
  
   
  
   
   
   
   
   

¡ón de tipos 243

 

to PuntoMedio( TipoPunto pl, TipoPunto p2 ) £
TipoPunto m;

m.x = (pl.x + p2.x) / 2.0,
my = (pL.y + p2.y) / 2.0
return

 

 

¡Punto a, b, centro;

ero = PuntoMedio( a, b );

.10 Ejemplos de programas

 

a finalizar este tema so recogen en este apartado varios ejemplos que utililos nuevos tipos introducidos.

 

10.1 Ejemplo: Cálculo del día de la semana de una fecha

¡Con este programa se calcula qué día de la semana corresponde a una fe¡cha cualquiera que se introduce como dato. Existen algoritmos que mediante
san cálculo matemático inmediato, permiten obtener el día de la semana para
¡uier fecha del calendario (ver algoritmo de congruencia de Zeller). Sin
'go, este ejemplo es un ejercicio de programación y se utilizarán directate las reglas con las que se conforma cada calendario. Para el cálculo se
me conocido que el día 31 de Diciembre de 1988 fue Sábado. El programa
“sirve para fechas desde el año 1989 hasta el año 2088.
declaraciones de los días de la semana y los meses son las empleadas en
llos apartados anteriores. Asimismo, se utiliza la función SunarDias descrita
¡en el apartado 9.222 para calcular el día de la semana que será dentro de N
«días conociendo el día de hoy.
“La función DiadelaSemana realiza el cálculo del día de la semana teniendo en
'guenta los siguientes aspectos:

 
   
   
  

+ El desfase en días de la semana que se introduce para cada mes, respecto
al mismo día del mes de Enero. Por ejemplo, el mes de Febrero son 3,
el mes de Marzo 3, .., el mes de Julio 6, etc.

+ Los años bisiestos son los múltiplos de 4.

+ Si el año es inferior a 89 se considera que es posterior al 2000.

+ Cada año bisiesto pasado incrementa en 1 día el desfase.

 
244 Fundamentos de programación

 

El procedimiento EscribirDia escribe el tipo de día resultante. El listado del
programa completo es el siguiente:

 

 

PARAR

* Programa: Calendario

* Descripción:

* Programa para el cálculo del día de la semana

* — que corresponde a una fecha comprendida entre:

* 1/1/1989 y 31/12/2088

RARA RRA REIR EIA RRR ORAR NARRAR RE ERRRRRRRAR RR AE

Kinclude <stdio.h>

typedef enun TipoDia £
Lunes, Martes, Miercoles, Jueves,
Viernes, Sabado, Domingo

)h

typedef emun Tipoles £
Enero, Febrero, Marzo, Abril, Mayo,
Junio, Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre

*

typedef struct TipoFecha (

int dia;

TipoNes mes;

int anno;

+

 

/

Función para sumar días de la semana ciclicamente

 

 

 

A =*/
TipoDia SumarDias( TipoDia día, int n) (
const int DiasSemana = 7;

int aux;
aux = (int(dia) + n) % DiasSenana;
return TipoDia(aux);

J
pu

 

 

Función para calcular el día de la
que corresponde a una fecha
TipoDia DiaDeLaSemana( TipoFecha fecha ) £
const int OrigenA = 89;
TipoDia TreintaUnoDiciembre88 = Sabado;

 

 

   
 

bool bisiesto;

ánt IncreBisis, IncreAnnos, IncreDias;
TipoMes M = fecha.mes;

nt A = fecha.anno;

Af (M == Enero) (
IncreDias = 0;
J else if (M == Febrero) (

 

 

 

 

  
  
 

IncreDias

3 else if (M == Marzo) £
IncreDias = 3;

3 else if (M == Abril) €
IncreDias = 6;

J else if (M == Mayo) £
IncreDias = 1;

) else if (M == Junio) (
IncreDias

) else if (M == Julio) £

IncreDias =
) else if (M == Agosto) (
IncreDias = 2;
) else if (M == Septiembre) £
IncreDias = 5;
J else if (M
Incredias =
J else if (M
IncreDias = 3,
) else (
IncreDias =
y
bisiesto = (A % 4) == 0;
if (A < Origena) (
A=A + 100; /* Año posterior al 2000 */
,
Increánnos = A - OrigenA; /* Años pasados desde el 89 */
IncreBisis = IncreAnnos/4; /* Bisiestos pasados */
IncreDias = IncreDias + fecha.dia + IncreAnnos + IncreBisis;
áf (bisiesto 88 (4 > Febrero) 4
IncreDias++;
3
return SunarDias( TreintaUnoDiciembreS8, IncreDias );

Octubre) (

 

 

Noviembre) (

  

 
246 Fundamentos de programación

 

   

PO

Procedimiento para escribir el día de la semana

void EscribirDia( TipoDia S ) £

 

   

if (S == Lunes) (
print£( "Lunes" );

) else if (S == Martes) (
print£( "Martes

) else if (S == Miercoles) 1
print£( "Miércoles" );

) else if (S = Jueves) €
print£( "Jueves

) else if (S = Viernes) €
print£( "Viernes" );

) else if (S == Sabado) (
print£( "Sábado"

) else £

 

  

 

 

 

 

 

 

printf( "Domingo" );

 

Procedimiento para leer una fecha (mes en número)

 

El
void LeerFecha( TipoFecha £ fecha ) £
int mes;

scanf( "Xd/Xd/kd", Efecha.dia, ames, ¿fecha.anno );
fecha.mes = TipoMes( mes=1 );
if (fecha.anno >= 100) (

fecha.anno = fecha.anno % 100;

 

Procedimiento para escribir una fecha

a

 

void EscribirFecha( TipoFecha fecha ) 1
print£( "x02d/X02d/%02d", fecha.dia, int(fecha.mes*1), fecha.anno );
3

 
)n de tipos 247

 

   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  

 

Programa principal

 

main() £

TipoFecha fecha; — /* fecha a manejar */
char tecla; /* tecla pulsada */
TipoDia Hoy;

TipoMes Pasado;

Hoy = Miercoles;
Pasado = Noviembre;
tecla = 'S';
while (tecla l= *N') 4
print£( "¿Dia Mes AñO(DD/MM/AA)? " );
LeerFecha( fecha );
print£( "Fecha: “ );
EscribirFecha( fecha );
print£( " Día de la semana: ");
EscribirDia( DiaDeLaSemana( fecha ));
tecla =**
print£( "Wmn¿Otra Fecha(S/N)?
while ((tecla l= 'S') 8% (tecla
scan£( "Xe", gtecla );
y
3

 

 

NY) 4

 

resultado de la ejecución del programa es el siguiente:

 

  
  
   
  
  
  
  

Mes AñO(DD/MM/AA)? 1/4/1993
:ha: 01/04/93 Día de la semana: Jueves

rra Fecha(S/N)? S
'a Mes AGO(DD/MM/AA)? 25/7/97
25/07/97 — Día de la semana: Viernes

“a Fecha(S/N)? S
Mes Año(DD/MM/AA)? 29/2/2000
ha: 29/02/00 Día de la semana: Martes

 

cra Fecha(S/N)? S
ia Mes AñO(DD/NM/AA)? 1/3/0
ha: 01/03/00 Día de la semana: Miércoles
248 Fundamentos de program:

¿Otra Fecha(S/N)? $
¿Día Mes Año(DD/MM/AA)? 13/3/2009
Fecha: 13/03/09 — Día de la semana: Viernes

¿Otra Fecha(S/N)? N

9.10.2. Frases palíndromas

   
 
  
  
 
  
  
 
   
  

Esto programa ilustra ol uso de vectores de caracteres. Se trata de com;
bar si una frase cs un palíndromo, esto es, si las letras de las que consta
leen igual hacia adelante que hacia atrás. Para ello se define un procedimi.
LeerTexto, capaz de leer un vector de hasta 100 caracteres. Este procedimis
to sólo guarda las letras válidas de la “a” a la 'z? incluyendo la “A (mayúsox
o minúsculas) y finaliza cuando se introduce un punto * o se llena el vec
pasado como argumento. Este procedimiento utiliza scanf leyendo carácter
carácter dando el tratamiento específico que se desea, en el que sólo se guard:
los caracteres mencionados.

La función predicado Simetrico es la encargada de comprobar que el conte:
do del vector, pasado como argumento por valor, es simótrico. Primeramente.
se busca el punto de final del texto a analizar o el final del vector. La posi
final se decrementa en uno después de la búsqueda para apuntar al pri
carácter válido. Después, se comprueba si coinciden los caracteros de un ex
tremo con los del otro. Esta comprobación acaba o bien cuando se cruzan
los índices y todos los caracteres han sido iguales o bien cuando no coinciden:

algunos de ellos.

El listado completo del programa es el siguiente:

 

 

A a
* Programa: Palindromo

= Descripción:

* Este programa comprueba si una frase es

* un palíndromo
Ae E /
tinclude <stdio.h>

+include <ctype.h>

  

const char Fin = * /* carácter final de la frase */
const int Maximo = 100; /* máxima longitud de la frase */
typedef char TipoCadena[Maximo];

 
Definición de tipos 219

 

[== rre
Procedimiento para leer una frase acabada
en punto (.) y dejarla en el argumento.
Sólo se guardan en el vector argumento las
letras a..z mayúsculas o minúsculas
incluyendo la ñ y Ñ y el punto final.

¡void LeerTexto( TipoCadena texto ) 4
int longitud
char caracter =

 

   

   
   
 

 

  

/*-- Leer y guardar sólo las letras de la frase --*/
printf( "¿Erase acabada en punto(.)2n" );
while (caracter != Fin) 88 (longitud < Maximo) 4
scan£("Xo",fcaracter);
if (((caracter>="a') 88 (caracter<="2')) ||
(Ccaracter>="A") £% (caracter<="2")) 11
(caracter=Fin) || (caracter=="K") ||
(caracter=="N")) [
texto[longitud] = toupper(caracter);
longitud++;

 
 

 

  

Función que comprueba si coinciden las letras en
posiciones simétricas: La frase es un palíndromo

 

Simetrico( const TipoCadena Texto ) €

int á, j:

/*-- 1%: Buscar el punto final --*/
ie (reno 1= Fin) 88 (GMaximo)) £
qa

     

/*-- 29: Comprobar igualdad entre simétricos =--%/

i=0;

while ((i < 3) 88 CTexto[i]
i++

 

Texto[41)) £

 
  

250, Fundamentos de programaci

 

 

3%: Es palíndromo si coincide todo --*/
return 1 >= J;
,

tn
Programa principal

 

 

*./
int main() (
TipoCadena frase;
LeerTexto( frase );
if (Simetrico( frase )) (
print£(” Es PalíndromoWn'
Y else (
print£(" No es PalínéromoWn");
J
,

 

 

El resultado de la ejecución del programa es el siguiente:

 

 

¿Frase acabada en punto(.)?
Dabale arroz a la zorra el abad.
Es Palíndromo

9.10.3 Ejemplo: Cálculos con fracciones

   
 
   
  

Como ejemplo de empleo de registros, se reescribe completo el programa del
tema 8 para realizar cálculos con fracciones. La nueva versión utiliza siempre
funciones para devolver un resultado de tipo registro. Esta solución es más
natural y nos introduce el concepto de nuevo de tipo de dato (TipoFraccion) y
sus operaciones. El listado completo del programa se ¡muestra a continuación:

PARAR ERRE
* Programa: Fracciones?

* Descripción:

* Este programa es una calculadora que suma,

* resta, multiplica y divide fracciones.

* Solución utilizando registros y funciones.
An /

*include <stdio.h>

typedef struct TipoFraccion (
int nunerador;

int denominador;

»
 
  
 
    
   
 
 
  
    
  
    
 

Definición de tipos 251

 

a pa
Procedimiento para simplificar una fracc
Devuelve la fracción £ reducida

 

 

 

 

A
ReducirFraccion( TipoFraccion € £ ) £
int divisor =

 

while (divisor <= f.numerador) 88
(divisor <= f.denominador)) £
while ((f.numerador % divisor == 0) 44
(£.denominador % divisor == 0)) €
£.numerador = f.numerador / divisor;
£.denominador = £.denominador / divisor;
y

divisor++;

 

y

 
   
  
   
 
 
 
    
 

Función para sumar fracciones.
Devuelve reducida la suma de f1 y f2

*/

¡Fraccion SumarFracciones( TipoFraccion £1, TipoFraccion £2 ) £
TipoFraccion suma;

 

 

 

'suna.numerador = £1.numerador*f2.denominador +
£2.numerador*£1.denominador;

suna.denominador = f1.denominador*£2.denominador;

ReducirFraccion( suma );

return suma;

  
      
  

Función para restar fracciones.
Devuelve reducida la resta de £1 y £2
.- rail

»Fraccion RestarFracciones( TipoFraccion fl, TipoFraccion f2 ) f

£2.numerador = — £2.numerador;
return SumarFracciones( £1, f2 );
 

252 Fundamentos de program:

 

Función para multiplicar fracciones.

Devuelve reducido el producto de £1 y £2

Y

TipoFraccion MultiplicarFracciones( TipoFraccion f1, TipoFraccion f2 )
TipoFraccion producto;

 

 

producto.numerador = £1.numerador * £2.numerador;
producto.denominador = f1.denominador * £2.denominador;
ReducirPraccion( producto )
return producto;

3

 

A
Función para dividir fracciones.
Devuelve reducido el cociente de £1 y £2

 

 

 

7
TipoFraccion DividirFracciones( TipoFraccion f1, TipoFracción £2 ) £
TipoFraccion cociente;

cociente.numerador = £1.numerador*£2.denominador;
cociente.denominador = £1.denominador*f2.munerador;
ReducirFraccion( cociente );
return cociente;

J

 

Jr
Procedimiento que lee una fracción.
Devuelve reducida la fracción leída

void LeerFraccion( TipoFraccion 4 £ ) £
scanf( "Xd/%d", £f.numerador, £f.denominador );
ReducirFraccion( £ );

 

 

 

Pp

 

$

 

y a
Procedimiento que escribe
una fracción £

 

 

Er
void EscribirFraccioní TipoFraccion f ) £
print£( "Xd/%dWn", f.numerador, F.denominador

 

y
   
   
  
  
     
   
  
   
 
   
   
  
   
   
  
   

main) (
¡Fraccion acumulador = £ 0, 0 ); /* acumulador = 0/0 */
¡Fracción operand /* nuevo operando a utilizar */

operación ; /* tecla de operación */

 

(operacion
print£( ">> "y;
scanf( " Xe", Soperacion );

yx

 

 

 

Af (operacion == '+") £
LeerFraccion( operando );
acumulador = SunarFracciones( acumulador, operando );

) else if (operacion == '-") £
LeerFraccion( operando );
acumulador = RestarFracciones( acumulador, operando );

) else i£ (operación == **") (
Leeriraccion( operando );
acumulador = MultiplicarPracciones( acumulador, operando );

 

 

) else if (operacion == */') [
LeerFraccion( operando );
acumulador = DividirFracciones( acumulador, operando );

) else if (operacion == 'N') £ /* Nuevos cálculos */
LeerFraccioní acumulador );

 

) else if (operacion == '=") 4
print£(” $
EscribirFraccioní acumulador );

 

) else if (operacion l= *F*) [

print£( "Pulse +, =, *%, /, N, =, 0. F9" );

 

y
,

 

este ejemplo cada fracción se almacena como un registro con dos campos,
:pondientes al numerador y al denominador, respectivamente. Compalo esta versión con la del tema 8 se aprecia que las cabeceras de los sub'amas, y por tanto las llamadas, son ahora más sencillas y naturales. El

   

 

 
254 Fundamentos de programación

 

precio a pagar es una ligera complicación al tener que hacer referencia a los
valores de numerador y denominador como campos de registros, y no directa
mente como argumentos separados.

El resultado de una ejecución de ejemplo se muestra a continuación:

 

>> 3
Pulse +, -, *, /,N,=,0F
>> N 45/78
>» =
15/26
>> 6/9
>».
97/78
> -4/5
»173/390
>» 2/3
>» 173/585
> F
  
 
   
    
   
  
  
  
  
  
      
  
  

ema 10

mpliación de estructuras de
ontrol

tes de pasar al estudio de las estructuras de datos complejas, se completa
repertorio de estructuras de control más frecuentes en los lenguajes impeivos, detallando las construcciones adoptadas en C4.

presentan algunas variantes para realizar la iteración y la selección, derivade las estructuras fundamentales, mostrando la. posibilidad que existe de
:amarlas en función de ellas.

10.1 Estructuras complementarias de iteración

10 se explicó en el tema 5, la programación estructurada propone la utiión del WHILE como estructura iterativa fundamental. Esta estructura
para poder realizar cualquier programa. Sin embargo, en el mismo tema.
también fue introducida la estructura FOR cuya utilidad fundamental es
“amar un número de iteraciones que se conoce a priori y que no depende la evolución de los cálculos realizados en cada iteración. La razón de
exista el FOR prácticamente en todos los lenguajes, es precisamente lo
.nte de este tipo de iteraciones y la facilidad que proporciona su uso en
casos.

estructuras iterativas que se explican en este apartado están también dis¡bles habitualmente en todos los lenguajes y pretenden facilitar la prograión de situaciones concretas y frecuentes. Utilizaremos en las explicaciones
sentencias disponibles en C£ para programar las muevas estructuras.

 
  
   
   
  
  
  
  
   

Fundamentos de program:

Será objeto de un apartado especial la sentencia continue de C2 que se pa
utilizar con cualquier tipo de bucle. Esta sentencia salta a la siguiente it
ción, lo que es necesario cuando no tiene sentido completar todos los cáll
previstos en la iteración en curso.

10.1.1 Repetición: Sentencia DO

A veces resulta más natural comprobar la condición que controla las iteraci
al finalizar cada una de ellas, en lugar de hacerlo al comienzo de las mis
En este caso, como se muestra en la figura 10.1, siempre se ejecuta al m
una primera iteración.

sr
Figura 10.1 Repetición.

El formato de la estructura de repetición en Ct es el siguiente:
do £

Acción
) while ( Condición );

La Condición que controla las repeticiones es una expresión cuyo resultado
un valor de tipo bool. Si el resultado es true se vuelve a ejecutar la Acción y
cuando el resultado es false finaliza la ejecución de la estructura.

Una situación típica en que resulta cómodo el empleo de esta sentencia es la:
que se produce cuando al finalizar cada iteración se pregunta al operador
desea continuar con una nueva. En todos estos casos, el programa siempre
ejecuta la primera iteración y pregunta si se desea o no realizar otra más. Par
ejemplo:
 
  
 
 
 
 
    
   
   
  
   
 
  
   
 
  
   
   
   
  
   
  
   

pliación de estructuras de control 257

 

t
Operación

ftecla );

5);

todos los programas realizados en los temas anteriores se ha podido prograesta forma de operar utilizando la sentencia while. Sin embargo, en los
“amas desarrollados ha sido necesario forzar la primera iteración inicialila variable que controlaba la iteración a un valor igual al necesario para
iteración. Para el mismo ejemplo anterior, esto se realizaría de la siguiento

 

print£( "¿Otra operación (S/N)?
scanf( " Xe”", átecla );

   

solución es menos elegante y además tiene como inconveniente la necede inicializar la variable de control, con lo que en caso de olvido, la
:ción puede ser impredecible, Como se sabe, las variables pueden tomar
riamente cualquier valor inicial y, dependiendo del mismo, se ejecutao no la primera iteración. Para estas situaciones es muy aconsejable la
1 de una estructura de repetición que evita todos estos problemas.

 

 

 

¡bién resulta adecuado el empleo de la repetición cuando solamente son váunos valores concretos para una determinada respuesta. Si la respuesta
es correcta se solicitará de muevo y no se continuará hasta obtener una res'a dentro de los valores válidos. La filosofía en este caso es práct
“misma del caso anterior, por ejemplo:

1

print£( "¿Mes Actual?" );

scanf( "Xd", Gmes );

<mhile (nes < 1) || (nes > 12);

 

temente la utilidad de la repetición no está ligada exclusivamente a
casos indicados. En general, es aconsejable su uso cuando se sepa que al
s es necesaria una iteración y por tanto utilizando la sentencia while es
o forzar las condiciones para que dicha iteración se produzca.

 
258 Fundamentos de programación

 

10.1.2 Sentencia CONTINUE

La sentencia continue dentro de cualquier clase de bucle (while, for o do)
finaliza la iteración en curso e inicia la siguiente iteración. A veces, dependiendo de la evolución de los cálculos realizados en una iteración, no tiene
sentido completar la iteración que se está realizando y resulta más adecuado
iniciar una nueva. Esto puede suceder cuando alguno de los datos suministrados para realizar un cálculo es erróneo y puede dar lugar a una operación
imposible (división por cero, raíz do un número negativo, etc.). En este caso lo
adecuado es detectar la situación y dar por finalizada la iteración e iniciar una
nueva iteración con nuevos datos de partida. Por ejemplo, supongamos que
tenemos un vector de N coeficientes por los que hay que dividir al realizar un
cierto cáleulo salvo obviamente cuando uno de los coeficientes sea cero. Esto
se programaría de la siguiente manera:

for (int i=0; 1 <Nj 14) 4

l£ ( vectorCoeficientes[i] == 0) (
continue;
>

calculo = calculo / vectorCoeficientes[i

 

,

Como se puede ver en el ejemplo, la sentencia continue siempre estará incluida
dentro de otra sentencia condicional puesto que en caso contrario nunca se
ejecutaría la parte de la iteración posterior a la sentencia continue. En un
for, tal como el del ejemplo anterior, al finalizar la iteración se comprueba la.
condición de terminación i < N y si no es cierta se incrementa el índice i++
antes de iniciar la siguiente iteración. En los otros bucles sólo se comprueba
la condición de finalización para ver si procede seguir con una nueva iteración.

 

10.2 Estructuras complementarias de selección

 

Para la selección entre varias alternativas es suficiente disponer de la estructura IF, estudiada en el tema 5. Do hecho, existen lenguajes en los que la única
sentencia disponible para la selección es la propuesta por la programación estructurada, que permite solamente la selección entre dos alternativas. La falta
de claridad cuando se utilizan varias selecciones anidadas aconseja disponer
de una sentencia de selección en cascada como la estudiada en el tema 5.
 
  
  
     
  
  
 
   
   
  
  

¡pliación de estructuras de control 259

 

Por las mismas razones de claridad y sencillez es habitual disponer de una

 

¡cia que permite una selección por casos. Este apartado está dedicado
jusivamente a dicha sentencia, estudiando la sintaxis y semántica que tiene

Ct.

10.2.1 Sentencia SWITCH

¡Cuando la selección entre varios casos alternativos depende del valor que toma
¡ana determinada variable o del resultado final de una expresión, es necesario
comparaciones de esa misma variable o expresión con todos los valores
¡gue puede tomar, uno por uno, para decidir el camino a elegir. Así, en el
"programa para el cálculo del día de la semana del tema anterior con la variablo
'M que guarda el mes teníamos:

(M == Enero) £

IncreDias = 0;

else if (M == Febrero) (

IncreDias = 3;

else if (M == Marzo) (

IncreDias =
else if (M
IncreDias = 6;

 

Abril) 4

 

 

else if (M == Octubre) £
IncreDias
else if (M
IncreDias
else [

IncreDias = 5;

 

  

Noviembre) (

 

¡Esto supone una sentencia larga y reiterativa, si se tiene en cuenta que además
¡para algunos casos, por ejemplo los meses de Febrero, Marzo y Noviembre, se
sepite la misma acción.

¡Silo que se necesita es comparar el resultado de una expresión, dicha expresión
"se reevaluará tantas veces como comparaciones se deben realizar (a menos que
se disponga de un compilador optimizante). En este caso y por razones de
simplicidad y eficiencia es aconsejable guardar el resultado de la expresión en
“ana variable auxiliar y realizar las comparaciones con dicha variable utilizando
sl esquema de selección por casos mostrado en la figura 10.2.

¡Si el tipo de valor que determina la selección es un tipo ordinal: int, char o
'enumerado, se dispone en C£ de la sentencia switch cuya estructura permite
 

260, Fundamentos de programación

  
 

default

Figura 10.2. Selección por casos.

agrupar los casos que tienen el mismo tratamiento y en la que se evalúa solas
mente una vez la expresión x. La sintaxis se ilustra con el siguiente ejemplo.
que muestra cómo las distintas vías de ejecución so asocian a grupos de valores
que pueda tomar la expresión o variable x; acciónA con el valor m5, acción
con los valores de 1, vy y 14, acciónC con los valores 15 y 1, y establecien=
do como vía alternativa la acciónH] para el resto de valores distintos de los
anteriores:

 

switch (expresión) (
case valor:
acciónA;
break;
case valor?
case valor3:
case valorj
acción E;
break;
case valoró:
case valoró:
acciónC;
break;

 

 

 

default
acciónil;

,

La sentencia comienza con la palabra clave switch y a continuación, entre
paréntesis, se indica la expresión o variable cuyo valor determina los casos
que se quieren analizar, seguida del símbolo de abrir llave (1). Para cada
vía de ejecución posible se detallan primeramente los valores que debe tomar.
la expresión, precedidos por la palabra clave case y seguido por dos puntos

 
 
  
  
  
  
   
   
 
 
 
 
 
    

¡pliación de estructuras de control 261

 

La correspondiente acción como una secuencia de sentencias se detalla a
tinuación de los correspondientes valores.

Manual de Estilo para C£ impone que cada acción finaliza siempre con la.
tencia break para que finalico la sentencia switch después de cada acción.
por error se omite la sentencia break, se continuaría ejecutando la acción
siguiente o siguientes casos, Aunque en C/C++ el uso del break es opJ, en Ci es obligatorio para lograr una programación estructurada fácil
entender y verificar. Además, se evita la ambigiledad de si la ausencia del
Jak es intencionada o es una omisión por error.

La alternativa para el resto de los valores es opcional, y va precedida de la
¡palabra clavo default. La sentencia finaliza con el símbolo de cerrar llave (3)

Esta sentencia no se puede utilizar cuando la variable o ol resultado de la
“expresión que controla la selección sca de tipo float 1 otro tipo no simple
En estos casos no queda más remedio que emplear la sentencia de selección
general o en cascada.

¡Como ejemplo se reescribe la selección anterior, según el mes:

itch (M)

case Enero:

case Octubre
IncreDias =
break;

case Mayo:
IncreDias = 1;
break;

case Agosto:
IncreDias
break;

case Febrero:

case Marzo:

 

  

 

 

 

break;

case Septiembre:

case Diciembre
InereDias =
break;

default:
Inerebias = 6;

 
 

 

 

 
 

|

 

262

    
  
  
  
  
   
 

Evidentemente esta sentencia da lugar a un fragmento de programa más
y fácil de entender.

En la sentencia switch se deben incluir todos los posibles valores que
tomar la variable o expresión. Cuando se obtiene un valor que no está.
a ninguna vía (y no hay alternativa default), el programa finaliza por
Si lo que sucede es que existen valores para los que no se debe realizar ni
acción, entonces estos valores se deben declarar asociados a una acción
Por ejemplo:
switch (M) (£

case Enero:

case

case

case

 

case Agosto:
case Septiembre:
case Octubre:
case Noviembre:
break;
case Junio:
case Diciembre:
sueldo = sueldo + extra;
break
)

Otra forma de conseguir esto mismo es mediante una alternativa def:
vacía utilizando sólo un punto y coma (5). Por ejemplo:
switch (0) (
case Junio:
case Diciembre:
sueldo = sueldo + extra;
break;
default:

 

7

 

La diferencia entre ambas es que en el primer caso se produciría un error q!
finalizaría la ejecución del programa si por cualquier causa la variable M ti
un valor fuera del rango de meses declarado de Enero ... Diciembre.
el segundo caso no se distingue la situación errónea de la que no lo es. Si
programa está completamente probado, es muy probable que tal situación
se produzca nunca. Sin embargo, cuando un programa cstá todavía en fa
 
  
  
 
    
  
 
 
   
  
  
   
   
   
   
   
  
  
 
 
  

Ampliación de estructuras de control 263

de prueba es importante conocer todos los errores para analizar sus causas y
"corregirlos.

Para acabar este apartado se detalla la sintaxis formal de la sentencia switch
de Ct:

Sentencia_SWITCH

 

3= switch ( Expresión ) £ Lista_de_casos Y

Lista_de_casos 333 Caso Í Caso )
[ default: Secuencia_de_sentencias ]

 

Caso $3= Lista_de_opciones Secuencia_de_sentencias break ;

case Valor : [ case Valor : )

tipo del resultado de la Expresión y cada Valor de la lista deben ser combles.

 

Lista_de_opciones

0.3 Equivalencia entre estructuras

'o ya ha sido explicado, las estructuras básicas estrictamente necesarias
la programación estructurada son la selección entre dos alternativas 1£ y
iteración while. Éstas se pueden considerar las estructuras primarias. El
, que denominaremos estructuras secundarias, son en general más comjas y tienen como objetivo lograr programas más sencillos en situaciones
¡culares,

Iquiera de las estructuras secundarias siempre puede ser expresada en fundelas primarias. Sin embargo, no siempre es posible expresar una sentenprimaria en función de una secundaria. Por ejemplo, no se puede realizar
iteración while condicionada por más de una variable do tipo simple mefte una estructura for de Ct. Tampoco es posible realizar una selección
condicionada por los valores que toma una expresión real mediante una
ictura switch

:que a lo largo de las explicaciones del tema 5 y en este mismo tema se
ido mostrando ciertas transformaciones y equivalencias entre estructuras,
este apartado a modo de resumen se muestra cómo cualquier estructura
¡daria se puede realizar mediante las estructuras primarias,

3.1 Selección por casos

estructura también se puede realizar mediante selecciones en cascada.
la estructura siguiente:

 
 

264 Fundamentos de program:

 

switch (Expresión) (
case vi:
Sentenciasa
break.
case v2
case v3
case vá:
SentenciasB
break;
case v5
case vÓ :
SentenciasC
break:

 

default
SentenciasH

,

se puede realizar de la siguiente forma:

valor = Expresion;

if (valor == v1) (
SentenciasA

) else if ((valor == v2) || (valor == v3) || (valor
SentenciasB

) else 1£ ((valor
SentenciasC

 

va) £

 

v5) || (valor = v6) 4

J else £
SentenciasH
)

Esta construcción se puede poner a su vez en función de la estructura básica:
if, de forma anidada.

10.3.2 Bucle con contador

Esta estructura se puede hacer mediante un control explícito del contador del
bucle, Sea la estructura siguiente:

 

for (int indice = Inicial; indice <= Pinal; indice++) (
Sentencias

3

Cuando el incremento es positivo se puede realizar de la siguiente forma:
 
  
  
  
   
 
 
  
 
   

Ampliación de estructuras de control 265

indice = Inicial;

¡le (indice <= Final) £
Sentencias

indice++;

 

:ndo el incremento es negativo la comparación so dobe hacer por mayor o
en lugar de por menor o igual.

10.3.3. Repetición

sentencia do se puede transformar en while forzando la ejecución incondide la primera iteración. La estructura:

 
 
 
   
    
 
   
 
   
  
  
    
  

1
Sentencias
(Condición);

puede convertir en esta otra:

-ncias
le (Condición) €
Sentencias

 

bien, usando una variable auxiliar para almacenar el valor de la condici
ir = true;

(seguir) £

Sentencias

seguir = Condición;

.4 Ejemplos de programas

este apartado se recogen algunos programas completos que utilizan las esvuras estudiadas. Algunas partes de estos programas ya han sido utilizadas
los ejemplos presentados a lo largo de este tema.

 

.4.1 Ejemplo: Imprimir tickets de comedor

'trata de confeccionar un ticket mensual de comedor con la cantidad a pagar
:ndiendo de los días laborables de cada mes y descontando las ausencias

 
266 Fundamentos de progr:

  
   
 
 
 

de cada persona. El objetivo fundamental es ilustrar el uso de la selección
casos en función del tipo enumerado de los meses del año. La selección
mes se realiza mediante una sentencia de repetición que controla que el
este comprendido entre 1 y 12. Asimismo, el programa permite confecci
todos los tickets necesarios hasta indicar que no se quiere continuar mé
un bucle repetitivo controlado por una respuesta del tipo Si/No. El li
completo del programa es el siguiente:

 

 

 

 

 

Ja
* Programa: Comedor

* Descripción:

* Programa para realizar el ticket

* — de pago de un comedor
AAA A/

tinclude <stdio.h>

int main) €
const float Menu =8.
const float IVAMenu =7.!

/* precio del menú */
/% 7% IVA del menú */

 

typedef enun TipoMes (
Enero, Febrero, Marzo,
Abril, Mayo, Junio,
Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre

 

TipoMes mes; /* mes a pagar */
int dias, diasPagar, diasFaltas, aux;
float total, totalIVA;

char tecla;

ye
do £

print£( "¿Mes? " );

scanf( "Xd", daux );
) while ((aux < 1) || (aux > 12);
mes = TipoMes( aux-1 );

 

Leer y validar el mes leído --*/

 

/*-- Calcular días según el mes —-*/
switch (mes) (
case Agosto:
dias = 0;
break;

 
Ampliación de estructuras de control 267

 

case Enero:
case Abril:
case Diciembre:
dias = 17;
break;
case Febrero:
case Septiemb
dias = 20;
break;
case Junio:
case Noviembre:
dias = 21;
break!
case Marzo:
case Julio:
dias = 22;
break:
case Mayo:
case Octubre:
dias = 23;

 

 

 

 

 

- Confeccionar los tickets a partir de las ausencias
do

printf( "¿Total de Ausencias? " );

scan£( "xd", ádiasFaltas );

print£( *
 

 

 

Any;

diasPagar = dias - diasFaltas;
total = diasPagar*Menu;
totalIVA = total*IVAMenu/100.0;

 

print£( " RECIBO de COMEDOR" );

printf( "Comidas Precio Totaln" );

printf£( "%44%11.2f413.2fin", diasPagar, Menu, total );

print£( " %3.1£ %% IVA %6.2fin”", IVAMenu, totalIVA );
printf( " Total Recibo %8.2f Eurosin", total+totallVA );
printe( * ds

 

tecla =
print£( "¿Otro Recibo(S/N)? " );

= '5') 8% (tecla l= 'N)) €
étecla );

 

     

) while (tecla l= 'N');

 

 
 

 
 
   
    
  

Fundamentos de progr:

  

Un ejemplo del resultado de la ejecución del programa es el siguiente:

 
 

¿Mes? 4
¿Total de Ausencias? 5

  
       
     
   
   
  

RECIBO de COMEDOR
Comidas — Precio Total
12 8.50 102.00
7.0 % IVA 7.14
Total Recibo 109.14 Euros
¿Otro Recibo(S/N)? $
¿Total de Ausencias? 7

     
   
        
   
 
  
   
   
  

RECIBO de COMEDOR
Comidas — Precio Total
10 8.50 85.00
7.0% IVA 5.95
Total Recibo 90.95 Euros

¿Otro Recibo(S/N)? N

10.4.2 Ejemplo: Gestión de tarjetas de embarque

Este programa realiza la gestión automática de los asientos de un avión
imprime las tarjetas de embarque, Cuando varios pasajeros solicitan jun
las tarjetas do embarque se les asignan asientos de la misma fila. Si no exis
asientos de la misma fla se ocupan los Imecos libres. El número de tarjetas
embarque que se pueden solicitar simultáneamente es como máximo de 6.
asientos se gestionan como tn vector de filas al que inicialmento se le asi,
un determinado núxero de asientos por fila.

  
  

 

El procedimiento BuscarPlazas es el encargado de realizar el algoritmo
situar las plazas solicitadas. En un primer intento se trata de asignar las nuevas
plazas en la misma fila. Como segundo intento se asignarán las plazas en filas
distintas, Cuando no hay suficientes plazas disponibles sc dará un mensaje.
Este procedimiento actualizará las plazas disponibles y el número total de:
plazas libres después de la asignación. Otro procedimiento es el encargado de
imprimir las tarjotas de embarque cuando se ha encontrado sitio.

 

Para comprobar la situación de los asientos libres se dispone de un procedi
miento que imprime las plazas libres y las ocupadas. El programa consiste
on un menú que utiliza el procedimiento para la búsqueda y el procedimiento

 
   
   
   
  
  
 
   
   
 
    
  
  
   
  

liación de estructuras de control 269

mostrar la situación según elección del operador. Todo el programa ostá
lo en base a las constantes del aforo, y el tamaño de la fila, Cualquier
de avión de un mismo formato se puede gestionar cambiando estas
constantes. El listado completo del programa es el siguiente:

 

Programa: Mostrador

 

Descripción:
Este programa confecciona tarjetas de embarque
y asigna plazas en la misma fila si es posible

 

q AAA AREA
<stdio.h>
int Aforo = 60; /* total asientos */

int AsientosFila = 6; /* asientos por fila */

't int Filas = Aforo/AsientosFila;
int Pasillo = AsientosFila/2;

 

:£ int Plazas[Filas];

Mostrar ocupación del avión */
PintarPlazas(const Plazas P) (
for (int i=0; 1 < Filas; 1er) £
for (int j = AsientosFila; j >= 15 3 £
if (j = Pasillo ) £
printEc ot);
,
if (G> Pit
printf(" (0;
Y else £
printfc” (0;
3
,
print£( "a" );
3

 

Imprimir una "tarjeta de embarque” */
ImprimirTarjeta( int fila, int asiento ) 4

 

 

print£( An");
print£( TARJETA DE EMBARQUE Ia" y;
printí( Fila :X3d", fila );

print£( Asiento :%X3d |yn”, asiento );
print£( y;

 

 
 

J

/** Buscar plazas libres contiguas */
void BuscarPlazas( int nuevas, int £ libres, Plazas sitios ) (
int ind, nue, dispo, aux;

if (nuevas <= libres) 4
/*-- Buscar plazas en la misma fila --*/
ind = 0;
mue = nuevas;
while ((ind < Filas) 8% (mue > 0)) (
dispo = sitios[ind];
if (nue <= dispo) (
aux = AsientosFila - dispo;
for (int 4 = 1; 1 <= mue; 14) (
ImprimirTarjeta( ind+1, auxei );

 

y
sitios[ind] = sitios[ind] - nuez
libres = libres - nue;
nue = 0;
y
inde;
y

/*—- Buscar plazas en cualquier fila --*/
ind = 0;
while (nue > 0) (
dispo = sitios[ind];
1£ (dispo > 0) (
aux = AsientosFila - dispo;
for (int i = 1; i <= dispo; i++) 1
InprimirTarjeta( ind+1, auxei );

 

J
sitios[ind] = sitios[ind] - dispo;
libres = libres - dispo;
nue = nue - dispo;
J
inde+;
)
) else £
print£( "No hay plazas suficientestn" );
3
)

 
liación de estructuras de control 271

 

Programa principal */
mainQ) (

Plazas pasaje;

int sitiosLibres = Aforo;
char tecla;

Ant aux;

   
     
 
   
 
 
 

for (int i=0; 1 < Filas; de) 1
pasajeli] = AsientosFila;
J
dol
print£C "Wn¿Opción (Tarjetas, Pasaje, Fin)? " );
scanf( " Xe", ttecla );
switch (tecla) (
case 'T':
do í
print£( "¿Número de plazas (1 a 6)? " );
scan£( "Xd", faux );
) while (aux < 1 || aux > 6);
BuscarPlazas( aux, sitiosLibres, pasaje );
break;
case 'P':
PintarPlazas( pasaje );
break;
default:

 

3
3 while (tecla l= 'F");

 

«continuación se muestra un fragmento de la ejecución del programa:

 

   

vión (Tarjetas, Pasaje, Fin)? P

E) 000
5) Mm Y (4% €%
00606 0.0
E) 1) 0) EH 13 02
E) E) (7 € £J El
BY) () (2 E) ES CI
OOO (y EY €
O 0) CY) (> €)
OOO EY E% €)
O. (10) Ed (2 7
 

   

¿Opción (Tarjetas, Pasaje, Fin)? T
¿Número de plazas (1 a 6)? 5

 

| TARJETA DE EMBARQUE |
| Fila: 4 Asiento: 11

 

| TARJETA DE EMBARQUE |
| Fila: 4 Asiento: 2 |

  

 

 

| TARJETA DE EMBARQUE |
| Fila: 4 Asiento: 5 |

 

  

¿Opción (Tarjetas, Pasaje, Fin)? P

0 0 0
0 10. ¡SN
0 0 0.0
O 0.
69 €% €) 9 3
Ey 09 E) (y 3
EX 4) (9 O 0
CY EF EY 0.0
() (1) 6) O 0
CY £% (7 A e

¿Opción (Tarjetas, Pasaje, Fin)? T
¿Número de plazas (1 a 6)? 2

 

| TARJETA DE EMBARQUE |
| Fila: 2 Asiento: 4 |

 

| TARJETA DE EMBARQUE |
| Fila: 2 Asiento: 5 |

 

 

Fundamentos de pro;
  

ión de estructuras de control

 
 
 
   
   
  
   
 

  

ión (Tarjetas, Pasaje, Fin)? P

0 0. 0 0
0 0 0 0 A
) 1 e) (1) ()
Da 0) 4) ()
OS () CY €)
0 CY 6) €)
Dd cd <<) €)
DD cr C3 23 £) €)
(1) O e) El 3
). Cd E (1) 1) €)

ión (Tarjetas, Pasaje, Fin)? F

.3 Ejemplo: Calculadora

 
 
 

programa simula una pequeña calculadora que realiza las cuatro ope
mes aritméticas básicas (suma, resta, multiplicación y división), tiene 4

ciones de memoria (A, B, C y D) para guardar resultados intermedios y

:ás indica los errores que se producen al escribir las operaciones a reali
- El programa es un ejemplo de combinación compleja de estructuras de

1 de diferentes clases: selección sencilla o múltiple, bucles normales o
nidos, con salida intermedia, etc.

 
 
   
  
    
  
 
   
  

 
  

programa leo como entrada líneas de texto con las operaciones a realizar.
línea de entrada puede contener una o varias expresiones terminadas
punto y coma (5). Cada expresión está formada por una secuencia de

dos y operadores, que se evalían estrictamente de izquierda a derecha.

operando puede ser cualquiera de las 4 posiciones de memoria o un valor
érico. Los valores numéricos sc indican mediante una secuencia de dígitos
0 al 9 sin blancos ni ningún otro carácter entre ellos. Es decir, los operannuméricos literales son valores enteros, pero los cálculos se realizan con
reales, de manera que un cociente puede dar un resultado con parte
maria.

 
  

operador puede ser el símbolo de una operación aritmética (+, =, *, /).
más el resultado en un punto cualquiera se puede guardar en una posición
memoria indicándolo mediante el signo igual (=) seguido de la posición (A,
CoD).

final del programa so indica usando un punto (.) al final de la última
sión, en lugar de un punto y coma.

 

ejemplos de expresiones válidas las signientes:

 
   
 
   
 
 
 
   
  
 

274 Fundamentos de programación

 

1232 * 456 = A;
A+34=B-5; A/B+7 5

 

El procedimiento LeerCaracter lec el siguiente carácter de la entrada y hace
eco por la salida. También permite releer el carácter anterior si no se
procesado efectivamente, sino que sólo se ha leído para detectar el final de
valor numérico. Además detecta el final del texto de entrada, devolviendo wa
carácter mulo en ese caso.

El procedimiento LeerSimbolo es el encargado de convertir grupos de carac
teres de entrada en el símbolo currespondiente. Si es un operando numéri
calcula además su valor,

 

El procedimiento Leer0perando lee el siguiente símbolo, comprueba que es un.
operando numérico o referencia a memoria, y en ese último caso recupera
valor almacenado.

El programa se plantea como un bucle indefinido en el que se analizan
ejecutan las operaciones que se introducen hasta cl punto final, o hasta agotar.
el texto de entrada. Se detectan los errores en los operandos, en los operad
y la falta de alguno de los símbolos necesarios. En caso de error se ignora el
resto de la expresión y se continúa con la siguiente, si la hay. El listado
completo es el siguiente:

 

 

ARA RRA
* Programa: Calculadora

* Descripción:

* Este programa simula una calculadora con las

% — cuatro operaciones básicas (+,-,*,/) y cuatro

* posiciones de memoria. Analiza y evalúa las

* expresiones e indica los errores que contengan,
* si los hay

AAA AAA AAA
include <stdio.h>

*include <stdlib.h>

typedef emum TipoSimbolo £
Numero, Memoria, Operador, Terminador, Desconocido


char e =* *; /% carácter leído */

bool releer; /* ya leído de antemano */

TipoSimbolo simbolo; /* símbolo leído y */

float nunero; /* su valor nunérico */

char caracter; /* o de texto */

bool primero; /* primer símbolo de una operación */

  
 
 
  
      
   
  
  
 
 
  
   
 
   
 
  

¡pliación de estructuras de control 275

 

float TipoMemoria[4];
ria memorisABCD; /* 4 memorias */

 

Leer siguiente carácter y hacer eco
Devuelve nulo al final del fichero

 

 

— MS RescSto
LeerCaracter() (£
if (primero) £ /* leer saltando espacios */

primero = false;
releer = false;

 

%o", ko);
if (releer) [ /* ya estaba leído de antemano */
releer = false;

 

 

) else £ /* lectura normal */
e= 0%;
scanf( "Xc", dc );

J

print£( "Xc", c);  /* hacer eco */

DP

poa
Procedimiento para reconocer el siguiente símbolo
y dejarlo en 'simbolo', 'numero' y 'caracter*
LeerSimbolo() (
do (
LeerCaracter(.
) mile (0 =="
caracter = c;
switch (c) £
case *
case
case
case
case

 

 

 

 

 

ie

 

 

 
   
   
    

simbolo = Memoria;
break;
     

Fundamentos de progra:

  

case '9"

simbolo = Numero;

numero = 0.0;

do £
numero = 10.0*numero + £loat( int(c)-int('0') );
LeerCaracter();

) while ((c >= "0") 84 (0 <= '9');

releer = true;

   

Terminador:
print£( "1n** Error: expresión incompleta" );
break;
case "M0":

simbolo > Terminador;
print£( "Yn** Error: fin de la entradaln" );
break;
default:
simbolo = Desconocido;
caracter = "0"
print£( "W** Error: símbolo no reconocidoWn" );

 
Ampliación de estructuras de control 277

 

 

Reconocer y obtener un operando con su valor

 

Y
id LeerOperando( float £ valor, bool $ error ) £
error = false;
LeerSimbolo();
if (simbolo == Numero) (

valor = numero;
) else if (simbolo — Memoria) (

valor = memoriaABCD[int(caracter)-int('A')
) else £

error = true;

A£ (caracter > * '")4

print£( "W** Error: se necesita operandoln" );

 

 

Programa principal
“int mainO £
float operando, resultado;
char operador;
bool seguir, error;

 

 

For (int k=0; k<4; ke) (
memoriaABCD[K] = 0.0;
Y

/*-- Bucle de procesar expresiones --*/
do £
print£( "Cálculo: "
resultado = 0.0;

 

Ss

/* Leer y procesar el primer operando */
primero = true;
Leer0perando( resultado, error );
 

 

278 Fundamentos de programación

 

/* Leer y procesar el resto de la expresión */
seguir = error;
while (seguir) ( /* bucle indefinido */

/*-- Leer operador o fin de expresión --*/
LeerSimbolo();
switch (simbolo) (

case Operador:
/*-—- Operaciones aritméticas o asignación --*/
operador = caracter;
LeerOperando( operando, error );
Af (error) (
seguir = false;
continue; — /* se da por terminada la expresión */
J
switch (operador) (
case Cel:
resultado = resultado + operando;
break;
case *-"
resultado
break;
case te:
resultado = resultado * operando;
break;
case '/':
resultado = resultado / operando;
break;
default: — /* guardar en memoria */
if (simbolo == Memoria) (
menoriaABCD[int(caracter)-int(*A")] = resultado;
) else (
print£( "Wn** Error: Se necesita A, B, Co Din" );
error = true;
false;
/* se da por terminada la expresión */

resultado - operando;

 

7
3
break;
 
  
 
   
  

Ampliación de estructuras de control 279

case Numero:
case Memoria:
/*-- Operador no válido --*/
print£( "Xn** Error: se necesita operadora" );

 
 

 

Fin de la expresión
false;
(caracter l= ';* 8% caracter l=

 

th

   

seguir = seguir £4 error;
) /* fin del bucle del resto de la expresión */

if (lerror) (
/*— Escribir resultado --*/
print£( "w>> Resultado: Xgin", resultado );

) else if Ccl="10') (
/*-- Saltar hasta fin de expresión, de línea o de fichero --*/
primt£( "<<" );
while (c!="5" 68 cl=".* 88 cl="n' 6% cl="10') (

LeerCaracter();

,
print£( "a" );

Y

print£c "a" );

) while (c !='.' 86 c l= 'x0'); /* fin del bucle principal */

 

 

 

y

 

A continuación se muestra un ejemplo de ejecución. El texto de entrada contiene las siguientes expresiones:

 

  
  
  
  
  

22 + 33 =A- 25
3; 8* (5-4); 44

A= 33 +73 9/7+5;
+22; final.

 

Aj B%2;

Y el resultado obtenido es:

 
 

   

Fundamentos de progr:

 

Cálculo: 22 + 33
>> Resultado: 30

 

Cálculo: A;
>> Resultado: 55

Cálculo: B*2;
>> Resultado: 60

Cálculo: 3;
>> Resultado: 3

Cálculo: 8.* (
** Error: símbolo no reconocido
<5s- mM;

Cálculos
** Erro
<<

48
expresión incompleta

  

Cálculo: A = 33
Se necesita A, B, Co D

 

Cálculo: 9 / 7 + 5;
>> Resultado: 6.28571

Cálculo: +
** Error: se necesita operando
<< 22;

Cálculo: £
** Error; símbolo no reconocido
<< inal.

 
Ejercicios sin resolver - II

A continuación se enuncian un segundo bloque de ejercicios sin resolver. Todos ellos pueden y deben ser realizados en Cé utilizando las herramientas y
metodología explicada hasta este momonto, Los enunciados de los ejercicios
son los siguientes:

1. Realizar una función que devuelva un valor booleano ciorto o falso si
el número que se le pasa como argumento es “perfecto”. Para que un
número sen “perfecto” es necesario que su valor sea igual a la suma
de todos sus divisores incluyendo al 1 y sin incluirle a él mismo. Por
ejemplo, los divisores de 6 son el 1, el 2 y el 3; su suma es igual a 6,
luego el número 6 es “perfecto”. Utilizando la función anterior realizar
un programa que escriba la lista de múmeros “porfectos” hasta uno dado,
introducido como dato al programa.

2. Realizar un procedimiento que lea una letra, compruebo que es una de
las utilizadas para escribir los números romanos y devuelva su valor,
según la siguiente tabla:

1-14 - 100
Y=b D - 500
X - 10 M - 1000

L - 50 Resto - 0
Utilizando ol procedimiento anterior, realizar otro procedimiento que
lea un número romano y devuelva su valor entero correspondiente. Este
procedimiento tendrá en cuenta las reglas de escritura de los números
romanos. Finalmente, utilizando este último procedimiento realizar un.
programa que lea dos números romanos e indique cuál de ellos es mayor.

3. Realizar un programa que escriba todas las permutaciones posibles que
se pueden obtener a partir de las 4 letras: A, B, C y D,

4. Realizar una función que devuelva el día de la semana cuando se le pasan como argumentos el día, el mes y el año de una fecha cualquiera.
Utilizando la función anterior escribir un programa al que se lo introdu
 

 
282 Fundamentos de program

 

      
 

cen como datos el mes y el año y devuelve como resultado la hoja
calendario de dicho mes. Por ejemplo;

Mes? 1
Año? 2018

 

5. Realizar un programa que analice un texto terminado con un punto (-)
y elabore las siguientes estadí:
+ Número total de palabras del texto
+ Número de palabras que utilizan N o más vocales diferentes
+ Número de palabras que utilizan M o más consonantes diferentes.
Los valores de N y M se leerán como datos del programa.
6. Realizar un programa para controlar las plazas de un aparcamiento.
El aparcamiento dispone de 25 plazas de dos tamaños diferentes: 15
pequeñas y 10 grandes con la disposición que se muestra a continuación:

c|o]c6]s c|cl]e 6
11213 [4 e|7|a 10

 

 

P ple ple
7 4112 14 | 15

La asignación se realizará automáticamente según el tamaño del vehículo
que se quiere aparcar con el siguiente algoritmo:
+ Cada vehículo solamente ocupará una plaza.

+ Un vehículo pequeño siempre ocupará una plaza pequeña, salvo que
estén todas ocupadas y exista alguna grande libre.

+ Un vehículo grande sólo puede aparcar en una plaza grande. Si
todas están ocupadas no podrá aparcar aunque estén todas las pequeñas libres.

+ De todas las plazas libres, siempre se ocupará primero la de número
menor.

 
Ejercicios sin resolver - IL 283

 

El programa tendrá 3 opciones básicas:
+ Entrada: es necesario indicar el tamaño de coche (P/G ).
+ Salida: es necesario indicar la plaza que se deja libre. Por ejemplo:
Pa
+ Situación del aparcamiento:
padas.

 

indicando las plazas libres y las ocu  
  
  
   
     
   
  
 
   
 

Tema 11
Estructuras de datos

En el tema 9 so han introducido mecanismos básicos para la definición de
"nuevos tipos, incluyendo tipos estructurados: formaciones o vectores (arrays)
y tuplas (struct). En este tema se introducen nuevas estructuras de datos
que aportan posibilidades adicionales

   

En particular se generaliza la estructura voctorial mediante el uso de veetores abiertos y matrices o formaciones de varias dimensiones, así como los
tipos unión, conjuntos, y estructuras de datos complejas que combinan varias
estructuras más sencillas.

 

11.1 Argumentos de tipo vector abierto

Si un subprograma debe operar con un vector recibido como argumento, necesita toda la información del tipo de dicho vector, es decir, el tipo y número de
¡sus elementos. Por ejemplo, en el tema 9 aparecían los siguientes fragmontos
de código:

yt int NumeroElementos = 10;

lef int TipoVector[NumeroElementos];

 

EscribirVector( const TipoVector v ) t.

 

Vector vectorUno, vectorDos;
-ribirvector( vectorDos );

El código del procedimiento EscribirVector puede redactarse con seguridad,
¿ya que se conoce toda la información del tipo del argumento:

 
     
   

286 Fundamentos de program

 

void EscribirVector( const TipoVector v ) €
for (int i =0; i < NuneroElenentos; 1*+) (
print£( "%108", v[i] );
,
primt£( “a” );
J

Si ahora necesitamos trabajar con vectores de otro tamaño, tendremos que
definir un nuevo tipo y, lamentablemente, también un nuevo procedimiento de
escritura (recordemos que en Ci el argumento real debe ser exactamente del
mismo tipo que el argumento formal):

const int NuneroElenentosLargo = 100;
typedef int TipoVectorLargo[NuneroElenentosLargo];

void EscribirVectorLargo( const TipoVectorLargo v ) (
for (int i = 0; i < NuneroElementosLargo; i++) (
print£( "%108", v[i] );
y
printe( a");
J

Como vemos, el código del nuevo procedimiento de escritura es idéntico al del
anterior, salvo por la referencia al número de elementos. En la práctica no
tiene sentido tener que duplicar el código sólo porque cambia el valor de una
constante. Más razonable es escribir un procedimiento general de escritura de
vectores de números enteros, y pasar como parámotro el tamaño del vector.
Para eso hace falta un mecanismo para expresar que un argumento de tipo
vector puede tener un tamaño cualquiera, es decir, indefinido. Los vectores
con un tamaño indefinido se denominan vectores abiertos.

En Ct los argumentos de tipo vector abierto se especifican de manera similar
a una declaración de tipo vector, omitiendo el tamaño explícito pero no los
corchetes (£J). Ejemplo:

void EscribirVectorabierto( const int v[], int numElementos ) £
for (int á i < nunElementos; 1++)
printf( "x104”, v[il );
y
print£( "in" );
3

 

 

Ahora podemos usar este procedimiento para escribir vectores de cualquiera
de los tipos anteriores:
icturas de datos 287

 

   
  
   
    
  
 
 
 
  
  
 
   
    
    
  
   
  
  
  

 

Vector vectorUno, vectorDos
VectorLargo vectorLargo;

“ibirVectorAbierto( vectorDos, NumeroElementos );
ibirVectorAbierto( vectorLargo, NumeroElenentosLargo );

precio que hay que pagar por disponer de esta facilidad es tener que pasar
;pre la longitud concreta del vector como argumento, en cada llamada.

supuesto, hay otras alternativas al paso explícito de la longitud del vector.
subprogramas estándar para operar con cadenas de caracteres (strings)
la técnica de almacenar un carácter nulo al final del valor efectivo de
'sada cadena. Esto exige disponer siempre de espacio para un carácter más, al
os, pero evitan tener que pasar la longitud como argumento. A continuase muestra un ejemplo de esta técnica.

11.1.1 Ejemplo: Contar letras y dígitos

Esto ejemplo analiza un fragmento de texto y cuenta el número de caracteres,
letras, dígitos y espacios en blanco de los que consta. Se usa un subprograma
¡que recibe el fragmento de texto como vector abierto, y analiza uno a uno
¡sus caracteres hasta encontrar el carácter mulo que marca el final. El listado
completo del programa es ol siguiente:

 

* Programa: ContarLetrasyDigitos

+ Descripci.
* Programa que analiza fragmentos de texto y
* cuenta las letras y dígitos lo componen
A A /
'sinclude <stdio.h>

'finclude <ctype.h>

 

 

 

 

./** Analizar el texto */

'void AnalizarTexto( const char textol] ) (
int letras = 0;

int digitos = 0;

int blancos
int posi =0,

 
  

288 Fundamentos de progr:

 

while (textolposi] l= 110%) 4
if (isalpha(texto[posi])) 4
letras++;
) else if (isdigit(texto[posiJ)) (
digitos++;
) else if (isspace(texto[posil)) (
blancos++;
y
posi++;
,

print£( "Texto: Xsin", texto );

print£(
"Longitud: X2d Letras: X2d Digitos: X2d Blancos: X2dinn"
posi, letras, digitos, blancos );

 

J

/** Programa principal */

ánt mainQ (
AnalizarTexto( "12 de Octubre de 1492" );
AnalizarTexto( "2001, una odisea del espacio" );
AnalizarTexto( "" );

y

 

y el resultado de la ejecución es el siguiente:

 

 

Texto: 12 de Octubre de 1492
Longitud: 21 Letras: 11 Digitos: 6 Blancos: 4

Texto: 2001, una odisea del espacio
Longitud: 28 Letras: 19 Digitos: 4 Blancos: 4

 

Texto:
Longitud: 0 Letras: 0 Digitos: 0 Blancos: 0

11.2 Formaciones anidadas. Matrices

   

En esta sección se generaliza el concepto de vector para disponer de formaciones de más de una dimensión. Para simplificar, la exposición se centra em
malrices de dos dimensiones, pero la notación y técnicas de uso se pueden
extender a formaciones de más de dos dimensi

 

¡ension

 
 

Estructuras de datos

11.2.1 Declaración de matrices y uso de sus elementos

   

Las matrices son estructuras de tipo formación (array) de dos o más dimensiones. Una forma sencilla de plantear la definición de estas estructuras es
considerarlas como vectores cuyos elementos son a su vez vectores (0 matrices). La figura 11.1 muestra la estructura de una matriz de dos dimensiones,
formada por filas o columnas.

 
  
  
  

Matrizt1i1
MatriatiXa)

Motriatun)

Figura 11.1 Matriz de dos dimensiones.

En la figura se presenta la matriz como un vector cuyos elementos son las filas
de la matriz, que a su vez son vectores de elementos de la matriz. Usando
directamente declaraciones de tipos vector podríamos escribir la declaración
de una matriz de números enteros de la siguiente manera:

¡const int NumFilas = 10;
¡const int NumColumnas = 1:
"typedef int TipoElemento;

 

“typedef TipoElemento TipoFila[NunColumnas];
¡typedef TipoFila TipoMatriz[NumPilas];

usará un doble subíndice:

 

Para designar un elemento do la matri
ipoMatriz matriz;
triz[3]15] = 27;

La declaración de una matriz puede simplificarse en cierta medida respecto a.
la notación anterior dado que no es necesario declarar un tipo intermedio para
las filas de la matriz. Por ejemplo:
Fundamentos de prog

const int NunFilas = 10
const int NunColumnas
typedef int TipoElemento;

 

Ss:

typedef TipoElemento TipoMatriz[NunFilas] [NunColumnas] ;

TipoMatriz matriz;

  
     
 

Como recordatorio, repetiremos aquí las reglas sintácticas de la definición:
formaciones, de una o varias dimensiones.

Tipo_formaci typedef Identificador_de_tipo_elemento
Identificador_de_tipo_ formación Dimensiones ;

= TamañoÍ Tamaño Y

[ Número_de_elementos 1

   

 

Dimensiones

 

Tamaño 3

11.2.2 Operaciones con matrices

Las operaciones con elementos individuales de una matriz pueden hacerse
rectamente, de forma análoga a la operación con variables simples de ese ti
En cambio las operaciones globales con matrices han de plantearso de
similar a las operaciones globales con vectores. En general habrá que
elemento a elemento, o a lo sumo por filas completas.

Por ejemplo, para imprimir matrices del tipo declarado anteriormente
mos escribir;

void EscribirMatriz( const TipoMatriz m ) (
for (int i = 0; i < NunFilas; d++) (

  

for (int j= 0; j < NunColumas; j++) £
print£( "%10d", m[iJ(31 0;
3
print£( “ad:
+

)

En este ejemplo se ha operado directamente con cada elemento de la
usando un doble bucle para recorrerla. También es posible operar con la.

por filas completas, y detallar por separado cómo se opera con cada fila,
supuesto, esto requiero haber definido explícitamente el tipo de las filas:
  
   
   
 
   
   
 
 
   
 
 
 
 
 
 
 
 
 
    
   
 
   
   
 
   

Estructuras de datos 291

 

EscribirFila( const TipoFila £ ) 1

for (int i =0; i < NunColumas; i++) £
print£( "x104", £[3] );

y

print£( "Ya" );

EscribirMatriz( const TipoMatriz m ) (
for (int i = 0; i <NunFilas; i++) (
EscribirFila( m(i] );

,

comienzo de este tema se ha mencionado la posibilidad de definir argu:tos de tipo vector como vectores abiertos, de tamaño indefinido. Podemos
en generalizar ese mecanismo y permitir el uso de argumentos de timatriz abierta. Lamentablemente los lenguajes C o C++, y por lo tanto
no lo permiten. El siguiente fragmento de código provoca un error de
pilación:

EscribirMatrizabierta( const int m[10]. /% <— ERROR */

int filas, int columas )

supuesto, si se manipula una matriz como vector de vectores sí se pueusar el mecanismo de vector abierto, pero limitado a formaciones de una
jensión cuyos elementos tienen un tipo explícito de tamaño conocido. A
iinuación se repite el código de ejemplo anterior ligeramente modificado
usar en lo posible el mecanismo de vector abierto, aunque de hecho no
ninguna ventaja importante:
EscribirFila( const TipoElemento £[], int columnas ) €
for (int i = 0; 1 < columnas; i++) (

print£( "X10d", £(1] );
y
print£( "a" );

 

EscribirMatriz( const TipoFila m[] ) (

for (int i =0; i < NunFilas; i++) €
EscribirFila( m[i], NunColumas );

3

realmente se necesita definir operaciones genéricas con formaciones de diiones indefinidas hay que recurrir al uso explícito de punteros, tal como
verá en el tema 13.
292 Fundamentos de programación

11.2.3. Ejemplo: Contrastar una imagen .

 

Las imágenes almacenadas por puntos (pizels) son un ejemplo típico de estructura matricial. Este programa trabaja con una imagen monocroma en
ue cada punto puede tener un nivel de gris que varía de 0 a 5. La imagen
introduce como dato en forma de matriz de caracteres numéricos, con una
por línea de texto, y a continuación se constrasta convirtiéndola a imagen
sólo niveles de blanco o negro puros. La imagen se presenta a la salida t
bión como matriz de caracteres, usando caracteres apropiados para aproxi
visualmente los distintos niveles de gris. El listado completo del programa
el siguiente:

 

 

 

AA
* Programa: Contrastar

+ Descripción:

* Este programa convierte una imagen digitalizada

* a niveles de blanco y negro puros
AA

*tinclude <stdio.h>

const int Ancho /% anchura de la imagen */
const int Alto /* altura de la imagen */
const int Blanco = 0; — /* nivel bajo de grises
const int Negro /* nivel alto de grises

 

blanco */
negro */

 

typedef int Imagen_t[Alto][Ancho:

 

/** Leer la imagen */
void LeerImagení Imagen t imagen ) (
char

 

for (int i=0; i<Alto; i++) (
for (int j=0; j<ancho; j++) (
seanf( " Xe”, 80 );
imagen(i][j] = int(e) - ánt('0');
3
+
ió

 
Contrastar la imagen */
Contrastar( Imagen_t imagen, int nivel ) (
for (int 1-0; i<Alto; i++) (
for (int j=0; j<Ancho; ++) 4
if (imagen[i][3] <= nivel) (
imagen[i][3] = Blanco;
Y else (
inagen[i][3] = Negro;

'* Imprimir la imagen */
Inprimir( const Imagen_t imagen ) (
const char Punto[6] =(' ', *.*

for (int i=0; icAlto; ies) (

print£( "%c", Punto[imagen[i1(311 3;
y
printf( "a" );
y
y

/** Programa principal */
'int main() (
Imagen_t imagen;

LeerImagen( imagen );
print£( "Inagen inicial:
Imprimir( imagen );

Contrastar( imagen, 3 );
print£f( "WnInagen contrastada:Wn" );
Imprimir( imagen );

3

 

A continuación se presenta un ojemplo de la ejecución de este programa. Los
datos de entrada contienen un carácter por cada punto de la imagen, y simulan
una rejilla. Los datos son:

 
 

294

Fundamentos de programación

 

 

0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212344
5432101234543210123454321012345432101233
4543212345454321234545432123454543212344
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432
0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212345
5432101234543210123454321012345432101234
4543212345454321234545432123454543212345
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432

El resultado de la ejecución del programa es el siguiente:

 

 

Imagen inicial:
AM A AAA ARI
A AA AR
ARAN AAN
APA A A NARA
RA A A
A
RA A A
AAA A
AMA AX
AAA A A AA
SS
AAA AA AA AN
AMIA A ANA
ON POLA CA
AR E E O
A
A AE A AO AAA
AA NC
AMA A NA
AE A AA AA
Estructuras de datos 295

 

id +44
AUREA RRA A
IRORRR A A
30 RR a a AAA AA A
E

es 2. ee. +“.

o E A
PER AMAR AAA ACA
e
PARAR RRA RRA RA
e. ud ee ..
BEAR RRA
BER RRR RRA RAN RAR
10 RAR A AA
104
* se. ... ed +
a o
E E
MON RAR ARA RRA HR
ARRRR RRA RRA RAR

11.3 El esquema unión

Hay aplicaciones en las que resultaría descable que el tipo de un dato variase
según las circunstancias. Si las posibilidades de variación son un conjunto
finito de tipos, entonces se puede decir que el tipo del dato corresponde a un
esquema que es la unión de los tipos particulares posibles. Cada uno de los
tipos particulares constituye una variante o alternativa del tipo unión. Representaremos simbólicamente este esquema de forma similar a las alternativas
en las reglas de sintaxis BNF:

tipo_unión = variante | variante ..

Como situaciones típicas en las que se pueden aplicar los esquemas unión
tenemos, entre otras, las siguientes;

+ Datos que pueden representarse de diferentes maneras.
+ Programas que operan indistintamente con varias clases de datos.
+ Datos estructurados con elementos opcionales.

Algunos ejemplos concretos serían:

múmero_general = entero | fracción | real

 
 

296 Fundamentos de program:

 

  
   
    

coordenadas = coordenadas cartesianas | coordenadas polares

 

punto | círculo | cuadrado | rectángulo | rombo | triángulo ||
elipse

figura

 

soltero | datos_menor | datos casado

El primer caso correspondería a un programa que opere indistintamente
números de diferentes clases. Los números enteros son datos simples, al i
«ue los reales, annque las colecciones de valores son diferentes. Los núme
fraccionarios se representan como dos números enteros (numerador y denominador).

En el segundo caso tenemos dos sistemas de coordenadas diferentes para representar los puntos del plano. Las coordenadas cartesianas son dos longitudes.
mientras que las polares son una longitud y un ángulo.

datos_persona = datos,

   

En el tercer caso tenemos un programa que maneja un repertorio limitado de
elementos gráficos. Para cada figura se necesitará conocer una colección de
parámetros diferentes.

En el último caso, los datos de un soltero mayor de edad constituirían la.
información básica de una persona. Los menores deberían tener además un.
tutor o persona responsable de ellos, y los casados deberían tener una fecha.
de matrimonio y un cónyuge.

11.3.1 El tipo union

Los esquemas unión pueden utilizarse en programas en C+ definiéndolos como.
tipos union. Un tipo union se define como una colección de campos alternativos, de tal manera que cada dato particular sólo usará uno de esos campos
en un momento dado, dependiendo de la alternativa aplicable. La definición
es similar a la de un agregado o struct, usando ahora la palabra clave union.
Por ejemplo:

  

typedef struct TipoFraccion (
int numerador;
int denominador;

Js

typedef union TipoNumero (
int valorEntero;
float valorReal;
TipoFraccion valorRacional;
  
 
   
    
   
   
  
  
     
   
   
 
 
 
  
  
    
 
    

'ucturas de datos 297

 

roferencia a los elementos componentes se hace también como en los tipos
et:

-o numero, otro, fraccioni, fraccion2;
:ro.valorEntero = 33;

.valorReal = float (nunero. valorEntero) ;
:cion2.valorRacional = fraccion1.valorRacional;

una variante de una unión es a su vez otra tupla o unión habrá que usar
rios cualificadores para designar los campos anidados:

:cion1.valorRacional.nunerador = 33;
-cion1.valorRacional denominador = 44;

 

xo se ha dicho, sólo una de las variantes puede estar vigente en un momento
lo. Si asignamos valor a una de ollas será ésta la que exista a partir de ese
mento, al tiempo que dejan de existir las demás:

Íccion1.valorEntero = 22;

intf( "xd", fraccion1l.valorEntero ); /* Correcto */
intf( "%d", fraccion1.valorRacional.denominador ); /* ERROR */

"Es fácil darso cuenta de que un dato de un tipo unión no contiene en sí mismo
información de cuál es la variante activa en un momento dado. Dicha información debe estar disponible de forma clara por otros medios. Si no es así,
será muy fácil que se produzcan errores, Por ejemplo, al redactar un procedimiento para imprimir un dato del TipoNunero deberíamos pasar también
'como argumento una indicación de la variante aplicable:

:£ enum ClaseNunero (Entero, Real, Fracción);

EscribirNumero( TipoNunero n, ClaseNumero c ) f
switch (0) (
case Entero:

print£(

 

, n.valorEntero

 

 

print£( "%£", n.valorReal );
break;
case Fraccion:
print£( "%a/%d", n.valorRacional.numerador, n.valorRacional.denominador );

 
 

 

   
  
     
  
  

298 Fundamentos de programación:

 

11.3.2 Registros con variantes

El hecho de que un dato de tipo unión deba ir acompañado de inform:
complementaria para saber cuál es la variante aplicable hace que los ti
unión aparezcan casi siempre formando parte de estructuras más complejas.

 

Un ejemplo frecuente es lo que se denominan registros con variantes. Se t
de agregados o tuplas en los que hay una colección de campos fijos, aplical
en todos los casos, y campos variantes que se definen según el esquema uni
Además suele reservarse un campo fijo para indicar explícitamente cuál es
variante aplicable en cada momento. A dicho campo se le llama discrimina:

A continuación se recodifica el ejemplo anterior usando esta técnica:
typedef enum ClaseNumero (Entero, Real, Fraccion);
typedef struct TipoFraccion (

int numerador;
int denominador;

 

+

typedef union TipoValor (
int valorEntero;
float valorReal;
TipoFraccion valorRacional;
J

typedef struct TipoNumero (
ClaseNumero clase; /* discriminante */
TipoValor valor;


void EscribirNumero( TipoNumero n ) £
switch (n.clase) (
case Entero:
print£( "%d", n.valor.valorEntero );
break;
case Real.
print£( "X£", n.valor.valorReal );
break.
case Fraccion:
print£( "Xd/xd", n.valor.valorRacional.numerador,
n.valor.valorRacional.denominador );

 

 
   
  
   
 
 
 
 
 
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
  

Estructuras de datos 299

pb

Si el tratamiento de los registros con variantes se hace sólo mediante subprogramas que comprueban siempre el discriminante antes de operar, el código
resulta mucho más seguro. Esta garantía de seguridad compensa perfecta
mente el esfuerzo adicional que representa definir y usar estructuras anidadas,
como en este ejemplo. Además el uso de los subprogramas de manipulación es
ahora más sencillo, ya que basta pasar como argumento sólo el propio dato,
que tiene en sí mismo toda la información necesaria.

11.4 Esquemas de datos y esquemas de acciones

Una vez presentadas las estructuras de datos de tipos formación y registro,
incluidos los registros con variantes, es interesante hacer notar la analogía que
puede establecerse entre los esquemas de acciones y los esquemas de datos.

La programación estructurada recomienda usar los esquemas más sencillos
posibles para organizar un elemento complejo de un programa a partir de
elementos más simples. Recordaremos que estos esquemas básicos eran la
secuencia, la selección, y la iteración, en el caso de acciones compuestas.

Estos esquemas se corresponden, respectivamente, con los esquemas tupla,
unión y formación, definidos para las estructuras de datos. La analogía se pone
de manifiesto si describimos dichos esquemas de forma generalizada, común a
los datos y acciones.

Tupla - Secuencia: Colección de elementos de tipos diferentes, combinados
en un orden fijo.

 

Unión - Selección: Selección de un elemento entre varios posibles, de tipos
diferentes.
Formación - Hteración: Colección de elementos del mismo tipo.
“Todavía puede manifestarse la analogía con más intensidad si observamos que

el tratamiento de las componentes de una estructura de datos se realiza fácil“mente con una acción compuesta de tipo análogo. Por ejemple

ESQUEMAS DE DATOS */

 

Esquema Tupla */
typedef struct TipoTupla £
char uno, dos, tres; *
+
TipoTupla agregado;
    

Fundamentos de progr:

/% Esquema Unión */
typedef union TipoUnion (
int alfa;
float beta;
1
Tipolnion variante;
bool nuneroEntero;

/* Esquema Formación */
typedef int TipoFormacion[10];
TipoFormacion vector;

/* ESQUEMAS DE ACCIONES */

/* Secuencia para imprmir los campos una Tupla */
print£( "Xc", agregado.uno );
printf( "Xc”, agregado.dos );
print£( "%c", agregado.tres );

/* selección para inprimir las variantes de una Union */
if (nuneroEntero) 4
print£( "%a", variante.alfa );
) else (
print£( "Xf", variante.beta );
)

/* Iteración para imprimir una Formación */
for (int KIO; ke) (
print£( "xd", vectorIk] );

 

 

+

    
 

Para imprimir el contenido de cada estructura de datos se ha utilizado
samente la acción compuesta de estructura análoga,

11.5 Estructuras combinadas

Como en cualquier otro lenguaje de programación actual, en Ci se

combinar entre sí los esquemas tupla, unión y formación para definir
turas de datos complejas, exactamente igual a. como se combinan la sec
selección e iteración para construir el código de acciones complejas. De
ya se ha hecho así en algún ejemplo anterior.

   
 
  
 
    
  
 
 
  
    
   
  
   
  
 
   
  
  
  
  
    
   
  
   

Estructuras de datos 301

 

Una característica de los lenguajes de programación modernos es que se pueden
combinar con bastante libertad elementos de la misma naturaleza. Esto ocurre
en Ci con las sentencias estructuradas, que permiten anidar esquemas de tipo
socuencia, selección e iteración unos dentro de otros. |

 

 

Con las estructuras de datos ocurre algo simi Se pueden definir estructuras
cuyas componentes son a su vez estructuras, sin límite de complejidad de los |
esquemas de datos resultantes. |

11.5.1 Formas de combinación

La manera de combinar las estructuras de datos es hacer que los elementos de
una estructura sean a su vez otras estructuras, sin limitación en la profundidad
de anidamiento. Podemos analizar algunos ejemplos:

typedef struct TipoPunto (
float x, y;

 

¡typedef TipoPunto TipoTriangulo[3];

¡const int MaxPuntos = 100;
¡typedef TipoPunto TipoPuntos[MaxPuntos];

typedef struct TipoListaPuntos (
int nuneroPunto:
TipoPuntos puntos;

 

TipoListaPuntos Poligonal; /* línea abierta */
¡typedef TipoListaPuntos Poligono; /* línea cerrada */

En estos ejemplos tenemos la representación de un triángulo como una for'mación de tres puntos, que son registros. La lista de puntos se estructura
¡como un registro, uno de cuyos campos es una formación de puntos, que son
su vez registros. Las últimas declaraciones definen tipos sinónimos de la
de puntos, general, con nombres particulares para ser usados en casos
iculares.

siguientes ejemplos definen registros que contienen campos que son cadode caracteres. El último ejemplo es un registro que contiene a su vez otro
o anidado.

char TipoNombre[20];
:£ char TipoApellido[30];
 

302 Fundamentos de progre

 

typedef char TipoLineaTexto[40];

typedef enun TipoProvincia (
SinProvincia, Alava, Albacete,

..- Zaragoza

a

typedef struct TipoNombreCompleto £

TipoNombre nombre;

Tipoápellido apellido1, apellido2;

"

typedef struct TipoDomicilio (
TipoLineaTexto calle;
int munero;
TipoLineaTexto zona, poblacion;
int codigoPostal;
TipoProvincia provincia;


typedef struct TipoDatosPersonales (
TipoNombreCompleto nombreyapellidos;
TipoDomicilio domicilio;

»

   
 

Cuando se utilizan estructuras combinadas, para hacer referencia a una come.
ponente en particular hay que usar los selectores apropiados, encadenados
tras otro. Como ejemplos de uso de las estructuras definidas en este apartada.
podemos poner:
TipoTriangulo pieza;
TipoListaPuntos camino;
TipoDatosPersonales empleado;

 

 

pieza[0].x = 2.33;
pieza[0].y = -3.45;
pieza[1].x = pieza[1].y;
pieza[1].y = 88.3;

 

camino.nuneroPuntos = 3
camino .puntos[0].x = 5.67;
camino.puntos[0].y = 7.21;
camino.puntos[1] = pieza[2);
camino.puntos[2] = camino.puntos[1];

 

strcpy( empleado.nombreyapellidos.nombre, "Alberto");
printf( "Xs", empleado.domicilio.calle );

 

if (empleado.domicilio.poblacion[0] == 'N0') £

  
Estructuras de datos 303

 

print£( "Sin domicilio" );
Y

En estos ejemplos aparecen combinados los selectores de campo de registro
y de componente de formación. La combinación es admisible cuando una
componente de una estructura es a su vez una estructura de datos. A cada
estructura se debe aplicar el selector que le corresponda.

11.5.2 Tablas

Aunquo el estudio de las estructuras de datos excede del ámbito de este libro,
resulta interesante mencionar algunos esquemas típicos que se obtienen combinando estructuras básicas. Este es el caso del esquema de tabla, que puede
plantearse como una formación simple de registros. En otros contextos se le
da también el nombre de diecionario o relación. Los esquemas de tabla son el
fundamento de las bases de datos relacionales, aunque su implementación es
muy diferente de las estructuras simplificadas que se presentan aquí.

 

 

Por ejemplo, podemos definir una tabla destinada a contener la identificación
de las provincias:
typedef enum TipoProvincia (
SinProvincia, Alava, Albacete,
. Zaragoza

 

+

const int MaxProvincias = int(Zaragoza);
typedef char TipoSiglas[2];

typedef char TipoNombre[30];

 

typedef struct TipoDatosProvincia (
TipoSiglas siglas;
TipoNombre nombre;
int codigo;

Y

typedef TipoDatosProvincia TipoTablaProvincias [MaxProvincias+1];

TipoTablaProvincias provincias;

En esta tabla se podrán almacenar los valores apropiados, asignándolos a los
correspondientes campos, Por ejemplo:

provincias[Cadiz].siglas[0] = 'C';

provincias[Cadiz].siglas[1] = 'A';

strcpy( provincias[Cadiz].nombre, "Cádiz”);

provincias[Cadiz].codigo = 11;
  
    

304 Fundamentos de programación

Estos datos podrán ser usados luego en programas que manejen direcci
postales, matrículas do coches, ote.

Pueden construirse estructuras de datos bastante complejas combinán
de manera que en algunas de ellas hagamos referencia a datos almacen:
en otras. Una forma de hacer referencia a los datos de una tabla es usanda:
el índice correspondiente a la posición de cada registro. A continuación se
muestra un ejemplo para manejo de figuras geométricas definidas a partir de:
puntos:
typedef struct TipoPunto (

float x,
»
const int MaxPuntos = 1000;
typedef int TipolndicePunto;
typedef TipoPunto TipoTablaPuntos [MaxPuntos];

 

 

typedef TipolndicePunto TipoTriangulo[3];

typedef struct TipoCirculo £
TipoIndicePunto centro;
float radio;

»

TipoTablaPuntos puntos;

En este ejemplo, la tabla puntos almacena las coordenadas de todos los puntos
utilizados para definir cualquiera de las figuras geométricas que se manejan.
Las figuras se definen almacenando referencias a los puntos de la tabla, em
lugar de almacenar dircctamente las coordenadas de los puntos. Un triángulo
T definido por tres puntos A, B y C so podría registrar, por ejemplo, almacenando los puntos, arbitrariamento, en las posiciones 10, 11 y 12 de la tabla de
puntos:

TipoTriangulo trianguloT;

LeerPunto( puntos[10] ); /* punto A */
LeerPunto( puntos[11] ); /* punto B */
LeerPunto( puntos[12] ); /* punto C */

trianguloT[1]
trianguloT[2]
trianguloT[3]

10; /* punto A */
11; /* punto B */
12; /* punto C */

 

 
Estructuras de datos 305

 

Como se decía, la tabla de puntos combina la información de todos los puntos
de todas las figuras. Por ejemplo, se pueden definir círculos centrados en los
vértices del triángulo T:

TipoCirculo cl, c2, 3;

e1.centro = 11
e1.radio = 3.3;
e2,centro = 11; /* punto B */
e2.radio = 3.3;
e3.centro = 12
[c3.radio = 3.3;

 

/% punto A =/

 

/* punto C */

 

El centro del círculo 1 es exactamente el mismo punto que el vértice A del
triángulo. Si desplazamos ese punto se moverán a su vez el vértice y el círculo:

 

puntos[10].x = puntos[10].x + 2.5;
Ipuntos[10].y = puntos[10].y + 4.3;

11.5.3. Ejemplo: Gestión de tarjetas de embarque

Este programa es una nueva versión más completa del ya presentado en el tema
10 para realizar la gestión de las plazas de un avión e imprimir las tarjetas de
embarque. Ahora se puede asignar una plaza del avión de manera individual.
También se puede reservar un grupo de dos a seis plazas de forma automática
asignando asientos de la misma fila cuando sea posible. Antes de que las plazas
asignadas automáticamente pasen a estar ocupadas se solicita confirmación de
la operación.

 

   

Las plazas so gostionan como una tabla o vector de filas. Cada fila es un
registro con un vector con el estado de cada asiento, e información precalculada,
del número y posición de las plazas contiguas que haya, con o sin pasillo en
medio. Cada plaza puede estar vacía, ocupada o reservada. El estado de
reservada es transitorio hasta que se confirma la asignación automática y pasa
a estar ocupada, o no se confirma y vuelve a quedar libre. También se mantiene
actualizado un contador del número total de plazas libres,

El procedimiento PintarPlazas es el encargado de mostrar la situación de
todas las plazas del avión. El procedimiento ImprimirTarjeta es el encargado
de escribir la tarjeta de embarque de una plaza del avión.

La función BuscarPlazas es la encargada de realizar el algoritmo para situar
las plazas solicitadas. En un primer intento se trata de asignar las nuevas
plazas en la misma fila y lado del pasillo. Como segundo intento se asignarán

 
306 Fundamentos de programación

 

plazas correlativas en la misma fila aunque tengan el pasillo en medio, Si
eso tampoco es posible se irán asignando los asientos de uno en uno según
haya sitios libres empezando por la primera fila. Cuando no hay suficientes plazas disponibles se dará un mensaje. Esta función utiliza las funciones
MarcarPlazasJuntas, MarcaPlazasJuntasConPasillo y MarcarPlazas que
implementan respectivamente cada una de las preferencias indicadas.

El procedimiento ConfirmarPlazas es el encargado de pasar las plazas reservadas bien a ocupadas o bien a vacías dependiendo de si se confirman o no las
reservas. Además, este último procedimiento es el encargado de actualizar el
número total de plazas libres después de la asignación.

 

El programa consiste en un menú con cuatro opciones (Plaza, Grupo, Estado y
Fin). La opción de Plaza permite elegir y ocupar una plaza concreta si no está
ocupada. La opción Grupo utiliza la función BuscarPlazas para la búsqueda
de 2 4.6 plazas libres y reservarlas. Estas plazas deben ser confirmadas con el
procedimiento ConfirmarPlazas. Para mostrar la situación de la ocupación
del avión se dispone de la opción Estado.

 

 

Todo el programa está realizado en base a las constantes del número de filas
NunFilas, y los asientos por fila AsientosFila. Cualquier tamaño de avión
con el mismo formato se puede gestionar cambiando estas dos constantes. El
listado completo del programa es el siguiente:

 

PARRA
* Programa: Mostrador?

* Descripción:
* Este programa confecciona tarjetas de embarque

* y asigna plazas en la misma fila si es posible
ARA RRA RARA RARA RNA /

finclude <stdio.h>
include <ctype.h>

 

 

const int NunFilas = 10;  /* núnero de filas */
const int AsientosFila = 6; /* asientos por fila
const int Pasillo = AsientosFila / 2;

 

typedef enun TipoEstado (vacio, ocupado, reservado);
typedef TipoEstado TipoOcupa(AsientosFila];
typedef struct TipoFila (

Tipo0cupa asientosOcupados;

int juntas; /* plazas seguidas al mismo lado */

int desde; /* desde ésta */

int juntasP; /* plazas seguidas con pasillo en medio */

 
 

Estructuras de datos

int desdeP; /* desde ésta */
di
typedef TipoFila TipoPlazas[NunPilas];

/** Mostrar ocupación del avión */
void PintarPlazas( const TipoPlazas P ) (
const char DibujoAsiento[3] = ( ' *, '*!, 'R'

print£("n A B C D E Finn);
for (int i =0; i < NumFilas; i++) £
print£( "X3d", i+1);
for (int j = 0; j< AsientosFila; j+=) (
if (j == Pasillo) (
print£(” di
)
printí( " (%c)”, DibujoAsiento[P[i].asientosOcupados[j1] );
,
print£ "Wa" );
)
print£(n");
,

/** Imprimir una "tarjeta de embarque" */

void InprimirTarjeta( int fila, int asiento ) (
print£( ". An
print£( "| TARJETA DE EMBARQUE — [1n"
print£( “| Fila :X3d", fila )
print£( " Asiento :X3c |", asiento );
print£( "" e a

)

/** Calcular núnero y posición de plazas contiguas */
void CalcularPlazasJuntas( TipoFila 4 fila ) (

int juntas = 0;

int juntasP = 0;

fila. juntas = 0;
fila. juntas? =
for (int j = 0; j <AsientosPila; jes) (
if (j == Pasillo) (
juntas = 0;
J
if (fila.asientosOcupados[¿] == vacio) (
juntas;
JuntasP++;
if (juntas > fila. juntas) (

 
 

308 Fundamentos de programación

fila.juntas
fila. desde
J
if (juntasP > fila. juntasP) €
fila.juntasP = juntasP;
Fila.desdeP = j - juntasP + 1;
J
) else £
juntas
Juntas? =0;
y
,
y

 

juntas;
- juntas + 1;

 

  

  

/** Reservar plazas contiguas al mismo lado de la fila */
bool MarcarPlazasJuntas( int numero, TipoFila £ fila ) (
if (fila.juntas < numero) £
return false;
) else 1
for (int j =1; j <= muero; j+*) (
fila.asientosOcupados[fila.desde+j-1] = reservado;
2
return true;
3
Y

 

/** Reservar plazas contiguas a uno u otro lado de la fila */
bool MarcarPlazasJuntasConPasillo( int numero, TipoFila 4 fila ) £
if (fila.juntasP < numero) 4
return false;

   

Y else £
for (int j j <= numero; j++) (
fila.asientosOcupados[fila.desdeP+j-1] = reservado;
y
return true;
J

y

/** Reservar plazas contiguas o no en la fila */
void MarcarPlazas( int £ munero, TipoFila 4 fila ) £
int j=0;

while (numero > 0 86 j < AsientosFila ) (
fila. asientosOcupados[j] = reservado;
numero==;

y

 

 
Estructuras de datos 309

 

Y

   
  
   
 
  
  
  

/** Buscar plazas contiguas o próximas */
1 BuscarPlazas( int nuevas, int libres, TipoPlazas plazas ) (
int fila;

Af (nuevas <= libres) £
/*— Buscar plazas juntas en la misma fila --*/
fila = 0;
while (fila < NunFilas) £
if (MarcarPlazasJuntas( nuevas, plazas[fila]) ) £
return true;
y
fila++;
J
/*-— Buscar plazas seguidas en la misma fila --*/
fila = 0;
while (fila < NunFilas) £
if (MarcarPlazasJuntasConPasillo(nuevas, plazas[fila])) £
return true;
J
fila:

 

 

/*— Ocupar plazas de una en una desde la primera fila —*/

fila = 0;

mhile (nuevas > 0) (

MarcarPlazas( nuevas, plazas[fila] );

y

return true;
) else £

print£("No hay plazas suficientes
,

return false;

 

 

'* Confirmar o liberar plazas reservadas */
ConfirmarPlazas( bool ok, TipoPlazas plazas ) £
bool cambio;

for (int i =0; 4
cambio = false
for (int j= 0; j < AsientosFil
if (plazas[i].asientos0cupados[j] == reservado) £
if (ok) (
plazas(i].asientosOcupados[j] = ocupado;
InprimirTarjeta(i + 1, char(int('A") + 3);

   

 
 

 

  

Fundamentos de progr:

  

cambio = true;
) else £
plazas[i].asientosOcupados[] = vacio;
,
3
y
if (cambio) £
CalcularPlazasJuntas( plazas[i] );
y
y
y

/%* Programa principal */
int mainO) (

TipoPlazas pasaje;

int sitiosLibres;

 

 
  

char car;

int aux, fil, col;

bool seguir;

/*-— Iniciar todo vacío --*/
sitioslibres = NunFilas * AsientosFila;
for (int á i < Nunrilas; 1++) (

for (int j= 0; j< AsientosFila; j++) 1
pasaje[i].asientosOcupados[j] = vacio;
J
CalcularPlazasJuntas( pasaje[il );
y

/*— Bucle de operaciones --*/
seguir = true;
while (seguir) (
print£( "¿Opción (Plaza, Grupo, Estado, Fin)?
scanf( " Xe”, ácar );
car = toupper(car);
switch (car) £

 

/*— Asignar una plaza determinada --*/
case "P
do í
print£( "¿Fila (1 a 10)? " );
scanf( "Xd", daux );
) while (aux < 1 || aux > 10);
do (
print£( "¿Asiento (A a E)? ");
scanf( " Xe", Scar );

 
'ucturas de datos

 

car = toupper(car);
) mhile (car < "A! || car> "E;
fil = aux - 1;
col = int(car - 'A');
if (pasaje[£i1].asientosOcupados[col] == vacio) (
pasaje[£i1].asientosOcupados[co1] = ocupado;
sitiosLibres—;
CalcularPlazasJuntas( pasaje[fi1] );
ImprimirTarjeta(fil + 1, char(int('A') + col);
Y else (
print£("** Plaza OCUPADA n"

Asignar automáticamente plazas contiguas --*/
case Go:
do (
printf( "¿Número de plazas (2 a 6)?
scan£( "Xd", daux );
) while (aux <2 || aux > 6);
if (BuscarPlazas( aux, sitiosLibres, pasaje )) (
PintarPlazas( pasaje );
print£( "¿Confirmar (S/N)?
scanf( " %e", Acar );
if (toupper(car) == 'S') (
ConfirmarPlazas( true, pasaje );
sitioslibres = sitiosLibres — aux;
) else (
ConfirmarPlazas( false, pasaje );
y
J
break;

/*— Dibujar estado de ocupación --*/
case 'E"

PintarPlazas( pasaje );

break;

/*-- Fin del programa --*/
case 'F!:

seguir = false;

break;

 

 
 

312 Fundamentos de programación

A continuación se muestra un fragmento de la ejecución del programa:

 

 

¿Opción (Plaza, Grupo, Estado, Fin)? p
¿Fila (La 10)? 4
¿Asiento (A a EJ? €

 

[TARJETA DE EMBARQUE |
| Fila: 4 Asiento: C |

¿Opción (Plaza, Grupo, Estado, Fin)? e

A B e D E F
12000. 000
2000. 000
2.000 00060
2000 000

| 530110 00
| $000 000
1400) (000
| 8167 (9 (7) EJ 6) (2
| 362107 010) 47
ODO 000

¿Opción (Plaza, Grupo, Estado, Fin)? g
¿Número de plazas (2 a 6)? 4

A BOC DOE F
1040 Mm
200404 1 00 3
30060 000
406) 4) (00 1) 0) 0)
5 (RM (m0 () ()
6(91C01 (16) CE
7604.07) (3 €) (3
$09 11 C7 (3 3 €)
8 3 01 CY) (€) (7
10 (3: 02 € 13 0) €)

¿Cor

    
 

| TARJETA DE EMBARQUE |
| Fila: 5 Asiento: A |

 

 
   
  
    
   
 
 
 
 
    
     
    
 
  

TARJETA DE EMBARQUE |
Fila : 5 Asiento

ión (Plaza, Grupo, Estado, Fin)? g
mero de plazas (2 a 6)? 5

   

 

000 10,»
0400 €
000 10%
7 £1 41 (1420)

2) 5 1 0
MAA MA )
E) Es EJ 69 19:06)
6) (UI 16) (4) 4)
(6) EC) 691/69
(90201 (91210)

'¿Confirmar (S/N)? s

 

 

| TARJETA DE EMBARQUE |
6 Asiento

   

TARJETA DE EMBARQUE
| Fila: 6 Asiento

    
   
 

   

 

¿Opción (Plaza, Grupo, Estado, Fin)? g
¿Número de plazas (2 a 6)? 3

 

A BOC DOE EF
100 00 cu 1
2000 SN)
58000 00
2000 008
E 9 1 1?
$004 0d
FL CPC 0
BC) t)() 044) 4)
YC) EX) €) 1)06)
10 () () ()> (Y) €) €)
 

31

Fundamentos de programación

 

¿Confirmar (S/N)? s

 

| TARJETA DE EMBARQUE |
| Fila: 4 Asiento: D |

 

TARJETA DE EMBARQUE — |
Fila: 4 Asiento: E |

 

| TARJETA DE EMBARQUE |
| Fila: 4 Asiento: F |

 

¿Opción (Plaza, Grupo, Estado, Fin)? £
Tema 12

Esquemas típicos de operación
con formaciones

Cuando se trabaja con colecciones de datos es habitual que las operaciones
globales sobro la colección se realicen a base do operar con los elementos uno
a uno. Esto exige el empleo de esquemas de programas en los que se recorren
los elementos de la colección en un orden adecuado.

 

De momento se han introducido las estructuras de tipo formación (vectores
y matrices) para almacenar colecciones de datos. En este tema se introducen los esquemas típicos de operación con formaciones, incluyendo recorrido,
búsqueda, inserción y ordenación así como ciertas técnicas partienlares que
facilitan su programación tales como centinelas y matrices orladas. Además,
para los esquemas básicos se realiza previamente su especificación formal y
se razona sobre la corrección de las implementaciones empleando los conceptos de precondición, postcondición, invariante y variante ya utilizados en los

 

 

 

 

Al igual que entonces, se emplea una notación lógico-matemática convencional,
con algunas simplificaciones y adaptaciones para hacerla más asequible a los
usuarios de lenguajes de programación C, C++ y similaros. La notación se
describe de manera más precisa en el apéndice C.

En cualquier caso conviene recordar que las expresones lógico-matemáticas
no triviales son relativamente difíciles de leer, por lo que siempre deberían ir
acompañadas de una descripción en lenguaje natural que aclare el significado
esperado.
 

316 Fundamentos de programación

 

12.1 Esquema de recorrido

El esquema de recorrido consisto en realizar cierta operación con todos y cada
uno de los elementos de una formación (en algunos casos con parte de ellos).
Evidentemente el esquema de recorrido se puede aplicar a formaciones de
cualquier dimensión tales como matrices con dos o más índices. Sin embargo,
para facilitar la compresión las explicaciones se circunscriben al caso de un
vector (una dimensión).

 

La forma más general del esquema de recorrido sería:

iniciar operación

mile (quedan elementos sin trutar) 4
elegir uno de ellos y tratarlo

,

completar operación

 

La corrección de este esquema, en términos generales, está garantizada por
su propia construcción. Al final del bucle la condición de repetición (quedan
elementos sin tratar) habrá dejado de cumplirse, y por tanto se cumplirá
su complemento (todos los elementos han sido tratados). Por otra parte la
terminación del bucle while está garantizada, ya que el número de elementos
ue faltan por tratar es un valor finito no negativo, que va disminuyendo en
cada iteración, es decir, la expresión variante es simplemente el (número de
elementos sin tratar).

Si es aceptable tratar todos los clementos en el orden de sus índices, el esquema.
de recorrido se puede concretar como un bucle for, más sencillo de entender.
Para el caso de un vector v (una dimensión) con un múmero N de elementos
(los índices van de O a N-1):

 

const int N=...;

typedef ... T_Elemento ...;

typedef T_Elemento T_Vector[N];

T_Vector v;

iniciar operación

for (int 1-0; i<Nj ie) €
tratar ofi

,

completar operación

Como ejemplo, la siguiente función calcula la suma de los elementos de un
vector abierto do números reales. Para razonar su corrección, el código se ha
anotado con las aserciones correspondientes a la precondición, postcondición
Esquemas típicos de operación con formaciones 317

 

y un invariante adecuado para el bucle. No es necesario identificar explícitamonto la variante del bucle, ya que todo bucle for de C+ tiene garantizada su

 

terminación.
float SumaV( const float v[], int N) (
«PRE: »

float suma = 0;

 

for (int 1-0; Nj i++) 4
suma = suma + v(i];

3

 

|
| <INVARTANTE; suma=Yv(0 .. i—1]»
| return suna;
«POST: SumaV(»,N)=E 00 .. NJ»

+

En este ejemplo la precondición queda vacía (vale siempre “cierto”), porque
siempre se puede obtener ln.suma de los elementos del vector, incluso aunque
tenga tamaño 0. La inicialización de la operación global consiste en poner a
cero la variable suna. El invariante indica que la variable suna al comienzo de
cada iteración contione la suma de los elementos ya procesados. La terminación
de la operación no exigo ninguna acción adicional. La postcondición expresa
que la variable suna al terminar la operación contiene la suma de todos los
elementos del vector. Esto se deduce del hecho de que al final del recorrido
todos los elementos han sido procesados.

Otro ejemplo ilustrativo es obtener el valor máximo de los números almaconados en un vector. En este caso el esquema es algo más complejo porque
el máximo sólo existe si hay al menos un elemento, y además el tratamiento del primer elemento es diferente al de los demás. Si tratamos de seguir
directamente el esquema inicial tendríamos lo siguiente:
float MaximoV( const float v[], int N) £
«PRE: N>0%

float max;

«INVARIANTE: ¡=0V maz =maximo(uí0 -- ¿= 1)»
for (int i-0; i<N; i++) £
if ( 1 vibra) £
max = víil;

 

Y
,
return max;
«POST: MazimoV(v,N) =maximo(ol0 -- N=1)»
,
 

   
  
   
  
   
  

318 Fundamentos de programación:

 

El invariante contiene una doble condición. En general nos dice que la vari:
max contiene en todo momento el valor máximo de los clementos que ya ham.

sido procesados (maz = mazimo(v[0..i— 1))), y por tanto al final ten
el valor máximo de todos los elementos del vector. Como caso especial al
comienzo del bucle (¿ = 0) no se impone ninguna restricción al valor de

variable max, ya que el máximo no está definido para una colección de
elementos.

Si queremos evitar la doble condición (i==0 || v[i]>max) dentro del bucle,
podríamos tratar el primer elemento por separado, fuera del bucle, y reco
iterativamente los restantes elementos a partir del segundo:
float MaximoV( const float v[], int N) £
«PRE: N>0%

float max;

max = v[0];
«INVARIANTE: maz=mazimo(v[0 .. ¿—1])»
for (int 5 AN; de.) 4
if (vlibmaod (
max = v[i];

  

 

 

return max.
«POST: MazimoV(v, N) = mazimo(oJ0 . N—1])»

12.1.1 Recorrido de matrices

Si la formación es de tipo matriz, para hacer el recorrido se necesitan tantos
for anidados como dimensiones tenga la formación. Por ejemplo, el recorrido
es la operación típica que se debe realizar con una formación cuando se quieren
inicializar todos sus elementos. El siguiente fragmento de código muestra cómo
inicializar a cero todos los elementos de la una matriz z de números enteros. Se
prescinde de formalizar los razonamientos de corrección por ser trivial en este
caso, ya que el tratamiento de cada elemento es completamente independiente
del de los demás, y no hay variables intermedias que vayan acumulando el
resultado de cada repetición.

const int N

typedef int TMatriz[N][N];
TMatriz z;

 
 
  
  
  
   
  
 
 
  
   
 
 
 
 
   

juemas típicos de operación con formaciones 319

 

Cint 4-0; 1<N; i++) (

for (int j=0; j<N; j+e) 4
211103] =0;

y

'Si se quieren escribir los valores de la matriz z, por filas, se puede utilizar el
¡mismo esquema, en el que al finalizar cada fila se salta a una nueva línea:

AmtE( e");

(int i=0; iN; i++) 4

for (int ¿=0; ¿05 519) €
printe( "ésa", 211]03] 9

)

print£c a");

 

3

La multiplicación de dos matrices x e y para dejar el resultado en la matriz z es
un ejemplo muy interesante de recorrido. Primero so inicializa cada elemento
de la matriz 211313] a cero utilizando el esquema anterior. A continuación,
al mismo elemonto inicializado se le van sumando los productos de cada uno
de los elementos de la fila i de la matriz x por los correspondientes elementos
de la columna j de la matriz y . Este cálculo de los productos para cada
elemento se consigue mediante otro recorrido anidado al de inicialización, sobre
los elementos de la fila/columna afectados:
for (int i=0; i<N; i++) (
for (int ¿03 joNj je) (
215)03) = 0;
for (int k: KN; k++) 4
205J03] > 205103] + «LiJ00*yI 031;

 

 

El razonamiento de corrección de los bucles externos es trivial. El razonamiento del bucle interno es similar al del ejemplo anterior de sumar los elementos
de un vector.

12.1.2 Recorrido no lineal

En los ejemplos anteriores el índice usado para controlar el bucle nos señala
directamente al elemento a procesar en cada iteración. En ciertos casos el
elemento a procesar debe elegirse realizando ciertos cáleulos, y el contador de

 

 
 

320 Fundamentos de progr:

 

  
   
   
    
  
  

 

iteraciones sirve fundamentalmente para contabil
detectar el final del bucle,

zar el avance del recorrido?

Un ejemplo puede ser la construcción de un cuadrado mágico, en el que
suma de los números de cada fila, columna y diagonal principal es sie
la misma. Si el lado es impar, se puede construir rellenando las casillas
números correlativos, empezando por el centro de la fila superior y avan:
en diagonal hacia arriba y a la derecha. Al salir del cuadro por un lado
pasa a la casilla correspondiente del lado contrario. Si la siguiente casilla
avance diagonal ya está ocupada no se avanza, sino que se desciende a la
inmediatamente debajo para continuar el recorrido. Para un cuadrado de
3 el proceso sería el mostrado en la figura 12.1.

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

 

1 1 1 ó
3 3

2 2) [4] J2

1 1T6 318] [8178] [eTaTe

3|5 3|5 315[7|[3]5[7] [3[5[7

a] [2]l2 4] [2] [+[ [2] [=Tof2

 

 

 

Figura 12.1 Recorrido no lineal: construcción de un cuadrado mágico.

El fragmento de código que rellona el cuadro de tamaño N, suponiendo que
previamente todas las casilla tienen valor cero, sería:

 

const int N=...;

typedef int T Matriz[N][N];
TMatriz cuadro;

int fil, col;

 

fil=0;

col=N/2;

for (int k = 1; k <= NN; ke*) [
cuadro[£i1][co1] = k;

 

 

Lil = (BN) KN
col = (col+1) % N;
if (cuadro[fil][col] 1= 0) 4

 

fil
col
,

(£i1+2) KN;
CcoleN-1) % N;

 
Esquemas típicos de operación con formaciones

12.2 Búsqueda secuencial

En las operaciones de búsqueda secuencial se examinan uno a uno los elementos de la colección para tratar de localizar los que cumplen una ciorta
condición. Si realmente queremos encontrar todos los que existan, entonces la
búsqueda equivale a un recorrido como los mostrados en la sección anterior.
¡Como ejemplo, si queremos determinar el número de Apariciones de un cio;
to elemento buscado dentro de un vector v podremos utilizar el esquerna de
recorrido siguiente:

¡typedef ... T_Elemento ...;

“int Apariciones( T_Elemento buscado, const T_Elemento v[], int N)
«PRE: »
int veces = 0;

«INVARIANTE: veces =cardinal(o/k=0 .. i—1], v[k] = buscado)»
for (int 1-0; 1; i++) (
if (v[i] == buscado) (
veces++;
,
$
return veces;
«POST: veces=cardinal(o[k=0 .. N—1], v[K] = buscado)»
y

Si no necesitamos localizar todos los elementos que cumplen la condición sino

sólo uno de ellos, si lo hay, entonces no necesitamos recorrer la colección en

su totalidad. El recorrido se debe detener en cuanto se encuentre el elemento

buscado, y por tanto sólo será un recorrido completo cuando no se encuentre

el elemento buscado dentro de la colección. Este planteamiento del problema

indica que no se puede utilizar directamente una sentencia for de C£ para la

operación do búsqueda.

iniciar operación

¡while (quedan elementos sin tratar y no se ha encontrado ninguno aceptable) 4
elegir uno de ellos y ver si es aceptable

y

completar operación

Como en el apartado anterior, utilizaremos para las explicaciones un vector v
de una sola dimensión con un número N de elementos (los índices van de 0 a
N-1). El objetivo es localizar si hay algún elemento con un valor dado, y en
este caso indicar su posición. Si no hay ningún clemento igual al buscado se

 
 

      
    
  
    
  
  

    

devuelve una posición negativa como indicación de fallo de la búsqueda.
esquema de búsqueda secuencial se puede plantear como:

typedef ... T_Elemento

 

int Indice( T_Elemento buscado, const T_Elemento v[], int N ) £
«PRE: »
int pos

 

«INVARIANTE: Ningún elemento vl[0.
«INVARIANTE : buscado $ v[0..pos — 1)»
while (pos<N 8% v[pos]!=buscado) (

pos++;
)
if (pos>=N) (
pos = -1;
)
return pos;
«POST: pos >0= vjpos] = buscado A. pos <0= buscado $ v[0..N — 1)»
,

os —1] es el buscado»

   

Cuando la búsqueda es infructuosa la posición pos llega a tomar un valor is
AN, que está fuera del margen superior del vector. La condición del bucle
no se cumple y el bucle finaliza, pero dicha condición incluye una refere:
al elemento v[pos] que no existe. Afortunadamente, como se explicó en
tema 5, el operador 84: de Ct se evalúa “en cortocircuito”. Cuando la pri
condición (pos<N) ya es falsa no se continúa evaluando ninguna condi:
posterior dado que el resultado será necesariamente falso. Si se hubiese esc
(v[pos] I=buscado 84: pos<N) sí se podría intentar accodor al elemento v[N]
que no existe y provocar errores graves en el programa.

  

12.3 Inserción

El problema que se plantea aquí es insertar un nuevo elemento en una colección
de elementos ordenados, manteniendo el orden de la colección. Se supone que
los elementos están almacenados en un vector, ocupando las posiciones desde
el principio, y que queda algo de espacio libre al final del vector (si el vector
estuviese lleno no se podrían insertar nuevos elementos).

La operación se puede realizar de forma iterativa, examinando los elementos
empezando por el final hasta encontrar uno que sea inferior o igual al que se
quiere insertar. Los elementos mayores que el que se quiere insertar se van
moviendo una posición hacia adelante, con lo que va quedando un hueco en
Esquemas típicos de operación con formaciones 323

medio del vector. Al encontrar un elemento menor que el nuevo, se copia el
muevo elemento en el hueco que hay en ese momento, La figura 12.2 muestra un
ejemplo de inserción en una colección de valores numéricos enteros ordenados
sde manera creciente. El muevo valor 10 debe insertarse entro el 8 y el 11.

 

 

obre

 

 

 

 

 

 

 

 

 

 

]
w>o|1[s]s]m]15 23 []
w>[1]5]s]n 1w]2]-..-. | ]
w>[+]s]e] [n[w[]----] ]
so RERREEE ]

 

 

 

 

 

 

Figura 12.2 Inserción de 1 nuevo elemento.

'Un esquema general del código de la operación sería:
Iniciar inserción
lle ( ! Final 8k ! Encontrado hueco ) £
Desplazar elemento
Pasar al siguiente elemento
,

Insertar nuevo elemento

A continuación se concreta este código para la inserción de un mievo elemento
entre los N elementos de un vector, que ya están ordenados. Evidentemento,
después de la inserción, el vector tendrá un elemento más. Por tanto, el valor
de N siempre deberá ser menor que el tamaño del vector. En todo momento
el índice auxiliar j señala al punto en el que hay hueco:

¡typedef ... T_Elemento ...;

 

 

void Insertar( T_Elemento v[], int N, T_Elemento elemento ) €
«PRE: v[0.N—1) está ordenado»
int j=N

 

«INVARIANTE: >
while (j > 0 88 elemento < v[j-11) 4
vljl = vii);

,
v[j] = elemento;

 

 
 

 

324 Fundamentos de programación

 

«POST: [0_N] está ordenado y
contiene los valores v[0.N—1] más “elemento”»

y

Es importante el orden en que se evalúan los términos de la condición del
bucle. Si se hubiese escrito (elemento < v[j-1] 8% j > 0) sería posible
intentar acceder al elemento v[-1], que no existe.

En este ejemplo se ha omitido escribir el invariante en modio del código, y
menos aún formalizarlo, por resultar muy prolijo. Dicho invariante, en lenguaje
natural, es:

«INVARIANTE: Los elementos delante del hueco están ordenados entre sé.
y los elementos detrás del hueco están ordenados entre sí y son mayores que
el nuevo, y los elementos delante del hueco son menores o iguales que los de
detrás del hueco, y la colección de valores delante y detrás del hueco coincide
con el contenido inicial del vector»

Por su parte la expresión variante es obvia:

«VARIANTE:

 

Número de elementos delante del hueco» > «VARIANTE: j»

12,4 Ordenación por inserción directa

En este apartado se aborda una solución para la ordenación de datos almacenados en un vector. Existen diversos métodos de ordenación de vectores
cuyo estudio cae fuera del alcance de este libro. El método de ordenación por.
inserción directa es uno de los más sencillos y está basado en el esquema de
inserción mostrado on el apartado anterior. Por ejemplo, se trata de orde:
nar un vector v de diez elementos (índices de O a 9) y que inicialmente está
desordenado, tal como se muestra en la figura 123.

 

001.2. 3.4 05060708

ETs a |12]65] 9 [36] 7 211]

Figura 12.3 Vector inicial

 

 

 

 

 

 

 

Para comenzar, el primer elemento (21) está ya ordenado consigo mismo. A
continuación, extracmos el segundo elemento (5) y se genera un hueco, que
se puede utilizar para ampliar la parte del vector ya ordenada. El método:
de ordenación consiste en insertar el elemento extraído en su lugar correspon
diente entre los clementos ya ordenados. Este proceso se repite con el tercero,
cuarto, quinto, .... y décimo elemento hasta quedar ordenado todo el vector.

 
 
  
  
  
 
    
   
    

Esquemas tí

icos de operación con formaciones 325

 

La secuencia de inserciones de los sucesivos elementos del vector se muestra
sen la figura 12.4.

insertar [3723 [i2Tes]o[3[7]2 740]
Insertar 3 >o[315im| 121651 9/36/7|2145
vetar? Tale 171778]
inserrss: — [3 To Ti ]afes]olei7]218
Insertaro =[3]5 797 =l2 [ss] 36] 7 ] 2 [45
nero: — [TT TAB 1778]
mera? > [Jsp Telalsie[z13]
wea > TT TRA]
Final >RlTs]7ToTeR]2]35T 45] 65

Figura 12.4 Secuex

 

 

 

 

 

 

 

 

ll

 

 

 

de inserciones para la ordenación

 

la secuencia se muestra con distinto fondo la posición del hueco inmediajente antes de la inserción del siguiente elemento. El final de la parte del
ya ordenada se marca con una línea de mayor grosor. Además, los
jeros ya ordenados también están en negrita. La inserción se realiza desde
posición anterior a la del elemento extraído.

 

   

 

continuación se muestra el código de una posible realización. La variavalor guarda el elemento extraído de la posición 4. La ordenación total
vector se consigue mediante ol recorrido de todos sus elementos, desde el
do, para buscarles su hueco e insertarlos en él.

 

 

.:. Elemento

 

 
 

     
  
   
 
  
   
    
   
 
 
  

Fundamentos de prog

void Ordenar( T Elemento v[], int N ) 4
«PRE: »

T_Elemento valor;

int j;

«INVARIANTE : v[0.i— 1] está ordenado»
«INVARIANTE: Vke (1.i—1) 0 0[k]>v[k— 1)»
for (int i-1; ioN; d++) 4

vid;

 

 

while (j > 0 4% valor < víj-11) 4
v[3] = vlj-1;
ds;

 

vIj] = valor
y

«POST: vl

)

 

—1] está ordenado y conticne los valores v[0..N — 1)»

12.5 Búsqueda por dicotomía

Cuando los datos están ordenados la búsqueda resulta mucho mas rápi
Si comparamos el elemento a buscar con cl que está justo en la mitad
los datos ordenados, podemos decidir si es ése el clemento que buscamos
debemos continuar buscando, pero sólo en la mitad derecha o sólo en la mil
izquierda.
El mismo proceso se puede repetir con la mitad elegida, comparando con
elemento que está en el centro de dicha mitad. En cada comparación,
búsqueda se reduce a comprobar si el dato buscado está entre la mitad
los anteriores, La búsqueda finaliza cuando el elemento se encuentra, o bi
cuando la zona pendiente de examinar queda reducida a un sólo clemes
(0 ninguno) después de sucesivas divisiones en mitades. Esta búsqueda se
denomina búsqueda por dicotomía. El esquema general de búsqueda sigue
siendo análogo al utilizado anteriormente. Sin embargo, ahora es necesario
cambiar la obtención del siguiente elemento a comparar:
iniciar operación
while (quedan elementos por ezaminar y no se ha encontrado ninguno aceptable) €
elegir el elemento central y ver si es aceptable

y

completar operación:
-mas típicos de operación con formaciones 327

   
 
   
  
  
   
   
 
   
  
   
   
   
 
 
 
 
 
   

ejemplo, realizaremos la búsqueda por dicotomía de un valor buscado
un vector v de N elementos. Se necesitan dos variables para acotar el trozo
vector que todavía queda por comprobar y otra variable para señalar cl
to medio de ambas. Estas variables las denominaremos izq , dch y mitad.
¡bién usaremos una variable pos para almacenar finalmente el resultado de
búsqueda, es decir, el lugar en el que se ha encontrado el elemento buscado,
bien un valor negativo (p. ej. -1) si el elemento buscado no se encuentra. El
digo s como sigue:

T Elemento ...;

 

Indice( T_Elemento buscado, const T_Elemento v[], int N) (
RE: v está ordenado»

int izq, dch, mitad, po:
izq = 0; deh = N-1; pos =-1;

 

«INVARIANTE : el clemento buscado, si existe, está en la zona vlizg..dch]»
«INVARIANTE: Vk€ (0.izq—1) e (v[k] < buscado) A
Vk € (dch+1.-N — 1) e (v[k] > buscado)»
«VARIANTE: deh—izq +1»
while (pos < 0 8% izq <= deh) (
mitad = (izq + deh) / 2;
if (vímitad] == buscado) £
pos = mitad;
) else if (v[mitad] < buscado) (
dch = mitad - 1;
Y else £
izq = mitad + 1;
y
,
return pos;
«POST: pos >0— vlpos] = buscado A pos <0= buscado E e[0..N — 1)»
y

 

 

 

 

Inicialmente se busca en el vector completo v[izq..dch] = w[O..N-1]. La
variable auxiliar pos se inicializa al valor de fallo de búsqueda (-1), y permanece con dicho valor hasta que se encuentre el elemento buscado, si existo,
en cuyo caso señala a la posición encontrada. En cada etapa se examina el
elemento central de la zona de búsqueda, mitad=(izg+dch)/2), y si v[mitad]
no contiene el elemento buscado la zona v[izq. .dch] se reduce a la mitad de
delante o a la de detrás. El bucle termina cuando se encuentra el valor buscado
o bien cuando la zona de búsqueda ya no contiene elementos (izg>dch)

   

 

La terminación se garantiza fácilmente. Como variante se puede utilizar el
tamaño de la zona de búsqueda dch-izq+1, que se reduce estrictamente a la

 
 

 

 

   
  
 
 
 
  
     
  
    
   
 
    
 
 
 
    
   

328 Fundamentos de program:

mitad (cociente entero por defecto) en cada paso, y por tanto se reduce a
en un número finito de pasos,

La búsqueda por dicotomía se puedo aplicar, por ejemplo, en el esquema
ordenación por inserción, para localizar el lugar en que hay que insertar
nuevo elemento.

12.6 Simplificación de las condiciones de contorno

La programación de operaciones con vectores, realizadas elemento a elems
exige con frecuencia realizar un tratamiento especial de los elementos ext
del vector o, en general, de los elementos del contorno de wna formación.
continuación veremos algunas técnicas particulares para evitar la necesidad
detectar de manera explícita si se ha llegado a un elemento del contorno y,
realizar con él un tratamiento especial.

  

12.6.1 Técnica del centinela

Por ejemplo, en el procedimiento general de búsqueda es necesario comp,
en cada iteración una condición doble: si no se ha alcanzado todavía el
del vector, y si se encuentra el elemento buscado. Repetimos aquí el esqu
de la sección 12.2:

 

iniciar operación

while (quedan elementos sin tratar y no 30 ha encontrado ninguno aceptable) £
elegir uno de ellos y ver sí es aceptable

A

completar operación

La doble condición del bucle de iteración complica ol código y supone
tiempo adicional en la ejecución de cada iteración. Si garantizamos que
dato buscado está dentro de la zona de búsqueda, antes o después se termi
encontrándolo y ya no será necesario comprobar explícitamente si se ale
el final del vector.

 

La manera de asegurar esto es incluir el dato buscado en el vector antes
comenzar la búsqueda. El vector se amplía, según se muestra en la figura 1:
con un elemento más situado al final (si se hace la búsqueda hacia adel:
o situado al principio (si la búsqueda se hace hacia atrás). En esc el
adicional se copia el dato a buscar antes de iniciar la búsqueda para
actúe como centinela (C) y asegure que la búsqueda nunca acaba de f
infructuosa.
 
  
 
  
     
   
 
   
   
  
   
 
 
 
 
  
  
   
  
   

Esquemas típicos de operación con formaciones 329

 

 

 

 

 

 

Figura 12.5 Vector con centinela situado al final.

Ahora, cl esquema general de búsqueda se simplifica de la siguiente forma:
iniciar operación (colocar el centinela)

ile (no se ha encontrado un elemento aceptable) £

elegir otro elemento y ver si es aceptable
y

¡completar operación (si se ha encontrado el centinela, indicar fallo en la búsqueda)

Igual que en los ejemplos anteriores, usaremos una variable pos para almacenar
fnalmente el resultado de la búsqueda, es decir, el lugar en el quo se ha
“encontrado el elemento buscado, o bien un valor negativo (p. ej. -1) si el
¡elemento buscado no se encuentra. El fragmento de programa sería como
sigue:

+ T_Elemento .

 

Indice( T_Elenento buscado, const T_Elemento v[], int N ) £
int pos

 

vIN] = buscado; /* centinela 3/

while (v[pos]!=buscado) (
poste;

,

i£ (pos>=N) 1 /* lo que se encuentra es el centinela */
pos = -1;

,

return pos;

 

este ejemplo la búsqueda se hace hacia adelante. El centinela se coloca al
, detrás del último elemento del vector original, es decir, en la posición
Si al final de la búsqueda la variable pos tiene un valor igual a N, quiere
ir que la búsqueda ha sido infructuosa: el clemento encontrado ha sido el
tinela, y no un elemento del vector original.

 

técnica del centinela so puede emplear en la ordenación por inserción,
echando que cada muevo elemento a insertar entre los anteriores está ya
lo al final de la parte ordenada. Ahora la localización del lugar que le
sponde y el movimiento de los elementos posteriores para hacer hueco se

 
 

  

330. Fundamentos de program:

 
   
 
    
   

 

hacen por separado, y la búsqueda entre los elementos anteriores se hace
adelante y no hacia atrás. La nuova redacción del programa es la siguiente:

typedef ... T_Elemento ..

 

void Ordenar( T_Elemento v[], int N ) £
T_Elemento valor
int j;

 

for (int 10 ie) dl
valor = v[il;
/*— Buscar la nueva posición del elemento, sin mover nada --*/

 

 

j

while (valor > v[j1) £
Je

+

/*-- Mover elementos mayores y poner el elemento en su sitio -
 

   

for (int k=i-1; lo=:
vIk+1] = v[k];

,

ví] = valor

3
4

Como se puede observar, la técnica del centinela simplifica la condición
bucle para la operación de buscar la nueva posición del elemento.

12.6.2 Matrices orladas

Cuando se trabaja con matrices, también se pueden simplificar las condicio,
de contorno utilizando matrices orladas. Estas matrices se dimensionan com
dos filas y dos columnas más do las necesarias tal como se muestra en la figura;
12.6

La matriz original la forman las filas 1 a M y las columnas 1 a N. Las filas y
columnas extra garantizan que todos los elementos de la matriz original tienen:
elementos vecinos en todas las direcciones. Antes de operar con la matriz se
inicializan las filas y columnas extra con un valor de contorno (C) que permita
simplificar la operación de modo que el tratamiento de los elementos del borde
de la matriz original sea idéntico al de los demás.

 

Para ilustrar el uso de una matriz orlada supongamos que tenemos una imagen.
en blanco y negro (escala de grises) de Ancho x Alto pixeles almacenada en.
una matriz definida de la siguiente forma:
Esquemas típicos de operación con formaciones

 

20;
¡const int Borde =-1;
¡const int Blanco = 0;
¡const int Negro = 5;

 

Figura 12.6 Matriz orlada.

/* Anchura de la imagen */

/* Altura de la imagen */

/* Indicador de borde de la imagen */
/* Nivel bajo de grises = blanco */
/* Nivel alto de grises = negro */

¡typedef int Imagen_t[Alto+2] [Ancho+21;

'Inagen_t imagen;

Los puntos de la imagen ocupan las columnas 1 a Ancho y las filas 1 a Alto.
¡Cada clemento de la matriz guarda el nivel de gris del correspondiente punto de
la imagen. Las columnas O y Ancho+1 y las filas O y ALto+1 son los elementos
extra del contorno. Para tratar cada punto de la imagen individualmente
basta hacer un recorrido completo, sin ninguna complicación. Por ejemplo,
para contrastar la imagen y reducir todos los puntos gris claro a blanco y
todos los gris oscuro a negro, bastará escribir:

'for (int i=l; ieAlto; i++) (
for (int j=1; j<=Ancho; j++) £

i£ (imagen[i][31

nivel) (

imagen[i][5] = Blanco;

) else £

imagen[i][j] = Negro;

7

 
  
   
   
    
   
   
  
  
  

332 Fundamentos de program:

 

En el fragmento de código anterior no se ha usado para nada el cont
de la matriz. Supongamos ahora que queremos recortar la imagen, esto
eliminar aquellos puntos externos de la imagen que están en blanco,
dejando los puntos blancos que son interiores y están rodeados de pu
negros. El tratamiento de cada punto exige examinar al mismo tiempo.
puntos contiguos. El programa se simplifica si se garantiza que todo pn
útil de la imagen tiene puntos contiguos en todas las direcciones, es decir,
hay situaciones excepcionales en los bordes.

 
 

Para ello so aprovecha el contorno de la matriz, es decir, la orla, inicializáne
con el valor que indicará los elementos del borde.
for (int i=0; i<-Alto+l; i++) (

imagen(i][0] = Borde;

imagen[i][Ancho+1] = Borde;

   

 

J

for (int i=0; i<-Ancho+l; i++) 4
imagen[0][i] = Borde
imagen[Alto+1][i] = Borde;

y

Suponiendo que imagen está ya contrastada anteriormente y que su conto.
está inicializado al valor de Borde, el recorte se realizaría mediante sucesi
recorridos de toda la matriz en los que los puntos blancos que tienen
punto Borde alrededor deben pasar también a puntos Borde. El proceso
recorte se termina cuando en un recorrido completo de toda la imagen no
ningún punto que cambic, El fragmento de programa que realiza el recorte es
el siguiente:

bool fin;

 

do í
fin = true;
for (int 1
for (int j=1;j<=Ancho;j++) (
if (Cimagen[i][j] == Blanco) 48
(Cimagen[i-1J[3] == Borde) [1
| (imagen[i][j-1] == Borde) 11
| (imagen(i](J+1] == Borde) 11
(imagen[i+1](3] == Borde))) £
inagen[iJ[4] = Borde;
fin = false;

 

 

 

 
Esquemas típicos do operación con formaciones 333

 

Esta forma de operar se denomina de fuerza bruta, y puede ser poco eficiente,
pero es muy sencilla de programar.

Este ejemplo es un fragmento de uno de los programas completos que aparecen
en este tema.

12.7 Ejemplos de programas

A continuación se muestran varios programas completos con ejemplos de sus
respectivas ejecuciones.

12.7.1 Ejemplo: Sopa de letras

Con este programa se trata de realizar la búsqueda de una palabra dentro de
una matriz de caracteres. La búsqueda debe realizarse en horizontal, vertical
y diagonal en ambos sentidos. Por tanto, se pueden establecer 8 direcciones
de búsqueda: norte, sur, este, oeste, noroeste, suroeste, noreste, sureste. En
la búsqueda se deben tener en cuenta los límites de la matriz. La función
Buscar comprueba si la palabra palabra de longitud letras coincido con los
caracteres de la matriz desde la posición: fila y columna, siguiendo la dirección rumbo. Esta función tiene en cuenta los límites de la matriz y devuelve
un resultado cierto o falso según se encuentro o no la palabra buscada.

 

Los demás procedimientos son auxiliares. El procedimiento IniciarSopa inicializa de forma aleatoria la matriz, mediante un recorrido de la misma. Cada
carácter se obtiene a partir de un número aleatorio entre 0 y 26, al que se
suma la posición del carácter *a' dentro de la tabla ASCIL.

El procedimiento Cambiar, es el encargado de pasar de minúsculas a mayúsculas la palabra encontrada. Este cambio se realiza mediante un recorrido
parcial de letras caracteres de la matriz desde la posición: fila y columna,
siguiendo la dirección rumbo.

 

El procedimiento EscribirSopa es un recorrido total de la matriz en el que se
escriben por filas todos los caracteres de la matriz separados por un blanco.

En el programa principal se leo la palabra a buscar, toda en minúsculas, e
inmediatamente se realiza su búsqueda exhaustiva desde todas las posiciones
de la matriz y con todas las direcciones posibles. Si se encuentra, se cambia a
mayúsculas. El listado del programa es el siguiente:
334 Fundamentos de program:

 

 

 

 

RRA
* Programa: SopaDeLetras

* Descripción:

* Este programa busca una palabra en una matriz

* de caracteres, en cualquier dirección, de forma
* — semejante a como se hace en una sopa de letras
enana nadan nan n rr rra caada tra nacn er ranaroias/
*include <stdio.h>

Hinclude <stdlib.h>

Hinclude <time.h>

*include <ctype.h>

const int Filas = /* Filas de la sopa de letras */
const int Columnas = 2 /* Columnas de la sopa de letras */
const int TotalLetras = 26; /* Total letras abecedario inglés */

   

typedef char TipoSopa[Filas] [Columnas];

typedef char TipoPalabra[Columnas];

typedef enun TipoRumbo (Norte, Sur, Este, Oeste,

Noroeste, Suroeste, Noreste, Sureste

 

 

 

 

const int PasoH[8] = (0, 0, 1, 1, 1 13
const int PasoV[8] = ( -1, 1, 0,0, 1,1, -1, 1;
¡Ji

Procedimiento para inicializar de manera

aleatoria una sopa de letras

pea */

void IniciarSopa( TipoSopa sopa ) (
srand( time(NULL) );
for (int £=0; f<Filas; £++) 4
for (int c=0; c<Columnas; c++) (
sopa[£][e] = char(rand(OXTotalLetras+int('a'));

ar
Procedimiento para cambiar "
desde la posición (columa,fila) con el "rumbo" indicado

void Cambiar( TipoSopa sopa, int letras,
int columna, int fila, TipoRumbo rumbo ) £

 
 

7

 
 

Esquemas típicos de operación con formaciones 335

for (int i=1; ic=-letras; i++) (
sopa[fila][columa] = toupper(sopa[fila] [columa]);
/*— Nueva fila y columa según el rumbo --*/
columa = columa + PasoH[rumbo];
fila = fila + PasoV[rumbo];
)
y

pta
Función para buscar las "letras" de una "palabra
desde la posición (columa, fila), con el "rumbo" indicado,
en la “sopa” de letras
A

bool Buscar( const TipoSopa sopa, const TipoPalabra palabra, int letras,

int columa, int fila, TipoRumbo rumbo ) (

int i - 0; /* contador de letras */
bool coincide = true; /* hay coincidencia */

 
   

 

/*-- Invariante: i = n* de letras examinadas
y coincide = "las i letras coinciden" --*/
while (i < letras 84 coincide 66 fila >= 0 8% fila < Filas 88
columa >= 0 4% columna < Columnas) £
/*-- Se acepta coincidencia en mayúscula o minúscula --*/
coincide = palabra[i] == tolower(sopa(£i1a] [columna]
if (coincide) (
e
/*-- Nueva fila y columna según el rumbo --*/
columna = columa + PasoM[ rumbo];
fila = fila + PasoV[rumbo

 

 

 

   

 

Procedimiento para escribir la sopa de letras
te a)
void EscribirSopa( const TipoSopa sopa ) (
print£( a");
for (int ¿=0; i<Pilas; i++) 1
for (int j<Columas; j++) €
print£( "Xe ".sopalil(J] );
J
print£c a");
,
y

 

  

 
336 Fundamentos de programación:

 

 

 

Programa principal

 

e

int mainQ £

TipoSopa sopa;

TipoPalabra palabra;

TipoRumbo rumbo;

int Jongitud;

char tecla; /* último caracter leído */
int encontradas;

/*-- Crear la sopa de letras al azar -—-*/
InictarSopa( Sopa );
EscribirSopa( sopa );

/*-— Búsqueda de palabras —-*/
do (
print£( "¿Palabra a Buscar? " );
/*-—- Leer palabra a buscar, saltando blancos iniciales --*/
scanf( " Xc", trecla ); /* primera letra */
longitud = 0;
while (islower(tecla)) [
palabra[longitud] = tecla;
longitude;
sean£( "Ke", Btecla );
y

/*— Buscar desde todos los puntos posibles
y en todas las direcciones posibles —*/
encontradas = 0;
for (int iFila = 0; iFila < Filas; iFila+) £
for (int iColumna = 0; iColuma < Columas; iColuma++) (
for (int ¡Rumbo = int(Norte); iRumbo <= int(Sureste); iRumbo++) €
rumbo = TipoRunbo(iRumbo);
if (Buscar( sopa, palabra, longitud, iColuma, iFila, rumbo)
/*— Cuando se encuentra se cambia a mayúsculas --*/
Cambiar( sopa, longitud, iColuma, iFila, rumbo)
encontradas++5
Y

 

 

+
3
+

/*-- Mostrar resultado --*/
Af (encontradas > 0) €
print£( "Wkd coincidenciasin”, encontradas );
as típicos de operación con formaciones

337

 

  
  

EscribirSopa( sopa );
Y else (

print£( "YaNo encontrada" );
J

/*-- Repetir búsqueda --*/
print£( "W¿Otra Palabra(S/N)? " )
do (
scanf( " ke", gtecla );
tecla = toupper(tecla);
) while (tecla 1= 'S" 4% tecla
) while (tecla l= 'N');

   

00);

 

 
  

ejecución del programa produce un resultado similar al siguiente:

 

   
    
   

dujapfuerwsyioopspw
aljmsxebfkvhxeepwun
hirwwlyzfqdbhneygrl
vfaeqjxuhiocaszfkor
wjccoybrftizberabjji
vuoicdoxdbrrvoydvyt
ziknwsmkyxhvcbierir
gznqpysw rqzbimenngn
jaqbngazxqbddzpxhue
lbdgananatpxtuiyhzp
abra a Buscar? pena

coincidencias
dwjapfuerwsyiooPspw
aljmsxebfkvhxeEpwun
hirwwlyzfqdbhNcygrl
vfaeqjxuhiocAszfkor
Wjccoybrftjzberabjj
vuoicdoxdbrrvoydvyt
ziknwsmkyxhvcbierir
gznqpyswrqazbimenmagn
jaqbnggzxabddzpxhue

mlbdganamatpxtuiyhzp

¡¿Otra Palabra(S/N)?

¿Palabra a Buscar? dos

 
 

  
  

338 Fundamentos de progr:

 

No encontrada
¿Otra Palabra(S/N)? s

¿Palabra a Buscar? voy

1 coincidencias
tdwjapfuerwsyiooPspw
paljmsxebfkvhxeEpwun
fhirwwlyzfgqdbhNcygrl
yvfaegjxuhiocAszfkor
jwjiccoybrftizberabjj
jvuoicdoxdbrrvoYdvyt
yziknwsmkyxhvcbierir
tgznqgpyswrqzbinenmgn
ojaqbngazxqbddzpxhue
wlbdganamatpxtuiyhzp
¿Otra Palabra(S/N)? 8

¿Palabra a Buscar? ir

3 coincidencias
tdwjapfuerusyiooPspw
paljmsxebfkvhxeEpwun
fhIRwwlyzfqdbhNcygrl
yvfaeqjxuhiocAszfkor
iwjccoybrftjizberabjj
jvuoicdoxdbrrvoYdvyt
yziknwsmkyxhvcbieRrIR
tgznapysurqzbimenmgn
ojaqbngazxqbddzpxhue
vlbdganamatpxtuiyhzp
¿Otra Palabra(S/N)? n

12.7.2 Ejemplo: Imprimir fechas en orden
En este ejemplo so lee una colección de fechas, comprobando que son correctas,
y a continuación se imprimen, ordenadas cronológicamento.

Las fechas se leen de la entrada principal. Cada fecha de entrada comprende
tres valores, correspondientes al día, mes y año. El día y el año se dan en
Esquemas típicos de operación con formaciones 339

forma numérica. El mes puede darso como número o en letra y por ello se
utiliza un esquema union con dos campos alternativos: un número entero o
bien un vector de hasta 15 caracteres.

El año puede darse completo, con cuatro dígitos, o en forma abreviada, con
dos. En este último caso se entiende que es un año de nuestro siglo, y se le
suma 2000. La lectura de datos termina al introducir un valor numérico cero
para el día.

Las fechas leídas se comprueban para garantizar que el día, mes y año forman
una combinación consistente. Las fechas erróneas so descartan.

Las fechas correctas so van almacenando en una tabla de fechas, que se mantiene ordenada en todo momento. Cada nueva fecha leída se inserta en la
posición que le corresponde, en orden cronológico. Al final se imprime toda la
colección de fechas, en el orden en que se han almacenado.

A continuación se presenta un ejemplo de ejecución del programa. Los datos
de entrada son:

 

10 Marzo 1972
30 feb 82

29 FEB 1900
1372

29 FEB 2000
28 diciem 1993
4 enero 91

15 error 89
10 10 10

'o

El resultado obtenido a la salida es:

 

 

Fechas leídas:

10-Marzo-1972

30-Febrero-2082 ** incorrecta **
29-Febrero-1900 ** incorrecta **
11-Marzo-2072

29-Febrero-2000
28-Diciembre-1993

4-Enero-2091

15- -2089 ** incorrecta **
10-Octubre-2010

Fechas en order
10-Marzo-1972

 

 
 

340 Fundamentos de programación

28-Diciembre-1993
29-Febrero-2000
10-Octubre-2010
11-Marzo-2072
4-Enero-2091

 

El listado completo del programa es el siguien:

 

 

PA

 

+ Programa: Fechas
* Descripción:
+ Programa que lee una serie de fechas, comprueba que son

correctas, y las imprime en orden cronológico.
AAA RARA RARE RARA
*include <stdio.h>
tinclude <ctype.h>

typedef struct fecha_t (
int día;
int mes;
int anno;

5

const int maxNombre = 15;
typedef char nombreMes_t[maxNombre];
typedef union dato_t

int mesNumero;

nombreMes_t mesLetra;
+
typedef struct datoMes_t (

bool esNumero;

dato_t dar
y

 

const int maxFechas = 100;
typedef fecha t listaFechas_t[maxFechas];

listaFechas_t lista; /* Lista de fechas leídas */
int nunFecha: /* número de fechas leídas */

 

typedef nombreltes_£ Jistalombres_t[13];
listaNombres_t nombres = /* sin nombre cuando mes = 0 */
/* nombres de los meses */

 
Esquemas típicos de operación con formaciones 341

 

"Abril",
"Mayo",
“Junio”,
“Julio”,
"Agosto",
"Septiembre",
"Octubre",
"Noviembre",
"Diciembre"

y
Comprobar si una fecha es correcta
bool EsCorrecta( const fecha_t fecha ) £
if ((fecha.anno<=0) || (fecha.dia<-0)) £
return false;
J
switch (fecha.mes) (
case 1:
case 3:
case 5:
case 7:
case 8:
case 10:
case 12:
return (fecha.dia <- 31);

 

 

 

 

=== /

 

case 9:

case 11:
return (fecha.dia
break;

case 2:
if (fecha.annok4 == 0 84 fecha.anno%100 I= 0 ||

 

= 30);

fecha. annox400

return (fecha.dia
) else (

return (fecha.dia

   
 
 
342 Fundamentos de programación:

 

 

void EscribirFecha ( const fecha_t fecha ) (

print£( "X2d-%s-X4d", fecha.dia, nombres[fecha.mes], fecha.anno );

 

y

pS
Leer un mes en núnero o letra

ta]

void LeerMes( datoMes_t 8 mes ) £
char c;

int ki

 

 

 

do £
scanf( " Xe", 8c );  /* leer primer carácter */
) while (! isalnum(c)); /* ignorando puntuación */
if (isdigit(c)) £  /* mes como múnero */
mes.esNunero = true;
mes. dato.mesNumero
do (
mes .dato.mesNumero = mes.dato.mesNumero*10 + int(c)-int(*0');
scanf( "Xc", Ec );
J mhile (isdigit(c));

 

) else ( /* mes en letra */
mes.esNumero = false;
k=0;
do (

if (k<maxiombre) £
mes.dato.mesLetra[k] = c;
kee;

J

scanf( "Xe", 8c );

) while (isalpha(c));
,
3

A

 

Convertir a minero el mes en letra. Sólo se
comprueban los tres primeros caracteres.
Si no es correcto se devuelve cero.

 

int NuneroDelMes( const nombreMes_t nombre ) (
int k;

 
Esquemas típicos de operación con formaciones 343

 

  

for (int mes=k=0;
while (toupper(nombre[k]) == toupper(nombres[mes][k])) £
if (k >= 2) 4 /* coinciden 3 caracteres */
return nes;

mes<=12; mes++) 4

 

 

 

Leer una fecha con el mes en núnero o letra.
Si el día es cero, se asume fin de los datos

void LeerFecha( fecha_t £ fecha ) 1
datoMes_t mes;

 

*/

 

fecha.dia = 0;

scan£( "xd", Afecha.dia );

if (fecha.dia != 0) 4
LeerMes( mes );

 

if (mes.esNunero) (
fecha.mes = mes.dato.mesNunero;
) else (
fecha.mes = NuneroDelMes( mes.dato.mesLetra );
7
scan£( "xd", Efecha.anno );
if (fecha.anno < 100) 4
fecha.anno = 2000 + fecha.anno;

 

Y E
Comparar dos fechas. Devuelve cierto si
la primera es posterior a la segunda
mmm==*/
bool EsPosterior( const fecha_t f1, const fecha_t f2 ) (
if (fl.anno != £2.anno) (
return (f1.anno > £2.anno);
) else if (fl.mes != f2.mes) £
return (fl.mes > £2.mes);
) else (
return (£1.dia > f2.dia);

 

 

 

 

 

 
 

 

344 Fundamentos de program

 

3
)

A ss
Insertar una fecha, en orden, en la lista de fechas

void InsertarFecha( const fecha_t £ ) 4
int izquierda, derecha, centro;

 

 

   

/*-- Poner la fecha como centinela, al final --*/
lista[munFechas] = £;
nunFechas++5

/*-- Determinar la posición que le corresponde --*/
izquierda = 0;
derecha = nunFechas-1;
while (izquierda < derecha) (
centro = (izquierda+derecha)/2;
if (EsPosterior( f, lista[centro] )) (
izquierda = centro+l;
) else (
derecha = centro;
y
J

/*-- Hacer sitio para la nueva fecha --"/

for (int pos = nunFechas-1; pos >= izquierda; pos--) (
lista[pos+1] = lista[pos];

)

 

/*-- Colocar la fecha en su sitio
lista[izquierda] = £;

 

3

fuma
Programa principal

 

 

fecha_t fecha; — /* fecha leída */
bool seguir = true;

printf( "Fechas leídas:Xn" );

nunFechas = 0;

LeerFecha( fecha );

seguir = (fecha. dia != 0);

while (seguir 4% nunFechas < maxFechas) (

 
Esquemas típicos de operación con formaciones 345

 

EscribirFecha( fecha );
i£ (EsCorrecta(fecha)) (
InsertarFecha( fecha );
Y else 4
primtf( " ** incorrecta ** );
3
printe( a"
IeerFecha( fecha );
seguir = (fecha.dia
,

 

 

print£( "WnFechas en orden:Wn" );
for (int k=0; k<nunFechas; k++) (
EscribirFecha( lista[k]
print£( "Wa" );
y
y

 

 

 

12.7.3. Ejemplo: Recortar una imagen

Este programa es un ejemplo de utilización de una matriz orlada. El procedimiento Recortar ya fue explicado en el apartado dedicado a las matrices
orladas. El procedimiento Imprimir es simplemente un recorrido de la matriz
para imprimir la imagen contonida. El procedimiento LeerTmagen lee una
imagen de los datos de entrada, leyendo un carácter por cada punto.

El listado completo del programa es el siguiente:

 

AAA A ARA AARRRRN
* Programa: Recorte

* Descripcion:

* Este programa recorta una imagen digitalizada,
* es decir, delimita el contorno

AARRRceR RANA RRA AAA RRA RA RAR RDA RARA CRA

'sinclude <stdio.h>

¡const int Ancho
¡const int Alto

40; /* anchura de la imagen */
20; /* altura de la imagen */
const int Borde =-1; /* marca de borde de la imagen * * */
¡const int Blanco = 0; — /* nivel bajo de gris = blanco *.* */
const int Negro =5;  /* nivel alto de gris = negro '*' */

   

typedef int Inagen_t[Alto+2][Ancho+2]; /* matriz orlada */

 
|
|
|

 

346 Fundamentos de program

 

/** Leer la imagen */
void LeerInagen( Imagen_t imagen ) £
char c;

/*-- 19 Paso: Inicializar toda la imagen a "Borde" --*/
for (int 1-0; i<Alto+2; 14) (
for (int j=0; j<Ancho+2; je) €
imagen[i][j] = Borde;
+
y

  

/*-- 29 Paso: Leer los datos, punto a punto --*/
for (int i=1; i<=Alto; i++) 1
for (int j=l; j<=Ancho; j++) €
scanf( " Ke", dc);
imagen[i][j] = int(c) - int('0');
+
,
3

/** Contrastar la imagen */
void Contrastar( Imagen_t imagen, int nivel ) (
for (int á=1; ic=Alto; 1++) (
for (int j=1; j<=Ancho; j++) (
if (imagen[i][3] <= nivel) €
imagen[i][3] = Blanco;
) else (
imagen[i][3] = Negre
J
)
y
Y

  

 

/** Recortar la imagen */
void Recortar( Imagen_t imagen ) 4
bool seguir;

do ( /* fuerza bruta, marcar borde hasta que no cambie más */
seguir = false;
for (int i=l; i<=Alto; i++) 4
for (int j=1; j<=Ancho; j++) 4
i£ (imagen(i](3] == Blanco 48 (
imagen[i-1][3] == Borde ||
imagen[i][J-1] == Borde ||

 

 

 

 

imagen(i][j+1] == Borde ||

 
“Esquemas típicos de operación con formaciones 347

imagen[is1][3] —= Borde )
E]
imagen[i][j] = Borde;
seguir = true;

,
,
y
) while (seguir);
»

'/** Imprimir la inagen */
¡void Imprimir( const Imagen t imagen ) £
const char Punto[9] =(' *, %.t, 0

 

for (int i<=Alto; dr) (

  

 

for (int j=1; j<=Ancho; je) 4
print£( "%c", Punto[imagen(1](J1+11 );

3

print£C "a" d;

3
y

'/** Programa principal */
int mainO) (
Imagen_t imagen;

/*-—- Leer la imagen inicial --*/
LeerImagen( imagen );

print£( "Inagen inicial:Wn" );
Imprimir( imagen );

/*-— Reducir la imagen a blanco y negro --*/
Contrastar( imagen, 3 );

print£( "YnImagen contrastada: Xn" );
Imprimir( imagen );

/*-- Recortar la imagen, marcando el borde externo --*/
Recortar( imagen );

print£( "WnImagen recortada:1n" );

Imprimir( imagen );

+

 

A continuación se presenta un ejemplo de la ejecución de este programa. Los
datos de entrada contienen un carácter por cada punto de la imagen, y simulan
una rejilla. Una de las esquinas del borde derecho está rota. Los datos son:

 
348

Fundamentos de programación:

 

0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212344
5432101234543210123454321012345432101233
4543212345454321234545432123454543212344
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432
0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212345
5432101234543210123454321012345432101234
4543212345454321234545432123454543212345
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432

El resultado de la ejecución del programa es el siguiente:

 

 

Imagen inicial:
A a o
AAA A
AAA AAA
AAA RR
RA A AA o
macia. tit. noo
ANO a nc
AAA ARE
AAA AN NX
AA A

   

 

    

 

 

AM RN RIN AX
AAN AE
ARA A o

 

AAA AAA
AAA A ARAN
AAA O NN
Esquemas típicos de operación con formaciones

349

 

¡Imagen contrastada:

  

     
    

   
    

 

    

 

a He. ad HA
A A
AAA
AER AARARR AAA
A
ea AE
ARA
a

 

LA
A
Lt M HER
A
ARBABA RARA ABRA
ARA AURA ARA AER.

     

   

 

 

A A A
HOR AUR AR ARR ARA AR
ABRIO ABRIR ABBR ABR

   

Imagen recortada:
e. a ad ad
Ane a a
MAR ARR RARA RARA AR
IHR ARANA AAA RARA
A ARA RRA

   

      

 
      

448 AH
O a $.
PE AMAR AAA RARA UA

ABR ARA ABRA ARA
RRRAA ABRA ABRA,
408 A
IAB. AR ABRA
A A
PEA AAA ARA
ARA ARA
eee 488
ARA ARA
iaa
PRADO AAA ARA RIA
PUnRa nad RRA

    
  
    
 

  

   
 

   

 

 

 

 
   

Fundamentos de pi

Como puede verse, la marca de borde exterior se ha ido propagando a

los puntos vecinos que estaban en blanco, hasta rellenar toda la zona

de la rejilla, incluyendo la malla abierta.
Tema 13

Punteros y variables dinámicas

En este tema se introducen estructuras de datos potencialmente ilimitadas.
Se justifica su interés y se describe en particular la estructura secuencia.

13.1 Estructuras de datos no acotadas

En los temas anteriores se han descrito las estructuras de datos que pueden
definirse en C+. Todas ellas tienen una característica en común: la capacidad
total (número de elementos componentes) se determina explícitamente al definirlas. Una estructura podrá usarso de manera que el número de componentes
¿que contengan información significativa soa variable, pero nunca mayor que el
tamaño total de la estructura.

Por ejemplo, en el tema anterior se ha presentado un programa para escribir en
orden una serie de fechas leídas como datos. El número de fechas leídas cambia
de una ejecución del programa a otra, pero la capacidad total del programa.
viene limitada por el tamaño de la estructura definida para almacenar la lista
de fechas.

 

La fijación del tamaño máximo representa una solución de compromiso entre la.
capacidad del programa y su eficiencia. Si el tamaño es relativamente pequeño
el programa tendrá una capacidad de tratamiento limitada. Si el tamaño se
fija a un valor muy grande, el programa será poco eficiente en el uso de la
memoria, pues necesitará espacio para toda la estructura de datos, aunque
sólo se aproveche una pequeña parte.

Tras el análisis anterior debe resultar evidente que sería útil disponer de estructuras de datos que no tuvieran un tamaño fijado de antemano, sino que

 
    
  
   
  
    
    
   
 
 
  
  
  
  
   

352 Fundamentos de programación

 

pudieran ir creciendo o reduciendo su tamaño en función de los datos particulares que se estén manejando en cada ejecnción del programa. Estas estructuras.
de datos se denominan, en general, estructuras dinámicas, y poseen la cualidad de que su tamaño es potencialmente ilimitado, aunque, naturalmente, no
podrá exceder la capacidad física del computador que ejecute el programa.

13.2 La estructura secuencia

La estructura secuencia puede definirse como un esquema de datos del tipo ite=
rativo, pero con un número variable de componentes. La estructura secuencia.
resulta parecida a ina formación con número variable de elementos.

En realidad existen diferentes esquemas secuencialos do datos. Aun teniendo
en común que el número de elementos pueda variar, hay varias formas posibles
de plantear las operaciones sobre sccuencias. Para describir las distintas ale
ternativas distinguiremos entre operaciones de construcción y de acoeso. Com
las primeras podremos añadir o eliminar componentes de la secuencia, Com
las segundas podremos obtener o modificar el valor de las componentes
existen en un momento dado.

 

  

Las operaciones de construcción pueden incluir:

+ Añadir o retirar componentes al principio de la secuencia.
+ Añadir o retirar componentes al final de la secuencia.
+ Añadir o retirar componentes en posiciones intermedias de la secuencia.

Las operaciones de acceso pueden ser:

Acceso secuencial: Las componentes deben tratarse una por una, en el orden:
en que aparecen en la secuencia.

Acceso directo: Se puede acceder a cualquier componente directamente i
cando su posición, como en una formación o vector.

En este toma se presentan varias estructuras de datos utilizables en C£ y
responden al esquema secuencia, con distintas posibilidades, según los casos.

En muchos casos, y en particular cuando el acceso es secuencial, el tratamiento
de una secuencia se realiza empleando un cursor. El cursor es una vari
que señala a un elemento de la secuencia. El acceso, inserción o eliminación de
componentes de la secuencia se hace actuando sobre cl elemento señalado por
el cursor, Dicho elemento lo representaremos simbólicamente como cursor”,
empleando la flecha (T) como símbolo gráfico para designar el elemento de:
información señalado por otro. Para actuar sobre el cursor se suelen plantear
las siguientes operaciones.
Punteros y variables dinámicas 353

 

+ Iniciar: Pone el cursor señalando al primer elemento.

+ Avanzar: El cursor pasa a señalar al siguiente clemento.

+ Fin: Es una función que indica si el cursor ha llegado al final de la
secuencia.

El empleo de un cursor se ilustra en la figura 13.1.

Secuencia

7 pap"

 

el momento, ilustraremos el concepto de secuencia describiendo de forma.
“abstracta un programa para leer números enteros y escribirlos en orden, usando
“ana secuencia ilimitada para almacenar los números leídos. Supondremos que
¡el final de los datos se indica mediante un valor cero. Los primeros pasos de
«refinamiento del programa serían:

Leer números e imprimirlos en orden —>
Leer los números y almacenarlos en orden
Imprimir los números almacenados

Leer los números y almacenarlos en orden —>

Iniciar la secuencia, vacía

Leer un número

while (no es cero) £
Almacenar el número, en orden
Leer un número

,

Almacenar el número, en orden —>
Buscar la posición que le corresponde
Insertarlo en su posición

Buscar la posición que le corresponde —>

| Iniciar cursor
while (no Fin 88 número > cursor!) 1
Avanzar cursor

J

 
 

354 Fundamentos de progre

 

Imprimir los números almacenados —

Iniciar cursor
while (no Fin) (
Imprimir cursor!
Avanzar cursor
)

 

 

    
  
  

En estos últimos refinamientos se ha usado la técnica del cursor para 1
zar la posición en la secuencia en que deberá insertarse el nuevo número,
para imprimir la secuencia de múmeros. Obsérvese que se han empleado
operaciones básicas indicadas anteriormente: Iniciar el cursor al comiex
Avanzar el cursor, y detectar si se llega al Fin de la secuencia. También se
usado cursor! para hacer referencia a la componente de la secuencia accesil
en cada momento.

En este ejemplo se supone, además, que es posible insertar una mueva compo
nente en medio de la secuencia. El desarrollo completo del programa en CE
se describe más adelante.

13.3 Variables dinámicas

Una manera de realizar estructuras de datos ilimitadas en C£ es mediante el
empleo de variables dinámicas. Una variable dinámica no se declara como.
tal, sino que so crea en el momento necesario, y se destruye cuando ya no.
se necesita. Las varinbles dinámicas no tienen nombre, sino que se designan.
mediante otras variables llamadas punteros o referencias.

13.3.1 Punteros

En Ct los punteros o referencias son variables simples cuyo contenido es preci
samente una referencia a otra variable, El valor de un puntero no es representable como número o texto. En su Ingar usaremos una representación gráfica
en la que utilizaremos una flecha para enlazar una variable de tipo puntero
con la variable a la que hace referencia, tal como se indica en la figura 13.

Variable apuntada
Puntero

Figura 13.2 Puntero y su variable apuntada.

 
iteros y variables dinámicas 355

 

   
 
 
   
   
   
   
 
 
  

"Los punteros de Ci están tipados, al igual que los demás valores manejados
sen el lenguaje. El tipo de un puntero especifica en realidad el tipo de variable
la que puede apuntar. La declaración es:

Tipo-de-variable*. Tipo-puntero;

¡Una vez declarado el tipo, se pueden declarar variables puntero de dicho tipo. Una variable puntero se puede usar para designar la variable apuntada
'mediante la notación:

puntero

Por ejemplo:

'rypedef int* Tp_Entero;
'Tp_Entero pez

ape = 33;
int£( "xd", *pe );

Estas sentencias asignan el valor 33 a la variable dinámica señalada por el
puntero pe, y luego la imprimen. Para que estas sentencias funcionen correctamente es necesario que exista realmente la variable apuntada. Si el puntero
no señala realmente a una variable dinámica, el resultado de usar *puntero
será imprevisible,

 

Para poder detectar si un puntero señala realmente o no a otra variable, existe en C el valor especial NULL (que no es una palabra clave, sino que está
definido en la librería estándar stdlib.h y también en otras librerías). Este
valor es compatible con cualquier tipo de puntero, e indica que el puntero no
señala a ninguna parte. Por lo tanto debería ser asignado a cualquier puntero que sepamos que no señala a ninguna variable. Normalmento se usará
para inicializar las variables de tipo puntero al comienzo del programa. La
inicialización no es automática, sino que debe ser realizada expresamente por
el programador. Por ejemplo:
'4f (pe l= NULL) £

*pe = 33;

printf£( "*d”, *pe );
)

  

En principio esta sentencia garantizaría que sólo se usa la variable apuntada
cuando realmente existe. En realidad eso no es del todo cierto, ya que sólo
una correcta disciplina en el uso de punteros permite asumir que sólo tienen
valor no nulo los punteros que realmente señalan a variables que existen. El
lenguaje Ci en sí mismo no puede garantizarlo (es una limitación inherente a C

 

 
356 Findamentos de progr:

 

  
  
  
    
    
   

y C++). Por ejemplo, se puede destruir una variable dinámica pero co
punteros que la referenciaban, y que ahora señalan a algo inexistente.

13.3.2 Uso de variables dinámicas

Una variable de un programa se corresponde, en general, con tma zona co!
de la memoria que el compilador reserva para almacenar en ella el valor de
variable. Las variables normales de un programa tienen esa zona de mel
reservada de antemano al empezar a ejecutarse el programa o subpro;
en que se declaran, y por tanto pueden ser usadas en cualquier mo:
Conviene recordar que las variables declaradas en un subprograma sólo existes:
mientras se ejecutan las sentencias de ese subprograma.

 

Las variables dinámicas no tienen ese espacio de memoria reservado de ant
mano, sino que se crean a partir de punteros en el momento en que se indique.
Además, una vez creadas siguen existiendo incluso después do que termine la:
ejecución del subprograma donde se crean. La forma más sencilla de crear una.
variable dinámica es mediante el operador new:

typedef Tipo-de-variable* Tipo-puntero;

Tipo-puntero puntos

 

 

puntero = new Tipo-de-variable;

El operador new crea una variablo dinámica del tipo indicado y devuelve una.
referencia que puede asignarse a un puntero de tipo compatible. Como en.
cualquier otra asignación, el valor anterior del puntero se pierde, Tal como se
ha dicho antes, la variable dinámica no tiene nombre, y sólo se puede hacer
referencia a, ella a. través del puntero. Podemos representar gráficamente el
efecto de esta sentencia según se nuestra en la figura 13.

 

Antes Después

a

P = new Tipo;

Figura 13.3 Creación de una variable dinámica.

 

La variable dinámica se crea a base de reservarle el espacio necesario en una
zona general de memoria gestionada dinámicamente. En principio no se puede
asumir que ln variable reción creada tenga un valor concreto, igual que las
variables normales que se declaran sin un valor inicial explícito.

 
 
  
   
   
     
   
    
   
   
      
  

eros y variables dinámicas 357

 

variables dinámicas, una vez creadas, siguen existiendo hasta que se injue explícitamente que ya no son necesarias, en cuyo caso el espacio que
había reservado para ellas quedará otra vez disponible para crear nuevas
iables dinámicas, Para ello existe la sentencia delete, que permite destruir
variable dinámica a la que señala un puntero:

puntero;

a sentencia destruye la variable apuntada pero no garantiza que el puntero
le con un valor determinado. En particular no garantiza que tome valor

variable dinámica puede estar referenciada por más de un puntero. Esto
cuando se copia un puntero en otro. Por ejemplo:

int* Tp_Entero;
itero pl, p2;

¡camente en la figura 13,4 se muestra el resultado de copiar un puntero
otro.

Antes Después
p2 p2
p2 = pl;
Figura 13.4 Copia de un puntero en otro.

“Tanto la variable p1 como p2 quedan señalando a la misma variable dinámi

 

Un problema delicado al manejar variables dinámicas es que pueden quedar
perdidas, sin posibilidad de hacer referencia a ellas. Esto ocurre en el siguiente
ejemplo:
int* Tp_Entero;
tero pl, p2;

= new int;

= new int;

[p2 = pl;

En la figura 13.5 sc muestra gráficamente el resultado.
     
   
  

Fundamentos de progr:

Antes Después
*S—_]” E]
Figura 13.5 Variable dinámica perdida.

En oste caso la variable crenda mediante p2 = new int; queda perdida,
posibilidad de ser usada, ya quo las variables dinámicas no tienen nombre,
el único puntero que la señalaba ha cambiado su valor, perdiendo el anteri
Además el espacio ocupado por la variable dinámica sigue reservado, lo
es totalmente inútil y representa una pérdida de la capacidad de me
disponible (en inglés so denomina memory leak)

13.4 Realización de secuencias mediante punteros

Los punteros son un clemento de programación de muy bajo nivel. Los ler
guajes de programación simbólicos deberían evitar su empleo, sustituyéndolo
por mecanismos más potentes de declaración de estructuras de datos, que
permitiesen definir directamente estructuras dinámicas ilimitadas

 

  

Desgraciadamente, muchos lenguajes están diseñados pensando en que su compilación no sea demasiado complicada. Las estructuras de datos con tamaño
variable presentan algnnas complicaciones para ser manejadas de manera ef
ciente, y es frecuente que los lenguajes de programación no incorporen direc
tamente esquemas de datos de tamaño varimble, Esta limitación facilita el
trabajo de compilación, ya que todas las variables tendrán un tamaño fijo que
puede ser calculado por el compilador, y determinar así el espacio de memoria.
que ha de reservarse para cada una.

 

Ct no dispone de esquemas de datos de tamaño variable. Dichos esquemas.
pueden ser realizados indirectamente por el programador mediante el nso de
punteros. Al hacerlo convendrá tener cuidado, y emplearlos de una manera
precisa, traduciendo a punteros los mecanismos de definición de alto nivel que
deberían estar disponibles.

La definición simbólica de una estructura ilimitada basándose en esquemas.
con número fijo de elementos será, normalmente, recursiva. Una definición
Punteros y variables dinámicas 359

 

recursiva es aquella en que se hace referencia a sí misma. Sería deseable que
ana secuencia ilimitada se pudiese definir de manera recursiva, sin necesidad
de punteros, de una forma parecida a la siguiente:

«typedef struct Tipo-secuencia £

bool vacia; /* indica si es la secuencia vacía */
Tipo-componente primero; /* sólo si no es vacía */
Tipo-secuencia resto; /* sólo si no es vacía */  /* ERROR */

 

Esta definición nos dice que una secuencia ilimitada de componentes es una de
dos cosas posibles: o bien una secuencia vacía, o bien una primera componente
seguida de la secuencia formada por el resto de las componentes.

Lamentablemente esta forma de definición recursiva no es admisible en C£.
Para definir una secuencia ilimitada tendremos que recurrir al empleo de vasiables dinámicas y punteros. Una manera de hacerlo es usar punteros para
enlazar cada elemento de la secuencia con el siguiente tal y como se muestra,
en la figura 13.6.

   

resto

secuencia

  

primero
Figura 13.6 Secuencia enlazada mediante punteros.

Cada elemento de la secuencia se materializa como un registro con dos campos:
el primero contiene el valor de una componente, y el segundo es un puntero
que señala al siguiente. El último elemento tendrá el puntero al siguiente con
valor NULL. La secuencia completa es accesible a través de un puntero que
señala al comienzo do la misma.

 

Aplicando este esquema con punteros sí es posible definir una secuencia ilimi
tada en CE. La siguiente definición trata de ser lo más parecida posible a la
definición recursiva propuesta antes:
typedef struct Tipo-nodo £

Tipo-componente primero;

Tipo-nodo * resto;

 

 

Y

typedef Tipo-nodo * Tipo-secuencia;

 
 

360 Fundamentos de progre

Esta pareja de definiciones es válida en CE, aunque tiene una caracterís
excepcional: se usa el identificador Tipo_nodo antes de haber sido def
completamente. Esto sólo es posible hacerlo en declaraciones de punteros
la anterior. Gracias a esa posibilidad se puede realizar mediante punteros
equivalente a una definición recursiva de un esquema de datos.

   

Una vez definidos los tipos de ln secuencia y sus componentes se podrán de
clarar variables de dichos tipos y operar con ellos:

Tipo-componente valor;
Tipo-secuencia secuencia, siguiente;

if (secuencia != NULL) £
(*secuencia) .primero = valor;
siguiente = (*secuencia).resto;

y

La combinación del operador do desroforonciación de puntero (*) y la selección.
de campo de registro (.) es incómoda de escribir, porque requiere paréntesis,
y difícil de leer. Por esta razón C+ permite combinar ambos en un operador.
único con una grafía más amigable (=>). Las sentencias anteriores se puedes
reescribir de la forma siguiente, mucho más fácil de leer:

if (secuencia 1= NULL) €
secuencia->primero = valor;
siguiente = secuencia->resto;

y

13.4.1 Operaciones con secuencias enlazadas

Describiremos la manera de realizar algunas operaciones típicas sobre secuen=
cias enlazadas con punteros. En ellas supondremos la existencia de un cursor
que va señalando a las componentes una tras otra. El cursor será simplemente
un puntero. Como ejemplos de operaciones desarrollaremos algunos fragmentos de un programa para leer números onteros e imprimirlos en orden, así como.
para quitar luego de la lista ordenada los números que se indiquen.

DEFINICIÓN - La definición de la secnencia será:

typedef struct TipoNodo (
int valor;
TipoNodo * siguiente;
>
typedef TipoNodo * TipoSecuencia;
TipoSecuencia secuencia;

 

 
  
   
   
 
   
   
  
 
   
   
  
 
   
  
  
 
   
  
 
  
 
  
    
    

Punteros y variables dinámicas 361

 

RECORRIDO - El recorrido de toda la secuencia se consigue mediante un
'buclo de acceso a elementos y avance del cursor. Puesto que la secuencia tiene
sun número indefinido de elementos, no se usará un bucle con contador. En
¡este caso usaremos tn esquema while . Como ejemplo describimos la escritura
ide los valores de la secuencia.

TipoNodo * TipoPuntNodo;
ipoPuntNodo cursor;

'sor = secuenci:
(cursor l= NULL) (

print£( "XSd", cursor->valor );

cursor = cursor->siguiente;

 

y

BÚSQUEDA - La búsqueda en una secuencia enlazada ha de hacerse de
forma secuencial. La búsqueda es parecida al recorrido, pero la condición de
terminación cambiará. De hecho habrá una doble condición de terminación:
¿que se localice el elemento buscado, y/o que se agote la secuencia. A continuación se presenta la búsqueda de la posición en que ha de insertarse un nuevo
múmero en la secuencia ordenada, La posición será la que ocupe el primer
valor igual o mayor que el que se quiere insertar.

 

¡int numero; — /* valor a buscar */
'TipoPuntNodo cursor, anterior;

¡cursor = secuencia;
lanterior = NULL;
iuhile (cursor |= NULL 84 cursor->valor < numero) (
anterior = cursor;

cursor = cursor->siguiente

 

 

y

Al salir del bucle cursor queda señalando al punto en que deberá insertarse
el nuevo elemento, y anterior señala al elemento que lo precede. Esto resulta
útil para realizar luego operaciones de inserción o borrado, como se verá a
«continuación.

INSERCIÓN - La inserción de un nuevo elemento se consigue creando una
variable dinámica para contenerlo, y modificando los punteros para enlazar
dicha variable dentro de la secuencia. El caso más sencillo es el de insertar un
muevo elemento detrás de uno dado. La representación gráfica sc muestra en
la figura 13.7

En la figura, el nuevo elemento creado tiene un fondo diferente, además se
han marcado con línea discontinua los enlaces creados o modificados por estas

  

 
 

    
   
  

Fundamentos de progr:

   

   

Y paso; nuevo = new Tipoliadoz

Figura 13.7 Inserción en una secuencia de punteros.

operaciones. El orden de las operaciones a realizar resulta esencial para.
no se produzca la pérdida de ninguna variable dinámica y por ello, en la fi
también so ha detallado el orden de los pasos a realizar. El código en Ct será

 

int numero; — /* valor a insertar */
TipoPuntNodo cursor, anterior, nuevo;

nuevo = new TipoNodo; /* 1% paso */
nuevo->valor = numero;

nuevo->siguiente = anterior->siguiente; /* 22 paso */
anterior->siguiente = nuevo; /* 39 paso */

BORRADO - Para borrar un elemento hay que quitar ol nodo que lo contiene,
enlazando directamente el anterior con el siguiente tal como se indica en la
figura 13.8. Es la operación inversa de la inserción. Si el nodo que contenía
el elemento ya no cs necesario hay que destruirlo explícitamente. También en
¡portante seguir el orden que se detalla en la figura 13,8.

 

r

 

Figura 13.8 Borrado en una secuen

 

ía de punteros.

Igual que antes, en la figura 13.8 se han marcado con línea discontinua los
enlaces modificados por las operaciones de borrado. Además, el elemento
borrado aparoco con un fondo diferento. Para hacer el código más robusto so.
ha forzado ol cursor a valor nulo, ya que de no hacerlo así quedaría apuntando
  
 
 
   
  
   
 
 
  
 
   
 
      
    
  
 
 
  
  
  
   
   
  
  

Punteros y variables dinámicas 363

 

'a un lugar que ya no existe (marcado con una X en la figura). El código en

Ct será:
ipoPuntNodo cursor, anterior;

terior->siguiente = cursor->siguiente;

Estos ejemplos de inserciones y borrados corresponden al caso general y operan
¡con elementos en medio de la secuencia. Si la inserción o borrado debe hacerse
al principio de la secuencia el código es algo diferente, ya que no hay elemento
anterior, pero es igualmente sencillo,

13.4.2 Ejempl

 

Leer números y escribirlos en orden

Reuniendo los fragmentos de código anteriores se puede escribir ya este ejemplo. Aquí se ha tenido en cuenta el caso especial de insertar o borrar al
principio de la secuencia. Esta situación so detecta porque no existe elemento
anterior, y el puntero al elemento anterior queda con valor NULL después de
la búsqueda.

El resto del código del programa es esencialmente idéntico a los fragmentos
desarrollados en los ejemplos anteriores. La mayor parte del código añadido
correspondo a la lectura de los datos y la escritura de los resultados. El listado
del programa completo es el siguiente:

 

AAA PPP

* Programa: Secuencia
* Descripción:

Programa que lee una serie de números enteros,
los almacena en una secuencia enlazada, en orden,
y los imprime. Después se pueden borrar de

* manera selectiva.
AAA

'sinclude <stdio.h>

typedef struct TipoNodo (

int valor;

TipoNodo * siguiente;

E

typedef TipoNodo * TipoSecuencia;
typedef TipoNodo * TipoPuntNodo;
 

   

Fundamentos de progr:

int mainO (
int numero;
TipoSecuencia secuencia;
TipoPuntNodo cursor, anterior, nuevo;

/*-- Leer los datos y almacenarlos --*/
print£( "Datos leídos:Yn" );
secuencia = NULL;
scanf( "Xd", ánumero ); — /* primer dato */
while (numero != 0) £

print£( " Xd", numero );

/*-— Buscar posición para el nuevo núnero --*/

/* 'anterior* señalará al nodo detrás del
cual hay que insertar el nuevo valor */

cursor = secuencia;

anterior = NULL;

while (cursor != NULL 88 cursor->valor < numero) £
anterior = curso,
cursor = cursor->siguiente;

$

 

 

/*— Crear nodo con el nuevo número --*/
nuevo = new TipoNodo;
nuevo->valor = numero;

/*-- Insertar el nodo en la secuencia --*/
if (anterior == NULL) (
/*— Insertar al comienzo de la secuencia --*/
nuevo->siguiente = secuencia;
secuencia = nuevo;
) else (
/*-- Insertar detrás del anterior --*/
nuevo->siguiente = anterior->siguiente;
anterior->siguiente = nuevo;
J
scanf( "Xd", Enumero ); /* siguiente dato */
y
print£( "a" );

 

 

/*— Mostrar la lista ya ordenada --*/
print£( "WnDatos ordenadosin" );
cursor = secuencia;
while (cursor != NULL) (

print£( "X5d", cursor->valor );

 
steros y variables dinámicas 365

   
  
  
  
   
  
  

cursor = cursor->siguiente;
3
print£( "w

 

/*— Bucle de búsqueda y borrado de núneros --*/
print£( "IwDatos a borrar:Wn" );

scan£( "%d", ánumero ); — /* primer dato */
mhile (numero != 0) (

/*— Buscar posición del número a borrar --*/
cursor = secuencia;
anterior = NULL;
while (cursor != NULL 84 cursor=>valor
anterior = cursor;
cursor = cursor->siguiente;

,

 

umero) £

/*— Borrar el múnero encontrado --*/
if (cursor != NULL) £ /* el múnero está en la lista */
if (anterior != NULL) £
anterior->siguiente = cursor=>siguiente;
) else £
secuencia = cursor=>siguiente;
$»
delete cursor;
print£( * xd borradowa", numero );
cursor = secuencia;
while (cursor != NULL) 4
print£( "X5d", cursor->valor );
cursor = cursor->siguiente;

 

  
 

y
print£( "y" );

) else ( /* el número no está en la lista */
print£( " %d no encontradoln”, nunero );

)

scanf( "Xd", ánumero ); — /* siguiente dato */
y

 

ejecución del programa utilizando los siguientes datos de ejemplo:

 

34256471330
115670

»rciona los siguientes resultados:

 
 

    
     
   
         
     
   
   
     
  
   
    
 
  

Datos leído:
12 34 2 5647133

   

Datos ordenados
1.02 4 7 12 33 34 50

Datos a borrar:

4 borrado

1. 2 7 1 33 34 56
11 no encontrado

1 borrado

2 7 12 33 34 56
56 borrado

2 7 12 33 34
7 borrado

2 12 33 34

13.5 Punteros y paso de argumentos

El manejo de punteros cuando se utilizan como argumentos de un subprogr:
tiene ciertas peculiaridades que requieren un estudio más detallado.

 

13.5.1 Paso de punteros como argumentos

Como cualquier otro dato, un puntero puede pasarse como argumento a un.
subprograma. Así, la operación de imprimir la lista de números enteros del
ejemplo anterior podría redactarse como procedimiento que reciba como argumento la secuencia enlazada. Tal como se veía, una secuencia enlazada se
maneja a partir del puntero al primer elemento. El código del procedimiento
y un ejemplo de cómo invocarlo sería:

 

 

void ImprimirLista( TipoSecuencia lista ) (
TipoPuntNodo cursor = lista;

while (cursor != NULL) £
print£( "X5d", cursor->valor );
cursor = cursor->siguiente;

dá

print£c "a" y;
 
  
  
  
   
 
 
 
 
 
 
    
  
  
  
   
  
  
   
  
 
  
  
 
    
  
  

Punteros y variables dinámicas 367

 

¡TipoSecuencia secuencia;
Imprimirlista( secuencia );

Por defecto, los datos de tipo puntero se pasan como argumentos por valor.
Es lo que ocurre en el ejemplo anterior. Si se desea usar un subprograma
para modificar datos de tipo puntero, entonces habrá que pasar el puntero
por referencia. Por ejemplo, si planteamos como subprograma la operación de
búsqueda en una secuencia enlazada podríamos escri

   

¡void Buscar( TipoSecuencia lista, int numero,
TipoPuntNodo 4 cursor, TipoPuntNodo 4 anterior ) (

 

cursor = lista;
anterior = NUL)
mhile (cursor != NULL 8% cursor->valor
anterior = cursor;
cursor = cursor->siguiente;
y
3

    

numero) [

¡TipoSecuencia secuencia;
¡TipoPuntNodo encontrado, previo;
¡int dato;

iBuscar( secuencia, dato, encontrado, previo );

En la llamada a Buscar la variable secuencia no podrá ser modificada, ya
¡que el argumento lista se pasa por valor. Por el contrario, las variables de
ipo puntero encontrado y previo serán modificadas por el subprograma para
lejar el resultado de la búsqueda.

.5.2. Paso de argumentos mediante punteros

general el valor de nn puntero en sí mismo no es significativo, sino que
puntero es sólo un medio para designar la variable apuntada. Desde nn
to de vista conceptual el paso de un puntero como argumento puede ser
iderado equivalente a pasar como argumento la variable apuntada.

 

ejemplo, si queremos pasar como argumento una variable dinámica poderecurrir a un puntero como elemento intermedio para designarla. Esto
nta una dificultad añadida para entender cómo funciona un doterminafragmento de código, y de hecho representa un peligro potencial de cometer
»rminados errores de codificación,

 
368 Fundamentos de program

 

     
 

La dificultad reside en el hecho de que pasar un puntero por valor no
que el subprograma pueda modificar la variable apuntada. Por ejemplo:

typedef int* Tp_Entero;
void Imprimir( Tp_Entero val ) [

print£( "Xd", *val );
F

 

void Incrementar( Tp_Entero val ) £
*val = *val +1;

)
Tp-Entero pl;
pl = new int;

Imprimir( pl);
Incrementar( pl );

Tanto el procedimiento de Imprimir como el de Incrementar reciben un puntero pasado por valor. El primero no modifica la variable apuntada pero el
segundo sí. Al establecer la analogía entre el paso como argumento del puntero y el paso como argumento de la variable apuntada, la distinción entre paso
por valor y por referencia se pierde. El paso por valor de un puntero equivale
al paso por referencia de la variable apuntada,

En realidad los punteros se usan implícitamente para pasar argumentos por.
referencia. Cuando se declara un argumento pasado por referencia, lo que hace:
realmente el compilador es pasar un puntero a la variable externa usada como
argumento actual en la llamada. Dado el subprograma:
void Duplicar( int £ valor ) £

valor = 2 * valor;
,

El código interno generado por el compilador es equivalente a:
typedef int + P_int;

void Duplicar( P_int p_valor ) (
*p_valor = 2 * (*p_valor);
3

 

De hecho la notación £ para indicar el paso de argumento por referencia es
una mejora de C++ respecto a C. En lenguaje C hay que usar siempre un
puntero explícito para pasar argumentos por referencia. Por supuesto, hace
 
  
 
 
   
   
    
  
 
 
 
 
 
 
 
 
   
   
 
   
 
   
  
    
  

 

Punteros y variables dinámicas 369

 

falta entonces un operador especial para obtener el valor de un puntero a una
variable (estática) y usarlo en la llamada al subprograma. En lenguaje C ese
operador corresponde también al símbolo €, como se muestra a continuación:

“int numero;

'Duplicar( énumero

 

Ahora debe quedar clara la manera de invocar ciertas funciones estándar de C,
tal como scan£(). A lo largo de todo este libro han ido apareciendo sentencias
de lectura como la siguiente:

Iscant( Enunero );

 

Lo que se está haciendo en esta llamada es pasar como argumento un puntero
que señala a la variable numero, a través del cual se puede modificar su valor.
Hay que hacer notar que el puntero en sí se está pasando por valor, y eso cs
equivalente a pasar el dato apuntado por referencia.

 

En bastantes casos cuando se trabaja con variables dinámicas, que sólo son
accesibles a través de punteros, resulta natural usar un puntero explícito para.
pasar como argumento la variable dinámica apuntada. Insistiremos en que el
paso del puntero equivale a pasar la variable apuntada siempre por referencia.
En C2 para pasar la variable apuntada por valor hay que hacerlo de la manera
convencional, como en el siguiente ejemplo de código:

int* Tp_Entero;

Imprimir( int val ) 4 /* paso por valor */
print£( "%a", val );
y

id Incrementar( Tp_Entero val ) £ /* paso por referencia */
*val = *val + 1;

y
Entero pl;

1 = new int;
imir( *pl );
icrementar( pl );

NOTA: En lenguaje C++ existe la posibilidad de programar algo equivalente al papor valor, pero usando un puntero explícito como intermediario. Esto se consigne
do adecuadamente el cualificador const en puntos determinados de la declara)n del tipo puntero y/o del argumento. Lamentablemente la semántica de estas
«trucciones es extraordinariamente compleja y confusa, por lo que se ha optado
por no incluirlas en el subconjunto C£.

 
 

     
  
   
  

Fundamentos de progr:

13.5.3. Ejemplo: Leer números y escribirlos en orden

Como ejemplo del uso de punteros como argumentos se reescribe a conti
ción el mismo ejemplo de manejo de una secuencia de números, pero defini,
ahora como subprogramas algunas de las operaciones sobre la secuencia.
listado del nuevo programa es el siguiente:

 

 

 

PARAR ARA RIAIA

* Programa: Secuencia2
* Descripción:

* — Programa que lee una serie de múneros enteros,

+ los almacena en una secuencia enlazada, en orden,
* y los imprime. Después se pueden borrar de

* — manera selectiva.
AAA ARANA RAR RARA RAR

*include <stdio.h>

typedef struct TipoNodo £
int valor;
TipoNodo * siguiente;
h
typedef TipoNodo * TipoSecuencia;
typedef TipoNodo * TipoPuntNodo;

/** Insertar un nuevo número en una secuencia ordenada */
void InsertarEnOrden( TipoSecuencia £ secuencia, int numero ) 1
TipoPuntNodo cursor, anterior, nuevo;

/*— Buscar posición para el nuevo múnero --*/

/* 'anterior' señalará al nodo detrás del
cual hay que insertar el nuevo valor */

cursor = secuencia;

anterior = NULL;

while (cursor != NULL 88: cursor=>valor < numero) £
anterior = cursor;
cursor = cursor->siguiente;

y

 

 

/*— Crear nodo con el nuevo número --*/
nuevo = new TipoNodo;
nuevo->valor = numero;

/*— Insertar el nodo en la secuencia --*/
á£ (anterior == NULL) (

 

 
      
    
 

Punteros y variables dinámicas 371

 

/*-- Insertar al comienzo de la secuencia --*/
muevo->siguiente = secuencia;
secuencia = nuev

) else (
/*-- Insertar detrás del anterior --*/
nuevo->siguiente = anterior->siguiente;
anterlor->siguiente = nuevo;

J

 

 

y

/* Quitar todas la apariciones de un núnero de una secuencia de números */
void Eliminar( TipoSecuencia £ secuencia, int nunero, bool E encontrado ) (
TipoPuntNodo cursor, anterior, aux;

encontrado = false;
cursor = secuencia;
anterior = NULL,
vhile (cursor l= NULL) (
aux = cursor->siguiente;
i£ (cursor->valor == numero) [ /* encontrado, borrarlo */
encontrado = true;
i£ (anterior l= NULL) (
anterior->siguiente = cursor->siguiente;
) else (
secuencia = cursor->siguiente;

 

 

 

J
delete cursor;

J else [  /* no encontrado */
anterior = cursor;

,

Cursor = aux;

/** Imprimir una secuencia de múneros */
¡void Imprimir( TipoSecuencia secuencia ) (
TipoPuntNodo cursor;

cursor = secuencia;
while (cursor != NULL) £
print£( "X5d", cursor->valor );
cursor = cursor->siguient
y
print£c a");

 

 

 
  

Fundamentos de progr:

int mainQ £
nt numero;
TipoSecuencia secuencia;
bool borrado;

/*-- Leer los datos y almacenarlos --*/
print£( "Datos leídos:Y" );
secuencia = NULL;
scan£( "xd", Emunero );  /* primer dato */
while (numero != 0) (
print£( " Xd", numero );
InsertarEn0rden( secuencia, numero
scan£( "Xd", dnumero );  /* siguiente dato */
Y
print£( "a" );

 

 

/*— Mostrar la lista ya ordenada —-*/
print£( "YnDatos ordenadosin" );
Imprimir( secuencia );

/*-- Bucle de búsqueda y borrado de números --*/
printf( "WnDatos a borrar:Wn" );
scanfí "Xd", émumero );  /* primer dato */
while (numero l= 0) (
Eliminar( secuencia, numero, borrado );
if ( borrado) (
print£f( " Xd borradoWn'
Imprimir( secuencia );

numero );

 

) else £
print£( " Xd no encontradoWn”, numero );
J
scanf( "Xd", ánumero );  /* siguiente dato */
+
J

 

 

 

El programa funcionará igual que antes. Por lo tanto se reproducirá el ejemplo.
de funcionamiento con los mismos datos y resultados que se mostraron antes.

13.6 Punteros y vectores en C y C++

En O/C++ existe una estrecha relación entre las formaciones y los punteros, Sin embargo desde un punto de vista metodológico esta relación resulta
bastante confusa, disminuye la claridad y aumenta la ambigtiedad de los programas. Por esta razón, en este libro y en el lenguaje C£ se ha tratado de
Punteros y variables dinámicas 373

 

separar ambos conceptos de manera expresa. Lamentablemente, en el lenguaje
Ck no ha sido posible incorporar restricciones sintácticas capaces de impedir
el manejo de punteros como formaciones debido al carácter semántico de esta
relación. Por ello, es en el Manual de Estilo donde se incorpora una regla de
obligado cumplimiento que prohíbe el uso de punteros como formaciones.

 

En las siguientes secciones se explica la analogía que existe en C/C++ entre
los punteros y las formaciones, mostrando algunas de las posibilidades y consecuencias de este hocho. La razón do estas explicaciones cs aclarar algunas
de las irregularidades que presenta el lenguaje CE en el manejo de las formaciones. Por tanto, en estas siguientes secciones se muestran operaciones que
están expresamente prohibidas y que no se deben ntilizar en los programas.

 

13.6.1 Nombres de vectores como punteros

Cuando se ha declarado una variable de tipo vector el nombre de dicha variable
equivale en gran medida a un puntero que apunta al comienzo del vector. El
siguiento fragmento de código es perfectamente válido en C/C++:

typedef int* Tp_Entero;
typedef int Tv_Entero[5];

void Incrementar( Tp_Entero val ) [ /* paso por referencia */
*val = *val + 1;

y

void ImprimirVector( const int v[], int nv) (
for (int k=0; kanV; ke+) (
primt£( "X10d", v[k] );
)
print£( *

 

2d

'Tp_Entero pl;
'Tv_Entero vl = (10, 20, 30, 40, 50);

pl = vi; /* vector como puntero */

Incrementar( pl );
ImprimirVector( pl, 5); /* puntero como vector */

Incrementar( v1 ); /* vector como puntero */
ImprimirVector( vl, 5

 
374 Fundamentos de programación

 

Incrementar( 8v1[0] );
ImprimirVector( £v1[0], 5 ); /* puntero como vector */

El nombre del vector v1 equivale al valor de un puntero que señala al comienzo,
es decir, al primer elemento v1[0]. Por lo tanto puede ser asignado a una
variable puntero del tipo equivalente. En sentido contrario, un puntero de ese.
tipo puede ser nsado como argumento al invocar un subprograma que requiera
un vector. Tras la asignación p1 = vl on el ejemplo, cada una de las parejas
de sentencias Incrementar(); ImprimirVector(); realizan la misma acción:
incrementar el valor del primer elemento y luego imprimir los 5 elementos del
vector.

 

 

La analogía alcanza incluso a poder utilizar el puntero como base para indexar
un elemento del vector. Tras ejecutar p1 = v1 las expresiones siguientes son
equivalentes;

p1(3] — equivalea — v1[31

Y aún más, en la declaración de un puntero so puede crear e inicializar un
vector al que apunte:

typedef char * TipoPalabra;
TipoPalabra nombre = "Juan Antonio";

A pesar de lo anterior una variable puntero es claramente distinta de una
variable vector. La asignación de un puntero a un vector

[v2 = pt;

no es aceptada por el compilador y provoca un mensaje de error.

13.6.2 Paso de vectores como punteros

Tras las explicaciones anteriores debe quedar elaro por qué el paso de vectores como argumentos sc trata de manera diferente al paso como argumento
de otros tipos de valores. Repetimos aquí algunos fragmentos de código del
tema 9:

 

const int NumeroFlementos = 10;
typedef int TipoVector[NumeroElenentos];

void LeerVector( TipoVector v ) (...) /* paso por referencia */

 

void Escribirvector( const TipoVector y ) f...J /* paso por valor */
eros y variables dinámicas 375

 

  
 
  
  
  
  
    
 
  
  
   
   
  
  
  
  
  
  
  
  
   
  
  

"Las cabeceras de los subprogramas son en realidad equivalentes a las siguientes:
lef int* TipoPuntero;

¡void LeerVector( TipoPuntero pv ) 1...) /* paso por referencia */
void EscribirVector( const TipoPuntero pv ) 1...) /* paso por valor */

Tal como se ha dicho antes en este tema, el paso por valor de un puntero
equivale al paso por referencia de la variable apuntada. El cualificador const
delante de un argumento formal de tipo puntero indica al compilador que ese
valor de tipo puntero no debe ser usado para modificar la variable a la que
“apunta.

 

 

13.6.3. Matrices y vectores de punteros

 

Siun puntero es análogo a un vector, entonces un vector de punteros es análogo
a una matriz, es decir, a un vector de vectores. Veamos primero un ejemplo
de declaración y uso de uma matriz de enteros con 10 filas de 15 elementos:
[typedef int TipoPila[15];

typedef TipoFila TipoMatriz[10];

 

TipoMatriz matriz;

matriz[3][5] = 27;

 

Y ahora un ejemplo si

typedef int + TipoPuntero;
typedef TipoPuntero TipoMatriz[10];

lar usando un vector de punteros:

TipoMatriz matriz;
matriz[3][5] = 27;

Este segundo ejemplo es sintácticamente correcto, pero sólo es realmente válido
si los punteros señalan a vectores de enteros. Para que la analogía sea total es
necesario crear dinámicamente cada fila de la matriz a partir de cada elemento
del vector de punteros:

k<=10; k++) €

new TipoFila;

 

  

for (int kmatriz[k]

3
 

 

   

Fundamentos de pro;

    
   
  
   

La figura 13.9 nuestra la diferencia entre una matriz propiamente dicha
decir, un vector de filas, y su estructura análoga en forma de vector de pa
afilas. En ambos casos un elemento se designa como matriz[£ila] [col
pero la organización de los datos en memoria es claramente diferente.

 

 

Figura 13.9 Matriz y vector de punteros a filas.

De hecho la segunda alternativa no exige que todas las filas tengan el mismo.
tamaño. Esto permite, por ejemplo, construir “diccionarios” en forma de,
vectores de palabras que son a su vez vectores de caractores, poro cada una de
un tamaño diferente:

typedef char * TipoPalabra;

typedef TipoPalabra TipoDiccionario[7];

£

 

"Sábado"
"Domingo'
,

 

En el lenguaje C/C++ el manejo de punteros permite realizar otras estrueturas y operaciones más complejas y sofisticadas pero que habitualmente dan
lugar a programas enrevesados y muy difíciles de comprender. Dichas operaciones, además de quedar fuera del alcance de esta asignatura, también
estarían expresamente prohibidas en CE.

 
Tema 14

Tipos abstractos de datos

En este tema se da una introducción a los tipos abstractos de datos (TADs),
como adelanto de lo que es la programación orientada a objetos, que excedo del
ámbito de este libro. Se introduce el concepto de tipo abstracto y las técnicas
para programarlos como tipos registro (struct) en C£.

Aunque los tipos struct de C++ son en realidad clases, en CE se plantean
de manera algo restringida, como un mecanismo relativamente sencillo para
la programación de tipos abstractos.

14.1 Concepto de tipo abstracto de datos (TAD)

En programación tradicional, se identificaba el concepto de tipo de dato con el
del conjunto de valores que pueden tomar los datos de ese tipo. De hecho esta
idea se ha aplicado más a la forma de representación de los valores que a los
valores en sí. Por ejemplo, si tenemos que operar con valores correspondientes
a los meses del año, lo podremos hacer representándolos mediante números
(1 al 12) o bien mediante cadenas de caracteres (ENE, "FEB, otc.), entre
otras posibilidades. Estas represontaciones se asocian con diferentes tipos de
datos. En CE cscribiríamos:

typedef int Tipoles;

 

 

o bien:
[typedef char TipoMes[4]; /* 3 caracteres + carácter nulo al final */

Un enfoque más moderno de la programación trata de asociar la idea de tipo
de datos con la. clase do valores, abstractos, que pueden tomar los datos. Esto

 
378 Fundamentos de programación:

 

quiere decir que la representación o codificación particular de los valores 19
cambia, de hecho, el tipo del dato considerado. Un paso adelante en este
sentido ha sido la introducción de los tipos enumerados, on los que se definen
colecciones de valores, abstractos, asociados a identificadores utilizables dentro
del programa.

Como ya se ha dicho, los valores de los tipos enumerados no son valores n=
móricos, ni cadenas de caracteres, aunque pueden transformarse en esas otras.
formas de representación usando apropiadamente los mecanismos del lenguaje.
Por ejemplo:

typedef enun TipoMes ( Enero, Febrero, ... Diciembre );

TipoMes mes;

  

   

print£( "Xd", int(mes)+1 );

En el enfoque actual de la programación se identifican los tipos de datos de
Torma completamente abstracta, llegando a la idca de tipo abstracto de datos
(TAD). Esto quiere decir que un programa que use ese tipo de datos no deboría necesitar ningún cambio por el hecho de modificar la representación o
codificación de los valores de ese tipo. Si analizamos con cuidado qué necesita
un programa para poder usar datos de un tipo, encontraremos que haco falta:

+ Hacer referencia al tipo en sí, mediante un nombro, para poder definir
variables, subprogramas, ete,

+ Hacer referencia a algunos valores particulares, generalmento como constantes con nombre.

+ Invocar operaciones do manipulación de los valores de ese tipo, bien
usando operadores cn expresiones aritméticas o bien mediante subprogramas.

El conjunto de todos estos elementos constituye el tipo abstracto de datos
(TAD)

Un tipo abstracto de datos (TAD) es una agrupación de una colección de
valores y una colección de operaciones de manipulación.

Es importante comprender que estas colecciones son cerradas, es decir sólo
se deben poder usar los valores abstractos y las operaciones declaradas para
ese tipo. Además los detalles do cómo se representan los valores y cómo so
implementan las operaciones pueden estar ocultos para quien utiliza el tipo
abstracto. Esto no ocurría cuando se asociaba el tipo de valor con su forma
de representación. Por ejemplo, si representamos los meses del año mediante
números, podremos usar el número 33, aunque no sca ningún mes válido, al
 

Tipos abstractos de datos 379

 

igual que podremos multiplicar los números de dos meses, aunque esto no
tenga ningún sentido.

La programación orientada a objetos, ampliamente usada en la actualidad,
se basa esencialmente en el uso de tipos abstractos de datos, con algunas
modificaciones. La terminología cambia bastante: se habla de clases y objetos
en Ingar de tipos y datos, y de métodos en lugar de operaciones. Por otra
parte se añade el concepto de herencia para facilitar la definición de nuevas
clases a partir de otras ya existentes, reutilizando elementos ya definidos,

 

Este tema se limita a introducir el concepto de tipo abstracto de datos, que es
perfectamente suficiente para desarrollar nna buena metodología de desarrollo
de programas. La programación orientada a objetos se deja para un estudio
posterior.

14.2 Realización de tipos abstractos en Ct

   

Cuando se utiliza un lenguaje de programación orientado a objetos el mec
mo de clases del que dispone es perfectamente adecuado para programar tipos
abstractos de datos, ya que de hecho las clases son implícitamente TADs. Eso
ocurre, por ejemplo con C++.

Sin embargo, el subconjunto denominado Ci que se usa en este libro no contempla la definición de clases como tales, sino que se limita a presentar una
forma algo más limitada de programar tipos abstractos de datos. Para ello se
aprovecha el hecho de que los tipos registro (struct) se tratan en C++ como
equivalentes a clases.

14.2.1 Definición de tipos abstractos como tipos registro
(struct)

Hasta ahora so ha visto que los tipos registro permiten definir estructuras con
varios campos de datos con nombre y tipo individual. Ahora añadiremos la
posibilidad de incluir también otros elementos, en particular subprogramas,
y distinguir entre elementos públicos y privados. De esta manera se pueden
definir tipos abstractos de datos, ya que:

+ Los campos de datos sirven para almacenar el contenido de información

del dato abstracto.
+ Los subprogramas permiten definir operaciones sobre esos datos.
 

 
   
   
    
  
   
   
   

Fundamentos de progr:

+ La posibilidad de declarar ciertos elementos como privados permite
tar detalles de implementación, y dejar visible sólo la interfaz del
abstracto

Para ello las reglas de sintaxis de la declaración de un tipo registro se

de la siguiente forma:

Tipo_struct 33= typedef struct Identificador
1 Lista_de_items [ private: Lista_de_items ] Y ;

Htem ; ( Ttem ; Y

 

 

Lista_de_items 3

Item 33= Campo | Cabecera _subprograma

 

Campo 33= Campos_:

 

mal_tipo | Campo_puntero | Campo_array
Identificador_de_tipo Lista_de_identificade

Identificador_de_tipo * Identificador

 

Campos_igual_tipo

  

   
 

Campo puntero

 

Campo_array 33 Identificador_de_tipo Identificador Dimensiones

 

Como ejemplo se muestra una declaración del tipo abstracto TipoPunto,
rrespondiente a un punto en el plano euclídeo. Cada punto se representa
sus coordenadas cartesianas, y se le asocian subprogramas para leer y
puntos (sus coordenadas), y para calcular la distancia entre dos puntos.
typedef struct TipoPunto (

float x; /* Coordenada X */

float y; /* Coordenada Y */

/** Leer un punto con formato "(x.y)" */
void Leer();
/** Escribir un punto con formato "(x,y)" */
void Escribir();
/** Calcular la distancia de un punto a otro */
float Distancia( TipoPunto p );

*

Como puede verso, los subprogramas correspondientes a las operaciones sobre
el tipo abstracto se declaran simplemente por su cabecera, porque lo que se
declara aquí es sólo la interfaz del tipo. La notación para referirse a las operaciones es la misma que para los campos de datos, usando el punto (.) como
operador de cualificación. El esquema de esta notación y un ejemplo de uso
son:

variable. campo Referencia a campo de datos
variable. operación(. argumentos ) Referencia a operación
 
  
  
  
    
  
  
  
 
   
 
 
 
   
    
   
  
 
 
    
  
  
 
  

¡Tipos abstractos de datos 381

, P.Distancial q ) );

¡Como complemento de la declaración de la interfaz se necesita además definir
la implementación de las operaciones. Esta implementación se hace fuera de
la declaración del tipo registro, usando la notación Tipo: : Operación como
nombre del subprograma. El código de implementación soría:

¡finclude <stdio.h>

'finclude <math.h>

 

./* Excepción en lectura */
¡typedef enun TipoPuntoError ( PuntoNoLeido );

|/** Leer un punto con formato "(x,y)" */
¡void TipoPunto: :Leer() [
int campos;

campos =scanf( " (%E , X£)", 8x, 4y);

if (campos < 2) ( /* comprobar que se han leído dos valores */
throw PuntoNoLeido;

3

y

/** Escribir un punto con formato "(x,y)" */
¡void TipoPunto: :Escribir() 1

print£C"(, ME", x, y);
3

/** Calcular la distancia de un punto a otro */
float TipoPunto: :Distancia( TipoPunto p ) 1
float deltaX, deltaY;

deltaX =x — px;

deltaY = y - py;

return sqrt( deltaX*deltaX + deltaY*deltaY );
,

 

Como se ve, en el código de implementación se puede hacer referencia a los
campos de la estructura directamente por su nombre, sin necesidad de cuali382 Fundamentos de programación:

 

ficación. Se sobreentiende que se refieren a la propia variable sobre la quese!
invoca la operación.

Adicionalmente en esto ejemplo se ha utilizado el subprograma scanf come.
función, y no como procedimiento (en C y C++ no hay diferencia entre ambos.
tipos de subprograma). Se aprovecha el resultado de la llamada, que es el
número de valores efectivamente leídos, para comprobar si hay errores en la.
lectura o se alcanza el final de los datos.

NOTA: Las operaciones definidas en los módulos de librería estándar de C quedas

fuera del lenguaje C2 en sí. Por lo tanto esas operaciones estándar podrán nsarse com
la misma libertad que en lenguaje €.

 

Una vez definido el tipo abstracto se puede escribir código que lo use. Por.
ejemplo, so puede escribir un programa que lea segmentos definidos por sus:
puntos extremos, y calcule e imprima sus longitudes:

tinclude <stdio.h>

/* Definición del tipo abstracto PUNTO */
/* ... aquí se incluye el código anterior ... */

/** Programa principal */
int mainO (

TipoPunto a, b;

bool seguir = true;

while (seguir) £

b.Leer();
printf( "Segmento: " );
a.Escribir()
print£( **)
b. Escribir();
printf( " Longitud: Xfin", a.Distancia( b )

) catch (TipoPuntoError e) (
seguir = false;

)

$
)

 

 

El programa se plantea como un bucle indefinido que va leyendo pares de
puntos y calcula e imprime la longitud del segmento que definen. El programa
termina cuando se produce una excepción en la lectura de un punto, bien
porque se termina el fichero de datos de entrada o porque apareco un dato que
Tipos abstractos de datos 383

 

no es una representación válida de un punto (z, y), con los paréntesis y la
coma de separación.

Combinando los fragmentos de código anteriores podemos mostrar ya el programa completo:

 

PORRA RARA RRA IRA RRA RRA
* Programa: Segmentos

* Este programa lee una serie de segmentos, dados
* — por sus extremos, y calcula sus longitudes.
AAA ARA RRA RARA RARA NARRAR 222248
|*include <stáio.h>

include <nath.h>

Ye

 

Interfaz del tipo abstracto PUNTO

 

   

 

typedef struct TipoPunto (
float x; /* Coordenada X */
float y; /* Coordenada Y */

/* Leer un punto con formato “(x,y)" */
void Leer();
/* Escribir un punto con formato "(x,y)" */
void Escribir();
/* Calcular la distancia de un punto a otro */
float Distancia( TipoPunto p );

*

/* Excepción en lectura */
typedef enun TipoPuntoError [ PuntoNoLeido );

Implementación del tipo abstracto PUNTO

 

/** Leer un punto con formato "(X,y)" */
void TipoPunto: :Leer() 4
int campos;

campos = scanf( " (Xg, Xg)", 8%, dy);
if (campos < 2) £
throw PuntoNoLeido;
y
3

 

 
 

 

384 Fundamentos de programación

 

/** Escribir un punto con formato "(x,y)" */
void TipoPunto: :Escribir() (

print£( "(gx y):
y

/** Calcular la distancia de un punto a otro */
float TipoPunto: :Distancia( TipoPunto p ) 4
float deltaX, deltaY;

  

    

deltaX =x - p.:
deltaY = y - p.:
return sqrt( deltaX*deltaX + deltaY*deltaY );
,
7 AAA

Programa principal

 

int mainO) (
TipoPunto a, b;
bool seguir = true;

while (seguir) (
try (
a.Leer();
b.LeerO);
print£( "Segmento: " );
a.EscribirO);
printer);
b. Escribir(;
print£C " Longitud: Xglw", a.Distancial b) )
) catch (TipoPuntoError e) £
seguir = false;
,
7
y

 

Ejemplo de datos de entrada:

 

(0, 4 (3, 0)
(1,2(3,4)

(5,
00.6, 0...)

AD aD
No hay más puntos

 
Tipos abstractos de datos 385

 

Resultados obtenidos:

 

(O, 4) (3, 0) Longitud: 5
(1, 2) (3, 4) Longitud: 2.82843
: (5, 0) (6, 0) Longitud: 1
CL, D (1, 1) Longitud: 2

 

14.2.2 Ocultación

Para que un tipo sea realmente abstracto haría falta que los detalles de implomentación no fucran visibles. Los subprogramas, como mecanismo de abstrucción, ya ocultan los detalles de la realización de las operaciones. Sin embargo
queda la cuestión de cómo ocultar la manera de representar los valores del
tipo abstracto.

En el ejemplo anterior al definir el TipoPunto se tienen visibles los campos
de información de sus coordenadas, que pueden ser consultadas y modificadas
por el código que usa el tipo. En este caso no so presenta ningún problema
por eso, ya que cualquier pareja de coordenadas define un punto válido.

No ocurre lo mismo con otros tipos de datos. Por ejemplo, si se almacena el
valor de una fecha como la tupla numérica (día, mes, año) no se puede admitir
cualquier combinación de valores. La fecha (20, 7, 2009) es correcta, pero
(7, 20, 2009) no lo es, y menos aún (50, -3, 54321). Si se quiere definir el tipo
fecha como tipo abstracto será necesario ocultar los detalles de representación
interna de los valores, de manera que sólo se puedan construir fechas usando
operaciones que garanticen la corrección de los valores del tipo.

 

Para permitir esta ocultación los tipos struct admiten la posibilidad de declarar ciertos elementos componentes como privados, usando la palabra clave
private para delimitar una zona de declaraciones privadas dentro de la estructura. La interfaz básica del TipoFecha podría ser:
“typedef struct TipoFecha £

/* Dar valor a un dato fecha */

void Poner( int día, int mes, int anno );

 

 

/* Obtener el contenido de un dato fecha */
int Dia();
int MesO;
int Anno();

private:
int dia, mes, anno;
»
 

 
      
    
  
    

Fundamentos de programs

Como contrapartida a ocultar los elementos internos de representación de
fechas, ha sido necesario añadir operaciones explícitas para asignar valor y
cuperar el contenido de una fecha. Estas operaciones son las más básicas.
aplicaciones informáticas que operan con datos de tipo fecha son enorme
frecuentes. En ellas se realizan operaciones muy diversas, de manera que
interfaz de un tipo fecha de uso general debería incluir decenas de operaci
Citaremos sólo algunas posibilidades, como ejemplo:

typedef struct TipoFecha 1

 

void Leer();
void Escribir( const char formato[] );

int Diasilasta( TipoFecha f
void Incrementar( int dias

 

bool EsAnterior( TipoFecha £ );
bool EsIgual( TipoFecha £ );
bool EsCorrecta();

TipoDiaSemana DiaSemana();
ete.

 

14.2.3. Ejemplo: Imprimir fechas en orden

Como ejemplo se presenta aquí una nueva versión del programa de leer fechas
e imprimirlas en orden, que ya apareció en el tema 12. Ahora se define el tipo
fecha como tipo abstracto de datos y se simplifica la lectura del mes para no
hacer el código demasiado largo.

 

PA RARA RARA RARA RRA RARA ERRADA
» Programa: Fechas2

* Descripción:

» Programa que lee una serie de fechas,

* comprueba que son correctas, y las

imprime en orden cronológico.
A RARA

*include <stdio.h>
*include <ctype.h>
*include <stdlib.h>
 

Tipos abstractos de datos 387

 

 

as

Tipo abstracto FECHA

 

 

 

typedef struct TipoFecha (

 

 

bool Leer();

void Escribir();

bool EsCorrecta();

bool EsPosterior( TipoFecha £ );

private:
int dia, mes, anno:

 

 

Lista de fechas
¡const int maxFechas = 100;
typedef TipoFecha listaFechas_t [maxFechas];

   

 

listaFechas_t lista; /* lista de fechas leídas, en orden */
“int nunFechas; /* minero de fechas leídas */
Br

 

Nombres de los meses

    
 

 

const int maxNombre = 15;
typedef char TipoNombreMes[maxNombre] ;
typedef TipoNombreMes listaNombres_t[13];

listaNombres_t nombres = ("?", /* sin nombre cuando mes = 0 */
/* nombres de los meses */

 

“Julio”,
"Agosto",

 
 

Implementación de operaciones con FECHAS

 

 

/** Comprobar fecha correcta */
bool TipoFecha: :EsCorrecta() 4

if ( dia<-0 || mes<=0 || anno<=0) £
return false;

y

switch (nes) £

 

case 10,
case 12:
return (dia <= 31);
break;

 

case 11:
return (día <= 30);

 

) else (
return (día <= 28);
break;
default:
return false;
3

J

/** Escribir fecha día-mes-año */
void TipoFecha: :EscribirQ) £

print£( "X2d-Xs-%4d", dia, nombres[mes], anno );
J

 

/** Leer mes en número o en letra completo o abreviado */
void LeerMes( int £ mes ) [

 
Tipos abstractos de datos 389

TipoNombreMes nombre;
bool encontrado;

scan£( "Xs", nombre ); /* leer mes como texto */
if (isdigit(nombre[0))) € /* mes en núnero */
mes = atoi( nombre
) else ( /* mes en letra */
mes = 13;
encontrado = false;
while (nes > 0 48 lencontrado) 1
mesencontrado = /* coinciden 3 caracteres */
nombres(mes][0] == toupper(nombre[0]) 84
nombres[mes][1] == tolower(nombre[1]) 88
nombres[mes][2] == tolower (nombre[2]);

 

 

 

 

y
J
3

/** Leer fecha "dia mes año” con el mes en núnero
o letra y el año con dos o cuatro cifras.
Devuelve 'true' si ha podido leer */

bool TipoFecha: :Leer() (

dia = 0;

scan£( "Xd", ádia );

Af (dia ==0) 4
return false;

J

LeerMes( mes );

scanf( "Xd", dano );

4£ (anno < 100) (
anno = anno + 2000;

y

return true;

 

 

,

/** Comparar dos fechas */
bool TipoFecha: :EsPosterior( TipoFecha £ ) (
i£ (anno != £.anno) £

return (anno > f.anno);

 

,

if (nes != f.mes) (
return (nes > f.mes);

y

return (dia > f.dia);

 

y

 
 

 

390 Fundamentos de progr:

 

/** Insertar una fecha en la lista ordenada */
void InsertarFecha( TipoFecha £ ) (
int izquierda, derecha, centro;

/*-- Poner la fecha como centinela, al final (evita
que añadir al final sea un caso especial) --*/
lista[nunFechas]

nunFechas++;

 

/*-- Determinar la posición que le corresponde --*/
izquierda = 0;
derecha = nunFechas-1;
while (izquierda < derecha) (
centro = (izquierdarderecha)/2;
i£ (£.EsPosterior( lista[centro] )) £
izquierda = centro+;
) else (
derecha = centro;
J
3

/*— Hacer sitio para la nueva fecha --*/
for (int ind = nunFechas-1; ind >= izquierda; ind--) (

listalind+1] = listalind:
+

 

/*-- Colocar la fecha en su sitio —-*/
lista[izquierda] = f;

 

,

Pr
Programa principal
int mainO) 1
TipoFecha fecha;
bool seguir;

 

   

print£( "Fechas leídas:Xn" );

numFechas = 0;

seguir = fecha.Leer();

while (seguir 4% nunFechas < maxFechas) 1
fecha.Escribir();
if (fecha.EsCorrecta()) £

InsertarFecha( fecha );

) else £
Tipos abstractos de datos

391

 

print£( " ** incorrecta **" )
3
print£( "mn"
seguir = fecha, Leer();
E

 

print£( "WnFechas en ordena" );
for (int k=0; k<numFechas; ke+) (
lista(k].EscribirO;
print£( "a" );
J

 

y

 

Ejemplo de datos de entrada:

 

10 Marzo 1972
30 feb 82

29 FEB 1900
11 372

29 FEB 2000
28 diciem 1993
4 enero 91

15 error 89
10 10 10

o

Resultados obtenidos:

 

 

Fechas leídas:

10-Marzo-1972

30-Febrero-2082 ** incorrecta **
29-Febrero-1900 ** incorrecta **
11-Marzo-2072

29-Febrero-2000
28-Diciembre-1993

4-Enero-2091

15-2-2089 ** incorrecta **
10-Octubre-2010

Fechas en orden;
10-Marzo-1972
28-Diciembre-1993
29-Febrero-2000
10-Octubre-2010
11-Marzo-2072
4-Enero-2091

 
 

392 Fundamentos de programación:

 

14.3 Metodología basada en abstracciones

La técnica de programación estructurada, basada en refinamientos sucesivos,
puede ampliarse para contemplar la descomposición modular de un programa.
La metodología de desarrollo será esencialmente la misma que se ha presentado.
en el tema 8, referente al desarrollo usando abstracciones en forma de subprogramas (abstracciones funcionales). La diferencia es que ahora disponemos
también de un nuevo mecanismo de abstracción, que son los tipos abstractos
de datos.

   

Igualmente son de aplicación las técnicas generales de desarrollo: descendente
o ascendente, que pueden plantearse no sólo con abstracciones funcionales sino:
también con abstracciones de datos. En cualquier caso el desarrollo deberá
atender tanto a la organización de las operaciones como a la de los datos sobre
las que operan, de manera que habrá que ir realizando simultáncamente las
siguientes actividades:

 

+ Identificar las operaciones a realizar, y refinarlas.
+ Identificar las estructuras de información, y refinarlas.

Como se verá, puede establecerse una analogía entre ambas.
14.3.1 Desarrollo por refinamiento basado en abstracciones
Comenzaremos por recordar lo que se decía en tema 8 sobre el desarrollo

descendente con abstracciones funcionales: en cada ctapa de refinamiento de
una operación hay que optar por una de las alternativas siguientes:

 

 

+ Considerar la operación como operación terminal, y codificarla mediante
sentencias del lenguaje de programación.

+ Considerar la operación como operación compleja, y descomponerla en
otras más sencillas.

+ Considerar la operación como operación abstracta, y especificarla, escribiendo más adelante el subprograma que la realiza.

Ahora podemos reformular estas opciones para las estructuras de datos a utilizar:

+ Considerar el dato como un dato elemental, y usar directamente un tipo
predefinido del lenguaje para representarlo.

+ Considerar el dato como un dato complejo, y descomponerlo en otros
más sencillos (como registro, unión o formación).

+ Considerar el dato como un dato abstracto y especificar su intorfaz, dejando para más adelante los detalles do su implementación.

 

 
Tipos abstractos de datos 393

Aplicaremos estas técnicas de refinamiento a un programa que construya y
dibuje de manera aproximada una de las llamadas Curvas-C, Estas curvas, que
son realmente líneas poligonales realizables sobre una cuadrícula, se definen
recursivamente. Hay toda una familia de Curvas-C, que se designan mediante
un número de orden, empezando por cero:

+ C(0) es un trazo recto de longitud unidad.

+ C(m), para 10, equivale a dibujar dos veces C(n-1), con un giro de 90%

a la derecha entre ambas.

Las primeras curvas de la familia se muestran en la figura 14.1.

Orden o

1 2 3
Curva € a ] LP

Figura 14.1 Familia de Curvas-C.

 

Para resolver el problema tendremos en cuenta que el procedimiento printf
disponible para escribir resultados exige ir imprimiendo las líneas una a una,
de arriba a abajo. Por lo tanto es preciso componer el dibujo completo antes de
imprimirlo. La acción principal se descompone inicialmente en una secuencia
de acciones sencillas, tal como:

 

 

Imprimir Curva O —>
Iniciar la página en blanco
Componer el dibujo de la curva
Imprimir la página
Componer el dibujo de la curva —
i£ (el onden es 0) £
Trazar un segmento unidad

) else if (el orden es > 0) 4
Componer la curva de orden anterior
Girar a la derecha
Componer la curva de orden anterior

Girar a la izquierda
a

Hasta aquí la descomposición funcional inicial. Ahora toca identificar las estructuras de datos necesarias para mantener la información necesaria y poder
implementar las operaciones. La descripción anterior ya contiene implícitamente algunas decisiones sobre cómo almacenar y componer el dibujo. En

 

 
 

  
  
  
 
  
 
 
 
  
  
  

304 Fundamentos de progr:

 

concreto se está asumiendo la técnica de gníficos de tortuga empleada em
lenguaje LOGO. Esta técnica consiste en disponer de un agente capaz de:
moviéndose sobre el plano al tiempo que deja un trazo o rastro de su
miento. A este agente le llamaremos “tortuga”, y se le puede ordenar
avance y que gire.

En cuanto a la posibilidad de componer el dibujo completo antes de impri
se asumo que la tortuga se mueve sobre un “papel” que almacena los trazos
hace una función de memoria o registro gráfico. Corresponde a lo que en
refinamientos anterioros sc ha. denominado página.

Pasaremos ahora a identificar las acciones a realizar con la tortuga y el
De los refinamientos anteriores podemos deducir que se necesitarán al m
las operaciones siguientes;

Para la tortuga

- Avanzar la tortuga un paso

- Girar la tortuga a la derecha

- Girar la tortuga a la izquierda
Para el papel

- Iniciar el papel en blanco

- Registrar un trazo horizontal

- Registrar un trazo vertical

- Imprimir el contenido del papel

Estas operaciones se realizan, en general, sobre el tipo de dato al que corres
ponden, excepto la operación de avanzar ln tortuga, que ha de registrar al
mismo tiempo el trazo sobre el papel, bien sca horizontal o vertical, depen=
«tiendo de su orientación en ese momento.

Ahora ya se dispone de una idea clara de la organización del programa, que
usaría las siguientes abstracciones

+ Un subprograma para generar recursivamente la Curva-C de un orden
dado.

+ Un tipo abstracto de datos que implemente el agente de dibujo, es decir,
la tortuga.

+ Un tipo abstracto de datos que implemente el registro del dibujo, es
decir, el papel

Con un poco de experiencia se pueden provor las operaciones complementarias
y los datos internos que serán necesarios para desarrollar el programa completo. En este caso pasaremos a presentar sin más unas posibles interfaces de las
abstracciones reconocidas hasta el momento:
 

Tipos abstractos de datos 395

 

pa

* Procedimiento: CurvaC

 

 

e)

void CurvaC( int orden, TipoTortuga 4 t, TipoPapel 8 p );

EEES AA

* Tipo abstracto: Papel
typedef struct TipoPapel £
void PonerEnBlanco();
void Marcartorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();
private:
/* matriz con los trazos horizontales y verticales */

  

 

y

 

pa

* Tipo abstracto: Tortuga
A 4 /

typedef enum TipoRumbo ( Este, Norte, Oeste, Sur );

 

typedef struct TipoTortuga (
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel € p );
void GirarDerecha() ;
void GirarIzquierda();
private:
/* posición y orientación de la tortuga */
$

 

14.4 Ejemplo: Dibujar una Curva-C

 

Aquí se presenta el programa completo correspondiente al ejemplo introducido
en la sección anterior, El programa responde a la descomposición obtenida por
refinamientos sucesivos, y en él se han completado las interfaces de los módulos
con los elementos auxiliares necesarios.

Tal como se apuntaba, se hace uso de tipos struet para definir la Tortuga y el
Papel como tipos abstractos de datos. Sus estados se almacenan en estructuras
de datos que se manejan internamente como datos privados.

 
 

     

396 Fundamentos de pros

 

La realización del tipo Papel limita arbitrariamente su tamaño a una e
cula de 19 líneas de 32 casillas. Cada casilla registra el trazo vertical en
borde izquierdo y el trazo horizontal en su borde inferior. Para imprimir
dibujo de manera aproximada cada casilla se imprime con dos caracteres,
este tamaño el resultado del ejemplo puede incluirse fácilmente en el texto
este libro. Los trazos horizontales y verticales se aproximan con el guión
(2) y la barra vertical (1).

Según se muestra en la figura 14.2, el origen de coordenadas es el es
inferior izquierdo. Los rumbos se miden en sentido antihorario, emp
por la orientación a la derecha, es decir, tal como se miden habitualmente
ángulos en la geometría del plano.

  
    
  
  

 

 

N N
4

411 E
AÑ r
(0.0) A s

Figura 14.2 Composición del dibujo sobre una cuadrícula.

 

La posición inicial de la tortuga se ha establecido para conseguir que entre
dentro del papel la Curva-C del orden más alto posible para el tamaño fijado.
El programa es robusto en cuanto que:

+ Ignora los intentos de dibujar curvas de orden negativo.

+ Si se manda dibujar una curva que ocupa más espacio del disponible la:
composición de la curva se sigue haciendo correctamente pero los trazos
fuera del papel no se registran.

 

El código desarrollado es, en general, bastante sencillo y puede ser leído sin
grandes difienitades. El único detalle algo complicado es el cálenlo de los
rumbos, que exigo convertir los valores enumerados a enteros en el rango 0-3,
y viceversa. El listado completo es el siguiente:

 

PA AAA RARA RARA
* Programa: DibujarC

* Descripción.
* Este programa lee como dato el orden de una curva C, y a

* continuación la dibuja en forma de texto en pantalla
PP LA /

 

 
Tipos abstractos de datos 397

+include <stdio.h>

[iraarrrmamaacanamnmaas:
Parámetros globales
const int ANCHO = 32; /* cuadrícula en
const int ALTO = 19; — /* la pantalla */

 

  
   

a

 

Tipo abstracto PAPEL

 

 

 

o */
typedef struct TipoPapel (
void PonerEnBlanco();
void MarcarHorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();
private:
bool Dentro( int x, int y );
char marcasH[ ANCHO] [ALTO] ;
char marcasV[ANCHO] [ALTO];
+

bool TipoPapel::Dentro( int x, int y ) 1
return (x >= 0 4% x < ANCHO 88 y >= 0 88 y < ALTO);
3

 

void TipoPapel::PonerEnBlanco() (
for (int x=0; x<ANCHO; xe+) (
for (dot y-07 yaLIO; ye) Y
marcastilx] [y] =
marcasVLaly)= "0
y
)

    

J

void TipoPapel: :Marcariiorizontal( int x, int y ) (
1£ (Dentro( x, y )) (
marcasH[x][y] = '_*
)

 

y

¡void TipoPapel::MarcarVertical(int x, int y ) (
Af (Dentro( x, y )) (
marcasV[x] [y] = "1%
,

 

y

 
398 Fundamentos de progr:

void TipoPapel:;
for (int y=ALTO-1; y»=0; y--) (
For (ánt x-0; X<ANCHO; x+*) 4
print£( "Xckc", marcasV[x][y], marcasH[x] [y1);
y
primt£( "ay;
y

 

Imprimir O)

 

 

)

q

 

Tipo abstracto TORTUGA

 

tia a /

typedef enun TipoRumbo ( Este, Norte, Oeste, Sur );

 

typedef struct TipoTortuga (
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel 4 p );
void GirarDerecha();
void GirarIzquierda();
private:
int xx, YY;
TipoRumbo sentido;

 

 

::Poner( ánt x, int y, TipoRumbo rumbo ) £

 

sentido = rumbo;
J

void TipoTortuga: :Avanzar( TipoPapel 4 p ) t

switch (sentido) (

case Norte:
p.MarcarVertical( xx, yy );
yyA+:
break;

case Sul
yy;
p.MarcarVertical( xx, yy );
break;

case Este:
p.Marcariiorizontal( xXx, yy )i
PA
break:

case Oeste:

 

 

 
Tipos abstractos de datos

399

 

 

p.MarcarHorizontal(xx, yy );
break;
,
,

void TipoTortuga: :GirarDerecha() £
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */

,

¡void TipoTortuga: :GirarTzquierda() (
sentido = TipoRumbo( (int(sentido)+1) % 4 );

 

 

Y

if (orden == 0) (
t.Avanzar( p );

) else if (orden > 0) (
CurvaC( orden - 1, t, p);
t.GirarDerecha()

 

CurvaC( orden — 1, t
t.GirarTzquierda() ;

 

Po

 

Programa principal

 

int mainQ (
int orden;
TipoTortuga tt;
TipoPapel pp;

print£( "Orden:
scanf( "Xd", £orden );

 

pp.PonerEnBlanco() ;

/* posición inicial de conveniencia */
tt.Poner( 8, 3, Este );

CurvaC( orden, tt, pp);

DD. Imprimir();

 

void CurvaC( int orden, TipoTortuga £ t, TipoPapel £ p ) £

 

 

 
Fundamentos de progr:

400

 

Ejemplo de ejecución del programa:

 

Orden: 8

 

 

 
Tema 15
Módulos

En este tema se da una introducción a la programación modular, en especial
basada en el empleo de tipos abstractos de datos.

Se introduce el concepto de módulo, en general, y su realización en C*, en
particular. Se discuten brevemente las características necesarias para compilar
módulos por separado, de forma segura, y la manera de conseguirlo en este
lenguaje.

 

Finalmente se extiende la metodología de desarrollo de programas con la po1 en módulos separados, estableciendo las recomendaciones del desarrollo modular basado en abstracciones.

 

15.1 Concepto de módulo

En programación, un módulo es, en general, un fragmento de programa utilizado en algún momento para la construcción del programa completo, Lo
que distingue a un módulo propiamente dicho de un fragmento arbitrario del
programa es el hecho de que en algún momento de la construcción haya sido
reconocido como tal, y por tanto que se haya desarrollado o refinado de forma.
relativamente independiente del resto del programa. Podríamos definir:

Módulo: Fragmento de programa desarrollado de forma independiente.

El desarrollo independiente debe serlo on el máximo grado posible. Atendiendo a las técnicas de preparación de programas en lenguajes de programación
simbólicos, diremos que un módulo debería ser compilado y probado por separado, y no tratarse de un simple fragmento de texto dentro de un único
programa fuente.

 
 

402 Fundamentos de programación

 

La razón de exigir compilación por separado para los distintos módulos de
un programa obedece a la necesidad de limitar la complejidad de aquello que
está siendo elaborado por una persona en un momento dado. Si el módulo se
va a compilar por separado, la persona que lo desarrolle podrá concentrarse
en él, prescindiendo en parte de cómo se utiliza ese módulo desde cl resto
del programa. De la misma forma, quien escriba el resto del programa no
se preocupará de los detalles de cómo está codificado el módulo, sino sólo de
cómo hay que usarlo.

El concepto de módulo, por tanto, está íntimamente ligado a la idea de adstracción. Un módulo debe definir un elemento abstracto (o varios relacionados
entre sí) y dobe ser usado desde fuera con sólo saber qué hace el módulo, pero
sin necesidad de conocer cómo lo hace.

15.11 Especificación y realización

Igual que en cualquier otro elemento abstracto, on un módulo podemos distinguir dos puntos de vista, correspondientes a su especificación y a su realización.
Tal como se ha indicado con anterioridad, la primera visión nos dice qué hace
el módulo, y la segunda nos dice cómo lo hace.

 

La especificación de un módulo que contenga la definición de una serie de
elementos abstractos consistirá, fundamentalmente, en el conjunto de las especificaciones de cada uno de ellos, por separado, más una indicación de los
posibles efectos de unos sobre otros cuando se usan de forma combinada.

La realización del módulo consistirá en la realización de cada uno de los elementos abstractos contenidos en dicho módulo.

 

La especificación del módulo es todo lo que se necesita para poder usar los
elementos definidos en él. Esta especificación constituye la interfaz (en inglés
interface) entre el módulo (incluida su realización) y el programa que lo usa.

 

La independencia entre la realización de un módulo y el programa que lo usa se
incrementa si la realización de un elemento abstracto no es visible desde donde
se usa. Esta característica se denomina ocultación, y ha sido ya desarrollada
en los temas 7 y 14 para las funciones, procedimientos y tipos abstractos de
datos.

Referida a los módulos, la ocultación consiste en que el programa que usa un
elemento de un módulo sólo tiene visible la información de la interfaz, pero no
la de la realización.

 
Módulos 403

 

 

Los lenguajes de programación que permiten programar usando módulos pueden emplear diversas técnicas para definirlos e invocar los elementos definidos
en ellos. Tal como se ha comentado antes, es importante que los módulos
puedan compilarse por separado. Esto quiere decir que los lenguajes de programación deben permitir escribir un programa complicado como un conjunto
de varios ficheros fuente distintos, cada uno de los cuales pueda compilarse de
manera más o menos independiento de los demás.

 

 

Por otra parte, para que el uso de los elementos de un módulo sea correcto,
habrá que hacerlo de acuerdo con la interfaz establecida. La interfaz debe ser
tenida en cuenta al compilar un programa que use elementos de un módulo
separado. Por el contrario, la realización del módulo debe permanecer invisible
para el programa que lo usa con objeto de mantener la deseable ocultación de
los detalles de los elementos abstractos contenidos en él.

isibilidad deseable entre un

 

En la figura 15.1 se representa gráficamente la
módulo y el programa que lo usa.

Programa Módulo

Realización — | (oculto)

jura 15.1 Visibilidad de un módulo.

 

Resumiendo:
Compilación separada: El programa está formado por varios ficheros fuente,
cada uno de los cuales se compila por separado.
Compilación segura: Al compilar un fichero fuente el compilador comprueba
que el uso de elementos de otros módulos es consistente con la interfaz.
Ocultación: Al compilar un fichero fuente el compilador no usa información
de los detalles de realización de los elementos de otros módulos.
Entre las tócnicas empleadas por lenguajes de programación de uso frecuente

en lo que respecta a compilación separada, tenemos situaciones tales como las
siguientes:

 
 

 

 

 

404 Fundamentos de programación

(a) El fichero del programa y del módulo se tratan de forma totalmente separada, sin visibilidad de la interfaz (lenguaje FORTRAN y las primeras
versiones del lenguaje C).

(b) La parte necesaria de la intorfaz se copia o importa manualmente en
el programa que la usa. La compilación de los ficheros del programa y
del módulo se hace con total independencia (lenguaje C ANSI con prototipos, C++, y algunas versiones del lenguaje Pascal, con la directiva
EXTERN o USE)

(0) La interfaz del módulo y su realización sc escriben en ficheros separados.
El mismo fichero de interfaz se usa tanto al compilar la realización del
módulo como al compilar el programa que lo usa (lenguajes Modula-2 y
Ada).

(d) La interfaz del módulo y su realización so combinan en un solo fichero
fuente. Al compilar el programa que lo usa el compilador lee el fichero
fuente del módulo, pero sólo utiliza los elemento de la interfaz (lenguajes
Oberon y Java).

En los lenguajes que nsan la técnica (a) no hay compilación segura. En los
mencionados en (b) la seguridad es mayor, pero aún hay posibilidad de errores
si no coincide la interfaz del módulo con la copia usada en el programa, Con
los lenguajes que usan las técnicas (c) y (d) la compilación es completamente
segura.

El lenguaje Ch está basado en C++ y comparte sus características en cuanto
a compilación separada y compilación segura.

15.1.3. Descomposición modular

La posibilidad de compilar módulos de forma separada permite repartir el
trabajo de desarrollo de un programa, a base de realizar su descomposición
modular. Los diferentes módulos pueden sor encargados a programadores diferentes, y gracias a cllo todos pueden trabajar al mismo tiempo.

De esta forma se pueden desarrollar en un tiempo razonable los grandes programas correspondientes a las aplicaciones de hoy día, que totalizan cientos
de miles o millones de sentencias.

La descomposición modular de un programa puede reflejarso en un diagrama.
de estructura, tal como el de la figura 15.2. En este diagrama se representa
cada módulo como un rectángulo, con el nombre del módulo en su interior, y
se usan líneas para indicar las relaciones de uso entre ellos,

En este ejemplo el módulo A nia elementos de los módulos B y C, y el módulo
B usa elementos de C y D. Los módulos C y D no usan ningún otro módulo.
Módulos 405

 

 

Figura 15.2 Ejemplo de diagrama de estructura.

Las líneas que indican relaciones de uso pueden llevar punta de flecha si es
necesario indicar expresamonto cuál es el sentido de la rolación. Normalmente
no es necesario, pues, como cn este caso, un módulo que usa otro se dibuja
encima de él, de manera que las líneas de uso se interpretan siempre de arriba
a abajo, estableciendo al mismo tiempo una jerarquía entre módulos.

El objetivo de la ingeniería de software es facilitar el desarrollo de una aplicación de forma organizada, de manera que muchas personas puedan colaborar
simultáneamente en un mismo proyecto. Para que la descomposición en módulos sea adecuada, desde ese punto de vista, conviene que los módulos resulten
tan independientes unos de otros como sea posible. Esta independencia se
analiza según dos criterios, denominados acoplamiento y cohesión.

El acoplamiento entre módulos indica cuántos elementos distintos o características de uno o varios módulos han de ser tenidos en cuenta a la vez
al usar un módulo desde otro. Este acoplamiento debe reducirse a un
mínimo.

La cohesión indica el grado de relación que existe entre los distintos elementos
de un mismo módulo, y debe ser lo mayor posible. Esto quiere decir
que dos elementos íntimamente relacionados deberían ser definidos en el
mismo módulo, y que un mismo módulo no debe incluir elementos sin
rolación entre sí.

15.2 Módulos en Ct

Un programa descompuesto en módulos se escribe como un conjunto de ficheros fuente relacionados entre sí, y que pueden compilarse por separado. Cada
fichoro fuente constituye así una unidad de compilación.

 
 

406 Fundamentos de programación

 

Lamentablemente hay que decir que los lenguajes Co C++ (y por tanto
C2) no incorporan ninguna estructura sintáctica para realizar programación
modular. Las descomposición de un programa cn partes se hace solamente a.
nivel físico combinando ficheros, y no a nivel lógico, usando estructuras bien.
definidas. Por esa razón se debe imponer una cierta disciplina de codificación
que permita mantener la organización modular del programa dentro de unos
límites aceptables de esfuerzo de comprensión y mantenibilidad.

Las siguientes secciones indican la manera de redactar programas compuestos
por varios módulos, señalando la forma de hacer corresponder los módulos lógicos con ficheros físicos de código fuente, y la manera de compilar el programa
en su conjunto.

 

15.2.1 Proceso de compilación simple

Un fichero fuente es un fichero de texto que contiene el código de na unidad de
compilación, es decir, es posible invocar el compilador dándole como entrada
sólo ese fichero fuente.

 

La compilación de un fichero fuente produce un fichero objeto que contiene la
traducción del código C a instrucciones de máquina, tal como se representa
en el ejemplo de la figura 15.3. Por convenio, los ficheros fuente en C+ tienen la
extensión .cpp (la misma usada habitualmente en C++) y los ficheros objeto
la extensión .o. Como regla de disciplina modular en C£ se exige que el
nombre del fichero objeto sea el mismo que el del fichero fuente.

 

 

   

 

Figura 15.3 Proceso de compilación simple,

INOTA: El lenguaje Ct es un subconjunto estricto del lenguaje C++. No existe
un compilador específico para CE. Los ficheros fuente en CÉ se compilarán con un
compilador de C++.

En general un fichero objeto no se puede ejecutar directamente. Se necesita un
paso adicional de montaje para obtener un programa o fichero ejecutable, En
MS-Windows os ficheros ejecutables tienen la extensión .exe (cn UNIX/Linux
no suelen tener extensión). Si el programa ejecutable se ha generado a partir
de un solo fichero fuente, debe tener tambión el mismo nombre.

En C y C++ es frecuente que el montador y el compilador sean una misma
herramienta, o al menos que se invoquen como si lo fueran, En casos sencillos
como éste es posible realizar la compilación y montaje como una sola operación.

 
Módulos 407

 

En esta primera visión simplificada del proceso de compilación y montaje se
ha omitido mencionar explícitamente las librerías estándar o de sistema. Más
adelante se mostrará cómo se usan durante ese proceso.

15.22. Módulo principal

Cuando se descompone un programa en CE en varios módulos uno de ellos
ha de ser el programa principal o módulo principal. Este módulo será el que
contenga la función main(). La ejecución del programa completo equivale a
la ejecución de dicha función principal. Por supuesto, la función principal
puede invocar durante su ejecución operaciones definidas en otros módulos,
Repetiremos aquí el primer ejemplo de programa completo mostrado en este
libro, y que corresponde también al ejemplo de la figura 15.3

/** Programa: Hola */

/* Este programa escribe Hola */

Htinclude <stdio.h>

int mainO) (
print£C'HolaWn");
3

Todos los ejemplos de programas completos desarrollados hasta ahora se componían exclusivamente de un módulo principal. Para ser precisos habrá que
decir que en estos ejemplos se usaban otros módulos de las librerías estándar,
tal como stdio, pero puede considerarse que estos módulos de sistema no son
parte del programa o aplicación desarrollada,

La manera de escribir un módulo principal ya ha sido expuesta en los temas
anteriores. Sólo falta indicar que el fichero fuente de ese programa principal
debe tener el nombre que se dará finalmente al programa ejecutable y tener la
extensión .cpp, tal como se ha indicado anteriormente.

15.2.3. Módulos no principales

Los módulos de la aplicación que no contienen una función main() no permiten
generar un programa ejecutable por sí solos. Los elementos que contienen están
destinados a sor usados por el programa principal u otros módulos. Al escribir
el código do estos módulos no principales hay que distinguir claramente entre
los elementos púllicos, que deben ser visibles desde fuera del módulo para

 

 
408 Fundamentos de programación

 

poder usarlos, y los elementos privados, que sólo necesitan ser visibles en el
interior del módulo.

La distinción entro los elementos públicos y los privados se hace repartiendo
el código del módulo en dos ficheros fuente separados: in fichero de interfaz
o fichero de cabecera, y un fichero de implementación. El siguiente ejemplo
muestra el código de un módulo que ofrece facilidades para imprimir series de
valores numéricos tabulando en varias columnas. El fichero de interfaz es:

 

JARA AAAR ARA RARA AAA RARA RRA
* Interfaz de módulo; Tabulacion

* Este módulo contiene los elementos para

* imprimir series de múneros en varias columnas
A LAR RARA

Apragma once

extern int numColumnas; — /* múnero de columnas */
extern int anchoColuma; /* ancho de cada una */

/*— Iniciar la impresión --*/
void Iniciar( char titulo[] );

/* Imprime un núnero, tabulando */
void Imprimir( int numero );

/* Completa la impresión de la última línea */
void Terminar();

 

 

A continuación se presenta el correspondiento fichero de implomentación. En
este ejemplo de código se ha aprovechado una característica especial del procedimiento printf que permite indicar el ancho de un campo como argumento
además del valor a imprimir, usando un asterisco como especificador del ancho
en el formato.

 

 

 

va
* Módulo: Tabulacion

* Este módulo contiene los elementos para

* imprimir series de números en varias columnas
AA A
kinclude <stdio.h>

sinclude <string.h>

tinclude "Tabulacion.h"
Módulos 409

 

int nunColunnas
int anchoColuma

/* múnero de columas */
10; /* ancho de cada una */

  

static int columa = /* columna actual */

  

 

/*— Iniciar la impresión --*/

void Iniciar( char titulo[] ) (
Terminar(); /* la serie anterior, por si acaso */
print£( "%sin", titulo );
columna = 1;

,

/*-- Imprime un número, tabulando
void Imprimir( int numero ) £
if (columna > nunColumas) (
primt£( a");
columa =
J
print£( "%*4", anchoColuma, numero );
columa++;

   

  

/*— Completar la impresión de la última línea --*/
void Terminar() (
if ( columna > 1) 4
print£( "a" );

 

,
columna = 1;
,
El código contiene nuevos elementos de C£ (fpragma once, extern, static)

 

que se explican más adelante.

Una buena disciplina de nombres exige que ambos ficheros tengan el mismo
nombre que el nombre lógico del módulo. El fichero de interfaz tendrá la extensión .h y el de implementación la extensión .cpp. Por lo tanto los nombres
de los ficheros fuente en este ejemplo deben ser:

 

+ Interfaz: Tabulacion.h
+ Implementación: Tabulacion.cpp

En Ck no existe el concepto de nombre de módulo a nivel de sintaxis del
lenguaje. El nombre lógico Tabulacion usado en el ejemplo aparece solamente
en comentarios do documentación del código. La directiva Hinclude sirve
para hacer referencia a un fichero fuente desde otro, y tiene como parámetro
el nombre del fichero físico "Tabulacion.h", incluyendo la extensión.
 

410 Fundamentos de programación:

 

15.2.4 Uso de módulos

Para usar los elementos públicos definidos en un módulo hay que incluir le
interfaz de ese módulo en el código donde se vaya a utilizar. Esto se consigue
con la directiva include que ya se ha empleado en otros ejemplos para usar”
las librerías estándar. La novedad ahora es que los nombres de los ficheros de
la propia aplicación deben escribirse entre comillas ("... .") y no entre ángulos.
(<...>). Con esto se indica al compilador que debe buscar dichos ficheros en
donde reside el código fuente de la aplicación y no donde está instalada la
herramienta de compilación. Ejemplo:

   

 

ENTRO
* Programa: Serie
+ Este programa imprime la serie de núneros

* del 1 al 20 en varias columas
AA AAA

kinclude "Tabulacion.h"

int mainO €

   

Iniciar( "-- Columas por defecto ——

  

 

for (int k k <= 203 k+*) (
Imprimir(k)

+

Terminar ();

nunColumnas

anchoColuma = 13;

Iniciar( "-- 3 columas de 13 caracteres —
   

 
 

for (int k
Imprimir(k.
y

Terminar ();

k <= 20; kes) £

nunColumnas =
anchoColumna

 

 

  

Iniciar( "-- 6 columas de 5 caracteres -—" );
for (int k = 1; k <= 20; ker) £
Imprimir(k);
y
Terminar);

 
Módulos 411

 

Este programa imprime una serie de números correlativo, usando el módulo
de tabulación anterior, y con varias configuraciones de columnas. El resultado
es:

 

-- Columas por defecto -
1 2 3 4
5 6 7 8
9 10 un 12
3 1 15 16
Y 18 19 20
-- 3 columnas de 13 caracteres -1 2 3
4 5 6
7 8 9
10 u 12
13 14 15
16 1 18
19 20

-- 6 columas de 5 caracteres ——
1.02. 3.4 5 6
7 8 9 10 1 12
13 14 15 16 17 18
19 20

15.2.5 Declaración y definición de elementos públicos

En los ejemplos de programas de los temas anteriores los distintos elementos
creados por el programador se definían completamente en un punto determinado del código. En los programas modulares, en los que hay elementos de un
módulo que se usan en otros, es prociso distinguir a veces entre la declaración
y la definición de un clemento.

En la declaración de un elemento hay que especificar lo necesario para que
el compilador pueda compilar correctamente el código que usa dicho
elemento.

En la definición de un elemento hay que especificar lo necesario para que el
compilador genere el código del propio elemento.

En el caso de los elementos públicos de los módulos, la declaración debe ponerse en el fichero de interfaz, y la definición en el fichero de implementación. En
algunos casos la declaración contiene toda la información posible, y no hace
falta una definición complementaria, La siguiente tabla recoge un resumen de
cómo se declaran y definen en Ck las distintas clases de elementos s

 

 

 

 
412 Fundamentos de programación

 

 

   

 

 

 

 

Declaración (fichero.h) Definición (fichero-cpp)
typedef... TipoNuevo ...: | (no aplicable)
const Tipo constante = valor; | (no aplicable)
extern Tipo variable; Tipo variable = valor;
Tipo SubprogramaCargumento) Y
Tipo SubprogramaCargumentos) ; + código
y

 

 

 

 

+ Los tipos y constantes se especifican totalmente en el fichero de interfaz.
No hay declaración y definición separadas.

+ Las variables se definen de la manera habitual en el fichero de implementación, incluyendo la especificación de valor inicial en su caso. Con ello
el compilador reserva espacio para dicha variable en el módulo que la define. En el fichero de interfaz se pone además una declaración que indica.
el tipo y nombre de la variable, sin indicar valor inicial, y precedida de la
palabra clave extern. Esta declaración permite al compilador generar
código de las sentencias que usan dicha variable en otros módulos sin

reservar espacio para ella, ya que formará parte efectiva del código del

módulo que la define. La conexión entre las referencias a la variable y

su ubicación real se resuelve durante la fase de montaje, posterior a la

compilación.

 

 

 

 

+ Los subprogramas se definen de la manera habitual en el fichero de implementación y permiten al compilador generar el código objeto del subprograma. En el fichero de interfaz se pone además una declaración on
forma de prototipo o cabecera de subprograma sólo con el tipo, nombre
y argumentos. Esta cabecera permite al compilador generar el código
de las sentencias de llamada al subprograma. La conexión entre las llamadas al subprograma. y su código real se resuelve durante la fase de
montaje, posterior a la compilación.

15.2.6 Conflicto de nombres en el ámbito global

El ámbito más externo en la jerarquía de bloques del programa principal y
de todos los módulos de una aplicación constituye un espacio de nombres
global y único, en el que no debe haber nombres repetidos. Esto exige na
clara disciplina para ovitar conflictos debidos al intento de usar el mismo
identificador en módulos diferentes al definir elementos distintos. Por ejemplo,
si dos módulos diferentes definen cada uno una operación de inicialización, y
ambos le dan el nombre Iniciar(), se obtendrá un error al tratar de compilar
y/o montar un programa que use ambos módulos.

 
Módulos 413

 

 

IENOTA: En C++ cs posible a veces definir subprogramas diferentes con el mismo
nombre, si se distinguen claramente por su tipo y múmero de argumentos. Esta
facilidad se denomina “sobrecarga” (overload). En Ci no se admite dicha posibilidad.

 

 

Una técnica sencilla para cvitar en lo posible los conflictos de nombres públicos
globales es asignar a cada módulo un prefijo diferente que so habrá de usar
en los nombres de todos sus elementos públicos. De esta manera no hay
que atendor a cada nombre particular para evitar conflictos, sino que basta
controlar que no haya prefijos repetidos. En el ejemplo anterior del módulo
de tabulación se podría haber empleado el prefijo TAB en los nombres de las
operaciones públicas:

parara cerraran eran

* Interfaz de módulo: Tabulacion (TAB)

AAA ARA

Apragna once

extern int TAB_nunColumas; — /* número de columas */
extern int TAB_anchoColuma; —/* ancho de cada una */

/*— Iniciar la impresión --*/
¡void TAB_iniciar( char titulo(] );

/* Imprime un número, tabulando */
void TAB_imprimir( int numero );

/* Completa la impresión de la última línea */
void TAB_terminar();

INOTA; El estándar actual del lenguaje C introduce el mecanismo de “espacios de
nombres” (namespaces) que tiene posibilidades similares al empleo de prefijos, pero
de forma más organizada (y también algo más complicada de usar).

 

 

El ámbito global más externo incluye también los elementos privados, que no
figuran en la interfaz de los módulos. Afortunadamente en esto caso el lenguaje
Ci ofrece un mecanismo quo evita los conflictos de nombres repetidos, ya que
es posible especificar clementos en el ámbito más externo que sólo sean visibles
en el fichero fuente donde se definen. Para ello basta poner la palabra clave
static delante de la definición del elemento. Esto es lo que se ha hecho en
el ejemplo de tabulación con la variable auxiliar que almacena el estado del
proceso de impresión en varias columnas:

pra R RARA RRA

+ Módulo: Tabulacion
AAA

  

static int columa = 1; — /* columa actual */
   
    

414 Fundamentos de programación:

 

Con esta definición es posible reutilizar el nombre columna para clem
globales de otros módulos, sin que haya conflicto entre ellos.

15.2.7 Unidades de compilación en C+

Los ficheros fuento de los tipos mencionados pueden ser considerados unid:
de compilación, en el sentido de que es posible invocar la compilación de
cada uno de ellos por separado. Por lo tanto tendremos como unidades de
mpilac

   

+ El módulo principal: programa.cpp
+ El fichero de interfaz de un módulo: modulo.h
+ El fichero de implemontación de un módulo: modulo.cpp

En realidad a la hora de preparar una aplicación sólo se mandan compilar real
mente los ficheros con extensión .cpp, que son los que generan código objeto.
Los fichero de interfaz con extensión .h no se mandan compilar por sí mismos,
ya que en principio no generan código objeto. De hecho algunos compiladores
de C y C++ rechazan la compilación de este tipo de ficheros, incluso aunque
el código que contienen sea perfectamente aceptablo y compilable como fichero
con extensión .cpp.

Lo que ocurre es que los ficheros de interfaz son parte efectiva de la compilación
de los ficheros de implementación, El significado de la directiva include es
equivalente a copiar en eso punto el contenido del fichero fuente indicado. Esta
copia o inclusión se hace sobro la marcha durante la compilación, en una fase
inicial de la misma denominada preproceso. La figura 15.4 muestra cómo se
preprocesa un módulo o programa de nombre A que usa otro de nombre B.

  

Figura 154 Expansión de la directiva £include durante el preproceso.

 

Finalmente se enumeran aquí las reglas de sintaxis correspondientes a la estructura general de cada una de las unidades de compilación mencionadas:

 

Unidad_de_compilación
Programa_principal | Módulo_interfaz | Módulo_implementación
Módulos 415

Programa_principal 33= 4 Include Y É Declaración global Y
int main() Bloque

 

Pragma_onceÉ Include Y [ Declaración_interfaz Y
£ Include Y[ Declaración global Y

Módulo_interfaz

 

n

  

Módulo_implementaci
Include 33=
*include <Nombre_módulo.h> | ginclude “Nombre_módulo.h"
Pragma_once 33= fpragma once
Declaración global 33=
Declaración. de constante |
Declaración _de_tipo |
[ static ] Declaración de variable |
[static ] Subprograma
Declaración_interfaz 333
Declaración de constante |
Declaración de_tipo |
Declaración_de_variable_externa |
Cabecera_ subprograma ;
Declaración _de_variable_erterna
extern Identificador_de_tipo Lista_de identificadores ;

 

 

   

15.2.8 Compilación de programas modulares. Proyectos

El proceso de compilación y montaje de un programa cuyo código fuente está
repartido entro varios módulos requiere una cadena de operaciones, tal como
se indica en la figura 15.5 para el ejemplo del programa de tabulación.

 

 

Es importante observar que el fichero de interfaz Tabulacion.h se incluyo
tanto en el programa principal Serie.cpp como en el propio fichero de implementación Tabulación.cpp. Eso es necesario para asegurar una compilación

 

 
 

416 Fundamentos de programación

 

segura al poder detectarse posibles errores de codificación que hagan inconsistente la definición de los elementos de un módulo con el uso que se hace de
ellos desde otras partes del programa.

  

La generación del programa ejecutable final exige:

1. Compilar los módulos uno a uno, generando el correspondiente fichero
objeto (.0) a partir del fuente (.cpp)- Cada compilación individual
usa también los ficheros de interfaz (.h) mencionados en las directivas
*include del módulo.

2, Montar el programa ejecutable combinando todos los ficheros objeto de
los módulos.

Los entornos de programación modernos simplifican la tarea de recompilar
los módulos después de editar alguno o varios de ellos, Para eso disponen de
un mecanismo de proyectos, consistente en disponer de un fichero con información de los ficheros fuente que forman parte de la aplicación. A partir de
ahí el entorno automatiza la generación o actualización de los ficheros objeto y el ejecutable final, que se invoca en conjunto como una operación única
denominada habitualmente “construir” (en inglés build).

 

 

La información mí
proyecto será:

ima que debe contener el fichero de descripción de un

+ Nombre del proyecto (= nombre del programa ejecutable)
+ Lista de ficheros fuente de implementación .cpp (incluyendo el programa
principal)
Opcionalmente se puede disponer también de otros datos útiles, tales como

+ Lista de ficheros de interfaz .h

+ Forma de invocar al compilador, con opciones particulares para ese proyecto

. eto.

15.3 Desarrollo modular basado en abstracciones

La organización de un programa en módulos puede hacerso aplicando diforontes criterios, en función de cada caso concreto. En general será adecuado
cualquier criterio que conduzca a módulos con buena cohesión y bajo acoplamiento. El reconocimiento de abstracciones en el desarrollo de una aplicación
es al mismo tiempo una ayuda para clegir una organización modular adecuada,
Módulos 417

 

15.3.1 Implementación de abstracciones como módulos

En la mayoría de los casos los tipos abstractos de datos identificados en una
aplicación son buenos candidatos para scr codificados como módulos independientes, y lo mismo ocurre con las abstracciones funcionales de cierta complejidad. Por lo tanto el desarrollo basado en abstracciones lleva implícita una
posible descomposición natural del programa en módulos. Esto ocurre de forma obligada en algunos lenguajes con una estricta orientación a objetos, por
ejemplo Java.

Para ilustrar esta idea se repite aquí el ejemplo de dibujar una Curva-C in
troducido en el tema 14, pero dedicando ahora un módulo separado a cada
abstracción principal.

 

AAA A AREA
* Interfaz de nódulo: Papel

* Este módulo define el tipo abstracto PAPEL, capaz de

* almacenar un dibujo formado por trazos en una cuadrícula
AAA ARANA RAN RRA RARA RA

hpragma once

const int ANCHO 32; /* cuadrícula en */
const int ALTO =19; — /* la pantalla */

 

typedef struct TipoPapel (
void PonerEnBlanco();
void Marcarorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();

private:
bool Dentro( int x, int y );
char marcasii[ANCHO] [ALTO
char marcasV[ANCHO] [ALTO];

  

 

 

 

 

 

AAA
* módulo: Papel
* Este módulo define el tipo abstracto PAPEL, capaz de

* almacenar un dibujo formado por trazos en una cuadrícula
AAA AAA

include <stdio.h>
Hinclude "Papel.h”
418 Fundamentos de programación

 

bool TipoPapel
return (x

 

entro( int x, int y ) 4
88 x < ANCHO Bi y >= 0 88 y < ALTO);

 

J

void TipoPapel: :PonerEnBlanco() £

 

  

for (int x=0; x<ANCHO; x0++) (
for (int y-0; y<ALTO; y++) £
marcasH[x][y] =' *
marcasV[x][y] = * *;
,

y
3

 

void TipoPapel: :MarcarHorizontal( int x, int y ) £
Af (Dentro( x, y D) £
marcasH[x][y] = '*;
+
y

void TipoPapel: :MarcarVertical(int x, int y ) 4
if (Dentro( x, y )) 4
marcasVlx][y] = "1";
3
y

void TipoPapel::Imprimir() £
for (int y=ALTO-1; y>=0; y--) 4
for (int x=0; x<ANCHO; x++) (
print£( "Xkc", marcasvIx]y], marcas ly]);
)
printf( “Ya” );
F
3

 

 

PA A A ARA
* Interfaz de módulo: Tortuga

* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
A AR REA /

Kpragma once
tinclude "Papel.h"

typedef emun TipoRumbo ( Este, Norte, Oeste, Sur );

 
Módulos 419

typedef struct TipoTortuga (
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel 4 p );
void GirarDerecha();
void GirarIzquierda();
private:
intoax, yy;
TipoRumbo sentido;
h

 

 

JERARCA RENA RARA
* Módulo: Tortuga
* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
AA e /

include "Tortuga.h"

void TipoTortuga: :Poner( int x, int y, TipoRumbo rumbo ) £
q xj
moy
sentido = rumbo;

y

void TipoTortuga: :Avanzar( TipoPapel € p ) (
switch (sentido) (
case Norte:
p.MarcarVertical( xx, yy )i

 

p.MarcarHorizontal( XX, yy );
xx;
break:
case Oeste:
xj
MarcarHorizontal( xx, yy );
break;

 

 

 

 
420 Fundamentos de programación

void TipoTortuga: :GirarDerecha() (
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */
J

void TipoTortuga: :GirarIzquierda() (
sentido = TipoRumbo( (int(sentido)+1) X 4);
Y

 

 

AEREA AAA RARA RR RN RRA RARA RRA

* Interfaz de módulo: CurvaC

+ Este módulo contiene la función que genera una Curva-C

AA A AA ARA /
Fpragma once

Kinclude "Tortuga.h"

*include "Papel."

 

void CurvaC( int orden, TipoTortuga £ t, TipoPapel Ep );

 

 

PA

* Módulo: CurvaC

 

 

* Este módulo contiene la función que genera una Curva-C
AAA AAA AA

*include "CurvaC.h"

void CurvaC( int orden, TipoTortuga £ t, TipoPapel £ p )
if (orden == 0) £
t.Avanzar( p );
Y else if (orden > 0) (
CurvaC( orden — 1, t, Pp);
t.GirarDerecha();
CurvaC( orden - 1, t, p);
t.GirarIzquierda() ;

,

 

J

 

 

PARRA
* Programa: DibujarC

Descripción:
Este programa lee como dato el orden de una curva C, y a

continuación la dibuja en forma de texto en pantalla
A A A AAA AAA

 
Módulos 421

 

*include <stdio.h>

 

int mainQ (
int orden;
TipoTortuga tt;
TipoPapel pp;

print£( "Orden: " );
scanf( "xd", forden );

 

pp-PonerEnBlanco();

/* posición inicial de conveniencia */
te.Poner( 8, 3, Este );

CurvaC( orden, tt, pp);

pp. ImprimirO);

 

Como puede verso, los ficheros de interfaz contienen obviamente la declaración de la interfaz del elemento abstracto, y los ficheros de implementación
contienen la realización del elemento. En el caso de la abstracción funcional
Curva la interfaz es simplemente la cabecera del subprograma.

En el caso de los tipos abstractos de datos Tortuga y Papel. la interfaz incluyo
no sólo el tipo struct que lo define, sino también los complementos necesarios.
En la interfaz de la abstracción Tortuga se ha incluido la definición del tipo
enumerado TipoRumbo, y en la del Papel se incluyen las constantes de tamaño.

 

 

Figura 15.6 Estructura modular del programa de dibujar ma Curva-C.

 
 

422 Fundamentos de programación

 

La figura 15.6 muestra la estructura del programa, indicando las relaciones de
dependencia (de uso) de unos módulos respecto a otros. Las flechas indican
que un módulo utiliza directamente elementos de otro.

En el diagrama, cada módulo se representa, en general, como un rectángulo.
Además, los módulos que corresponden a tipos abstractos de datos se han
representado de manera similar a la usada en los dingramas de clases UML,
marcando una banda superior con el nombre del módulo, Se puede anmentar.
la analogía con la notación UML enumerando en la banda inferior los elementos
públicos del módulo, como se muestra en la figura 15.7:

 

Girarizquierda

 

Figura 15.7 Representación gráfica de la interfaz de los módulos.

15.3.2 Dependencias entre ficheros. Directivas

Las relaciones de uso entre módulos se corresponden, en principio, con las
directivas finclude nsadas en un fichero fuente para hacer visibles los elementos de otro, y que pueden aparecer en el fichero .cpp y/o en el .h. La
recomendación es:
+ Un fichero »ocx.h debe incluir otros yyy.h que uso directamente.
+ Un fichero »00x.cpp debe incluir su propio xxx.h y otros yyy.h que use
directamente. Pero no hace falta hacerlo oxplícitamente si ya los incluye
su o0.h.

 

En el ejemplo anterior hay dependencias indirectas. Por ejemplo, el módulo
principal DibujarC usa elementos de Tortuga directamente y también indirectamente a través de CurvaC. Si no se toman precauciones el preprocesador
incluirá el código de Tortuga.h dos veces, y se tendrán errores por duplicación
de definiciones. La directiva fpragma once sirve precisamente para evitar esa
duplicación.

  

IENOTA: La directiva fpragma once no es estándar en C++, En su Ingar la receta
habitual es similar a la siguiente (para un fichero 200t.h):

1 ttifndef xxh

| Adefine oh

1... código de la interfaz ...

Lo endif

Este esquema de código es algo más seguro poro bastante más complej
la decidido no incluirlo en el subconjunto C2.

  

y por ello se
  

Módulos 423

 

15.3.3. Datos encapsulados

En este tema y el anterior se ha visto cómo al definir un tipo abstracto de
datos hay que declarar luego varinbles de ese tipo para trabajar con ellas, En
algunos casos concretos resulta que sólo es necesario una única variablo del
tipo abstracto, Si es así, existe la posibilidad de oncapsular dicha variable en
un módulo y cvitar la declaración explícita del tipo. La facilidad de ocultación
que provee la programación modular es suficiente para conseguir la abstracción
del dato, de forma que sólo sean visibles las operaciones que lo manipulan pero
no los detalles de su implementación.

La siguiente tabla compara los esquemas generales de código correspondientes
ala declaración y uso de un tipo abstracto de datos y a un dato encapsulado.
En ambos casos se usa un módulo separado para el clemento abstracto.

 

Tipo abstracto Dato encapsulado
Interfaz

 

 

typedef struct Tipo (
void Operacion1();
void Operación2();
private:
UnTipo valorTnterno;
void Operación3();

y

void Operacion1O);
void Operacion2();

 

Implementación
static UnTipo valorInterno;
static void Operacion3() (

 

void Tipo::Operacion3() £
a )

HE O OO O

 

 

 

y valorinterno ... O
ee sy 3
vola: ES dc tl void Operacion? £
as» VELOGINECONO . valorInterno .
H
y
Uso
Tipo dato;
OperacionLO);

 

 

 

dato. Operacion1();

 
 

424 Fundamentos de programación

Conviene recordar que los nombres de variables y subprogramas definidos en
el nivel más externo de 1n fichero fuente son globales, por defecto. Para que
sean tratados como identificadores locales al fichero deben ser marcados como
static.

Como puedo vorse el segundo esquema es más sencillo, ya que ni el tipo ni el
dato son visibles. Eso es posible por la limitación de que sólo hay un dato del
tipo abstracto. El dato encapsulado aparece simplemente como una colección
de operaciones que manipulan la misma variable interna, oculta.

 

Podemos ilustrar esta técnica recodificando el ejemplo modular de dibujar
una Curva-C, convirtiendo ahora el Papel cn un dato encapsulado. Puesto
que cambia el código de la interfaz, hay que retocar también el código de los
demás módulos que lo usan.

 

AAA
* Interfaz de módulo: Papel?

* Este módulo encapsula un único ejemplar de dato abstracto

+ de tipo PAPEL, capaz de almacenar un dibujo formado

* por trazos en una cuadrícula

AAA ARA RINA

Hpragna once

void PonerEnBlanco();

void Marcarllorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();

 

 

 

a
* Módulo: Papel2

* Este módulo encapsula un único ejemplar de dato abstracto

* de tipo PAPEL, capaz de almacenar un dibujo formado

* por trazos en una cuadrícula

+. ARALAR RRA RARA
include <stdio, h>

Hinclude "Papel2.h”

 

qe Elementos privados

 

+

 

const int ANCHO = 32; /* cuadrícula en */
const int ALTO = 19; — /* la pantalla *,

 

typedef char MatrizMarcas[ANCHO] [ALTO];

 
Módulos 425

 

static MatrizMarcas marcasH;
static MatrizMarcas marcasV;

static bool Dentro( int x, int y ) (
return (x >= 0 8% x < ANCHO 8% y >= 0 88 y < ALTO);
,

 

Ps Elementos públicos - Y
void PonerEnBlanco() (
for (int x=0; x<ANCHO; x++) (
for (int y=0; y<ALTO; y++) (
marcasH[x][y] =* *;
marcasV[x][y] = *
)
,

 

 

y

void Marcarorizontal( int x, int y ) £
if (Dentro( x, y ) £
marcasH[x][y] = '_*;
y
J

void MarcarVertical(int x, int y ) 1
i£ (Dentro( x, y )) (
marcasV[x][y] ="1*%;
y
J

void Imprimir() (
for (int y=ALTO-1; y>=0; y--) (
for (int x=0; x<ANCHO; x++) (
print£f( "Xc%c", marcasV[x] [y], marcasH[x][y]);
3
print£( "a" );
ss
,

 

 

PA RRA AAAA

* Interfaz de módulo: Tortuga?
* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
AAA

 
 

426 Fundamentos de programación

 

Apragna once
typedef enun TipoRumbo ( Este, Norte, Oeste, Sur );

typedef struct TipoTortuga (
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar();
void GirarDerecha();
void Girarlzquierda();
private:
nto, yy;
TipoRumbo sentido;

 

 

 

 

 

A
+ Módulo: Tortuga?

* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros

A AA AAA
tinclude "Tortuga?.h"

include "Papel?.h"

 

 

 

void TipoTortuga::Poner( int x, int y, TipoRumbo rumbo ) £
a
w=Y
sentido = rumbo:

y

void TipoTortuga: :Avanzar(Q) (
switch (sentido) (
case Norte:
MarcarVertical( xx, yy );
ye;

 

MarcarVertical( xx, yy );
break;

case Este:
MarcarHorizontal( xx, yy );
xx;
break;

case Oeste:
xx

 
Módulos 427

Marcarllorizontal( xx, yy );

 

void TipoTortuga: :GirarDerecha() (
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */

3

void TipoTortuga: :GirarIzquierda() (
sentido = TipoRumbo( (int(sentido)+1) X 4 );
J

 

 

A RAR

* Interfaz de módulo: CurvaC2

+ Este módulo contiene la función que genera una Curva-C
AAA RRA ARA RANA

kApragna once
*include "Tortuga2.h”

void CurvaC( int orden, TipoTortuga 4 t );

 

 

ERRE ERAAA RARA RRA RR ARANA RRA ARENA RRA
* Módulo: CurvaC2

* Este módulo contiene la función que genera una Curva-C
AAA AAA AAA RARA RARA IR NAAA /

kinclude "CurvaC2.h"

void CurvaC( int orden, TipoTortuga 4 1.) £

£ (orden == 0) (
t.Avanzar();

) else if (orden > 0) (
CurvaC( orden - 1, t );
t.GirarDerecha();
CurvaC( orden — 1, t );
t.GirarTzquierda() ;

 

y
+

 

 

Con estos cambios, el programa principal y un ejemplo de su ejecución quedan
como sigue:
428 Fundamentos de programación

 

 

PA ona
* Programa: DibujarC2

* Descripción:

* Este programa lee como dato el orden de una curva C, y a

* — continuación la dibuja en forma de texto en pantalla

AAA AAA AAA
Hinclude <stdio.h>
kinclude "CurvaC2.
include "Tortuga2.h"
include "Papel2.h"

 

int mainQ £
int orden;
TipoTortuga tt;

print£( "Order
scanf( "Xd", Sorden );
PonerEnBlanco();

/* posición inicial de conveniencia */
tt.Poner( 8, 3, Este );

CurvaC( orden, tt );

Inprimir();

  

 

 

Orden: 6

 

 
Módulos 429

 

Ahora han desaparecido todas la referencias a la única variable que había del
tipo TipoPapel, tanto en su declaración como en su uso como argumento,
Además han quedado ocultas las definiciones de las constantes de tamaño del
papel, que son realmente detalles de implementación, lo cual puede resultar
ventajoso.

Por otra parte, las modificaciones en el código no han cambiado en modo
alguno el funcionamiento global del programa, que se sigue utilizando exactamento igual que antes. La modificación del código de un programa para
reorganizarlo sin cambiar su funcionalidad se denomina refactorización.

15.3.4 Reutilización de módulos

 

Los expertos en desarrollo de software suelen considerar que la descomposi
modular basada en abstracciones es una buena metodología para desarrollar
módulos con bastantes posibilidades de ser reutilizados en el futuro. Los elementos abstractos de una aplicación pueden ser de utilidad en otras apli
ciones del mismo campo de actividad, especialmente si se procura que dichos
olementos abstractos correspondan a clementos reales signi

rre en los ejemplos anteriores con la tortuga y el papel, que podrán reutilizarse
para componer otros dibajos con trazos rectos sobre una cuadrícula.

 

 

Los módulos que definen abstracciones relacionadas entre sí pueden agruparse

en una biblioteca o librería (eu inglós lébrary) que se pone a disposición de
aniones desarrollan aplicaciones en un campo determinado. Por ejemplo, se
pueden combinar módulos que operen con fechas, horas, calendarios de diferentes culturas, políticas de cambio de horario vorano/invierno, etc. Todos
estos módulos constituirán una biblioteca de utilidad para quienes desarrollen
aplicaciones que manejen datos de tiempo oficial.

 

 

 

Un caso extremo de reutilización se tiene en los módulos “estándar” que ncompañan a muchos lenguajes de programación. Estos módulos contienen elementos de uso general, que resultan útiles en un porcentaje muy elevado de
programas de todo tipo.

Como ejemplo de reutilización de Tortuga y Papel se presentan un par de
programas que dibujan otras figuras. Se incluye el listado de cada nmo y un
ejemplo de su ejecución.

El primer ejemplo dibuja una espiral cuadrada de un tamaño dado:

 
 

430, Fundamentos de programación

 

Tamaño: 15

 

 

PARE AARAA ARRAAARRAAA

* Programa: Espiral
* Descripción:

* Este programa dibuja una figura espiral cuadrada, del

* tamaño que se indique como dato

ARA AAA RARA
*include <stdio.h>

*include "Tortuga.h"

*include "Papel."

/%* Avanzar N pasos */
void AvanzarN( TipoTortuga £ t, TipoPapel £ p, int pasos ) 4
for (int k=1; k<=pasos; ke) £
t.Avanzar( p );
J
y

/** Programa principal */
int mainO) £
int lado;
TipoTortuga tt;
TipoPapel pp;

 
Módulos 431

 

print£( "Tamaño: " );
scan£( "%d", Elado );
pp.PonerEnBlanco() ;
tt.Poner( 0, O, Este );
for (int k=lado; ko=1; k--) 4
AvanzarK( tt, pp, k);
tt.GirarIzquierda() ;
AvanzarW( tt, pp, k);
+t.GirarTzquierda( ;
y
pp.Imprinir();

 

 

El segundo ejemplo dibuja una serie de cajas adosadas de los tamaños que se
indiquen. El final de los datos se indica mediante un tamaño cero.

 

Ancho y alto: 3 17
Ancho y alto: 94
Ancho y alto: 7 12
Ancho y alto: 7.7
Ancho y alto: 0.0

 

 

 
 

432 Fundamentos de programación

 

 

 

 

o]
* Programa: Cajas

* Descripción:

* Este programa dibuja una serie de cajas adosadas, de los

* tamaños que se indiquen como datos
ARRE AR AR AREA RARA NA /
*include <stdio.h>

Hinclude "
*include *

 

/%* Avanzar N pasos */
void AvanzarN( TipoTortuga £ t, TipoPapel £ p, int pasos ) £
for (int k-1; k<=pasos; k+s) (
t.Avanzar( p );
)

 

Y

/** Programa principal */
int main) €
int ancho, alto;
TipoTortuga tt;
TipoPapel pp;

P-PonertnBlanco();
tt.Poner( 0, 0, Este );
do (
print£( "Ancho y alt
ancho
alto =
scan£( "Xdkd", Sancho, £alto );
if (ancho > 0 8% alto > 0) 4
AvanzarN( tt, pp, ancho );
tt.GirarIzquierda();
AvanzarN( tt, pp, alto );
tt.GirarIzquierda();
AvanzarNC tt, pp, ancho );
tt.Girarlzquierda();
AvanzarN( tt, pp, alto );
tt GirarTzquierda();
AvanzarNC tt, pp, ancho );
,
) mhile (ancho > 0 68 alto > 0);
Pp. ImprimirO);

 

dy

 

y

 
Ejercicios sin resolver - TIT

A continuación se enuncian un tercer bloque de ejercicios sin resolver. Todos
ellos deben ser realizados en Ct utilizando la motodología explicada durante
el libro. Los enunciados de los ejercicios son los siguientes:

 

 

1. Realizar un programa que siraule un cajero automático do monedas. Los
tipos de monedas que dispone el cajero son de 10, 20 y 50 céntimos de
euro y 1 y 2euros. Inicialmente el cajero tiene 100 monedas de cada tipo,
que se van consumiendo para proporcionar las cantidades solicitadas. El
cajero debe obtener la cantidad solicitada con los tipos de moneda que
tenga en cada momento, tratando siempre de utilizar las monedas do
mayor valor.

2. Realizar una función que a partir de dos puntos del plano pasados como
argumentos, devuelva cierto cuando el primero esté mas alejado del origen de coordenadas que el segundo y falso en caso contrario. Utilizando
la función anterior realizar un programa que ordene en un vector hasta
10 puntos según su distancia al origen.

3. Realizar un programa que analice un texto terminado con un punto (.)
y extraiga del mismo las siguientes palabras:

+ Palabra más larga.

+ Palabra más corta.

+ Palabra con más vocales.

+ Palabra con más consonantes.

4. Realizar un tipo abstracto de datos (TAD) para manejar datos enteros
en forma de lista con los valores ordenados de menor a mayor y que
disponga de las siguientes operaciones básicas:

+ Iniciar la lista vacía

+ Comprobar si la lista está vacía.

+ Retirar el primer número de la lista.

+ Insertar un número en la lista ordenada.

+ Conocer el número de elementos de la lista.
Apéndice A

Sintaxis de C+

 

En este apéndice se recogen de forma precisa todas las reglas sintácticas que
definen el lenguaje Ct, ntilizando la notación BNF (Backus-Naur Form). En
las reglas so utilizan los siguientes metasímbolos:

 

13= Metasímbolo de definición. Indica que el elemento a su izquierda puedo
desarrollarse según ol esquema de la derecha.

| Metasímbolo de alternativa. Indica que puede elegirse uno y sólo uno de
los elementos separados por este motasímbolo.

L ) Metasímbolos de repetición. Indican que los elementos incluidos dentro
de ellos se pueden repetir cero o más veces.

 

[ ] Metasímbolos de opción. Indican que los elementos incluidos dentro de

ellos pueden ser utilizados o no.

( ) Metasímbolos de agrupación. Agrupan los elementos incluidos en su
interior.

Estos metasímbolos se escriben con el tipo de letra especial indicado para
distinguirlos de los paréntesis, corchetes, etc. que forman parte del lenguaje
C+/-. También se emplearán distintos estilos de letra para distinguir los
elementos simbólicos siguientes:

Elemento _no_ terminal: Este estilo so emplea para escribir el nombre de un
elemento gramatical que habrá de ser definido por alguna regla. Cualquior clemonto a la izquierda del metasímbolo ¿+= sorá no terminal y
aparecerá con este estilo,

   

Elemento_terminal: Este estilo se emplea para representar los elementos
que forman parte del lenguaje C£, es decir, que constituyen el texto de

 
 

436 Fundamentos de programación

un programa. Si aparecen en una regla deberán escribirse exactamente
como se indica.
La mayoría de las reglas ya han sido introducidas a lo largo del texto, Pese a
todo y con la idea de ofrecer una guía de referencia del lenguaje, se ha preferido
ronlizar una dofinición conjunta de todas las roglas del lenguaje desde la regla
más global hasta la más particular. Estas reglas, agrupadas por los principales
elementos del lenguaje, son las siguientes:

A.1 Unidad de compilación

1 Unidad _de_compilación 3
Programa_ principal | Módulo interfaz | Módulo implementación

 

2 Programa. principal 33% É Include YÁ Declaración global Y
int main() Bloque

3 Módulo interfaz

 

Pragma_onceÉ Include Y [ Declaración interfaz Y

4 elude HA Declaración global Y

 

4 Módulo_implementación:

A.2 Directivas de programa

 

Include
Hinclude <Nombre_módulo.h> | +include "Nombre_módulo.

 
 

6 Pragma_ once 33= fipragma once

A.3 Declaraciones globales

7 Declaración globa
Declaración _de_constante |
Declaración. de tipo |
[ static ] Declaración _de_variable |

[ static ] Subprograma

  
Sintaxis de C+ 437

A.4 Declaraciones de interfaz

 

8 Declaración interfaz
Declaración. de constante |
Declaración _de_tipo |
extern Lista_de_ variables |
Cabecera_subprograma ;

 

A.5 Constantes

 

9 Declaración de_constante 333 Constante_simple
| Constante_cadena | Constante_estructurada

10. Constante_simple 33= const Identificador_de_tipo
Identificador = Expresión ;

11 Constante_cadena 33= const char
Identificador [ ] = Cadena. de_caracteres ;

12 Constante estructurada 353 const Identificador_de_tipo
Identificador Dimensiones = Inicio_estructurado ;

 

 

 

13 Dimensiones 33= [ Expresión constante ] Í [ Expresión constante ] )
14 Inicio_estructurado 333 ( Lista_estructurada y

 

15 Lista estructurada 333 Lista de valores | Lista_de inicios

 

16 Lista_de_valore Expresión constante Í[ , Expresión constante )

 

    

17 Lista_de inicios 33= Inicio estructurado Í , Inicio_estructurado Y

A.6 Tipos

 

18 Declaración_de_tipo
"Tipo_sinónimo | Tipo enum | Tipo_array |
Tipo_struct | Tipo_unión | Tipo_puntero
19 Tipo_sinónimo 33= typedef Identificador_de_tipo Identificador ;
20. Tipo_enum 33= typedef enum Identificador
Y Lista_de_identificadores Y ;
21 Lista_de identificadores 33= IdentificadorÍ , Identificador Y
22 Tipo_array *3= typedef Identificador. de_tipo
Identificador Dimensiones ;

 

 

 

 
 

438 Fundamentos de programación

 

 

23 Tipo_struct
1 Lista_de

24 Tipo_unión *

typedef struct Identificador
items [ private: Lista_de items ]) 5

   
 

typedef union Identificador £ Lista_de_campos Y ;
typedef Identificador_de_tipo * Identificador ;
Ttem ; [ lem; Y

Campo ; É Campo ; Y

 

25 Tipo. puntero

26 Lista_de_items 3

 

 

27 Lista_de_campos

 

28 ltem*3= Campo | Cabecera_subprogruma

 

= Campos_igual_tipo | Campo_puntero | Campo_array
Identificador _de_tipo Lista_de_identificadores
Identificador_de_tipo * Identificador

Identificador. de_tipo Identificador Dimensiones

29 Campo
30 Campos igual_tipo

 

31 Campo_puntero

  
 

32 Campo_array $

A.7 Variables

33. Declaración de variable
Variable_simple | Variable_estructurada | Lista_de_variables
34 Variable_simple
Identificador. de l:
35 Variable_estructurada
Identificador_de_tipo Identificador [ = Inicio_estructurado ] ;
36 Lista de variables

Identificador_de_tipo Lista_de identificadores ;

      

 

   

 

ipo Identificador [ = Expre

   

A.8 Subprogramas
37 Cabecera_subprograma 33= Cabecera_función | Cabecera_procedimiento
38 Cabecera función 332 Identificador_de tipo

[ Jdentificador :: ] Identificador ( Lista_de argumentos )
39 Cabecera procedimiento 33= void

[ Zdentificador :: ] Identificador ( Lista_de argumentos )

 

  

 

 

40 Lista de argumentos 33= Argumento Á , Argumento )

41 Argumento onst Identificador_de_tipo Identificador [ 1.1] |
Identificador_de_tipo [ 4. ] Identificador [ 1 1]
42 Subprograma

 

 

Cabecera_subprograma Bloque
Sintaxis de C+ 439
A.9 Bloque de código

43 Bloque ++= ( Secuencia_de

44. Secuencia _de_declaracione:

 

leclaraciones Secuencia _de sentencias Y

 

É Declaración_de_bloque Y
= ([ Sentencia Y

 

45 Secuencia_de_sentencias

A.10 Declaraciones de bloque

46 Declaración _de_bloque 3
Declaración_de_ constante |
Declaración de_tipo |
Declaración _de_variable

 

 

A.11 Sentencias ejecutables

 

47 Sentencia
Asignación | Incremento | Decremento |
1f_else | Switch |
While | Do_white |
For_creciente | For_creciente_menor | For_decreciente |
Llamada_a_procedimiento |
Continue | Return |
Delete |
Throw | Try |
Sentencia_nula |
£ Secuencia_ de sentencias Y

 

48 Asignación 332 Identificador_gencral = Expresión ;
= Identificador_general ++ ;

Identificador_general —— ;

   
 
 
 

49 Incremento
50 Decremento

ia de sentencias )
de_sentencias 3 )

 

52 switch ( Expresión ) Y Lista_de_casos Y
53 Lista_de_casos 353
Caso Í Caso ) [ default : Secuencia_de_sentencias ]
 

440 Fundamentos de programación

 

ista_de_ opciones Secuencia_de_sentencias break ;

case Opción : Í case Opción : Y

 

Expresión constante

 
 

while ( Expresión ) £ Secuencia_ de. sentencias

 

58 Do_while 33= do £ Secuencia_de_sentencias ) while ( Expresión ) ;
59 For_creciente 33= for (int Identificador = Expresión ;
Identificador <= Expresión ; Identificador ++ )
1 Secuencia_de_sentencias y
60. For_creciente menor vor (int Identificador = Expresión ;
Identificador < Expresión ; Identificador ++ )
1 Secuencia_de_sentencias Y
61 For_decreciente 333 for (int Identificador = Expresión ;
Identificador >= Expresión ; Identificador -- )
1 Secuencia de sentencias Y
62 Llamada_a procedimiento 3
Identificador _general ( Lista_de_expresiones ) ;

 
 

 

 

  

    

 

63. Continue 33= continue ;

64 return [ Expresión ] ;
65 delete Identificador ;
66 throw Expresión ;

 

67 Try 33= try [ Secuencia_de_sentencias Y
[ catch ( Identificador_de_tipo Identificador )
í Secuencia_de_sentencias ) ]

 

68 Sentencia_nula

 

A.12 Expresiones
69 Lista_de_ezpresiones Expresión Í , Expresión Y ]
70 Expresión 33= Expresión ORÁ Operador _OR Expresión OR Y
71 Expresión OR 33= Expresión AND

£ Operador _AND Expresión _AND Y
72 Expresión AND 332 Expresión_igualdad

[ Operador _igualdad Expresión_igualdad ]
73. Expresión_igualdad 33= Expresión_numérica

[ Operador_comparación Expresión numérica ]

 

 

  

 

 
Sintaxis de C+ E

 

 

Término Í Operador_sumador Término Y
= FactorÍ Operado:

74. Expresión numérica

 

75 Término

 

multiplicador Factor Y

76. Factor 33= + Factor | - Factor | ! Factor | * Factor | 8: Factor |
Factor_cualificado

 

 

77. Factor_cualificado 333 Elemento |
Factor cualificado . Elemento |

Factor cualificado [ Expresión ] |
Factor_cualificado > Elemento

78. Operador_OR
79 Operador _AND33= 88

80 Operador_igualdad 35=

 

  
 

>|
82 Operador sumador 333 + | 
83 Operador_multiplicador 333: * | /|%

 

8l Operador comparación

 

 

A.13 Elementos básicos

 

84 Elemento 3
Valor_entero | Valor_real | Carácter | Cadeno_de_ caracteres |
Identificador | new Identificador |
Identificador ( Lista_de_expresiones ) |
Identificador_de- tipo ( Expresión ) |
(Expresión )

 

 

[+ | -] secuencia _dígit
86 Secuencia dígitos 33= Dígito Í Dígito Y
sr Dígtos:=o|1|213 41516171819
88 Valor_real
89
90 Identificador general 353 [ + ] Identificador

L . Identificador | [ Expresión 1 | > Identificador Y

91 Identificador_de_ tipo 53=
int | char | £1oat | boo1 | Zdentificador

 

85 Valor_entero

 

 

Valor_entero . [ Secuencia_dígitos ] [ Escala ]

  

cala 33= E Valor_entero

 
442 Fundamentos de programación

 

 

92 Identificador 33% Letra É Letra | Guión | Dígito Y

93 Letra
Hada daa
olrlolrIsIriufvIwIxfwIz
alblclalelrlalnlslilxfxPn
nlololalrisIilulvlwIxIy hz

94 Guión e
95 Cadena_de caracteres +

96 Carácter

 

 

 

 

 

v,..caracteres normales o lescapes...”

 

“carácter normal o Jescape"

A.14 Índice de reglas BNF

Argumento, 41
Asignación, 48

Bloque, 43
Cabecera_función, 38
Cabecera_procedimiento, 39
Cabecera_subprograma, 37
Cadena de caracteres, 95
Campo, 29
Campo_array, 32
Campo puntero, 31
Campos _igual_tipo, 30
Carácter, 96

Caso, 54
Constante_cadena, 11

 

 

Constante tructurada, 12
Constante simple, 10
Continue, 63

Declaración _de_bloque, 46

 

Declaración_de_constante, 9
Declaración_de_tipo, 18
Declaración_de_variable, 33
Declaración global, 7
Declaración interfaz, 8
Decremento, 50

Delete, 65

Dimensiones, 13

 

 
Sintaxis de (+. 443

 

Do_uhile, 58

Dígito, 87

Elemento, 84

Escala, 89

Expresión, TO
Expresión AND, 72
Etpresión OR, TL
Expresión igualdad, 73
Expresión numérica, 74
Factor, 76
Factor_cualificado, 77
For_creciente, 59
For_creciente_menor, 60
For_decreciente, 61
Guión, 94

Identificador, 92
Identificador_de_tipo, 91
Identificador general, 90
If_else, 51

Include, 5

Incremento, 49

Inicio_ estructurado, 14
Hem, 28

Letra, 93

Lista _de_argumentos, 40
Lista_de campos, 27
Lista_de casos, 53
Lista_de expresiones, 69
Lista_de_identificadores, 21
Lista_de inicios, 17
Lista _de_items, 26
Lista_de opciones, 5!
Lista de valores, 16
Lista_de_variables, 36
Lista estructurada, 15
Llamada a procedimiento, 62
Módulo_implementación, 4
Módulo_interfaz, 3
Opción, 56
Operador_AND, 79

 

 

 

 

 

 
 

444 Fundamentos de programación

 

Operador OR, 78
Operador comparación, 8
Operador_igualdad, 80
Operador_multiplicador, 83
Operador _sumador, 82
Pragma_once, 6
Programa_principal, 2
Return, 64
cia_de_declaraciones, 44
cia_de_sentencias, 45
cia_dígitos, 86
Sentencia, AT
Sentencia_rula, 68
Subprograma, — 42

Suiteh 52

Throw, 66

Tipo_arruy, 22
Tipo_enum, 20
Tipo_puntero, 25
Tipo_sinónimo, 19
Tipo_struct, 23

Tipo unión, 24

Try, 67

Término, 75
Unidad_de_compilación, 1
Valor_entero, 85
Valor_real, 88

Variable. estructurada, 35
Variable_simple, 34
While, 57

   
 
Apéndice B

Manual de Estilo

Esto apóndice constituyo ol Manual de Estilo básico para la realización de
programas en G£. El objetivo de un manual de estilo es recopilar un conjunto
de buenas prácticas de programación para establecer una forma sistemática en
la olaboración de todos los programas. A lo largo del libro se han presentado
algunas de las normas de programación y en este apéndice se han recopilado
para facilitar la elaboración de los programas con una mayor calidad, facilitar
su mantenimiento y evitar ambigñiedades.

 

Hay que tener en cuenta que en cualquier desarrollo de software pueden intervenir decenas o incluso centenares de programadores y es absolutamente
necesario disponer de un manual de estilo para que todos los que participan
en el proyecto tengan un estilo de programación único, uniforme y asumible
por todos. El estilo debe ser fruto de la experiencia en el desarrollo de proyectos anteriores y para que su empleo sea efectivo y generalizado es necesario
disponer de las herramientas adecuadas para verificar que todos los programas
siguen el estilo establecido. Así, una norma se considera Obligatoria cuando
se debe cumplir siempre y además se dispone de una adecuada herramienta
de verificación do su cumplimiento. Una norma es Recomendable cuando es
aconseja su utilización pero la verificación sistemática no es posible en todos
los casos.

Como caso especial, se han incluido como reglas de estilo algunas que son
realmente restricciones de Ch respecto a C++, y que obviamente no son comprobadas por el compilador de C++ usado para compilar los programas en
Cz.

En este apéndice se han agrupado las normas en cinco grandes apartados que
se describen a continuación.

 

 

 
 

446 Fundamentos de programación

 

B.1 Aspectos generales

En este apartado se agrupan las normas que se deben aplicar en cualquier
punto de un programa con carácter general.

B.1.1 Sintaxis

+ Obligatoria: Cualquier programa debe ajustarse estrictamente a la sintaxis de Ck que se detalla en el apéndice A.

+ Obligatoria: En cualquier bloque de programa todas las declaraciones
se deben agrupar en la parte declarativa que siempre precederá a la parte
ejecutiva compuesta por una secuencia de sentencias. Por tanto, munca.
se pueden mezelar declaraciones y sentencias ejecutables.

B.1.2 Encolumnado

+ Obligatoria: Siempre se debe utilizar el mismo indentado en el encolumnado de todos los programas de un mismo proyecto.

+ Obligatoria: El indentado máximo será de 4 espa
mínimo de 2 espacios en blanco.

+ Recomendable: Es aconsejable utilizar un indentado de 2 espacios en
blanco.

 

en blanco y el

B.1.3 Comentarios

+ Obligatoria: El programa deberá tener al menos un comentario de
cabecera de programa que incluya el nombre del programa y del antor,
una breve descripción de lo que hace y la fecha de su última modificación.
NOTA: En la mayoría de los ejemplos del libro no se incluye esta
cabecera por la limitación de espacio y porque casi siempre resultaría
redundante ya que la descripción se detalla en las explicaciones del texto.

+ Obligatoria: Se utilizará un comentario de cabecera de socción para documentar cada una de las partes importantes dol programa y separarlas
convenientemente.

+ Recomendable: Es aconsejable utilizar comentarios-orden y comentarios al margen siempre que so requiera cualquier aclaración adicional
sobre los refinamientos empleados o el significado de algún elemento del
programa.

+ Obligatoria: Las sentencias relativas a un comentario-orden se agruparán mediante llaves £. ...) para realizar un indentado con las sentencias
del comontario-orden agrupadas.

 
Manual de Estilo 447

 

B.1,4 Identificadores

+ Obligatoria: Los identificadores deben scr nombres que reflejen su utilidad sin que sca necesario ningún comentario adicional sobre su sigui
cado.

+ Obligatoria: Nunca so utilizarán identificadores formados sólo por letras mayúsculas (salvo que se trate de siglas u otra abreviatura de uso
común).

+ Obligatoria: Los identificadores compuestos realizados por concatenación de palabras se realizarán intercalando una letra mayúscula al
comenzar la nueva palabra o bien separando las palabras por el guión
bajo ().

+ Obligatoria: Los identificadores de un tipo de dato serán siempre identificadores compuestos que comenzarán con el prefijo Tipo.

+ Recomendable: Es aconsejable que los identificadores de constante y
subprograma comiencen por una letra mayúscula.

+ Recomendable: Es aconsejable que los identificadores de variable comiencen por una letra minúscula.

+ Recomendable: Es aconsejable que los identificadores de funciones
scan nombres (del valor resultante).

+ Recomendable: Es aconsejable que los identificadores de procedimientos sean verbos o nombres de acciones

     

 

 

 

B.2 Declaraciones

+ Obligatoria: Cuando las doclaraciones de un bloque de programa no
superen el tamaño do una página, el orden de las declaraciones será
siempre: Constantes, Tipos, Variables y finalmente Subprogramas.

+ Recomendable: Cuando las declaraciones de un bloque de programa
tengan cierta complejidad y la aplicación estricta de la regla anterior
pueda disminuir la claridad, es aconsejable agrupar las declaraciones por
aquellos olementos significativos del programa que ostón relacionadas entre sí. En este caso, aunque no existe un orden riguroso para declarar
constantes, variables, tipos y subprogramas sí que es aconsejable que las
declaraciones de un mismo elemento conserven entre sí el orden establecido en la regla anterior. Como se ha visto en el tema 14, los tipos
abstractos de datos son una forma adecuada adecuada de agrupar todas
las declaraciones relativas a un elemento significativo del programa.

 

 
y 448 Fundamentos de programación

B.2.1 Constantes

+ Recomendable: Es aconsejable agrupar todas las declaraciones de las
constantes globales de un programa en un punto único para que Su parametrización resulte clara y evidente.

+ Recomendable: Es aconsejable no utilizar directamente valores constantes numéricos o literales en las sentencias ejecutables de un programa.
(salvo casos triviales). Resulta preferible dofinirlos como constantes con
nombre.

  

B.2.2 Tipos de datos

+ Obligatoria: Todos los nuevos tipos de datos del programa se deben
definir con un typedef. No se permite la existencia de tipos anónimos.

+ Obligatoria: La declaración de un nuevo tipo sinónimo o puntero se
realizará siempre en una sola línea de código.

B.2.2.1 Formato para tipo enumerado

+ Recomendable: Siempre que sea posible es aconsejable que la declaración de un tipo enumerado se realice en una única línea de programa
utilizando el siguiente formato:

[typedef enun TipoNuevo (Valor, Valor, . . . , Valor)

 

+ Obligatoria: Cuando el número de elementos del tipo enumerado sea
amplio o en general resulte aconsejable utilizar más de una línca de
programa en la declaración, el formato utilizado sora el siguien
typedef enum TipoNuevo [

Valor, Valor, . . . . . Valor,
Valor, Valor, . . . . . Valor,

 

 

Valor, Valor, . . . . . Valor

B.2.2.2. Formato para tipo formación

+ Obligatoria: La declaración de un tipo formación se realizará siempre
en una única línea de programa utilizando el siguiente formato:

| typedef TipoElemento TipoNuevo [Dimension] [Dimension]...
 

Manual de Estilo 449

 

+ Recomendable: Es aconsejable que el valor de cada Dimension que
fija el tamaño de la formación se declarare previamente como constante
con nombre.

B.2.2.8. Formato para tipo registro (struct)

+ Obligatoria: La declaración de un tipo registro (struct) nunca se realizará en una única línea de programa. El formato utilizado sera el
siguiente:
typedef struct TipoNuevo [

TipoCampo NombreCampo;
TipoApuntado * NombreCampo;
TipoCampo NombreCampo;

,

+ Obligatoria: Todos los tipos TipoCampo son identificadores de tipo que
tienen que haber sido declarados previamente.

+ Obligatoria: Cuando un campo es de tipo puntero (*), el tipo de dato
al que apunta TipoApuntado también tiene que haber sido declarado
previamente o bien ser el propio nuevo tipo TipoNuevo que se está defi
niendo. Los campos de tipo puntero son el único caso de tipo anónimo
permitido.

 

.4 Formato para tipo registro variante (union)

+ Obligatoria: La declaración de un tipo registro variante (union) nunca
se realizará en una única línea de programa. El formato utilizado sera
el siguiente:
typedef union TipoNuevo [

TipoCampo NombreCampo;
TipoApuntado * NombreCampo;
TipoCampo NombreCampo;

,
+ Obligatoria: Todos los tipos TipoCampo son identificadores de tipo que
tienen que haber sido declarados previamente.

+ Obligatoria: Cuando un campo es de tipo puntero (*), el tipo de dato
al que apunta TipoApuntado también tiene que haber sido declarado
450, Fundamentos de programación

 

previamente o bien ser el propio nuevo tipo TipoNuevo que se está definiendo. Los campos de tipo puntero son el único caso de tipo anónimo
permitido.

B.2.3 Variables

+ Obligatoria: En la declaración de variables sólo se puede utilizar un
identificador de tipo válido predefinido o declarado previamente. Dicho
de otra manera no se pueden declarar variables de tipo anónimo.

+ Obligatoria: Cuando se inicializa una variable sólo está permitida la
declaración de esa variable de manera individual. Por tanto, no está
permitido realizar inicializaciones de ninguna variable cuando se declaran
como una lista de variables del mismo tipo.

+ Obligatoria: Cuando se realiza la asignación de un resultado de tipo
distiuto al tipo de la variable es obligatorio realizar siempre nna conversión explícita del resultado al tipo de la variable,

+ Recomendable: Es aconsejable realizar la inicialización de la variablo
en la misma declaración.

   

 

 

 

B.2.4 Subprogramas

+ Recomendable: Dentro del bloque de un subprograma no se deben
realizar ninguna asignación a un argumento pasado por valor. Cualquier
asignación a un argumento formal pasado por valor sólo tiene efecto
dentro del bloque del subprograma y no se transmite al argumento real
después de finalizar la ejecución del subprograma por lo que resulta
confuso y se debe evitar.

+ Recomendable: Salvo que sea imprescindible no es recomendable utilizar redefinición de elementos.

+ Recomendable: No se debe utilizar doble referencia salvo que el subprograma se diseñe pensando en esta posibilidad.

+ Obligatoria: La declaración de la cabecera de un subprograma se realizará en una sola línoa siempre que lo permitan el número de argumentos
y la longitud de los identificadores y además no se requiera ningún comentario adicional para explicar el significado de cada argumento. En
este caso la cabecera se formateará como se indica en los Siguientes apartados:

Función

TipoResultado NombreFuncion (Lista de argumentos) £
Bloque de la función
Manual de Estilo 451

 

B.2.

pb

Procedimiento

void NombreProcemiento (Lista de argumentos) £
Bloque del procedimiento

Recomendable: Cuando la cabecera resulte poco clara en una única
línea por el excesivo número de argumentos, la necesidad de explicar
el significado de cada argumento o cualquier otro motivo, la cabecera
se formateará con un solo argumento por línea según se indica en los
siguientes apartados:

Función

'TipoResultado NombreFuncion (
TipoArgunento NombreArgumento, /* paso por valor */
TipoArgumento £ NombreArgunento, — /* paso por referencia */
const TipoArgunento NombreArgumento, /* vector por valor */
TipoArgumento NombreArgumento, /* vector por refer. */

1
Bloque de la función

7

Procedimiento

¡void NombreProcemiento (
TipoArgunento NombreArgumento, /* paso por valor */
TipoArgunento £ NombreArgunento, — /* paso por referencia */
const TipoArgumento NombreArgunento, /* vector por valor */
TipoArgunento NombreArgunento, /* vector por refer, */

1

Bloque del procedimiento
3

5 Tipos abstractos de datos

Obligatoria: Un tipo abstracto de dato siempre se declarará mediante
un tipo registro (struct) con funciones y/o procedimientos encapsulados
dentro del struct. El formato de declaración será el siguiente:

typedef struct TipoNuevo (
TipoCampo NombreCampo;

 

 
452, Fundamentos de programación

 

TipoCampo * NombreCampo;
void NombreProcedimiento (Argumentos);
TipoResultado NombreFuncion (Argumentos);

private:
TipoCampo NombreCampo;
TipoCampo * NombreCampo;
void NombreProcedimiento (Argumentos);
TipoResultado NombreFuncion (Argumentos);

+

+ Obligatoria: En primor lugar se agruparán todos los elementos publi
cos. A continuación se declararán los elementos privados precedidos de
la palabra clave private:

+ Obligatoria: La declaración de los campos del tipo abstracto de datos
se realizará de la misma forma que cualquier otro registro.

+ Obligatoria: Para la declaración de las funciones y/o procedimientos
se utilizarán las mismas normas de los subprogramas.

  

B.3 Sentencias

+ Recomendable: Para visualizar la separación entre las declaraciones y
el comienzo de las sentencias del programa es aconsejablo dejar al monos
una línea en blanco.

+ Recomendable: Es aconsejable que en una misma línea de programa
sólo se escriba una única sentencia acabada en punto y coma.

+ Obligatoria: El formato de las sentencias cuya sintaxis se define en función de cualquier sentencia del lenguaje de una manera recursiva nunca.
se puede escribir en una única línea de programa. Más concretamente,
el formato que se debe utilizar dependiendo del tipo de sentencia es el
siguiente;

Selección IF

if (Condicion) £
Sentencias

) else if (Condicion) (
Sentencias

) else if (Condicion) (

 

  

 

 
Manual de Estilo 453

Y else £
Sentencias
,

Selección SWITCH

switch ( Expresion ) (
case valor:
Sentencias
break;
case valor:
case valor:
Sentencias
break;
default:
Sentencias

3

Bucle WHILE

mhile (Condicion) 4
Sentencias

3

Bucle DO

do £
Sentencias
) while (Condicion);

Bucle FOR incremental

for (int indice=ValorInicial; indice <= ValorFinal; indice++) (
Sentencias

3

Bucle FOR decremental

for (int indice-ValorInicial; indice >= ValorFinal: indice--) (
Sentencias

,

Bucle FOR incremental menor

for (int indice-ValorInicial; indice < ValorFinal; indice++) 4
Sentencias

 

2
454

Fundamentos de programación

Bloque TRY-CATCH para manejo de excepciones
my t
Sentencias
) catch (Tipo excepcion) (
Sentencias
J

Obligatoria: La variable indice de un bucle FOR puede ser utilizada
dentro del bucle pero nunca debe ser modificada, pues se perdería el
control automático de las repeticiones.

B.4 Expresiones

Obligatoria: Hay que tener en cuenta que en la evaluación de las es
presiones complejas el orden por defecto que se sigue viene fijado por
nivel de prioridad que tienen asignadas las distintas operaciones, Si no
se utilizan paréntesis, el orden de evaluación de los 7 niveles de prioridad
os el siguiente:

 

 

l. Operador Unari
2. Operador Multiplicativo:
3. Operador Aditivo:

4. Operador de Comparación:
5. Operadores de Igualdad:
6. Operador AND lógico:

7. Operador OR lógico:

 

Recomendable: Es aconsejable utilizar paréntesis adicionales para evitar cualquior ambigiiedad o dificultad de interpretación de la expresión,
Por ejemplo, cuando se combinen operadores de comparación y lógicos.
Recomendable: No es aconsejable utilizar paróntesis adicionales en
aquellas expresiones que, aprovechando los niveles de prioridad por defecto del lenguaje, estén ampliamente consensuadas y 1o planteen ninguna duda en su interpretación.

Obligatoria: No está permitido realizar expresiones aritméticas entr
operandos de distintos tipos. Siempre es obligatorio realizar una conversión explícita de tipos para precisar la operación aritmética que se
uioro realizar. Esta regla trata de evitar resultados inesperados provocados por las conversiones numéricas por defecto,

Obligatoria: No está permitida ninguna forma de comparación entre
elementos de distintos tipos.

 
Manual de Estilo 455

 

  

+ Obligatoria: Los operadores lógicos (88 y 11) s
con elementos de tipo SI(cierto)/NO(falso)

llo se pueden utilizar

  

 

B.5 Punteros

+ Obligatoria: Está prohibido utilizar los punteros como formaciones.

B.6 Módulos

+ Obligatoria: El fichero fuente del módulo principal debe tener el mismo
nombro que el programa ejecutable final, y la extensión .cpp.

+ Obligatoria: Por cada módulo no principal debe haber dos ficheros
fuente, con el mismo nombre que el nombre lógico del módulo y extensiones -h (interfaz) y .cpp (implementación)

+ Obligatoria: Cada fichero de interfaz de un módulo no principal
(modulo.h) debe comenzar con la directiva Hpragna once.

+ Obligatoria: Cada fichero de implementación de un módulo no
principal (modulo.cpp) debe incluir su propio fichero de interfaz
(tinclude "modulo.h") |

+ Obligatoria: Las constantes y tipos públicos de un módulo deben declararse solamente en el fichero de interfaz (modulo.h)

+ Obligatoria: Las variables y subprogramas públicos deben definirse
completamente en el fichero de implementación (modulo. cpp) y además
deben declararse en el fichero de interfaz (modulo.h).

+ Obligatoria: La declaración de cada variable pública en el fichero de
interfaz debe ir precedida de la palabra clave extern y no debe incluir
especificación de valor inicial.

+ Obligatoria: La declaración de cada subprograma público en el fichero de interfaz debe consistir solamente en su cabecera (tipo, nombre y
argumentos).

+ Obligatoria: La definición de cada variable global y subprograma no
públicos en cl fichero de implementación de un módulo no principal debe
ir precedida de la palabra clave static.

+ Recomendable; Conviene que los nombres de todos los elementos públicos de un módulo comiencen por un mismo prefijo corto y con valor
nomotécnico que identifique el módulo al que corresponden. Esto es importante en aplicaciones con muchos módulos o en el caso de librerías de
módulos reutilizables.

 

  

 
Apéndice C
Notación lógico-matemática

En este apéndice se describe la notación utilizada en las especificaciones formales que aparecen en algunos puntos de este libro para anotar y razonar
sobre la corrección de ciertos fragmentos de código. La notación empleada es
esencialmente la notación matemática habitual, con ciertas simplificaciones y
adaptaciones para hacerla más asequible a los lectores de este libro.

     

En lo que sigue, se usan los siguientes nombres para designar elementos genéricos del tipo que se indic:

 

a bc: valores numéricos

p q: valores lógicos

e: elemento genérico (valor de cualquier tipo)

1 5 kz índice (valor entero)

e v: colecciones (conjuntos o vectores)

P(z...); predicado (expresión lógica que depende de ciertos argumentos)

 

C.1 Operadores numéricos

Las operaciones aritméticas habituales:

 

 

 

 

 

 

 

a+] Suma a más b
[ a—b | Diferencia a menos b
ax B| Producto a multiplicado por b
aJb | Cociente a dividido por $
—a | Cambio de signo | menos a
Ye — | Sumatorio suma de los elementos de e

 

 

 

 

 
458

Fundamentos de programación

También se usarán funciones matemáticas de todo tipo que se supongan ya
definidas: máximo(x, y, ..), factorial al, etc.

C.2 Operadores de comparación

Igualdad y relación

de orden:

 

a>b | mayor

a es estrictamente mayor que b

 

ab | mayor o gual

“a es mayor o igual que b

 

a <b | menor

a es estrictamente menor que b.

 

a <b | menor o igual

“a es menor o igual que b

 

a=b | igual

aos igual a b

 

 

a Eb | diferente

 

a es distinto de b

 

C.3 Operadores lógicos

Operadores de la lógica booleana:

 

png

conjunción | p y además q

 

Pvg

disyunción | p o q 0 ambos

 

E

negación —| nop

 

 

 

p>4

 

implicación | si os cierto p también es cierto q

 

 

Formas abreviadas:

 

asb<cc.
asb<c<

 

 

 

 

az bAb<co Ac
conjunción | (y también para otras combinaciones
de operadores de comparación)

 

 

C.4 Colecciones

Se usa la misma notación para colecciones no ordenadas (conjuntos) y ordenadas (vectores, listas o secuencias). Cuando sea oportuno se usarán los
conjuntos como vectores, y viceversa.

 

[e ec, P(e))

comprensión

conjunto de elementos e
de un conjunto universal c,
que cumplen la propiedad P.

 

 

"elemento de vector

i-simo clemento de v (+)

 

 

cardinalle]

 

cardinal

 

 

"número de elementos de €

 
Notación lógico-matemática

 

 

Formas abreviad:

 

colección de valores correlativas.
desde ¡ hasta , ambos inclusive
(si ¡ es mayor que j, entonces
denota el conjunto vacío)

J rango o intervalo

 

da E conjunto de valores correlativos k
ber < rango o intervalo | desde ¿hasta ¿
i<k<j (incluidos o no los extremos)

 

colección de elementos de y que
cumplen la propiedad P
colección de elementos de 1 cuyos
índices cumplen la propiedad P
“colección de elementos de v cuyos
índices son los elementos de e

tofil, P(oti))) | comprensión

 

olP(i)] comprensión

 

sección

 

 

 

 

 

  

la expresión de un conjunto mediante (elemento, propiedad) se
pueden omitir si la expresión ya va entre paréntesis o corchetes.

 

C.5 Cuantificadores

Universal y existencial:

 

 

Z todos los elementos de e cumplen la
Veco Ple) | paratodo a p

a “al menos un elemento de e cumple la
reco eo roniedad P

 

 

 

 

 

C.6 Expresiones condicionales

Expresión con formas alternativas dependiendo de alguna condición:

 

si se cumple e se evalúa Á,
en otro caso se evalúa B

si se cumple cl se evalúa El,
si se cumple c2 se evalúa E2,
-... €n otro caso se evalúa El

e>A|B si, en otro caso

 

si, o bien si, ....

el > Ell2> E2)..]E
en otro caso

 

 

 

 

 

Es equivalente a las sentencias IF-THEN-ELSE, pero para expresiones en lugar
de acciones.

 
Bibliografía

ACERA GARCÍA, Miguel Ángel: C/C++. Edición revisada y actualizada
2010. Anaya Multimedia, 2009

BALCAZAR, José Luis: Programación metódica. McGraw-Hill, 2001.

CEBALLOS SIERRA, Francisco Javier: C/C++ Curso de programación. Tercera edición. Editorial RA-MA, 2007.

DEITEL, Harvey M. y DEITEL, Paul J.: Como programar (C++. Prentice
Hall Mexico, 2003.

GARCÍA-BERMEJO, José Rafacl: Programación estructurada en C. Pearson
Educacion. 2008

JOYANES AGUILAR, Luis: Programación en C++. Algoritmos, estructuras
de datos y objetos. Segunda edición. McGraw-Hill, 2006.

KERNIGHAN, Brian W. y RITCHIE, Dennis M.: El lenguaje de programación
€. Segunda edición. Prentice-Hall Iberoamericana. 1991.

 

 

 

PEÑA MARÍ, Ricardo: Diseño de programas. Formalismo y abstracción.
Tercera edición. Pearson Educacion, 2005.

STROUSTRUP, Bjarne: Bl lenguaje de programación C++. Addison-Wosley
Tberoamericana, 2009.
Índice analítico

abstracción, 20, 181, 220, 239, 385,
402
de datos, 417, 423
funcional, 184, 186, 392, 417
acceso directo, 352
acceso socuencial, 352
acción, 20, 98, 181
abstracta, 186
compuesta, 20
parametrizada, 159, 186
primitiva, 20
acoplamiento, 405
agregado, 238
argumentos
formales, 155, 157, 161
reales, 157, 161
arquitectura Von Neumann, 16
array, 228, 289
aserciones, 137
autodecremento, 62, 110, 111
autoincremento, 62, 110

bases de datos relacionales, 303
biblioteca, 429

bloque de código, 154, 155, 165, 182
bucle, 100

buenas prácticas, 23, 445

búsqueda por dicotomía, 326
búsqueda secuencial, 321

cabecera de función, 154, 155
cabecera de programa, 82
cabecera de sección, 82

cabecera de subprograma, 165, 182,
412
cadena de caracteres, 31, 235
campos, 240
caracteres de control, 31
casos generales, 167
casos minimales, 167
centinela, 315, 328
charsel, 37
claridad, 6
clase, 379
codepoínt, 37
cohesión, 405
comentario, 46
comentarios al margen, 83
comentarios-orden, 82
compilación segura, 403, 416
compilación separada, 403
compilador, 9
complejidad algorítmica, 143
componentes, 227
comportamiento asintótico, 146
computador, 4
condiciones, 98
constante, 27, 54
con nombre, 54, 89
literal, 54
local, 155
simbólica, 54
contorno, 328
corrección, 6, 135, 315
corrección parcial, 136

 

 
 

464

Fundamentos de programación

 

 

corrección total, 136
cuerpo de función, 155
cursor, 352

cálculo-A, 13

código de máquina, 7
cómputo, 3

 

dato, 27

dato abstracto, 392

dato complejo, 392

dato elemental, 392
declaración, 411

definición, 411

definición de tipos, 219
depuración, 135

desarrollo ascendente, 206
desarrollo descendente, 188, 392
descomposición modular, 404
diagramas de flujo, 98
diccionario, 303

directivas para el compilador, 45
discriminante, 298

doble referencia, 173

  

efectos secundarios, 169
eficiencia, 7, 142
eficiencia en tiempo, 143
ejecutar, 3
elección de nombres, 85
elomento

global, 165

local, 165
elementos privados, 408
elementos públicos, 407
encolumnado, 80
ensayo, 135
especificación, 182, 186, 402
especificación formal, 137, 183, 315
especificación informal, 183
esquema, 21, 76

de iteración, 121

de recorrido, 316

de selección, 120

secuencial, 76

típico de operación, 315
estructuras dinámicas, 352
evaluación en cortocircuito, 103
expresión

abstracta, 184

aritmética, 39, 103

condicional, 101

constante, 56

lógica, 102

parametrizada, 155, 185

fichero
de cabecera, 408
de implementación, 408
de interfaz, 408
fuente, 405
flujo de control, 98
formación, 227, 289, 299
fuerza bruta, 333
función, 154, 181
estándar, 158
predefinida, 157
pura, 169, 186

glifo, 37
gráficos de tortuga, 394

hardware, 4
herencia, 379

 

identificadores, 51
implementación, 182
ingeniería de software, 5, 23
inicializar, 60

inserción, 322

instrucción, 17

interfaz, 182, 402

intérprete, 10

invariante, 140, 141, 315, 317
Índice analítico.

iteración, 21, 99, 100, 109, 110, 299
juego de caracteres, 31

lenguaje
de máquina, 7
de programación, 8
ensamblador, 21
fuente, 9
objeto, 9
lenguaje C+, 25
librería, 429
librerías estándar, 158

Mmantisa, 30
Manual de Estilo, 23, 26, 41, 46, 52,
60, 63, 68, 80, 101, 105, 111,
163, 230, 241, 261, 373, 445

matrices, 288

orladas, 315, 330, 345
mayúsculas (en nombres), 88
metasímbolo, 27, 435
metodología de programación, 23
minúsculas (en nombres), 88
modelo abstracto de cómputo, 11
modelo de flujo de datos, 11
modelo de terminación, 213
máquina, 1

automática, 2

de programa almacenado, 4

no automática, 2

programable, 2

virtual, 1, 4, 10
método, 379
módulo, 206, 401

de librería, 42, 64

estándar, 162

principal, 407

notación BNF, 26, 435
notación UML, 422

 

465

a, 188, 392
compleja, 188, 392
de escritura, 42
de lectura, 64
terminal, 188, 392
operador, 33, 39
operador unario, 103
operando, 39
orden de evaluación, 104
ordenación por inserción directa, 324
orientada a objetos, 379
overflow, 123

palabras clave, 53
palabras reservadas, 53
parámetros del programa, 89
paso de argumentos

por referencia, 162, 163

por valor, 162, 163
plataforma, 33
postcondición, 137, 315, 316
precondición, 137, 315, 316
predicados, 226
preproceso, 414
problemas intratables, 146
procedimiento, 42, 154, 159

estándar, 162

puro, 187
procesador, 20
procesadores de lenguajes, 9
programa, 2

fuente, 9

objeto, 9

principal, 154, 407

robusto, 210
programación, 5

a la defensiva, 211

declarativa, 15
 

466

estructurada, 21, 76, 97, 255, 258,
261, 263

funcional, 11, 12

imperativa, 11, 17

lógica, 11, 15

orientada a objetos, 11
prototipo, 412
proyectos, 416
punteros, 354

realización, 182, 186, 402

recorrido de matrices, 318

recursividad, 167, 359, 393, 394, 452

red de operadores, 13

redefinición de elementos, 171, 172

reducción, 12

reescritura, 13

refactorización, 429

referencias, 354

refinamientos sucesivos, 76, 98, 101,
152

registro, 239

registros con variantes, 208

regla de producción, 27

relación, 303

representación (de un valor), 28

reutilización, 199

secuencia, 21, 98, 99, 106, 299, 352
secuencia de escape, 31
selección, 21, 99, 100, 106, 299
solección en cascada, 108
semántica, 182

sentencia, 17

sontencia de asignación, 61
seudofunciones, 158
shadowing, 171

signatura, 166

sintaxis, 182

software, 4

string, 31, 235

 

Fundamentos de programación

subproblema, 151
subprograma, 151

tabla, 303
tamaño del problema, 143
terminación, 214
tipado fuerto, 62
tipo, 28
abstracto de datos, 28, 206, 378,
392
anónimo, 230, 241
booleano, 226
char, 37
definido, 32
enumerado, 222
escalar, 226
estructurado, 227
float, 35
int,
ordinal, 222
predefinido, 32
sinónimo, 220
vector, 229
transparencia referencial, 169, 185
tratamiento de la información, 3
tupla, 227, 238, 239, 299

 

unidad de compilación, 405, 406
unión, 295, 299

valor, 27
carácter, 31
entero, 29
real, 30
variable, 17, 56
dinámica, 354
local, 155
variante, 137, 141, 295, 315-317
vectores abiertos, 286
visibilidad, 165
 

 

FUNDAMENTOS
DE
PROGRAMACIÓN

José A. Cerrada Somolinos
Manuel E. Collado Machuca

 

Editorial universitaria.
3 ¡e Ramón Areces
JOSÉ A. CERRADA SOMOLINOS
Catedrático de Lenguajes y Sistemas Informáticos (UNED)
MANUEL E. COLLADO MACHUCA
Catedrático de Lenguajes y Sistemas Informáticos (UPM)

FUNDAMENTOS
DE PROGRAMACIÓN

€ Ramón Areces

Q Editorial universitaria ES

 

 
 

14.

1.3

15

16

LR

 

Máquinas y programas 8
1.1.1 Máquinas programables
1.1.2. Concepto de cómputo
1.13 Concepto de computador
Programación e ingeniería de software .
1.2.1 Programaci
1.2.2 Objetivos de la programación . ....
Lenguajes de programación . . .
Compiladores e Intérpretes . . .
Modelos abstractos de cómputo
1.5.1 Modelo funcional E
1.5.2 Modelo de flujo de datos 3
1.5.3. Modelo de programación lógica . . .
1.5.4 Modelo imperativo .
Elementos de la programación iorecaliva..
1.6.1 Procesador, entorno, acciones . .... E
LES Aceros pricitias. Acciones compuesta sua e
1.6.8. Esquemas de acciones... +0... .... z
Evolución de la programación .............

1.7.1 Evolución comparativa Hardware/Software ...
1.7.2 Necesidad de metodología y buenas prácticas... ..

 

   

 

 

 

Lenguaje CE 4 pcia a
Notación BNF .......

Valores y ti

Representación de valores constantos
2.4.1 Valores numéricos enteros . ....
2.4.2. Valores numéricos reales...

 

 

 

 

 

 

  

ma

oa

 
viii Fundamentos de programación

 

A
2.4.4 Cadenas de caracteres (strings)
2.5 Tipos predefinidos . ....
2.5.1 El tipo entero (int)
2.5.2. El tipo real (float) . 2.5.3. El tipo carácter (char)
2.6 Expresiones aritméticas... ......-.
2.7 Operaciones de escritura simples . . .
2.7.1 El procedimiento printf
2.8 Estructura de un programa completo... .
2.8.1 Uso de comentarios
2.8.2 Descripción formal de la estructura de un programa
2.9 Ejemplos de programas
2.9.1 Escribir
Suma de múmeros consecutivos . . .
Área y volumen de un cilindro...

 

 

 

   

 

  

 
 
 

2.9.
B_Constantes y Variabled

3.1 Identificadores
3.2 El vocabulario de C£ ...
3.3 Constantes... ......
3.3.1 Concepto de constante .
3.3.2 Declaración de constantes con nombre .
o A
3.4.1 Concepto de variable... ooo...
3.4.2 Declaración de variables . . Sa
3.4.3. Uso de variables. Inicialización . . .
3.5 Sentencia de asignación .......-.
3.5.1 Sentencias de autoincremento y autodecremento .
3.52 Compatibilidad de tipos
3.6 Operaciones de lectura simple. .
3.6.1 El procodimiento scanf ......
6.2 Lectura interactiva... .- Sia
Estructura de un programa con declaraciones
3.8 Ejemplos de programas ...... 0.0...
3.8.1 Ejemplo: Conversión a horas, minutos y segundos
3.8.2 Ejemplo: Área y volumen de un cilindro
3.8.3 Ejemplo: Realización de un recibo... .

[4 Metodología de Desarrollo de Programas (1

4.1 La programación como resolución de problemas

 

  
 
  
  

 

 

 

    

 

 

 

 

 

 

32
33
35
37
Índice ix

 

    

 

4.2 Descomposición en subproblemas 74
4,3 Desarrollo por refinamientos sucesivos . . - ... 76
4.3.1 Desarrollo de un esquema secuencial . . 76
4.3.2 Ejemplo: Imprimir la silueta de una silla 79
4.4 Aspectos de estilo . 80
4.4.1 Encolumnado . 80

     

4.4.2 Comentarios. Documentac dl relata dde 8l

 

 

 

 

  

 

4.4.3 Elección de MOMbreS . o. oooooooo o 85
4.4.4. Uso de letras mayúsculas y minúsculas 88
4.4.5 Constantes con nombre . 89

4.5 Ejemplos de programas ass e YU
4.5.1 Ejemplo: Imprimir la figura de un árbol de navidad... 90
4.5.2 Ejemplo: Calcular el costo de las baldosas... ..... 92
4.5.3. Ejemplo: Calcular los días entre dos fechas ...... 93
oo 97
51 Programación estructurada ooo 0 ss
5.1.1 Representación de la estructura de un programa... . 98
A 5.1.3. Selección - 100
5.1.4 Iteración -.. 100
5.15 Estructuras anidadas 0 oo cocino ca: e 10L

58) Eeeredonescondicionsios 101
5.3 Estructuras básicas en CE... o ooooooooooco... 106

 

1 Ejemplo: Ordenar tres datos CESESAVADA 112

 

 

 
 

5.42 Ejemplo: Escribir un triángulo de dígitos ...... 114

3. Ejemplo: Elaboración de tickets y resúmenes ....... 116
LETEPES 119
6.1 Desarrollo con esquemas de selección e iteración . ....... 119
6.1.1 Esquema de selección .. ooo ooo oo ooo omo... 120

6.1.2 Esquema de iteración .. 0000. 121

6.2 Ejemplos de desarrollo con esquemas 5 se 108
6.2.1 Ejemplo: Imprimir el contorno de un triángulo ... . .. . 123

6.2.2 Ejemplo: Imprimir el triángulo de Floyd... ... - 199

6.3. Verificación de Programas. ooo - 135

 

 
 

 

   

    

  

    
 
 
 
 
   

 
 

 

  

   

   

 

x Fundamentos de programación
Notación lógico-matemática . . . 136
Corrección parcial y total... o... 136
Razonamiento sobre sentencias de asignación . 137
Razonamiento sobre el esquema de selección - 138
Razonamiento sobre el esquema de iteración: i
A RA 140

6.4 Eficiencia de programas. Complejidad 142
6.4.1 Medidas de eficiencia. . 142
6.4.2. Análisis de programas . . 143
6.4.3 Crecimiento asintótico . 145

Ejercicios sin resolver = 1... .. «o .oooo.ooo ccoo...» 147

“o. - 151

7.1 Concepto de subprograma 151

7.2 Funciones. . 154
7.2.1 Definición de funciones - 154
7.2.2. Uso de funciones ...... - 156
7.2.3 Funciones predefinidas .

7.2.4 Funciones estándar. . .
7.3 Procedimientos ......
7.3.1 Definición de procedimientos
7.3.2 Uso de procedimientos .
7.3.3. Procedimientos estándar
7.4 Paso de argumentos ........
7.4.1 Paso de argumentos por valor .
7.4.2. Paso de argumentos por referencia . . 163

7.5 Visibilidad. Estructura de bloques 165

7.6 Recursividad de subprogramas . . 167

7.7 Problemas en el uso de subprogramas . . . ¿GREAT
7.7.1 Uso de variables globales. Efectos secundarios 169
7.7.2. Redefinición de elementos . . . 171
7.7.3. Doble referencia .. . 173

7.8 Ejemplos de programas... 174

 

 

7.3.1 Ejemplo: Raíces de una ecuación de segundo grado
7.82 Ejemplo: Ordenar tres valores .. +... 0.0... .
7.83 Ejemplo: Perímetro de un triángulo ..... ¿0 078

  

. 181
181
8.11 Especificación y realización .......-.-. +05 40 182

 
Índice xi

 

  

 

  
 
    

 

8.1.2 Funciones. Argumentos .. o... 184
8.13. Acciones abstractas. Procedimientos . o... 186
8.2 Desarrollo usando abstracciones 188
8.2.1 Desarrollo descendente E 188
8.2.2. Ejemplo: Imprimir la figura do un árbol de navidad... . 189
8.2.8. Ejemplo: Imprimir una tabla de números primos . . . . . 196
82.4 199
8.2.5 Ejemplo: Tabular la serie de Fibonacci 200

8.2.6 Desarrollo para reutilización
8.2.7 Desarrollo ascendente... .
8.3 Programas rODUStoS -.... o... ...
8.3.1 Programación a la defensiva
8.3.2. Tratamiento de excepciones . .

 

PB Definición de tipog . . - - 219
9.1 Tipos definidos 219

 

 

 

9.2 Tipo enumerado .... j 221
9.2.1 Definición de tipos enumerados « « 209
9.2.2 Uso de tipos enumerados . 222

  

9.3 El tipo predefinido bool ....... 2-50 545 088
9.4 Tipos estructurados
9.5 Tipo formación y su necesidad . . o
DíA" Tinoivecióne.s sus eos Ems e 228
9.6.1 Declaración de vectores ....
9.6.2 Inicialización de un vector

 

 

 

9.6.3. Operaciones con elementos de vectores 231
9.6.4 Operaciones globales con vectores 232
9.6.5 Paso de argumentos de tipo vector . . . 233
9.7 Vector de caracteres: Cadena (string) . . 235
9.8 Tipo tupla y su necesidad 5 ¿33m 288
9:9 Tipo registro (struct) +00 ccoo. ...s pe . 239
9.9.1 Dofinición de Tegistros - o .oooococoo os. 240
9.9.2 Variables de tipo registro y su inicializaci 241
9.9.3. Uso de registros 241
9.10 Ejemplos de programas z 243
9.10.1 Ejemplo: Cálculo del día de la semana de una fecha... . 243

9.10.2 Frases palíndromas. .........o.....
9.10,3 Ejemplo: Cálculos con fracciones

o Ampliación de estructuras de control ..

10.1 Estructuras complementarias de iteración . .

 

 
xii Fundamentos de programación

10.1.1 Repetición: Sentencia DO . .
10.1.2 Sentencia CONTINUE

10.2 Estructuras complementarias de selección
10.2.1 Sentencia SWITCH

10.3 Equivalencia entre estructuras . 10.3.1 Selección por casos
10.3.2 Bucle con contador
10.3.3 Repetición

10.4 Ejemplos de programas
10.4.1 Ejemplo: Imprimir tickets de ia ea
10.4.2 Ejemplo: Gestión de tarjetas de embarque
10.4.3 Ejemplo: Calculadora 
 

 

 

  

 

 

  

   

Ejercicios sin resolver - IL ..... o... oonooooo... 281

[1 Estructuras de datos e e a
11.1 Argumentos de tipo vector abierto .
11.1.1 Ejemplo: Contar letras y dígitos ......
11.2 Formaciones anidadas. Matrices . . .
11.2.1 Declaración de matrices y uso de sus 5 elententos sá. 289.
11.22 Operaciones con matrices . .....
11.2.3 Ejemplo: Contrastar una imagen .
11.3 El esquema unión . .
11.3.1 El tipo union .
11.3.2 Registros con variantes LEE
11.4 Esquemas de datos y esquemas de acciones... o... o... 299
11,5 Estructuras combinadas . ..... 0... oo...
11.5.1 Formas de combinación . .

 

  

    

  
  

 

 

 

  

11,52 TAbliBo sur a es
11.5.3 Ejemplo: Gestión de tarjetas de embarque
12 Esquemas típicos de operación con formaciones ......s 315
12.1 Esquema de recorrido .......-. 316
12.1.1 Recorrido de matrices . . .
12.1.2 Recorrido no lineal... ..
12.2 Búsqueda secuencial
12.3 Inserción mor umomsprsrass
12.4 Ordenación por inserción directa .

12.5 Búsqueda por dicotomía ..... 0.0. <.....
12.6 Simplificación de las condiciones de contorno . ..........
12.6.1 Técnica del centinela... ooo coco 328
Índice xdii

 

12.6.2 Matrices orladas 330

   

 

 

12.7 Ejemplos de programas . . 333
12.7.1 Ejemplo: Sopa de letras - 333
12.7.2 Ejemplo: Imprimir fechas en orden . varios y suo DEN
12.7.3 Ejemplo: Recortar una imagon ......... 2 como ES

 

 

 

113 Punteros y variables dinámicad .........
13.1 Estructuras de datos no acotadas
13.2 La estructura secuencia . .
13.3 Variables dinámicas ....

13.3.1 Punteros Res
13.3.2 Uso de variables dintnicas 90% s ee
13.4 Realización de secuencias mediante Punteros AA - 358
13.4.1 Operaciones con secuencias enlazadas . a...» 360
13.4.2 Ejemplo: Leer números y escribirlos en pa o. - . 363

351
351
352
354
. 354
- 356

 

 

 

   
   

     

   

 

   

13.5 Punteros y paso de argumentos... . 366
13.5.1 Paso de punteros como argumentos Ana - 366
13.5.2 Paso de argumentos mediante punteros ...... - 367
13.5.3 Ejemplo: Leer números y escribirlos en orden . ... - 370

13.6 Punteros y vectores en C y C++ : 372
13.6.1 Nombres de vectores como punteros . - 373
13.6.2 Paso de vectores como punteros - 374

 

13.6.3 Matrices y vectores de punteros o... o... : 37

[4 Tipos abstractos de datog AA SEA ....... 377

14.1 Concepto de tipo abstracto de datos (TAD) - 377
14.2 Realización de tipos abstractos en Ch 379
14.21 Definición de tipos abstractos como tipos registro (struct)379
14222 Ocultación: 00. sus econ a PS + 385

 

 

 

  

 

 

 

 

 

 

 

 

 

14.2.3 Ejemplo: Imprimir fechas en orden - 386

14.3 Metodología basada en abstracciones . ooo... 0... 392
143.1 Desarrollo por refinamiento basado en abstracciones . . . 392

14.4 Ejemplo: Dibujar ua Curva-C - 395

5 Módulod ......... 401
15.1 Concepto de módulo 401
15:11 Especificación y realización 402

15.1.2 Compilación separada . - 403

15.1.3 Descomposición modular - 404

15.2 Módulos en C£ 405

 

15:21 Procesodecomplaión glmpla y 02 ego cts - - 406

 

 
xiv Fundamentos de programación

 

15.2.2 Módulo principal... .

15.23 Módulos no principales
15.2.4 Uso de módulos
15.2.5 Declaración y definición de elementos públicos ...... 411
15.2.6 Conflicto de nombres en el ámbito global
15.2.7 Unidades de compilación en Ct...

    

 

15.2.8 Compilación de programas modulares. Proyectos... . 415
15.3 Desarrollo modular basado en abstracciones .. +0... .0.010. 416
15.3.1 Implementación de abstracciones como módulos... .. 417

15.3.2 Dependencias entre ficheros. Directivas .
15.3.3 Datos encapsulados
15.3.4 Reutilización de módulos .....

  

Ejercicios sin resolver - ll .¿.....cosoocm.o.o...oo.o.. 433

lA Sintaxis de CE .]
A.1 Unidad de compilación
A.2 Directivas de programa
A.3 Declaraciones globales... .... +
A.4 Declaraciones de interfaz... A.5 Constantes . ...
A
A.7 Variables ....A.8 Subprogramas ..
A.9 Bloque de código en
A.10Declaraciones de bloque. ... . A.l1 Sentencias ejecutables . . ...
A.12Expresiones
A.13Elementos básicos .
A.14Índice de reglas BNP

[B_Manual de Estild ...
B.1 Aspectos generales .
B.1,1 Sintaxis - 0...

B.1.2 Encolumnado . . .
B.1.3 Comentarios
B.1.4 Identificadores . .
B.2 Declaraciones
B.2.1 Constantes .......-.

B.2.2 Tipos de datos . .
B.2.3 Variables

 

  

 

 
 
  
  
  
 
 
 
 
 
  
 
 
 
 
 
 
  
  

 

 
Índice xv

 

B.2.4 Subprogramas .. o... ...
B.2.5 Tipos abstractos de datos .. ...
B.3 Sentencias ... .
B.4 Expresiones
B.5 Punteros ....
B.6 Módulos

       

  

Notación lógi: temáti:
7.1 Operadores numéri
C.2 Operadores de mparición
C.3 Operadores lógicos .....
C.4 Colecciones . 305
C.5 Cuantificadores 4
C.6 Expresiones condicionales .

Bibliografía ...... RAI a rs RRA A 461

 

  

 

Índice analítico .

   
Prólogo

Objetivos

El objetivo fundamental do este libro es introducir de manera progrosiva y
sistemática una correcta metodología para la programación de computadores
Las materias que se cubren son las que se necesitan conocer en un curso de
primer nivel de programación. Además, a lo largo del libro se van introduciendo de forma progresiva las estructuras y herramientas necesarias en cada
momento y que están disponibles en cualquier lenguaje de programación de
propósito general. No se ha considerado adecuado presentar un lenguaje en
su totalidad dado que las estructuras no utilizadas quedan fuera del alcance
de este libro.

El contenido ha sido pensado como libro de texto para una asignatura de
Fundamentos de Programación del primer cuatrimestre del primer año de un
Grado en Informática o similares dentro del marco de la UNED. Por tanto, se
cuidan de manera especial los aspectos específicos de la enseñanza a distancia.
Se trata de introducir los conceptos de manera progresiva, poco a poco, de
manera que el alumno pueda ir avanzando a su ritmo. Cada concepto que se
introduce se acompaña de las técnicas necesarias para su inmediata aplicación
y ejemplos ilustrativos.

En este libro se utiliza como vehíenlo para la enseñanza de la programación
el lenguaje C+ (léase C-más-menos) que está constituido por un subconjunto
del vocabulario de los lenguajes C y C++. Por lo tanto, cualquier programa.
escrito en el lenguaje C£ se podrá editar, compilar y ejecutar en un entorno
de desarrollo para C/C++. Se considera muy importante usar un lenguaje
real para que el alumno acceda de manera natural e inmediata al computador,
Esto permite al alumno comprobar en la práctica que los ejemplos propuestos
funcionan.

Con la definición del lenguaje CE se ha buscado la creación de un lenguaje
que facilite la enseñanza de la programación y que también se pueda utilizar

 
xvii Fundamentos de programación

 

en el desarrollo de cualquier aplicación real. Las ventajas del lenguaje CH se
pueden concretar en las siguientes:

+ Es un lenguaje bien estructurado; que ha sido pensado para aplicar la
metodología de programación estructurada, en sentido amplio. Los lenguajes C/C++ son excesivamente complejos para un primer curso de
programación y en algunas ocasiones sus sentencias resultan complejas,
ambiguas y poco claras. En el lenguaje Ct no se incluyen todas las

sentencias de C/C++ y además se imponen ciertas restricciones metodológicas en las sentencias utilizadas.

+ El aprendizaje del lenguaje es relativamente sencillo dado que ha sido
diseñado para la enseñanza de programación.

+ Ci soporta la programación modular y tipos abstractos de datos: ambos paradigmas de programación se consideran muy importantes para
introducir al alumno en una buena metodología de diseño y desarrollo
de programas de cierta complejidad.

+ Las características antes mencionadas permiten que Ci se pueda utilizar
en cursos posteriores de programación. Por ejemplo, para presentar la
programación orientada a objetos se debería incorporar a C+ el concepto
de clase y las estructuras de programación que ya están disponible en
C++

 

En todo caso, el texto no se limita a enseñar un lenguaje, sino que trata que
el alumno adquiera desdo un principio una correcta metodología de programación, independiente del lenguaje utilizado. Así, se considera muy importante
que el alumno adquiera una buena capacidad general de expresarse de manera
formal, con independencia del lenguaje empleado. En todo momento se insiste
en las técnicas de desarrollo por refinamiento progresivo.

Por otro lado, los desarrollos de grandes aplicaciones nunca los realiza un único
programador. En este texto so consideran fundamental el empleo de buenas
prácticas de ingeniería de software aplicadas a la programación. Cualquier
empresa o equipo de desarrollo de software debe disponer antes del inicio de
cada desarrollo de un “Manual de Estilo” para lograr la adecuada claridad,
homogeneidad y mantenibilidad de los programas, El “Manual de Estilo” que
se propone en este texto recopila un conjunto de buenas prácticas de progra
mación que el alumno deberá seguir incluso para la realización de programas
sencillos.
 

Prólogo xix

 

¿A quién va dirigido el texto?

En principio, se trata de un texto pensado para una asignatura de Fundamentos de Programación del primer curso de un Grado en Informática o similares;
por tanto va dirigido a los alumnos de primer año de estas carreras.

Sin embargo, podrá ser usado como texto de introducción a la programación
por cualquier otra. persona interesada en este tema. Los requisitos que se
consideran necesarios para poder seguir adecuadamente el contenido del texto
son los siguientes:

+ Conocimientos generales de matemáticas, en especial de formalismos algebraicos.

+ Capacidad para seguir un razonamiento lógico.

+ Capacidad de organización.

+ Aptitud para expresarse formalmente (dominio del lenguaje).

Metodología

Para un correcto aprovechamiento del contenido del curso es imprescindible
que el alumno tenga acceso a un computador con el compilador de Ct. En el
Manual de Prácticas asociado a este libro se dan las pautas para que el alumno
pueda instalar y utilizar un entorno de programación configurado y adaptado
especialmente para verificar la sintaxis de CE y que inmediatamente procede
a compilar el programa con un compilador de C++. Además, el entorno
de programación dispone de una herramienta para formatcar el programa de
acuerdo con las recomendaciones del "manual de estilo” de este libro.

Conviene que el alumno compruebe en el entorno de programación el correcto
funcionamiento de algunos los ejemplos descritos en cada capítulo para someterlos a crítica. Esto le permitirá adquirir una capacidad de análisis previa a
las tareas de diseño de sus propios programas. A continuación convendrá que
el alumno realice los ejercicios propuestos también en el computador, y que
compruebe igualmente su funcionamiento. En general no existe una solución
única para un mismo problema. La solución debe ser examinada a posteriori para analizar además del correcto funcionamiento también los aspectos de
claridad y estilo.

 
Tema 1

Introducción

El objetivo de este tema es introducir los conceptos generales, y dar una panorámica de la programación que permita posteriormente situar en el contexto
adecuado las técnicas y motodologías que se expondrán en el resto del libro.

Especialmente importante es la presentación de diferentes modelos abstractos
de cómputo, para poner de manifiesto que la programación imperativa, aunque
sea la más extendida, no constituye la única manera de representar programas,
y que no hay que identificar el concepto de programa con el de secuencia de
órdenes

 

 

1.1 Máquinas y programas

Intuitivamente podemos asociar el concepto de máquina a un dispositivo o
instrumento físico capaz de realizar un cierto trabajo u operación. El concepto
puede extenderse incluyendo máquinas que, aunque no existan físicamente,
pueden concebirse y describirse con precisión y predecir su comportamiento.
Estas máquinas se denominan máquinas virtuales.

 

1.1.1 Máquinas programables

En general, las máquinas operan a lo largo del tiempo, por lo que el concepto de
máquina lleva asociado el de un proceso de funcionamiento en el cual diferentes
operaciones se van realizando sucesiva o simultáneamente. Desde el punto de
vista del control de su funcionamiento, podemos clasificar las máquinas en
diferentes tipos.

 
 

2 Fundamentos de programación

 

Las máquinas no automáticas, o de control manual, son gobernadas por un
operador o agente externo que desencadena unas determinadas operaciones en
cada momento. Por ejemplo, una máquina de escribir imprime las letras o
mueve el papel de acuerdo con las teclas pulsadas por el mecanógrafo.

Las máquinas automáticas actúan por sí solas, sin necesidad de operador, aunque pueden responder a estímulos externos. Por ejemplo, un ascensor automático gobierna por sí mismo los movimientos de subida y bajada incluyendo
cambios de velocidad, apertura y cierre de puertas, etc., de forma coordinada,
respondiendo a los estímulos de los botones de llamada o envío a un piso dado. |

El funcionamiento de una máquina automática puede depender de la forma
en que está construida, es decir, de los elementos que la componen y la manera en que están conectados entre sí. En este caso el comportamiento de la
máquina será fijo, en el sentido de que a unos determinados estímulos externos responderá siempre de la misma manera. Esto ocurre en el ejemplo del
Ascensor.

Otras máquinas automáticas se denominan programables , y sn comportamiento no es siempre el mismo. Una máquina programable (figura 1.1) se puede
concebir como una máquina basc, de comportamiento fijo, que se completa
con una parte modificable que describe el funcionamiento de la máquina base.
Esta parte modificable se denomina programa.

 

Programa
Programa
3 E

Máquina Base

 

Máquina Base
Componentes Máquina Completa
Figura 1.1 Componentes de una máquina programable.

Aunque habitualmente no se considere como tal, podemos analizar un reproductor de CD como una máquina programable, identificando el CD (reemplazable) con el programa. Incluso podemos establecer la siguiente serie de
ejemplos:

+ Piano: máquina manual de producir música.

+ Caja de música: máquina automática de producir música (fija).

+ Reproductor de CD: máquina programable de producir música (variable).
 

Introducción e

 

Dependiendo de cuál sea el programa que gobierne su funcionamiento, una
máquina programable responderá a los estímulos externos de una forma o
de otra. Una máquina programable se comporta, por tanto, como diferentes
máquinas particulares, en función del programa utilizado

Programa A Programa B

Máquina Base Máquina Base

  

Máquina A Máquina B

Figura 1.2 Una máquina programable puede comportarse como diferentes máquinas.

Cuando una máquina programable opera bajo control de un programa determinado, se dice que el programa se ejecuta en dicha máquina.

1.1.2 Concepto de cómputo

La palabra cómputo es sinónimo de cuenta o cálculo. Si consultamos un diccionario podemos encontrar una definición más elaborada:

Cómputo (del latín computum ). Determinación indirecta de una cantidad
mediante el cálculo de ciertos datos.

En esta definición se puede apreciar que un cómputo es una operación de
tratamiento de información. A partir de una información conocida se obtiene
otra mueva como resultado de unos cálculos. En informática y de una forma
general puede identificarse el concepto de cómputo con el de tratamiento de la
información.

Un cómputo puede expresarse de diferentes maneras. Por ejemplo, medianto
una fórmula o expresión matemática, tal como

34x5+8x7
Un cómputo se concibe también como un proceso a lo largo del cual se van
realizando operaciones o cálculos elementales hasta conseguir el resultado final.

En el ejemplo anterior se encuentra implícito dicho proceso. El resultado se
podría obtener mediante los siguientes cálculos elementales:

 
4 Fundamentos de programación

 

1. Producto de 34 por 5, obteniendo 170.
2. Producto de 8 por 7, obteniendo 56.
3. Suma de los resultados anteriores, obteniendo 226.

En la expresión matemática usada como ejemplo están implícitos estos cálenlos
elementales, así como el orden en que pueden ser realizados. Los cáleulos 19
y 2 podrían realizarse en cualquier orden, pero el cálenlo 32 ha de realizarse
necesariamente después de los otros dos.

1.1.3 Concepto de computador

La máquina programable por excelencia es el computador. Un computador se
define como una máquina programable para tratamiento de la información, es
decir, un computador es (¡obviamente!) una máquina para realizar cómputos.

Un programa de computador es, por tanto, una descripción de un cómputo. Al
mismo tiempo nos encontramos con que un programa es también una descripción del comportamiento de una máquina, y podemos así considerarlo como
una máquina virtual cuando convenga.

Un computador, como máquina programable que es, posee unos elementos
fijos (máquina base) y otros modificables (programa). De forma simplificada
podemos asociar los elementos fijos a los dispositivos físicos del computador,
que constituyen el hardware, y los elementos modificables a las representaciones
de los programas en sentido amplio, que constituyen el software.

Los computadores actuales corresponden a un tipo particular de máquinas
programables que se denominan máquinas de programa almacenado. En estas
máquinas la modificación del programa no implica un cambio de componentes
físicos de la máquina, sino que estas máquinas poseen una memoria en la cual
se puede almacenar información de cualquier tipo, debidamente codificada, y
esta información incluye tanto los datos con los que opera la máquina como
la representación codificada del programa. El programa es, por tanto, pura
información, no algo material.

La estructura general de un computador se puede representar como se muestra en la figura 1.3. La. memoria almacena datos y programas. Los dispositivos de entrada/salida permiten intercambiar información con el exterior, y
el procesador es el elemento de control, que realiza operaciones elementales
de tratamiento de la información interna, u operaciones de entrada o salida
de información al exterior, de acuerdo con los códigos del programa que están
almacenados en la memoria.
Introducción 5

 

 

 

Memoria

Procesador
Datos > ana > Resultados
de entrada Entrada/Salida de salida

Figura 1.3 Esquema general de un computador.

1.2 Programación e ingeniería de software

De las explicaciones anteriores se deduce que una máquina programable, y
en particular un computador, es totalmente inútil si no dispone del programa
adecuado. Para realizar un determinado tratamiento de información con ayuda
de un computador habrá sido necesario:

(a) Construir el computador (hardware).
(b) Tdear y desarrollar el programa (software).
(e) Ejecutar dicho programa en el computador.

Sólo la última fase (c) es habitualmente realizada por el usuario. Las dos
primeras corresponden a los profesionales de la informática: la fase (a) a los
fabricantes de hardware y la. (b) a los de software. En los siguientes apartados
se analiza la actividad de desarrollo de software.

 

1.2.1 Programación

La labor de desarrollar programas se denomina en general programación. En
realidad este término se suele reservar para designar las tareas de desarrollo
de programas en pequeña escala, es decir, realizadas por una sola persona. El
desarrollo de programas complejos, que son la mayoría de los usados actualmente, exige un equipo más o menos numeroso de personas que debe trabajar
de manera organizada. Las técnicas para desarrollo de software a gran escala
constituyen la ingeniería de software.

Programación e ingeniería de software no son disciplinas independientes, sino
complementarias. El desarrollo de software en gran escala consiste esenci
mento en descomponer el trabajo total de programación en partes independientes que pueden ser desarrolladas por miembros individuales del equipo.
La ingeniería de software se limita a añadir técnicas o estrategias organizativas a las técnicas básicas de programación. El trabajo en equipo es, en último
extremo, la suma de los trabajos roalizados por los individuos.

   

 
6 Fundamentos de programación

 

1.2.2 Objetivos de la programación

La ingeniería de software excede del ámbito de este libro. En él nos centraremos sólo en la labor de programación, correspondiente a la preparación de
programas medianos o pequeños, realizables por una sola persona. No obstante, las técnicas de programación han de establecerse con el objetivo de ser una
base adecuada para la ingeniería de software. Entre los objetivos particulares
de la programación podemos reconocer los siguiente

 

+ CORRECCIÓN: Es evidente que un programa debe realizar el tratamiento esperado, y no producir resultados erróneos. Esto tiene una
consecuencia inmediata que no siempre se considera evidente: antes de
desarrollar un programa debe especificarse con toda claridad cuál es el
funcionamiento esperado. Sin dicha especificación es inútil hablar de
funcionamiento correcto.

+ CLARIDAD: Prácticamente todos los programas han de ser modificados
después de haber sido desarrollados inicialmente. Por esta razón es fundamental que sus descripciones scan claras y fácilmente inteligibles por
otras personas distintas de su autor, o incluso por el mismo autor al cabo
de un cierto tiempo, cuando ya ha olvidado los detalles del programa.

+ EFICIENCIA: Una tarea de tratamiento de información puede ser programada de muy diferentes maneras sobre un computador determinado,
es decir, habrá muchos programas distintos que producirán los resultados deseados. Algunos de estos programas serán más eficientes que otros.
Los programas eficientes aprovecharán mejor los recursos disponibles y,
por tanto, su empleo será más económico en algún sentido.

  

Estos y otros objetivos resultan a veces contrapuestos. Quizá el ejemplo más
intuitivo sea la dualidad entre claridad y eficiencia. Para ser claros los programas han de ser sencillos, pero para aprovechar los recursos de manera eficiente
en muchos casos hay que introducir complicaciones que hacen el programa más
difícil de entender

 

Si se trata de establecer una importancia relativa entre los distintos objetivos,
habría que considerar como prioritaria la corrección. Piénsese, por ejemplo,
que un programa de contabilidad no es aceptable si no calcula correctamente
los saldos de las cuent:

 

A continuación debe perseguirse la claridad, que como ya se ha indicado es
necesaria para poder realizar modificaciones, o simplemente para poder certificar que el programa es correcto. En realidad el objetivo de claridad va ligado
al de corrección. Es prácticamente imposible asegurar que un programa es
correcto si no puede ser entendido claramente por la persona que lo examina.
Introducción dd

 

Tal como se ha dicho antes, la claridad facilita la tarea de realizar modificaciones cuando las necesidades así lo exijan. Puede afirmarse que esto ocurre
siempre con todos los programas que tienen un cierto interés.

Finalmente ha de atenderse a la eficiencia. Este objetivo, aunque importante,
sólo suele ser decisivo en determinados casos. En muchas situaciones el aumento de capacidad de los computadores a medida que avanza la tecnología va
permitiendo utilizar de manera aceptable, desde el punto de vista económico,
programas relativamente menos eficientes.

1.3 Lenguajes de programación

Ya se ha explicado que un computador funciona bajo control de un programa
que ha de estar almacenado en la unidad de memoria. El programa contiene
una descripción codificada del comportamiento deseado del computador.

Cada modelo de computador podrá utilizar una forma particular de codificación de programas, que no coincidirá con la de otros modelos. La forma de
codificar programas de una máquina en particular se dice que es su código de
máquina o lenguaje de máquina. La palabra “lenguaje” utilizada habitualmente en el vocabulario informático en español es, en realidad, una transcripción
directa del término inglés “language”, cuyo significado correcto es “idioma”,

Un programa codificado en el lenguaje de un modelo de máquina (figura 1.4)
no podrá ser ejecutado, en general, en otro distinto. Si queremos que un
programa funcione en diferentes máquinas tendremos que preparar versiones
particulares en el lenguaje de máquina de cada una de ellas. Evidentemente
con ello se multiplica el costo de desarrollo si cada versión se prepara de manera

independiente.
Programa Programa
LM1 1M2
LM1 1M2
Máquina Base Máquina Base

Figura 1.4 Cada computador necesita programas en su lenguaje de máquina (LM)
particular.

Por otra parte, los programas en código de máquina son extraordinariamente
difíciles de leer por una persona. Normalmente contienen códigos numéricos
 

8 Fundamentos de programación

 

(figura 1.5) sin ningún sentido nemotécnico, y compuestos por millones de
operaciones elementales muy sencillas que en conjunto pueden realizar los
tratamientos complejos que vemos a diario.

 

88 94 50 FF 76 OA FF 76 08 9A BA CD 3A 16 B8 01
00 EB ES B8 88 94 50 2B CO 50 9A FA C5 3A 16 EB
ED B8 88 94 50 B8 01 00 FB EF B8 88 94 50 9A 48
D1 3A 16 EB D9 5D CA OA 00 55 8B EC 83 EC 08 57
56 B8 01 00 50 9A 97 41 9B 34 8B DB 8R 47 14 89

Figura 1.5 Fragmento de programa en código de máquina.

Para facilitar la tarea de programación resulta muy deseable disponer de formas de representación de los programas que sean adecuadas para ser leídas o
escritas por personas. En particular los lenguajes de programación sirven precisamento para representar programas de manera simbólica, en forma de un
texto (figura 1.6) que puede ser leído con relativa facilidad por una persona
Además los lenguajes de programación son formas de representación prácticamente independientos de las máquinas particulares que se vayan a usar.

 

 

Void PintarPlazas(const TipoPlazas P) f

print£(ma");
print£(" A BOC DOE Ema;
for (int i = 0; i < NunFilas; i++) £
print£("%3d",1+1);
for (int j= 0; j < AsientosFila; j++) £
if ( j= Pasillo ) £
primt£(" o");
y
if (P[i].AsientosOcupa[j] == ocupado) £
printf(" (0%;
) else if (P[i].AsientosOcupa[j] == reservado) (
printf(" (2);
) else if (P[i].AsientosOcupa[j] == vacio) (
print£(" (3;
y
e
print);
3
print£C'n");

 

  

Figura 1.6 Fragmento de programa en lenguaje Ct.
Introducción. 9

 

La comparación de los fragmentos de programa de las Figuras 1.5 y 1.6 pone
de manifiesto sin necesidad de más explicaciones la ventaja de nsar lenguajes
de programación simbólicos.

1.4 Compiladores e Intérpretes

Un programa escrito en un lenguaje de programación simbólico puede ser
ejecutado en máquinas muy diferentes. Pero para ello se necesita disponer de
los mecanismos adecuados para transformar ese programa simbólico (figura
1.7) en un programa en el lenguaje particular de cada máquina.

Programa
1»

Por im A

Máquina 1 Máquina 2

 

Figura 1.7 Un programa en un lenguaje de programación simbólico ha de adaptarse
al lenguaje de cada máquina.

Existen diferentes estrategias para conseguir ejecutar en una máquina determinada un programa escrito en un lenguaje de programación simbólico. Normalmente se basan en el uso de programas especiales que realizan un tratamiento
de la información en forma de texto que representa el programa en el lenguaje
de programación simbólico. Estos programas para manipular representaciones
de programas los denominaremos procesadores de lenguajes.

Un compilador es un programa que traduce programas de un lenguaje de programación simbólico a código de máquina. A la representación del programa
en lenguaje simbólico se le llama programa fuente, y su representación en código de máquina se le llama programa objeto. Análogamente al lenguaje simbólico y al lenguaje máquina se les llama también lenguaje fuente y lenguaje
objeto, respectivamente.

La ejecución del programa mediante compilador exige al menos dos ctapas
separadas, tal como se indica en la figura 1.8. En la primera de ollas se traduce
el programa simbólico a código de máquina mediante el programa compilador.
10 Fundamentos de programación

 

En la segunda etapa se ejecuta ya directamente el programa en código de
máquina, y se procesan los datos y resultados particulares. La compilación
del programa ha de hacerse sólo una vez, quedando el programa en código de
máquina disponible para ser utilizado de forma inmediata tantas veces como
se desee.

    
   

Prog. Fuente| —w- | Máquina Baso
LE

=> |prog. Objeto
1

—»| Máquina Base

 

Figura 1.8 Proceso de un programa en lenguaje fuente (LF) mediante compilador.

Un intérprete es un programa que analiza directamente la descripción simbólica del programa fuente y realiza las operaciones oportunas. El intérprete debe
contener dentro de él los fragmentos de código de máquina de todas las operaciones posibles que se puedan usar en el lenguaje de programación simbólico.
Puede decirse que el intérprete es (o simula) una máguina virtual (figura 1.9)
cuyo lenguaje de máquina coincide con el lenguaje fuente.

se
IM Intérprete
=>
Máquina Base
Máquina Base
Máquina Virtual

Figura 1.9 Un intérprete se comporta como una máquina virtual cuyo lenguaje es el
lenguaje fuente.

 

 

El proceso de un programa mediante intérprete (figura 1.10) se limita a ejecutar directamente el programa en la máquina virtual, es decir, sobre el intérprete.
Introducción u

 

    
  

Prog. Fuente

 

—» | Máquina Base

Figura 1.10 Proceso de un programa en lenguaje fuente (LF) mediante intérprete.

El proceso mediante intérprete es más sencillo, en conjunto, que mediante
compilador, ya que no hay que realizar dos fases separadas. Su principal
inconveniente es que la velocidad de ejecución es más lenta, ya que al tiempo
que se van tratando los datos de la aplicación hay que ir haciendo el análisis
e interpretación de las operaciones descritas en el programa fuente.

1.5 Modelos abstractos de cómputo

Los lenguajes de programación permiten describir programas o cómputos de
manera formal, y por tanto simbólica y rigurosa. La descripción se hace,
naturalmente, basándose en determinados elementos básicos y formas de combinación de estos elementos simples para construir programas tan complicados
como sea necesario.

Existen muchísimos lenguajes de programación distintos que unas veces difieren en aspectos generales y otras simplemente en detalles. Si analizamos estos
lenguajes podremos observar que muchos de ellos utilizan elementos básicos y
formas de combinación similares, aunque representándolos con símbolos diferentes.

Si de un conjunto de lenguajes de programación basados en elementos computacionales similares extraemos los conceptos comunes, obtendremos un modelo
abstracto de cómputo. Este modelo abstracto recoge los elementos básicos y
formas de combinación de una manera abstracta, prescindiendo de la notación
concreta usada en cada lenguaje de programación para representarlos.

Existen diversos modelos abstractos de cómputo, o modelos de programación,
que subyacen en los lenguajes de programación actuales. Entre ellos están la
programación funcional, programación lógica, programación imperativa, modelo de flujo de datos, programación orientada a objetos, etc. Todos estos
modelos son modelos universales, en el sentido de que pueden utilizarse para
describir cualquier cómputo intuitivamente posible.
12 Fundamentos de programación

 

Quizá el aspecto más interesante a destacar en este análisis de modelos abstractos de cómputo es que un programa que permita resolver un determinado
problema puede adoptar formas muy diferentes, dependiendo del modelo de
cómputo que se utilice para desarrollarlo. El modelo de programación imperativa es el más extendido, y eso induce a quienes empiezan a estudiar
informática a identificar el concepto de programa con el de secuencia o lista
de órdenes. Sin embargo, como veremos a continuación, existen otras formas
igualmente válidas de representar un programa.

 

1.5.1 Modelo funcional

El modelo de programación funcional se basa casi exclusivamente en el empleo
de funciones. El concepto de función se corresponde aquí de manera bastante
precisa con el concepto de función en matemáticas. Una función es una aplicación, que hace corresponder un elemento de un conjunto de destino (resultado)
a cada elemento de un conjunto de partida (argumento) para el que la función
esté definida.

 

Por ejemplo, la operación de suma de números enteros es una función en que
el conjunto de partida es el de las parejas de números enteros y el de destino
es el conjunto de los números enteros. A cada pareja de enteros se le hace
corresponder un entero, que es su suma.

De forma convencional, representaremos como f(x) al resultado que se obtendrá al aplicar la función f al argumento x. Por ejemplo, podemos suponer
definidas las funciones de suma, resta y producto de la forma:

Función Resultado
Suma( a, b) a+b
Diferencial a,b) a-b
Producto( a,b) axb

Para describir cómputos complejos, las finciones pueden combinarse unas con
otras, de manera que el resultado obtenido en una función se use como argumento para otra. De esta manera un cómputo tal como
34x5+8x7
puede representarse de manera funcional de la forma:
Suma( Producto( 34, 5 ), Producto( 8, 7.) )
Este es el aspecto que tiene un programa funcional, que será siempre en último

extremo una aplicación de una función a unos argumentos, para obtener un
resultado. El proceso de cómputo, llamado reducción, se basa en reemplazar
Introducción 13

 

progresivamente cada función por el resultado de la misma. Este sistema.
de evaluación por sustitución es la base del llamado cálculo-A. Aplicado al
ejemplo se tendría:

 

Cómputo parcial Expresión / Resultado
Suma( Producto( 34, 5), Producto( 8, 7) )
34x5 Suma( 170, Producto( 8, 7) )
8x7 Suma( 170, 56)
170 + 56 226

Las explicaciones anteriores se refieren a cómputos en los que sólo intervienen
funciones primitivas, que son las que el computador o máquina abstracta que
ejecnta el programa puede evaluar de forma directa. La programación funcional permite la definición por parte del programador de nuevas funciones a
partir de las ya existentes. Utilizando de manera convencional el símbol
para indicar definición, podremos crear tma nueva función, Cuadrado, para
obtener el cuadrado de un número basándose en el uso del producto de dos
números.

 

Cuadrado( x )

Cuando en un cómputo intervienen funciones definidas, la evaluación se sigue
haciendo por sustitución. El proceso, llamado reescritura, consiste en reemplazar una función por su definición, sustituyendo los argumentos simbólicos
en la definición por los argumentos reales en el cómputo. Por ejemplo, para
evaluar (5 +3)? tendremos:

Producto( x, x )

 

 

Cómputo parcial Expresión / Resultado
Cuadrado( Suma( 5, 3) )

reducir Suma. Cuadrado( 8 )

reescribir Cuadrado Prodneto(8, 8)

reducir Producto 64

1.5.2 Modelo de flujo de datos

En este modelo de cómputo, un programa corresponde a una red de operadores interconectados entre sí. Cada operador lo representaremos gráficamente
mediante un cuadrado con entradas y salidas, y dentro de él el símbolo de la
operación que realiza. Un operador espera hasta tener valores presentes en
sus entradas, y entonces se activa él solo, consume los valores en las entradas,
calcula el resultado, y lo envía a la salida. Después de esto vuelve a esperar
que le lleguen nuevos valores por las entradas.

 
14 Fundamentos de programación

 

 

“o
O

Figura 1.11 Red de lujo de datos.

 

 

 

Por ejemplo, la expresión 34 x 5 +8 x 7 puede ser calculada por la red de la
figura 1.11.

El cómputo se realiza durante la evolución de la red, tal como se indica en
la figura 1.12. Cuando la evolución termina, el resultado está presente en la
salida de la derecha.

 

 

 

iy?
.

 

Paso 1 Paso 2
Figura 1.12 Evolución de la red de flujo de datos.

Una red de flujo de datos puede organizarse de manera que opere de forma
iterativa, obteniendo no ya un resultado sino una serie de ellos. Por ejemplo,
la red de la figura 1.13 produce la serie de números naturales, a base de reciclar
sobre sí mismo un operador de incremento. Las líneas verticales representan
operadores de duplicación o mezcla de valores.

4

Figura 1.13 Generación de una serie de números.

112,34, 02.

   

Esta red no termina nunca de evolucionar. Añadiendo operadores especiales
de bifurcación se puede conseguir que se detenga al llegar a un resultado
adecuado.

 
Introducción 15

 

1.5.3 Modelo de programación lógica

Este modelo abstracto de cómputo corresponde plenamente a lo que se denomina programación declarativa. Un programa consiste en plantear de manera
formal un problema a base de declarar una serie de elementos conocidos, y
luego preguntar por un resultado, dejando que sea la propia máquina la que
decida cómo obtenerlo,

En programación lógica los elementos conocidos que pueden declararse son
hechos y reglas. Un hecho es una. relación entre objetos concretos. Una regla
es una relación general entre objetos que cumplen ciertas propiedades. Una
relación entre objetos la escribiremos poniendo el nombre de dicha relación y
luego los objetos relacionados entre paréntesis. Por ejemplo:

Hijo( Juan, Luis )

significaría que Juan es hijo de Luis. Si tenemos el árbol genealógico como el
de la figura 1.14

Luis Ana

Felipe Juan Sonia
Figura 1.14 Árbol genealógico.

podremos declarar (prescindiendo del sexo) los hechos siguientes:

Hechos
Hijo( Felipe, Luis )
Hijo( Juan, Luis )
Hijo( Sonia, Luis )
Hijo( Felipe, Ana )
Hijo( Juan, Ana )
Hijo( Sonia, Ana )

Para realizar una consulta escribiremos el esquema de un hecho en que alguno
de los elementos sca desconocido. Esto lo indicaremos usando nombres de
incógnitas en minúscula, para distinguirlos de los nombres de clementos conocidos, que en este caso se habían escrito en mayúsculas (en lenguaje Prolog se
usa el convenio contrario). La consulta será respondida indicando todos los
valores posibles que puedan tomar las incógnitas. Por ejemplo:
 

16 Fundamentos de programación

 

Consulta Respuesta
Hijo(x, Ana) lipe

 

uan

 

 

La verdadera potencia de la programación lógica aparece cuando declaramos
reglas. Al realizar consultas basadas en reglas la máquina realiza automáticamente las inferencias (deducciones) necesarias para responderla. Por ejemplo,
usando el símbolo “—” para definir una regla, escribiremos:

Reglas
Padro(x, y ) Hijo(
Hermano( x, y ) :— Hijo( x, z ), Hijo( y, z)

 

La primera regla se limita a nombrar la relación inversa de “hijo”. La segunda
expresa que dos personas son hermanas si son hijas de un mismo padre o
madre. Ahora pueden realizarse consultas como las siguientes:

Consulta Respuesta
Padre( x, Sonia ) x

Hermano( x, Felipe )

 

x
x

x

g=
La segunda consulta tiene wma respuesta aparentemente errónea. Un análisis
detallado nos permite comprobar que el error está en la formulación de la
regla, ya que no se le ha informado a la máquina de que una persona no se

considera hermana de sí misma. Modificando la regla se obtendrá la respuesta
deseada.

Reglas
Hermano( x, y )  Hijo(x, z ), Hijo( y, 2), 4(% y )

Consulta Respuesta _
Hermano( x, Felipe) "x= Juan
x = Sonia

 

1.5.4 Modelo imperativo

El modelo de programación imperativa responde a la estructura interna habitual de un computador, que se denomina arquitectura Von Neumann. Un
Introducción Y

 

programa en lenguaje de máquina aparece como una lista de instrucciones u
órdenes clementales que han de ejecutarse una tras otra, en el orden en que
aparecen en el programa. El nombre de programación imperativa deriva del
hecho de que un programa aparece como una lista de órdenes a cumplir.

El orden de ejecución puede alterarse en caso necesario mediante el uso de
instrucciones de control. Con ello se consigue ejecutar o no, o repetir, determinadas partes del programa dependiendo de ciertas condiciones en los datos.

 

Las instrucciones de un programa imperativo utilizan datos almacenados en
la memoria del computador. Esta capacidad de almacenamiento de valores se
representa en los programas imperativos mediante el uso de variables. Una
variable no tiene aquí el mismo significado que en matemáticas, sino que representa 1n dato almacenado bajo un nombre dado, Una variable contiene un
valor que puede ser usado o modificado tantas veces como se desee.

  

Un programa imperativo se plantea como el cáleulo o modíficación de sucesivos
valores intermedios hasta obtener el resultado final. Las instrucciones típicas
de un programa imperativo son las de asignación, que consisten en obtener un
resultado parcial medianto un cálculo elemental que puede ser realizado por la
máquina, y que se almacena en una variable para ser utilizado posteriormente.

En los lenguajes de programación simbólicos las instrucciones u órdenes se
denominan sentencias. En C+ y otros lenguajes similares la sentencia de asignación se representa de la forma
variable = expresión.

La parte derecha de esta sentencia es una expresión aritmética que puede
usar variables o valores constantes, así como operadores que estén definidos
en el lenguaje, tales como los correspondientes a las operaciones aritméticas
habituales: suma, resta, etc. Una sentencia de asignación representa una orden
de calcular el resultado de la expresión y luego almacenar dicho resultado como
nuevo valor de la variable.

 

Usando sólo expresiones simples y variables auxiliares, podremos expresar el
cálculo de

34x54+8x7
mediante las sentencias siguientes
l.a=34x5
2.b=8x7
3.0=a+b

 

que obtendrán el resultado final en la variable e.

 
18 Fundamentos de programación

 

En realidad los lenguajes de programación permiten escribir directamente expresiones complejas. El cálculo anterior podría haberse hecho con una sola
sentencia

1.c=34x5+8x7

Para mostrar cómo las variables en programación imperativa pueden ir modificando su valor paso a paso hasta obtener el resultado deseado, analizaremos el
siguiente fragmento de programa, que calcula el valor de 5! = 1x2x3x4x5. En
este programa se ha supuesto que existen instrucciones REPETIR y HASTA
que permiten programar la repetición controlada de una parte del programa.

1.f=1

%de=1

3. REPETIR
4.k=k+1
5.f=fxk

6. HASTA k== 5

 

Este programa obtiene el resultado final en la variable f. La variable k se
utiliza para ir disponiendo de los sucesivos valores 2, 3, 4, etc. Las instrucciones
3. y 6. controlan la repetición de 4. y 5. La instrucción:

4.k=k+1

tiene el significado siguiente: Se calcula el resultado de la expresión k-+1,
usando el valor de k al iniciarse la ejecución de esa instrucción, y el valor
obtenido se almacena de nuevo en k reemplazando el valor anterior, La primera
vez que se ejecuta esa instrucción k tiene el valor 1, asignado inicialmente por
la instrucción 2. Al sumarle 1 se obtiene el valor 2, y la variable k pasa a
tener ahora este nuevo valor. Cada vez que se vuelva a ejecutar la instrucción
4. la variable k incrementará su valor en 1 unidad.

 

El análisis detallado del funcionamiento de un programa imperativo puede
hacerse mediante una traza en la que se van anotando las sentencias o instrucciones de asignación que se van ejecutando sucesivamente, y los valores que
toman las variables inicialmente y tras cada instrucción. En este ejemplo se

 
Introducción 19

 

Instrucción —_k r
A A

Ñ ? q
a 1 A
4. 2 1
5. 2 2
4. 3 2
5. 3 6
4. 4 6
5 4. 24
4. Bonds
5. 5 120

El programa comienza con valores no definidos (?) para las variables. Termina
cuando k ha tomado el valor 5, en cuyo caso finalizan las repeticiones y / tiene
el valor 120 = 5!.

1.6 Elementos de la programación imperativa

La mayoría de los lenguajes de programación actualmente en uso siguen el modelo de programación imperativa. Por esta razón se ha optado en este primer
nivel de enseñanza de programación por seguir dicho modelo. El lenguaje de
programación Ct so utilizará en este libro como herramienta para desarrollar
las ideas generales en ejemplos prácticos realizables en máquina. Ck es un
subconjunto de los lenguajes C y C++ que se utilizan habitualmente en desarrollos reales. Además, C+ presenta importantes ventajas para la enseñanza,
por ser un lenguaje bien estructurado, permitir el uso de programación modular, permitir la implementación de tipos abstractos de datos, y ser un primer
paso hacia el uso de lenguajes más evolucionados (y más complicados) como
ocurre con los lenguajes C++, Ada o Java.

 

 

En el resto de este texto se irán desarrollando las ideas abstractas o generales
de programación, junto con su realización en lenguaje Ct. Todo ello en el
marco de la programación imperativa, cuyos elementos abstractos se describen
a continuación.

1.6.1 Procesador, entorno, acciones

Al introducir el modelo de programación imperativa se ha definido un programa, de manera intuitiva, como una lista de órdenes o instrucciones que han
de ir siendo ejecutadas por la máquina en el orden preciso que se indique.

 
20 Fundamentos de programación

 

La idea abstracta correspondiente al concepto físico de máquina es el procesador. Definiremos como procesador a todo agente capaz de entender las órdenes
del programa y ejecutarlas.

El procesador es esencialmente un elemento de control. Para ejecutar las instrucciones empleará los recursos necesarios, que formarán parte del sistema.
en el enal se ejecute el programa. Por ejemplo, se necesitarán dispositivos de

 

almacenamiento para guardar datos que habrán de ser utilizados posteriormente, o dispositivos de entrada-salida que permitirán tomar datos de partida
del exterior y presentar los resultados del programa. Todos estos elementos
disponibles para ser utilizados por el procesador constituyen su entorno.

Las órdenes o instrucciones del programa definen determinadas acciones que
deben ser realizadas por el procesador. Un programa imperativo aparece así
como la descripción de una serie de acciones a realizar en un orden preciso. Las
acciones son la idea abstracta equivalente a las instrucciones de 1m programa
real.

 

1.6.2 Acciones primitivas. Acciones compuestas

Las acciones que son dire

 

amente realizables por el procesador se denominan
acciones primitivas. Estas acciones suelen ser bastante sencillas, incluso en el
caso de programas descritos en lenguajes de programación simbólicos. Entender un programa. descrito enteramente a base de acciones primitivas suele ser
muy difícil, por el nivel de detalle con el que hay que analizar cada una de sus
partes, y todas ellas en conjunto.

El planteamiento razonable de un programa complejo debe pasar por usar
la idea de abstracción para limitar la complejidad de detalles al estudiar el
programa en su conjunto. Es muy útil usar la idea de acción compuesta como
abstracción equivalente a un fragmento de programa más o menos largo que
realiza una operación bien definida.

La descripción de un programa en términos de acciones compuestas puede facilitar su comprensión. Por supuesto, al desarrollar el programa habrá sido
preciso describir o descomponer las acciones compuestas en obras más senci
llas, hasta llegar finalmente a acciones primitivas, que son las que realmente
podrá ejecutar el procesador. Las acciones compuestas son un elemento de
descripción que facilita la comprensión del programa en su conjunto, o de
partes importantes de él, pero no reduce el tamaño total del programa, que
necesariamente deberá ser largo si se han de realizar operaciones complicadas.

 

 

 
Introducción 21

1.6.3 Esquemas de acciones

Una acción compuesta consistirá, tal como se ha indicado, en la ejecución
combinada de otras acciones más sencillas. La manera en la que varias acciones sencillas se combinan para realizar una acción complicada se denomina
esquema de la acción compuesta.

 

Una buena metodología de programación exige usar esquemas sencillos y fáciles de entender a la hora de desarrollar acciones compuestas. A lo largo
de este libro se irán introduciendo los principales esquemas de programación
imperativa, junto con recomendaciones para su aplicación en el desarrollo de
programas.

En particular, la llamada programación estructurada sugiere el uso de tres
esquemas generales denominados secuencia, selección e iteración, con los enales
(junto con la definición de operaciones abstractas) se puede llegar a desarrollar
de forma comprensible un programa tan complicado como sea necesario.

1.7 Evolución de la programación

Las ideas sobre cuál es la manera apropiada de desarrollar programas han
ido evolucionando con el tiempo. Ha habido diversos motivos para ello, que
pasaremos a analizar brevemente.

1.7.1 Evolución comparativa Hardware/Software

Los primeros computadores eran máquinas extraordinariamente costosas, y
con una capacidad que hoy día considoraríamos ridíenlamente limitada. Sin
embargo en su momento representaban el límite en la capacidad de tratamiento de información, y hacían posibles determinados trabajos de cálculo
inabordables hasta entonces.

 

Como consecuencia de ello la finalidad principal de la programación era obtener el máximo rendimiento de los computadores. Los programas se escribían
directamente en el lenguaje de la máquina, o a lo sumo en un lenguaje ensamblador en que cada instrucción de máquina se representaba simbólicamente
mediante un código nemotécnico para facilitar la lectura del programa.

No existían ideas abstractas sobre el significado u objetivo preciso de un programa. Simplemente se consideraba que el mejor programa era el que realizaba
el trabajo en menos tiempo y usando el mínimo de recursos de la máquina.
La programación era, por tanto, una labor artesana, basada en la habilidad

  

 
22 Fundamentos de programación

 

personal del programador para conseguir que el programa cumpliera con esos
objetivos de eficiencia, para lo cual era imprescindible conocer en detalle el
funcionamiento interno del computador, y poder así emplear ciertos “trucos”
de codificación que permitían ahorrar algunas instrucciones o usar menos elementos de memoria para almacenar datos intermedios.

El costo de desarrollo del software resultaba, en todo caso, muy inferior al
costo del equipo material (hardware), por lo que pocas personas se paraban a
considerar las posibilidades de reducir los costos de desarrollo de programas.

Por otra parte, y dada la limitación de capacidad de las máquinas, los programas eran necesariamente sencillos, en términos relativos, y se consideraba que
podían llegar a depurarse de errores mediante ensayos o pruebas en número
suficiente,

Los avances en la tecnología electrónica han ido suministrando computadores
cada vez más capaces y baratos, en términos relativos. La necesidad de preparar sistemáticamente programas muy eficientes ha ido disminuyendo, y poco
a poco se ha ido haciendo rentable utilizar programas no tan eficientes.

La mayor capacidad de los computadores ha permitido abordar aplicaciones
cada vez más complejas. En los primeros computadores el software de una
aplicación podía contener algunos cientos o quizá miles de instrucciones. En
la actualidad las aplicaciones consideradas sencillas tienen decenas de miles
de instrucciones, y en aplicaciones de gran envergadura el volumen del software desarrollado se cuenta por millones de instrucciones y en ellos trabajan
centenares de programadores.

Con estos volúmenes de programa el costo del desarrollo del software supera
ampliamente al costo de los equipos hardware utilizados. Ya no tiene sentido dedicar un gran esfuerzo a conseguir programas eficientes. Es más barato
desarrollar programas relativamente más simples, aunque no aprovechen muy
bien los recursos de la máquina, y comprar un computador de mayor potencia de proceso que compense esa posible falta de eficiencia. Los lenguajes
de programación simbólicos han facilitado extraordinariamente las tareas de
programación, al poder invocar en un programa operaciones cada vez más
complejas como acciones primitivas. De esta manera se reduce el volumen
total del programa medido en número de instrucciones, que ahora pasan a ser
sentencias del lenguaje simbólico.

1.7.2 Necesidad de metodología y buenas prácticas

Los programas actuales son tan complicados que ya no es posible desarrollarlos de una manera artesanal. Es necesario aplicar técnicas de desarrollo muy
Introducción 23

 

precisas para controlar el producto obtenido. Ya se ha indicado que estas técnicas aplicables a proyectos desarrollados en equipo constituyen la ingeniería
de software.

A nivel individual hay que promover el empleo de una metodología de programación apropiada, que satisfaga los objetivos de corrección y claridad mencionados anteriormente. Para aplicaciones grandes la claridad se convierte en un
objetivo prioritario, ya que resulta imposible analizar y modificar un programa
si no se comprende suficientemente su funcionamiento.

Para facilitar la obtención de programas correctos, sin fallos, se pueden emplear técnicas formales, que permitan en lo posible garantizar la corrección del
programa mediante demostraciones lógico-matemáticas, y no mediante ensayos en busca de posibles errores. La técnica de ensayos sólo resulta útil si
consigue descubrir fallos, pues así demuestra que el programa contiene errores
que hay que corregir, pero es más bien inútil si no se descubre ningún fallo,
porque eso no garantiza que el programa. no contenga errores, los cuales pueden
manifestarse (y lamentablemente se manifiestan con harta frecuencia) cuando
el programa ya está en explotación y los usuarios lo emplean en multitud de
situaciones nuevas que no habían sido ensayadas nunca.

Lamentablemente las técnicas formales son tan complejas que sólo son utilizables en programas críticos de pequeño tamaño. Para grandes aplicaciones en
las que intervienen cientos de ingenieros es absolutamente necesario emplear
técnicas de ingeniería de software basadas en las buenas prácticas. Las buenas
prácticas son un conjunto de normas, basadas en la experiencia de desarrollos
anteriores, que se autoimponen todos los miembros de un equipo. El Mamual de Estilo es el documento que compendia el conjunto de buenas prácticas
que todos los miembros del equipo deben utilizar de una manera disciplinada
durante el desarrollo de una aplicación compleja.

 

 
Tema 2

Elementos básicos de
programación

En este tema se presenta un conjunto mínimo de elementos de un lenguaje
de programación imperativo. Este conjunto se particulariza para el lenguaje
C£. Con los elementos presentados se podrán construir programas completos
aunque con una estructura muy simple, ya que sólo pueden estar formados por
una secuencia de sentencias. Para que estos primeros programas produzcan
resultados, se introducen también varios mecanismos de escritura simple.

 

El objetivo que trata do alcanzar oste tema es permitir el desarrollo de programas completos desde el principio. Estos programas se podrán realizar como
prácticas con el computador de manera inmediata y directa utilizando un

compilador de C/C++.

2.1 Lenguaje C+

El lenguaje de programación C+ (léase C-más-menos), que se utilizará a lo
largo de todo este libro para introducir los diferentes conceptos de programación, está constituido por un subconjunto del vocabulario de los lenguajes C
y C++. Por lo tanto, cualquier programa escrito en el lenguaje Ct se podrá
editar, compilar y ejeentar en mn entorno de desarrollo para C++ que incluya como subconjunto al lenguaje C. Conviene señalar que los ficheros fuente
que contengan los programas Ct deberán tener extensión .cpp como si fueran
programas en C++.
 

 

2 Fundamentos de programación

 

El objetivo fundamental de utilizar el lenguaje Ci es la introducción de los conceptos fundamentales de programación de una manera progresiva, sistemática
y sin ambigiiedades con el fin de que se adquiera una buena metodología de
programación. Lamentablemente C o C++ no fueron diseñados para la formación de programadores y disponen de ciertas estructuras que conceptualmente
son poco rigurosas y que por ello no forman parte de C+.

El lenguaje Ct se irá presentando de manera simultánea a la introducción de
los conceptos según se avance en el curso. La presentación de cada nuevo
elemento de Ct se realizará formalmente mediante la notación BNF (ver siguiente epígrafe de este tema). En el apéndice A de este libro se recopila la
descripción formal en BNF de la sintaxis completa del lenguaje Ct.

En cada tema sólo se utilizarán aquellos elementos del lenguaje C+ que ya
hayan sido presentados. Dado el enfoque metodológico de la asignatura, oualquier programa o práctica que no se realice en el lenguaje CE y siguiendo
las pautas marcadas a lo largo del libro se considerará incorrecto. Aunque
el exigir restricciones como éstas pueda parecer de carácter solo formativo o
estrictamente académico, el poner ciertas restricciones para la codificación en
determinados lenguajes de programación resulta una práctica bastante habitual en el desarrollo de software a nivel industrial.

 

Siguiendo las pautas de buenas prácticas de ingeniería de software, cualquier
empresa o equipo de desarrollo de software debe disponer antes del inicio de
cada desarrollo de un Manual de Estilo. Para lograr la adecuada claridad,
homogeneidad y mantenibilidad de los programas, en el Manual de Estilo, se
establecen prohibiciones expresas de uso de algunas estructuras del lenguaje de
programación empleado, el formato de escritura de cada sentencia, recomendaciones de uso de los distintos elementos del lenguaje (constantes, variables,
tipos y subprogramas) y otros muchos aspectos. Para garantizar que todo el
desarrollo sigue estas pautas establecidas, una o varias personas del departamento de calidad son las encargadas del garantizar la calidad requerida de
todos los programas y para ello tienen la potestad de exigir las correcciones o
modificaciones que consideren necesarias a los programadores.

2.2 Notación BNF

Un lenguaje de programación sigue unas reglas gramaticales similares a las de
cualquier idioma humano, aunque más estrictas. Para la definición formal de
dichas reglas sintácticas utilizaremos la notación BNF (Backus-Naur Form)
basada en la descripción de cada elemento gramatical en función de otros más
Elementos básicos de programación 27

 

sencillos, según determinados esquemas o construcciones. Cada uno de estos
esquemas se define mediante una regla de producción.

Estas reglas sobre cómo han de escribirse los elementos del lenguaje en forma
de símbolos utilizan a su vez otros símbolos, que se denominan metasímbolos.
Son los siguientes:

 

= Metasímbolo de definición. Indica que el elemento a su izquierda puede
desarrollarse según el esquema de la derecha.

|. Metasímbolo de alternativa. Indica que puede elegirse uno y sólo uno de
los elementos separados por este metasímbolo.

([ ) Metasímbolos de repetición. Indican que los elementos incluidos dentro
de ellos se pueden repetir cero o más voces.

[ ] Metasímbolos de opción. Indican que los elementos incluidos dentro de
ellos pueden ser utilizados o no.

( ) Metasímbolos de agrupación. Agrupan los elementos incluidos en su
interior.

Estos metasímbolos se escriben con el tipo de letra especial indicado para distinguirlos de los paréntesis, corchetes, etc. que forman parte del lenguaje Ct.
También se emplearán distintos estilos de letra para distinguir los elementos
simbólicos siguientes:

Elemento_no_terminal Este estilo se emplea para escribir el nombre de un
elemento gramatical que habrá de ser definido por alguna regla. Cualquier elemento a la izquierda del metasímbolo 332 será no terminal y
aparecerá con este estilo.

 

Elemento_terminal Este estilo se emplea para representar los elementos que
forman parte del lenguaje Ci, es decir, que constituyen el texto de un
programa. Si aparecen en una regla deberán escribirse exactamente como
se indica.

2.3 Valores y tipos

computador, como máquina de tratamiento de información, manipula diferentes datos. Un dato es un elemento de información que puede tomar un
salor entre varios posibles. Si un dato tiene siempre necesariamente un valor
fijo, diremos que es una constante.

 
28 Fundamentos de programación

 

Los valores de los datos pueden ser de diferentes clases. En general un dato
sólo puede tomar valores de una clase. Por ejemplo, la estatura de una persona
no puede tomar el valor “Felipe”, ni el nombre de nna persona puede ser “175”,
En programación a las distintas clases de valores se les denomina tipos. Un
dato tiene asociado un tipo, que representa la clase de valores que puede tomar.
Por ejemplo, son tipos diferentes:

+ Los números enteros.
+ Los días de la semana.
+ Los meses del año.

+ Los títulos de libros.
e ól0.

Es importante destacar que el concepto de tipo es algo abstracto, e independiente de los símbolos concretos que se empleen para representar los valores.
Por ejemplo, aunque podemos representar los meses del año mediante números
enteros de 1 a 12, los meses no son números enteros, pues no tiene sentido,
por ejemplo, sumar Enero (1) y Marzo (3) para obtener Abril (4).

 

Con más precisión se habla de tipos abstractos de datos, que identifican tanto el conjunto de valores que pueden tomar los datos de ese tipo como las
operaciones significativas que pueden hacerse con dichos valores.

En la comunicación humana usamos habitualmente dos grandes clases de valores: los números y los tertos. Los lenguajes de programación llevan incluidas
formas de representación concretas de estas clases de valores, que se traducen
en la existencia de tipos de datos predefinidos, ya incorporados al lenguaje,
y que pueden usarse, en su caso, para representar también valores de otros
nuevos tipos de datos definidos por el programador. Aunque en la práctica
los números han de escribirse externamente en forma de texto para poder ser
leídos por las personas, desde el punto de vista abstracto son valores de tipos
diferentes a los de los caracteres que los representan.

 

 
  

2.4 Representación de valores constantes

 

Uno de los objetivos de los lenguajes de programación es evitar las ambigñe.
dades o imprecisiones que existen en los lenguajes humanos. Por ejemplo,
la representación de valores numéricos en los países anglosajones se realiza.
separando por comas (,) los millares. Así, trescientos cuarenta y ocho mil
quinientos treinta y seis se representa de la siguiente manera:

348,536

 
Elementos básicos de programación 29

 

Sin embargo, nosotros utilizamos la coma para separar la parte entera de la
parte decimal de un número no entero. Por lo tanto, la interpretación con esta
regla del número anterior sería: trescientos cuarenta y ocho con quinientas
treinta y seis milósimas.

 

A continuación se indican las reglas particulares de CE para la representación
de valores básicos, tanto numéricos como de texto.

2.4.1 Valores numéricos enteros

Los valores enteros representan un número exacto de unidades, y no pueden
tener parte fraccionaria. Un valor entero se escribe mediante una secuencia
de uno o más dígitos del 0 al 9 sin separadores de ninguna clase entre ellos y
precedidos opcionalmente de los símbolos más (+) o menos (-). Son enteros
válidos los siguientes:

 

2

+56

0
-234567745
1000000000

Sin embargo, no son valores enteros válidos los siguientes:

123,234 No se pueden usar comas
22.56 No se pueden usar puntos
13E5 No se pueden usar letras

Usando la notación BNF podemos representar de manera precisa las reglas
para escribir estos valores:

 

Valor_entero 335 [+ | - ] Secuencia_dígitos
Secuencia dígitos 33= Dígito Í Dígito y

olil2lalaIsl6l718l9

 

Dígito

NU NOTA: El lenguaje Ct como derivado de C/C++ considera que cuando el valor
entero comienza por un primer dígito ( se está escribiendo en base 8 (octal) en lugar
de en base 10 (decimal). Así, el valor númerico 020 es un número octal que equivale a
16 en decimal. En este curso no se hace uso de los valores octales y carece de sentido
poner ceros a la izquierda de un valor numérico. En cualquier caso, el compilador de
C/C++ da un error si al escribir un valor octal se utilizan los dígitos 8 ó 9.

 

 
30 Fundamentos de programación

2.4.2 Valores numéricos reales

Los valores numéricos reales permiten expresar cualquier cantidad, incluyendo
fracciones de unidad. Se pueden representar de dos maneras distintas: en la
notación decimal habitual, o en la notación científica. En la notación decimal
habitual un valor real se escribe con una parte entera terminada siempre por
un punto (.), y seguida opcionalmente por una secuencia de dígitos que constituyen la parte fraccionaria decimal. De acuerdo con ello son valores reales
válidos los siguientes:

Ss.
-0.78
+234.53
0.0000000034
1234.000

En la notación científica un número real se escribe como una mantisa, que es
un número real en la notación decimal habitual, seguida de un factor de escala
que se escribe como la letra E seguida del exponente entero de una potencia de
10 por la que se multiplica la mantisa. Son valores reales válidos en notación
científica:

-23.2E+12 equivalente a -23.2x10'?
14567.823E4 equivalente a 14567.823x10*
126.E-34 equivalente a 126x107%

Sin embargo, no son valores reales válidos los siguientes:

4,78 No se pueden usar comas
56.7F-56 No se puede usar la letra F

A diferencia de los valores enteros, un mismo valor real puede tener muy diversas representaciones válidas. Por ejemplo, todas las representaciones siguientes
corresponden al mismo valor:

45.6 456.E-1 4.56E+1 45.60E+0 456000.00E-4

Las reglas anteriores, expresadas en notación BNF son:

Valor_real 33= Valor_entero . [ Secuencia_dígitos ] [ Escala ]
Escala 33 = E Valor_entero
 

Elementos básicos de programación 31

2.4.3 Caracteres

Además de los valores numéricos enteros o reales, empleados para la realizasión de cálculos numéricos, los lenguajes de programación nos deben permitir
representar valores correspondientes a los caracteres de un texto, y que están
isponibles en cualquier teclado, pantalla o impresora.

Dentro del texto de un programa en C+ el valor de un carácter concreto se
escribe poniendo dicho carácter entre apóstrolos (*). Ejemplos de valores de
earacteres son los siguientos:

a
a

oy

  

Es interesante hacer las siguientes observaciones

+ el espacio en blanco (* *) es un carácter válido como los demás
+ hay que distinguir entre un valor entero de un dígito (p.ej. 7) y el carácter
correspondiente a dicho dígito (p.ej. '7")

La colección o juego de caracteres (charset) que pueden manipularse en un programa depende de la máquina que se esté usando. Sólo se pueden representar
de la forma indicada (escribiéndolos entre apóstrofos) aquellos caracteres que
tengan asociado un símbolo gráfico (letra, dígito, signo de puntuación, ete.)
que pueda introducirse en el texto del programa. Otros caracteres definidos,
tales como los caracteres de control, que no tienen símbolo gráfico, se representan mediante una secuencia de escape con la siguiente notación:

'Xn' Salto al comienzo de una nueva línea de escritura
*Xr* Retorno al comienzo de la misma línca de escritura
*Yt*  Tabulación

''*  Apéstrofo

XV" Barra inclinada

*X£* Salto a una mueva página o borrado de pantalla

2.4.4 Cadenas de caracteres (strings)
Es frecuente que los caracteres no se utilicen de forma aislada, sino formando

palabras o frases. Una cadena de caracteres (en inglés string) se escribe como
una secuencia de caracteres incluidos entre comillas ("). Por ejemplo:
 

$2 Fundamentos de programación
"Palabra"
"Este texto es una cadena de caracteres”
"gr

"El resultado de A+B es:
"Incluir entre 'apóstrofos' el texto”
"Conteste "Si" o W"NoX"
"¿Año de fabricación?"

 

Conviene observar que:

si una cadena incluye comillas en su interior se escribirá mediante Y"
no hay que confundir un valor de tipo carácter ("x") con una cadena del
mismo único carácter ("x"). La distinción se produce por el delimitador
utilizado comillas (") para una cadena y apóstrofo (*) para un carácter
es posible definir una cadena vacía que no contenga ningún carácter,
como en el último ejemplo

Una cadena puede contener cualquier número de caracteres y puede incluir
cualquier carácter alfabético o de puntuación que sea representable dentro del
texto del programa. Aquí se aplican las mismas observaciones que se han
hecho antes respecto al juego de caracteres particular de cada máquina.

2.5 Tipos predefinidos

Las diferentes formas de representación de valores constantes presentadas en
los apartados anteriores distinguen ya varias clases de datos, pero que no llegan
aser tipos en sí mismos. En efecto, tal como vamos a ver a continuación, dentro
de una misma clase de valores pueden distinguirse varios tipos diferentes, tanto
a nivel de tipos predefinidos en el lenguaje, como de tipos definidos por el
programador.

Recordaremos que un tipo de datos define:

1. Una colección de valores posibles
2. Las operaciones significativas sobre ellos

En el lenguaje Ct hay cuatro tipos de datos predefinidos, que se designan con
los nombres int, float, char, bool, así como mecanismos para definir nuevos
tipos a partir de ellos. En los lenguajes C y C++ hay tipos predefinidos
adicionales. En las secciones siguientes se describen los tipos predefinidos
fundamentales, excepto el tipo bool, que se describe más adelante.
 

Elementos básicos de programación 33

2.5.1 El tipo entero (int)

Los valores de este tipo son los valores numéricos enteros positivos y negativos.
¡Como tipo abstracto su definición coincide con el concepto matemático de los
ameros enteros. Sin embargo, dado el carácter físico de los computadores,
sl rango de valores nunca podrá ser infinito como se establece en el concepto
matemático, En cada caso el rango de valores del tipo int depende de la
plataforma (combinación de: procesador, sistema operativo y compilador) que
se esté utilizando. En general se corresponde con el rango de valores que
pueden manipularse con instrucciones básicas del lenguaje de máquina y viene
2 ser simétrico en torno al valor cero. Dentro de dicho rango la representación
de cualquier valor es exacta. Son rangos comunes los siguientes:

 

Tamaño de palabra Rango de valores enteros

 

   
   

 

   

 

16 bits 32.768 ... 0 .. 767

32 bits 147.483.648 ... O... 2.147.483.647
-9.223.372.036.854.775.808

64 bits Usos

9.223.372.036.854.775.807

 

 

 

 

Estos rangos obedecen a que los computadores suelen emplear la codificación
en base 2 de los valores enteros. Para el signo del número se utiliza un bit,
quedando, por tanto, 15, 31 ó 63 para el valor absoluto:

 

26 — 9.223.372.036.854.775.808

MU NOTA: Para facilitar la escritura de programas que tengan en cuenta la limitación
particular de rango existente en cada caso, C y C++ permiten hacer referencia al valor
mínimo mediante el nombre simbólico INT_MIN, y al 2 máximo mediante INI_MAX.
El rango admisible será, por tanto: INT_MIN ... 0 ... INT_MAX, Estos nombres están
definidos en el módulo limits de la librería estándar da C (cabecera <limits.h>).

 

 

 

Asociadas al tipo int están las operaciones que se pueden realizar con los
valores de este tipo. Las operaciones predefinidas entre valores enteros son
las operaciones aritméticas básicas, que se realizan entre enteros y devuelven
como resultado valores enteros. Para invocar estas operaciones se dispone de
los siguientes símbolos de operación u operadores:
 

34 Fundamentos de programación

 

+

Suma de enteros

Resta de enteros
Multiplicación de enteros
División de enteros
Resto de la división
Identidad de un entero

- Cambio de signo de un entero —

coro

 

+ RO xl
+20 p2.$»
Does!

Siguiendo la representación aritmética habitual, los símbolos + y — tienen un
doble significado, según se usen como operadores infijos entre 2 operandos o
como operadores prefijos con un tínico operando.

El operador / realiza la división entre dos números enteros y obtiene como
resultado el cociente entero truncado al valor más próximo a cero. Cuando el
divisor es cero se obtiene como resultado un error. Por ejemplo:

Operación Resultado
10/73 3

(20) / (7) 2
(15) /4 3

17 / (3) 5
34 /0 Error

El operador % obtiene el resto de la división de enteros realizada con /. Por
ejemplo:

Operación Resultado
10% 3 1
(20) % (7) 6
(15) % 4 «3
17 % (-3) 2
34% 0 Error

Entre los operadores / y % se cumple la regla aritmética habitual:
Dividendo = Divisor x Cociente + Resto
que en Ch so expresaría así:
a = b* (a/b) + (ab)

Cuando se realiza una operación con enteros se debe tener en cuenta el rango
de valores disponible en la plataforma que se esta utilizando. Si se produce un
resultado fuera del rango disponible se producirá un error. En algunos casos
este tipo de errores no se indica y puede ser difícil su detección. Por ejemplo,
para enteros de 16 bits con un rango entre -32.768 y 32.767, se obtienen los
siguientes resultados:
Elementos básicos de programación 35

 

Operación Resultado

234 + 89 323

345 +97 Error
214 * (-203) Error
15456 + 18678 Error
(-20) - 32750 Error

2.5.2 El tipo real (float)

Con el tipo float se trata de representar en el computador los valores numérisos reales positivos y negativos. Sin embargo, al contrario que en caso del tipo
int, esta representación puede no ser exacta. Además, dado que la capacidad
de los computadores es limitada, la representación sólo se puede considerar
válida dentro de un rango, de forma semejante a como sucede con los enteros.

Tanto el rango como la precisión dependen de la plataforma concreta utilizada. Dentro de dicho rango para algunos valores coneretos es posible una
representación exacta. Sin embargo, dado el carácter discreto de los datos que
siempre se manejan en un computador, nunca será posible una representación
exacta de valores tales como los valores irracionales mo e o, en general, de valores cuya precisión sea superior a la disponible en la plataforma que estemos
astilizando. En estos casos se manejan valores aproximados.

Los valores reales se suelen representar internamente de forma equivalente a la
notación científica, con una mantisa y un factor de escala. El rango de valores
representables está limitado tanto para valores grandes como pequeños. Los
salores más pequeños que un límite dado se confunden con el cero. Al igual
'que en el caso de los valores enteros, el rango y precisión de los valores reales
puede cambiar de una plataforma a otra. Algunos de los rangos habituales
son los siguientes:

 

Tamaño de palabra
epreridión Rango de valores reales

348438... -1.28-38

32 bits; 6 cifras decimales | 0

+1.28-38 ... +3.4E438

-1.7E+308 ... -2.3E-308

64 bits; 15 cifras decimales | 0

+2.3E-308 ... +1.784308

 

 

 

 

 

 

Estos rangos dependen del número concreto de bits y de la codificación que se
emplean para la mantisa y el exponente del valor float. En el caso de valores

 
36 Fundamentos de programación

 

representados con 32 bits no existe ningún valor intermedio entre —1, 2x 1078
y el valor 0, ni tampoco entre O y 1,2 x 10-35 (y análogamente para valores
en 64 bits).

Asociadas al tipo £loat están las operaciones que se pueden realizar con ól.
Las operaciones entre valores reales son las operaciones aritméticas básicas,
que se realizan entre reales y devuelven como resultado valores reales. Los
correspondientes operadores son los siguientes:

 

+ Suma de reales
- Resta do reales
Multiplicación de reales
División de reales
Identidad de un real

- Cambio de signo de un real 
+0.
+2. 2»

pao
coco

Los símbolos empleados para estos operadores son los mismos que para. los
operadores enteros. Sin embargo, en todos los casos son operadores distintos
de los operadores enteros. Las operaciones entre reales dan como resultado un
real con la precisión de la plataforma. Así, para valores reales no se cumple
siempre exactamente la relación básica:

la / by) *b= au

Es importante tener en cuenta imprecisiones como ésta cuando los cálculos
sean más complejos y se puedan acumular errores. Ejemplos de operaciones
entre valores reales son las siguientes:

 

Operación Resultado
— OE OZ.
-20.6 * 2.4 -49,44
-15.4E2 + 450.0 -1090.0
23.4. - 2E-1 23.2

La representación sólo aproximada de los valores reales se pone de manifiesto si
tratamos de expresar con más precisión de la realmente existente el resultado
de una operación. Por ejemplo:

Operación Resultado
10.0 / 3.0 3.3333332538604736E+0

En este caso concreto el valor es inexacto a partir de la 72 cifra decimal. En
cada plataforma so podrá obtener un resultado ligeramente diferente.
Elementos bésicos de programación 37

 

2.5.3 El tipo carácter (char)

Para comprender bien el manejo de valores de tipo carácter en um computador
es necesario conocer cómo se definen y representan esos valores de caractoses. Cada carácter no se representa internamente como un dibujo (el glifo
del carácter), sino como un valor mumérico entero que es su código. La coJección concreta de caracteres y sus códigos numéricos se establecen en una
tabla (charset) que asocia a cada carácter el código numérico (codepoint) que
de corresponde.

 

Dependiendo del número de bits reservado para representar el código de cada carácter podremos tener tablas más o menos amplias. Algunas tablas de
caracteres de amplio uso son:

 

Tamaño
Tabla (charset) del Repertorio de caracteres
carácter

 

Letras inglesas mayúsculas y
ASCII 7 bits minúsculas. Algunos signos de
puntuación y códigos de control.

 

 

 

Oo LE
| a m eu mieyoreignodepenbiasón

o Incluye además los alfabetos griego,
| AE má 16 bits cirílico, árabe, chino/japonés/coreano,
| land signos matemáticos, etc.

Tacluye la práctica totalidad de
UNICODE be caracteres ntilizados en cualquier
completo ns idioma o notación textual existente en

nuestro mundo actual

 

 

 

 

Las tablas mencionadas son compatibles entre sí en el sentido de que cada
=na de ellas incluye la anterior, manteniendo los códigos muméricos de los
caracteres. Lamentablemente la compatibilidad no se extiende a otras muchas
tablas de caracteres de amplio uso. Por ejemplo, otras tablas de caracteres de
8 bits muy conocidas son:

 

 
 

38 Fundamentos de programación

 

 

 

 

Tamaño
Tabla (charset) del Repertorio de caracteres
carácter
pertorio ASCII má.
19088507 ms Repertorio ASCIT más el alfabeto
griego
180-8859-15 8 bits Repertorio Latin-1 revisado. Incluye

el símbolo de Euro

 

IBM-PC-437
(original del

sistema operativo

Repertorio ASCII más simbolos
8 bits semigráficos y letras con acentos,
pero con códigos distintos de Latin-1

 

 

MS-DOS)

TBM-PC-850 Casi el mismo repertorio de Latin-1
(usado también 8 bits pero con códigos diferentes, y

en MS-DOS) diferentes también de IBM-PC-437.
Windows-1252

Coincide con Latin-1 excepto en
8 bits un rango de 32 códigos de Latin-1
que repiten códigos de control

(usado en los

sistemas operativos
MS-Windows)

 

 

 

 

 

En Ct (como en C/C++) los valores del tipo char ocupan 8 bits e incluyen el
repertorio ASCIT. Además incluyen otros caracteres no-ASCIT que dependen
de la tabla de caracteres establecida. En los ejemplos de este libro asumiremos
que se dispone de los caracteres comunes a Latin-1 y Windows-1252. Por
lo tanto la colección de valores del tipo char incluye caracteres alfabéticos,
numéricos, de puntuación y caracteres de control.

Como ya se ha dicho, en el texto de un programa se pueden escribir los valores
de los caracteres, bien directamente, o mediante una secuencia de escape, p.ej.
para los caracteres de control. También se puede representar cualquier carácter
mediante la notación char(z) siendo x el código del carácter. Por ejemplo, en
ASCIL

char(10) Salto al comienzo de una nueva línea. Posición 10%
char(13) Retorno al comienzo de la misma línea. Posición 13%
char(65) Letra A mayúscula. Posición 65%

En sentido inverso, el código numérico de un determinado carácter e se expresa
como int(c). Por ejemplo:

int('A') 65 (65* posición de la tabla ASCII)

int('Z') 90 (90* posición de la tabla ASCII)

De forma inmediata se puede decir que, para cualquier carácter c, cuyo código
sea x, se cumplirá que:
 
  
    
  
 
 
 
 
 
 
 
  
 
  
 
 
 
 
   
 
 
 
    
  
  

Elementos básicos de programación 39

 

char(int(c))

int(char(z)) = x

 

Además conviene saber que la tabla ASCII posee las siguientes características:

+ Los caracteres correspondientes a las letras mayúsculas de la “A' a la Z'
están ordenados en posiciones consecutivas y crecientes según el orden
alfabético.

+ Los caracteres correspondientes a las letras minúsculas de la “a” a la 2?
están ordenados en posiciones consecutivas y crecientes según el orden
alfabético.

» Los caracteres correspondientes a los dígitos del '0' al
en posiciones consecutivas y crecientes.

 

están ordenados

Esto facilita el obtener por cálculo el valor mumérico equivalente al carácter
de un dígito decimal, o la letra mayúscula correspondiente a una minúscula o
<mieversa.

Ez C (y en Ct) se puede nsar también el módulo de librería etype (cabecera
«ctype.h>), que facilita el manejo de diferentes clases de caracteres. Este
módulo incluye funciones tales como:

 

  

ásalpha( e ) Indica si e es una letra
ii( e) Indica si e es un carácter ASCII
€ ) Indica si e es un carácter de espacio o tabulación
€ ) Indica si e es un carácter de control
€ ) Indica si e es un dígito decimal (0-9)
islower( e ) Indica si e es una letra minúscula
isspace( c ) Indica si e es espacio en blanco o salto de línea o página
iswpper( c ) Indica si e es una letra mayúscula
tolower( e ) Devuelve la minúscula correspondiente a €
toupper( « ) Devuelve la mayúscula correspondiente a €

« El concepto de función se introduce en el tema 7, y el de módulo en el tema

Expresiones aritméticas

expresión aritmética representa un cálculo a realizar con valores numéricos
adelante se verán expresiones que utilizan también valores de otros tipos).
expresión aritmética es una combinación de operandos y operadores.

 
40 Fundamentos de programación

 

Para indicar el orden en que se quieren realizar las operaciones parciales se
pueden utilizar paréntesis. Si no se utilizan paréntesis el orden de las operaciones depende de una jerarquía entre los operadores empleados, que para los
operadores numéricos es la siguiente:

1% Operadores multiplicativos: * / %
2% Operadores aditivos: qe =

Dentro del mismo nivel las operaciones se ejecutan en el orden en que están
escritas en la expresión aritmética de izquierda a derecha.

Si una expresión va precedida del signo más o menos, se entiende que solamente
le afecta al primer operando. Si se quiere que afecte a toda la expresión, ésta
deberá incluirse entre paréntesis.

Ejemplos de expresiones entre datos enteros son las siguientes:

Expresión Resultado
5*30+5 155
334 /6%4*5 15
-5 10% 3/2 =L

Cuando la complejidad de la expresión puede dar lugar a posibles errores de
interpretación, es preferible utilizar paréntesis para clarificar cuál es el cálculo
exacto que se quiere realizar. Así las expresiones anteriores son equivalentes a
las siguientes:

(5.* 30) +5
((334 / 6) % 4) *5
(5) * 10) % 3) / 2

Igualmente, ejemplos de expresiones entre valores reales son las siguientes:

 

Expresión Fesul —— Exprosión equivalente
35.3 *5.1/7.6 - 4,5 19.18816 ((35.3*5,1)/7.6)-4.5

-23.1/6.2* 5,4 / 2.4 -8.38306 (((-23.1)/6.2)*5.4)/2.4

Aunque se represente por los mismos símbolos, los operadores aritméticos para
valores reales y enteros son cn realidad diferentes. Así, si se mezclaran en una
misma expresión valores de tipos diferentes, las expresiones aritméticas son
completamente ambiguas. Por ejemplo en las siguientes operaciones:

33.7 / 5 ¿La división a realizar es entera o real?
33 / 5.3 ¡La división a realizar es entera o real?
25 * 3.5 ¿La multiplicación a realizar es entera o real?
 
  
  
   
  
   
   
    
   
  
  
   
  
 
  

tos básicos de programación 41

 

temente, los resultados serán diferentes según el tipo de operación que
realice. Además no queda claro si el resultado que se pretende obtener es
walor entero o real. Para poder realizar estas operaciones combinadas es
io que previamente se realice una conversión de la representación de
datos al tipo adecuado. La representación real de un dato entero se indica
la siguiente manera:

float(45) Representa el valor numérico 45.) con tipo float

forma similar la representación entera de un dato real (correspondiente a
«parte entera, truncando el valor) se consigue de la siguiente forma:

int(34.7) Representa el valor numérico 34 con tipo int

tanto, si queremos obtener un resultado entero, las operaciones entre eny reales anteriormente indicadas se tienen que realizar de la siguiente

Expresión Resultado Tipo
int(33.7) / 5 6 int
33 / int(5.3) 6 int
25 * int(3.5) 75 int

el resultado deseado es un valor real, es necesario realizar previamente
conversiones a. real de los operandos enteros y lógicamente obtendremos
completamente distintos:

 
 
 
  
  
   
 
 
   
   
  

Expresión Resultado Tipo

33.7 / float (5) 6.74 float
float(33) /5.3 6.22642 float
float(25) * 3.5 87.5 float

 

lenguaje C£ permite la ambigijedad que supone la mezcla de tipos de dadiferentes en la misma expresión sin exigir una conversión explícita. Para
la ambigúedad, C+ utiliza el convenio de C/C++ de convertir previade manera automática todos los valores de una misma expresión al tipo
valor con mayor rango y precisión. Por tanto, el resultado siempre se obtambién en el mayor rango y precisión utilizado en la expresión. El
imiento de esta regla implícita, puede dar lugar a que el resultado
una expresión aritmética sea completamente inesperado. Para evitar esta

ión, en el Manual de Estilo para la realización de programas en esta
ura es obligatorio que se realice siempre una conversión explícita de

 
 

42 Fundamentos de programación

 

2.7 Operaciones de escritura simples

 

El objetivo de un programa es obtener unos resultados. Estos resultados deben
ser emitidos al exterior del computador a través de un dispositivo de salida
de datos: impresora, pantalla, trazador (plotter), línea de comunicaciones,
etc. Las acciones que envían resultados al exterior se llaman, en general,
operaciones de escritura, con independencia de que se trate de una impresión
en papel, o la simple visualización en pantalla, o la grabación de los datos en
un soporte donde queden registrados, o su envío a otro equipo remoto.

Existe una gran variedad de dispositivos periféricos, que se diferencian mucho
en los detalles de su manejo. Para simplificar la escritura de resultados los
lenguajes de programación prevén sentencias de escritura apropiadas para ser
usadas con cualquier tipo de dispositivo, facilitando la tarea de programación
al especificar la escritura de resultados de una manera uniforme, con independencia de las particularidades del dispositivo físico que se 1 en cada
caso,

 

Al diseñar un lenguaje de programación se puede optar por usar sentencias o
instrucciones especiales para ordenar la escritura de resultados, o bien ordenar
la escritura del resultado con las mismas sentencias generales que sc empleen
para invocar operaciones definidas por el usnario. Los primeros lenguajes
de programación solían emplear la primera alternativa. Los lenguajes más
modernos utilizan con preferencia la segunda, que simplifica la complejidad
del lenguaje en sí, a costa de permitir a veces una cierta variación en las
operaciones de escritura entre diferentes versiones del lengua

 

 

El lenguaje Ct adopta también la segunda alternativa que es la utilizada en
C/C++. Las operaciones de escritura se definen como procedimientos (ver
tema 7), que se invocan escribiendo el nombre de la operación, seguido de una
serie de valores o argumentos entre paréntesis. Estos procedimientos están
definidos en módulos de librería (ver tema 14) disponibles de antemano.

 

   

 

En todas las versiones de C/C++ deben estar disponibles ciertos módulos
estándar con la definición de operaciones de escritura normalizadas. En este
apartado describiremos una operación disponible en el módulo llamado stdio.

2.7.1 El procedimiento printf

Este procedimiento pertenece al módulo stdio (cabecera <stdio.h>). La
forma más sencilla de invocarlo es escribir:

print£( cadena-de-caracteres );
Elementos básicos de programación 43

 

ANOTA: Esta forma sencilla sólo es válida si la cadena de caracteres a escribir no
eontiene el carácter %.

El procedimiento printf escribe en la pantalla del computador la cadena de
caracteres. Por ejemplo, para cada una de las siguientes operaciones de escri
tara se obtiene el resultado que se muestra a su derecha. Para visualizar con
detalle el resultado se ha utilizado el símbolo “-? para representar el carácter
de espacio en blanco.

 

Operación de escritura Resultado en pantalla
printé( "En un lugar de * ); En-un- lugar: deprint£f( "¿Año de nacimiento?" );  ¿Año-de-nacimiento?

Si lo que se quiere escribir es la representación como texto de una serie de
valores de cualquier tipo de los vistos hasta el momento (enteros, reales, caracteres, etc.), habrá que usar la forma general de la orden printf:

print£( cadena-con-formatos, valor1, valor2, ... valorW );

Una cadena de caracteres con formatos deberá incluir en su interior una. especificación de formato por cada valor que se quiera insertar. La forma más
simple de especificar un formato es mediante %z, es decir, usando el carácter
Sjo % seguido de una letra de código que indica el tipo de formato a aplicar.
Algunos códigos de formato habituales son:

 

Código Nemotécales Tipo de valor
(inglés)
a decimal entero
£ fized point real
e exponential real con notación exponencial
g general real con/sin notación exponencial
€ character un carácter
s string una cadena de caracteres

Por ejemplo, para cada una de las siguientes operaciones de escritura se obtiene
el resultado que se muestra a su derecha:

 

Operación de escritura Resultado
primt£( "%d”, 120 / 12 ); 10
print£( "Datos:%dH%d", 23*67, -50 ); Datos:15414-50
print£( "Datos: %d 4 %d", 23*67, -50 ); Datos: -1541.4--50

Como se puede apreciar en los ejemplos estos formatos simples usan sólo el
número de caracteres estrictamente necesarios para escribir el valor de cada
dato, sin añadir espacios en blanco. Si se quiere separar con espacios unos
valores de otros, entonces hay que incluirlos en el formato.
 

44 Fundamentos de programación

 

Otra forma de conseguir espacios en los resultados es indicar explícitamente
cuántos caracteres debe ocupar el valor de cada dato escrito. Esto se hace
poniendo el número de caracteres entre el símbolo de % y el código del formato.
Ejemplos:

 

 

Operación de escritura Resultado
print£( "X5d", 120/12 ); 710
print£( "Datos:%7dH%5d", 23*6, -50 );  Datos:----138H---50
print£( "%3d", 1000*34 ); 34000

Cuando el múmero de caracteres indicado es insuficiente para representar completamente el valor, como ocurre en el último ejemplo, se utilizan tantos caracteres como sean necesarios para que el resultado aparezca completo.

Además, cuando se utiliza un formato £, e ó g se puede especificar tambión el
número de cifras decimales que se deben escribir después del punto decimal.
Por ejemplo:

 

 

Operación de escritura Resultado
print£( "X10.38", 1.2); ==.1.200
print£( "%10.4e", 23.1%67.4 ); — 0.1557E+04
print£( "%15.3g", -50.6E-6 ); -»-0.506E-04

   

 

Salvo que se indique otra cosa, los resultados obtenidos mediante sucesivas
sentencias de escritura van apareciendo en el dispositivo de salida uno tras
otro en la misma línea de texto. Por ejemplo, las siguientes sentencias de
escritura:

print£( "Area = " );

print£( "%10.4f", 24.45 );

print£( "Mi ciudad es Avila" );

print£( "Descuento: "
print£( "%5.2d", 12.5
print£( "%c", %' );

   

 

producen el resultado siguiente (se prescinde ya del símbolo *«? para representar un espacio en blanco):

 

Area = 24.4500Mi ciudad es AvilaDescuento: 12.50%

Para escribir resultados en varias líneas de texto habrá que recordar que dentro
de una cadena se pueden incluir caracteres especiales mediante secuencias
de escape. Más concretamente, si queremos dar por terminada una línea de
resultados y pasar a escribir en la siguiente bastará con incluir en el punto
adecuado la secuencia de escape An. Por ejemplo, si se modifican ligoramente
las anteriores operaciones de escritura:
 

Elementos básicos de programación 45

 

print£( "Area =");

print£f( "%*10.4fin", 24.45 );
print£( "Mi ciudad es Avilatn" );
print£( "Descuento: ;
printf( "%5.2d", 12.5 );
printE( cn", 0%);

 

se obtendrá como resultado:

 

¡Area =  24.4500
¡MG ciudad es Avila
|Descuento: 12.50%

2.8 Estructura de un programa completo

Con los elementos introducidos hasta este momento pueden formarse ya programas completos. Sólo falta indicar cuál es la estructura global del programa.

Un programa en C+ se engloba dentro de una estructura principal o main().
Un ejemplo de programa muy sencillo es el siguiente:

 

/*= Programa: Hola */
|/* Este programa escribe "Hola" */

'sinclude <stdio.h>

lint mainO) £
print£( "Holaya" );
py

 

Podemos observar que en el texto del programa aparece una línea precedida
del símbolo 4. Con este símbolo comienzan lo que se llaman directivas para el
compilador. En concreto con la directiva Kinclude se indica al compilador que
utilice el módulo de librería stdio (cabecera <stáio.h>) para las operaciones
de escritura que se realizarán en el programa. De hecho la directiva Kinclude
será la única que se usará en C£.

El cuerpo del programa contiene las sentencias ejecutables correspondientes
a las acciones a realizar, escritas entre los símbolos £ de comienzo y 3 final.
Cada sentencia del programa termina con un punto y coma (;).

Es conveniente recordar que todos los programas en C+ se deben guardar en
un fichero con el nombre del programa y la extensión .cpp. Así, el nombre
del fichero fuente de este programa deberá ser: hola.cpp.
 

46 Fundamentos de programación

 

Una vez compilado y ejecutado este programa de ejemplo produce, como es
de esperar, el siguiente resultado:

 

[hola

En el anterior ejemplo de programa aparece también un nuevo elemento no
mencionado hasta el momento, y que se explica a continuación.

2.8.1 Uso de comentarios

El código de un programa en un lenguaje de programación tal como C, C++
o Ci puede no ser suficiente, en muchos casos, para comprender el sentido del
programa. Casi siempre es conveniente alguna aclaración adicional que explique el significado exacto de los elementos usados para desarrollar el programa.
Estas aclaraciones facilitan la labor de una posible modificación posterior del
programa por nosotros mismos u otros programadores.

 

Todos los lenguajes permiten incluir dentro del texto del programa comentarios
que faciliten su comprensión. Estos comentarios sirven sólo como documentación del programa fuente, y son ignorados por el compilador, en el sentido de
que no pasan a formar parte del código objeto al que se traducirá el programa.

En Ct los comentarios se incluyen dentro de los símbolos /* y */.. Por ejemplo:

/* ¡Ojo!. Esto es un comentario */

2.8.2 Descripción formal de la estructura de un programa

La descripción formal de la estructura (simplificada) de un programa es la
siguiente:
Program ( Include Y int main(O) Bloque

Htinclude <Nombre_módulo.h>

  
 

Include

Cada directiva debe ocupar una línea del programa ella sola. En los lenguajes
C y C++ hay una gran variedad de directivas, pero en Ci se utilizará casi
exclusivamente la directiva *include, que sirve para indicar que el programa
utilizará un determinado módulo de librería. El parámetro Nombre_módulo
corresponde en realidad al nombre del fichero de cabecera (header) del módulo.

El resto del código del programa se podría repartir en líneas de código como se
desce, aunque en el Manual de Estilo de Ct se exigirá un estilo de presentación
uniforme, tal como se irá indicando a medida que se introduzcan los elementos
del lenguaje.
 

Elementos básicos de programación 47

 

La estructura de un bloque solamente puede indicarse de momento de forma
simplificada, ya que sólo se han visto los elementos mínimos necesarios para
escribir un programa. Por ahora diremos que un bloque puede contener una
secuencia de sentencias:

 

£ Parte_ejecutiva Y

[ Sentencia )

La única sentencia que se ha descrito hasta el momento es la orden de escritura
printf. Más adelante se irán introduciendo nuevas sentencias de Ct.

Bloque

 

Parte ejecutiva

2.9 Ejemplos de programas

En este apartado se muestran programas completos que pueden ser compilados
y ejecutados de manera directa e inmediata. Aunque estos ejemplos son de
una gran sencillez, permiten ilustrar los conceptos introducidos en este tema,

2.9.1 Escribir una fecha

En este ejemplo se escribe una fecha. El día y el año se escriben como valores
numéricos, y el mes como un texto.

 

/** Programa: EscribirFecha */
/* Escribe la fecha del descubrimiento de América */

 

*include <stdio.h>

 

int main) €
printí( "%2d", 12 );
print£( " de Octubre de" );
print£( "Xsdin", 1492 );

y

 

La ejecución del programa produce el signiente resultado (usando el símbolo
*-> para representar el espacio en blanco):

 

[12.de.Octubre-de-1492

Obsérvese cómo se han incluido los espacios en blanco en las sentencias de
escritura.
48 Fundamentos de programación

 

2.9.2 Suma de números consecutivos

Con este programa se trata de obtener la suma de una serie de números consecutivos, desde uno inicial a otro final. Para su obtención utilizaremos la
fórmula de la suma de una progresión aritmética. Si n es el número de términos, a, el primer término, y y el último, la fórmula general de la suma
es:

 

Y ¿As
a=n
i=l 2

Y para una serie de números enteros consecutivos se cumple que:
n=a,-a,+l

El listado del programa es el siguiente:

 

/*= Programa: SumarNumeros */
/* Este programa calcula e imprime la suma
de los números correlativos desde 4 hasta 45

El algoritmo empleado es el utilizado para
calcular la suma de una progresión aritmética:
Suma = (Final — Inicial + 1) * (Inicial + Final) / 2
Y
*include <stdio.h>

ánt mainQ) (
print£( "La suma de los números desde 4 hasta 450" );
print£( "es igual a: ");
print£( "X5din",(45 - 4 +1) * (45 +4) /2);

 

,

 

 

La ejecución del programa produce el siguiente resultado:

 

La- suma: de-los-números - desde-4-hasta-45
es-igual-a:--1029

 

Es interesante analizar la manera en que se evalúa la expresión aritmética,
dado que / trunca el resultado. Si se hubiera escrito la expresión de la forma
que sugiere la fórmula de la suma de la progresión aritmética, tal como se ha
presentado anteriormente:

(45 -4+1)* ((45+4)/2)

se obtendría un resultado erróneo igual a 1008, al producirse el truncamiento
de la división por 2 antes de multiplicar.
 

Elementos básicos de programación 49

 

2.9.3 Área y volumen de un cilindro
En este tercer programa sencillo se obtienen el área y el volumen de un cilindro
E partirde suradio Ryeu altura A:
área = MR +2MRA = IR(R+A)
volumen = TRA
DS listsiodál programa eel siguiente:

 

/** Programa: Cilindro */
/* Cálculo del área y el volumen de un cilindro */

Finclude <stdio.h>

ánt main() €
print£( "%sta", "Dado un cilindro de dimensiones:" );
print£( "%sin", "radio = 1,5 y altura = 5,6" );
print£( "%s", "su area es igual a: "
print£( "%glw", 2.0*3,141592*1.5*(1.5*5.6) );
print£( "%s", "y su volumen es igual a:" );
print£( "%20.8f£in", 3.141592*1.5*1.5*5.6 );

3

   

 

La ejecución del programa produce el siguiente resultado:

 

Dado un cilindro de dimensiones:

radio = 1,5 y altura = 5,6

su área es igual a: 66.9159

y su volumen es igual a: 39.58405920

En este ejemplo se ha renunciado a marcar expresamente los espacios en blanco
impresos por el programa, para facilitar la lectura de los resultados.
 

Tema 3

Constantes y Variables

Este tema complementa el anterior con nuevos elementos que permiten construir programas algo más realistas.

Primeramente se indica el interés que tiene dar nombre a las constantes que
se manejan en los programas. A continuación se introduce el concepto de
wariable. Este concepto es muy importante y una gran parte del tema está
organizada en torno a él. De hecho la existencia de variables constituye el
elemento diferenciador del paradigma de la programación imperativa respecto
a los demás.

El tema se completa con la presentación de varias sentencias de lectura simple.
Estas sentencias permiten construir programas en los que se pueden introducir
valores para ser usados durante su ejecución.

3.1 Identificadores

La manera de hacer referencia a los diferentes elementos que intervienen en
un programa es darles un nombre particular a cada uno. En programación se
llaman identificadores a los nombres usados para identificar cada elemento del
programa.

En el tema anterior ya se han utilizado identificadores para dar nombre a
elementos tales como los tipos de datos, las operaciones de escritura, etc.,
que se suministran ya con un significado determinado. Ahora se inventarán
nombres para designar variables y constantes en el programa.

En Ct los identificadores son una palabra formada con caracteres alfabéticos
o numéricos seguidos, sin espacios en blanco ni signos de puntuación inter
 
 

52 Fundamentos de programación

 

calados, y que debe comenzar por una letra. Pueden usarse las 52 letras
mayúsculas y minúsculas dol alfabeto inglés, el guión bajo (_), y los dígitos
decimales del 0 al 9.
Ejemplos de identificadores válidos son los siguientes:

Indice diaDelMes Nombre_Apellido

E Eje_3 IdentificadorMuyyyyyyLargo
No serían válidos los siguientes identificadores:

3_Eje No puede comenzar por un dígito

14508 No se pueden usar los caracteres: 4 y $

dia Del Mes No se pueden intercalar blancos

Año No se puede utilizar la letra ñ

Es importante resaltar que las letras ñ o Ñ o las vocales acentuadas no están
incluidas en el alfabeto de la mayoría de los lenguajes de programación, y
por supuesto tampoco en Ct, por lo que no pueden formar parte de ningún
identificador. Sin embargo, estas letras sí pueden ser utilizadas como valores
de tipo char o formando parte de una cadena,

Ci distingue las letras mayúsculas de las minúsculas. Así, son identificadores
distintos los siguientes:

DiaSemana Diasemana diaSemana DIASEMANA

En general, se debe tener cuidado al utilizar identificadores que difieran en
pocas letras y en particular que difieran sólo en el uso de las letras mayúsculas
o minúsculas para distinguir identificadores diferentes. En estos casos, es difícil

distinguir entre un cambio de alguna. letra por error y una utilización correcta
de identificadores distintos.

Las reglas exactas para la formación de identificadores en Ct son las siguientes:

 

Identificador 33= Letra Í Letra | Guión | Dígito )

Letra 333
alelclolelriolalrls]x]i]m1
A IA El
alblclalelrlglnlililxlifol
nlolplalrIsIrlulvlwlxIvlz

 

=ol1l2lal«lsl6l718lo

A la hora de inventar nombres conviene seguir nnas reglas de estilo uniformes
que faciliten la lectura del programa. En el Manual de Estilo de Ct se sugieren,
entre otras, las siguientes:
Constantes y Variables 53

 

+ Por defecto, escribir todo en minúsculas:
indice nombre apellidos area
+ Escribir en mayúsculas o empezando por mayúsculas los nombres de
constantes que sean globales o que sean parámetros generales del programa:
Pi NULO MAXIMO
+ Usar guiones o mayúsculas intermedias para los nombres compuestos:
diaDelMes ANCHO_MAXIMO dia_del_mes

3.2 El vocabulario de Ct

Además de los identificadores usados para nombrar diferentes elementos, en un
programa podemos encontrar otras palabras que siguen las mismas reglas de
formación que los identificadores pero que realmente no son nombres. Se trata
de las palabras clave, que sirven para delimitar determinadas construcciones
del lenguaje de programación.

Las palabras clave son elementos fijos del lenguaje. También son elementos
£jos del lenguaje los nombres de los tipos fundamentales y los de algunas
funciones especiales incorporadas en el propio lenguaje. Este conjunto de
«lementos fijos se denominan palabras reservadas, y no pueden ser redefinidas
por el programador para utilizarlas con otros fines. Las palabras reservadas
en el subconjunto Ci son las siguientes:

bool break case catch char const default
delete do else enum extern false float
for if int new private return struct

switch true try typedef union void while

Aunque en CE sólo usaremos las palabras reservadas que se han indicado, para
poder compilar los programas con compiladores de C+-+ deberemos considerar
también como palabras reservadas todas las del lenguaje completo, y no sólo el
subconjunto empleado en este libro. La lista completa de palabras reservadas

es:

 
54 Fundamentos de programación

 

and and_eq asm auto bitand  bitor
bool break case catch char class
compl const const_cast continue default
delete do double dynamic_cast else
enum explicit extern false float for
friend goto if inline int long
mutable  namespace new not not_eg operator
or or_eq private protected public register
Teinterpret_cast return short signed sizeof
static static_cast struct switch template
this throw true try typedef  typeid
typename union unsigned using virtual void
volatile wchar_t while xor xor_eq

Además de las palabras de la lista anterior hay algunos identificadores que
sin estar reservados en C++ tienen un significado preciso en cada programa.
en el que aparezcan. Por lo tanto tampoco deberían ser redefínidos por el
programador para otros fines. Por ejemplo:

main NULL std string

En Ci se considerarán también estos identificadores como palabras reservadas,
y por lo tanto será un error redefinirlos.

3.3 Constantes

En primer lugar se introduce el concepto de constante y a continuación se
explica cómo se manejan las constantes en CE,

3.3.1 Concepto de constante

Una constante es un valor fijo que se utiliza en un programa. El valor debe
ser siempre el mismo para cualquier ejecución del programa, es decir, el valor
no puede cambiar de una ejecución a otra. Son ejemplos de constantes el
número de meses del año, el número de días de una semana, las constantes
matemáticas tales como el número r, los factores de conversión de unidades
físicas de medida, etc.

Hasta el momento se ha visto la manera de representar valores constantes en un
programa escribiéndolos explícitamente, en forma de constantes literales, como
se las denomina en programación. Otra posibilidad es definir estos valores
como constantes simbólicas o constantes con nombre.
y Variables 55

Declaración de constantes con nombre

   
  
 
 
   
   
    
  
  
  
 
   
   
 
     
 
    
    
  
  
   
   

declaración de un valor constante con nombre consiste en asociar un idena dicho valor constante. La declaración de la constante especifica su
'ambre y tipo y el valor asociado. Si queremos declarar el valor de la constante
asociado al nombre Pi escribiremos;

float Pi = 3.14159265;

 

 

La declaración se inicia con la palabra clave const, y a continuación se escriben
“sl tipo y nombre simbólico de la constante, seguidos del signo igual y el valor
asociado.

Las constantes con nombre han de ser declaradas en el programa antes de ser
atilizadas. Una vez definida la constante se puede utilizar su nombre exactamente igual que si fuera su valor explícito. Por ejemplo, serán equivalentes la
dos expresiones siguientes:

2 * 3.14159265 * R y 2” H "RX

Algunos ejemplos de declaración de constantes son los siguientes:
¡const int largo = 34;

const int ancho = 78;

¡const char dospuntos = ':';

const float NumeroE = 2.718281828450;

const char Pregunta[] = "¿Código postal?";

const float radio = 1.5;

Como puede verse, el tipo de valor de una constante se declara explícitamente,
y no viene forzado por el valor constante literal que se le asocia. En el caso
de la constante Pregunta su tipo es cadena de caracteres y la forma en que se
declara es utilizando los símbolos [] a continuación del nombre de la constante.
La siguientes constantes tienen tipos diferentes, aunque se use el mismo valor
literal para ambas:

const int  minimaTemperatura = -50;

const float temperaturaMinima = -50;

Una posibilidad interesante es poder declarar el valor de una constante en
forma de expresión. En C£ sólo se permite hacer esto si la expresión puedo
ser evaluada por el compilador en el momento de traducir el programa fuente
a programa objeto. Para ello es necesario que todos los operandos que intervengan en la expresión sean valores constantes, y que las operaciones entre
ellos sean operadores fijos del lenguaje o funciones predefinidas (que tienen
56 Fundamentos de programación

identificadores predefinidos). En este caso la expresión se denomina expresión
constante. Los operandos constantes pueden ser valores explícitos o constantes
con nombre declaradas en algún punto anterior del programa.

Por ejemplo, tras las declaraciones de los ejemplos anteriores se podría añadir:

const float diametro = 2*radio;

const int  constanteRara= (23 * 5) / ((7 - 4) % 2));
const int area = largo * ancho;

const int perimetro = 2*(largo + ancho);

Todas estas constantes con nombre se pueden utilizar exactamente igual que
el valor literal que representan. Por ejemplo, el resultado de las siguientes
operaciones de escritura sería;

Operación de escritura Resultado
print£( "%s ", Pregunta ¿Código-postal?printf( "%x9.2dH%5d", radio, area ); +... .1.50%-2652
print£( "%e", dospuntos ); :

 

 

 

En la primera de estas operaciones de escritura se hace uso del código de

formato %s para la escritura de una cadena de caracteres con el procedimiento

printf.

Las reglas precisas que han de seguir las declaraciones de constantes con nom
bre son las siguientes:
Declaración _de constante

const Tipo Nombre = Expresión constante ;

Tipo +3= Identificador

Identificador

Una expresión constante incluye, como caso particular, un único término que
sea un valor explícito.

 

 

Nombre

3.4 Variables

En este apartado se introduce el concepto de variable y a continuación se
explica cómo se declaran y utilizan las variables en C£.

3.4.1 Concepto de variable

El concepto de variable en programación imperativa es diferente del concepto
de variable algebraica. Cuando escribimos expresiones algebraicas usamos
Constantes y Variables 57

 

variables para representar un valor indefinido, pero fijo. Por ejemplo, cuando
escribimos la igualdad:

(a+b)?= 024 2ab +0?
queremos indicar que dicha igualdad se cumple asociando a y b con valores

cualesquiera, pero siempre los mismos. No tiene sentido pretender que a tenga
un valor en una parto de la expresión y otro diferente en otra parte.

Algo similar ocurre cuando escribimos fórmulas matemáticas o leyes físicas,
que ligan diversas magnitudes. Por ejemplo, la fórmula del volumen (V) de
un cilindro en función de su radio (RR) y su altura (4) es:

V=HTRA
Una vez asociadas las variables R y A con el radio y altura de un cilindro en
particular, la variable Y debe tomar necesariamente el valor del volumen de
dicho cilindro.
Insistiendo en esta idea, consideremos un sistema de ecuaciones, tal como:

3x4 5y=19
7a-5y=11

Las variables x e y, denominadas incógnitas, representan los valores, inicialmente desconocidos, que satisfacen dichas ecuaciones, y en concreto:

Con todo ello insistimos en que las variables algebraicas representan valores
simbólicos, bien valores cualesquiera, o bien valores desconocidos, pero de
manera que una vez asociada la variable a un valor determinado dicho valor
zo debe cambiarse.

En programación el concepto de variable es diferente, y está directamente asosiado a la memoria del computador. Esta memoria permite almacenar información para ser usada posteriormente. La función de la memoria es mantener
dicho valor todo el tiempo que sea necesario para usarlo tantas veces como se
necesite.

Los valores almacenados en la memoria pueden ser modificados cuantas veces
se desce. Al almacenar un valor en un elemento determinado de la memoria,
dicho valor se mantiene de ahí en adelante, pero sólo hasta que se almacene
en dicho elemento un nuevo valor diferente.

Las variables en los lenguajes de programación imperativos son el concepto
abstracto equivalente a la memoria física de la máquina. Una variable representa un valor almacenado que se puede conservar indefinidamente para ser

 
58 Fundamentos de programación

 

usado tantas veces como se desee. El valor de una variable se puede modificar
en cualquier momento, y será el nuevo valor el que estará almacenado en ella
a partir de entonces.

Las variables de un programa se designan mediante nombres o identificadores.
El identificador de una variable representa el valor almacenado en dicha variable. El programador puede elegir los nombres que considere más apropiados
para las variables que utilice en su programa.

3.4.2 Declaración de variables

Cada variable en un programa en C£ debe tener asociado un tipo de valor
determinado. Esto quiere decir que si una variable tiene asociado el tipo int,
por ejemplo, sólo podrá almacenar valores de este tipo, pero no valores de tipo
float u otro diferente.

Las variables han de ser declaradas en el programa antes de ser utilizadas.
La declaración simple de una variable especifica su nombre y el tipo de valor

asociado. Por ejemplo, para usar una variable que almacene la edad de una
persona como un número entero de años, podríamos declarar:

[int edad;
Podemos observar que la declaración consiste simplemente en escribir el tipo
y el nombre de la variable. La declaración termina con punto y coma (5).

Si varias variables tienen el mismo tipo, se pueden declarar todas conjuntamente, escribiendo sus nombres seguidos, separados por el carácter coma (,)
detrás del tipo común a todas ellas. Por ejemplo:

[int dia, mes, anno;

La descripción BNF (simplificada) de una declaración de variables es la siguiente:

 

Declaración _de_variable Tipo Nombre Í. , Nombre Y

Identificador
= Identificador

Por el momento las posibilidades de especificación de tipos se limitan a los tipos
predefinidos presentados hasta ahora; más adelante se indicará la manera de
definir nuevos tipos.

 

 

Tipo +3

 

Nombre
Constantes y Variables 59

 

3.4.3 Uso de variables. Inicialización

El valor almacenado en una variable puede utilizarse usando la variable como
operando en una expresión aritmética. El tipo declarado para cada una de las
variables determina las operaciones que posteriormente se podrán realizar con
ella, de la misma forma que sucedía para los valores literales según se explicó
en el tema anterior.

Por ejemplo, si declaramos las variables:

int base, altura;

int saldo, meses, dias;
float volumen, area, gastos;
¡char modelo, codigo;

podremos escribir expresiones tales como:
ES * altura

días + int( codigo )
'volumen / area

pero sería inapropiado escribir

area / base
saldo + gastos
base + modelo

porque combinan operandos de tipos diferentes.

Si se usan correctamente los tipos de operandos para cada operación, en una
misma expresión pueden intervenir operandos de diferentes clases. Por ejemplo, pueden usarse a la vez variables, constantes con nombre y valores muméricos constantes. Con las declaraciones de constantes de la sección anterior y
las variables de los últimos ejemplos se podría escribir:

Pi * volumen * 5.7

base * altura / constanteRara

float( saldo ) + NumeroE

int( area ) / ancho % 5

Estos ejemplos de expresiones son formalmente correctos, de acuerdo con las
reglas de Ci, pero no se pretende que tengan ningún sentido intuitivo que se
ajuste al significado de los nombres empleados.

Con independencia de que las operaciones con variables sean consistentes con
los tipos de valores que almacenan, para que sea válido evaluar una expresión
aritmética en la que intervengan variables es necesario que todas ellas tengan

   
 

60 Fundamentos de programación

 

un valor definido. Tal como se ha dicho anteriormente, los nombres de las
variables representan los valores almacenados en ellas. Si en una variable
no se ha almacenado todavía ningún valor, su uso conduce a un resultado
imprevisible,

 

Para usar una variable de manera correcta es necesario inicializarla antes de
usar su valor en ningún cálculo. Inicializar una variable es simplemente darle
un valor determinado por primera vez.

 

Para cvitar confusiones, en el Manual de Estilo de C+ sólo está permitido
especificar el valor inicial de una variable en una declaración individual para
esa variable, Por tanto, no está permitido realizar inicializaciones de ninguna
variable cuando so declaran como una lista de variables del mismo tipo. Para
inicializar la variable, su nombre irá seguido del signo igual (=) y a continuación
su valor inicial, de forma similar a una declaración de constante:

float gastos = 0.0;
[char modelo = '?*

 

 

omo no es obligatorio dar valor inicial a todas las variables, unas pueden
llevar valor inicial y otras no;

int base:
ánt  altura=0;

float volumen, area, gastos;
char modelo="?*

char codigo;

 

 

La descripción BNF (corregida) de la declaración de variables, con valor inicial
opcional, es la siguiente:

Declaración _de_variable 333 Variable_simple | Lista_de_variables

 

Variable_simple 33= Tipo Nombre [ = Expresión ]
Lista de variables 333 Tipo NombreÍ , Nombre Y
Identificador

Identificador

 

Tipo *

 

Nombre

Si no se especifica el valor inicial al declarar la variable, entonces deberá ser
inicializada en el momento adecuado asignándole valor de alguna manera durante la ejecución del programa, antes de usar el valor almacenado para operar
con él.
 

Constantes y Variables 61

 

3.5 Sentencia de asignación

Una forma de conseguir que una variable guarde un determinado valor es
mediante una sentencia de asignación. Esta sentencia es característica de
la programación imperativa, y permite inicializar una variable o modificar el
valor que tenía hasta el momento. Mediante asignaciones podremos dar valores
iniciales a las variables, o guardar en ellas los resultados intermedios o finales
de cualquier programa.

La estructura de una sentencia de asignación es la siguiente:

Asignación 33% Variable = Expresión ;
Variable += Identificador

Por el momento la única manera que se ha presentado de hacer referencia a
una variable es usando su nombre. Más adelante se indicarán otras formas
de hacer referencia a variables, especialmente en el caso de que la variable
designada sea parte de una estructura de datos.

El signo igual (=) es el operador de asignación. Este operador indica que el
resultado de la expresión a su derecha debe ser asignado a la variable cuyo
identificador está a su izquierda. Por ejemplo, la secuencia de asignaciones
siguiente:

base = 18;
area = 56.89;
codigo =

 

sustituye los valores que tuvieran las variables base, area y codigo hasta ese
momento por los nuevos valores 18, 56,89 y la letra “2”, respectivamente.

Si intervienen variables en la expresión a la derecha de una sentencia de asignación, se usará el valor que tenga la variable en ese momento. Por ejemplo,
la siguiente secuencia de asignaciones:

meses = 2;
dias = meses;
meses = 7;

 

saldo = meses;

dejará finalmente almacenados en las variables meses, dias y saldo los valores
7, 2 y 7, respectivamente.

Un caso especial, que requiere cierta atención, es aquél en que a una variable

se le asigna el valor de una expresión de la que forma parte la propia variable.
Por ejemplo:
 

62 Fundamentos de programación

| dias = dias + 30;

Esta asignación recuerda a una ecuación, pero su significado es completamente diferente. Esta sentencia es una orden de evaluar primero la expresión a
la derecha usando el valor que tenía la variable hasta ese momento, y luego
modificar el valor de la variable almacenando en ella el resultado de la expresión. En este ejemplo, si la variable dias tenía el valor 16, esta sentencia
almacenará en ella el nuevo valor 46. En general, al ejecutar esta sentencia de
asignación, el valor de la variable dias se incrementará en 30 unidades.

3.5.1 Sentencias de autoincremento y autodecremento

Resulta bastante frecuente la necesidad de incrementar en uno el valor de una
variable, Para ello, empleando la sentencia de asignación se tiene que escribir:

[variable = variable + 1;

Para simplificar y aumentar la claridad del programa, en C£ se dispone de
una sentencia especial de autoincremento que utiliza el símbolo ++. Así, en
lugar de la sentencia de asignación anterior se suele utilizar habitualmente la
sentencia de autoincremento de la siguiente manera:

| variable++;

De forma semejante cuando se necesita decrementar una variable en una unidad, C+ dispone de la sentencia especial de autodecremento que utiliza el
símbolo -- y que se escribe:

| variable--;

Esta sentencia es equivalente a la sentencia de asignación:

|variable = variable - 1;

3.5.2 Compatibilidad de tipos

Una sentencia de asignación puede resultar confusa si el tipo de la variable
y el del resultado de la expresión son diferentes, de manera similar a lo que
ocurre con na operación aritmética entre operandos de tipos diferentes. El
lenguaje Ct no es fuertemente tipado y permite la ambigiedad que supone la
asignación de un valor de un tipo a una variable de otro tipo. Para salvar la
ambigiledad, C£ utiliza el convenio de C/C++ de convertir previamente de
manera automática el valor a asignar al tipo del valor de la variable. De todas
Variables 63

 

 

«maneras, para evitar confusiones, en el Manual de Estilo se establece que para
la realización de programas en Ct es obligatorio que se realice siempre una
conversión explícita de tipos en estos casos. Ejemplo:

ánt saldo;

float gastos;

saldo = int(gastos);

Para finalizar este apartado se presenta una declaración de variables y luego
la traza de una secuencia de sentencias de asignación. En el lado izquierdo
se muestran los valores que guardan las variables inmediatamente antes de la
ejecución de cada sentencia. Nótese que las variables tienen un valor indefinido
hasta que son inicializadas asignándoles valor por primera vez.

Declaración:

ánt posi, dato;

float ejeX, ejeY;

 

Traza de ejecución:
ejeX ejeY dato posi Secuencia de sentencias
7 E T 7 ejeX = 34.89;
34.89 ? Y 7 dato = 67;
34.89 ? 67 ? posi = int(ejeX) + dato;
34.89 y 67 101 dato = int(ejeY) + posi;
34.89 P ? 101 ejeY = ejeX + float(posi);
34.89 135.89 q 101 dato = posi / 5;
34.89 135.89 20 101 posi = posi % 5;
34.89 135.89 20 1 posi = posi * dato;
34.89 135.89 20 20 ejeY = ejeY/ejex;
34.89 3.8948 20 20 ejeX = ejeX/2.0;
17.44 3.8948 20 20 posi = int(ejeY) - posi;
17.44 3.8948 20 17

Los datos representados con interrogación (?) significan valores imprevisibles,
debidos a variables no inicializadas cuyo contenido no puede conocerse con
seguridad. Obsérvese que la variable dato, después de tomar un valor definido
(67), vuelve a tomar un valor arbitrario al asignársele el resultado de una
expresión en la que participa la variable ejeY que todavía estaba sin inicializar.

 
64 Fundamentos de programación

 

3.6 Operaciones de lectura simple

Los programas presentados hasta el momento producen siempre el mismo resultado cada vez que se mandan ejecutar. Por ejemplo, con los elementos
introducidos hasta ahora se podrían escribir programas para calcular la suma
de los números del 4 al 45 o imprimir la nómina de Febrero del Sr. González.
Programas que produzcan resultados fijos son poco habituales en la práctica.
Bastaría ejecutarlos una sola vez, guardar los resultados y reproducirlos tantas
veces como se necesiten, sin tener que repetir la ejecución del programa.

Los programas habituales suelen resolver problemas genéricos. Por ejemplo,
obtener la suma de N números desde uno inicial a otro final, o calcular cada
mes la nómina de cada uno de los empleados de una empresa. Un programa
que produzca cada vez resultados diferentes deberá operar en cada caso a
partir de unos datos distintos, y dichos datos no pueden ser, por tanto, valores
constantes que formen parte del programa.

Para resolver cada, vez el problema concreto que se plantea, el programa, debe
leer como datos de entrada los valores concretos a partir de los cuales hay
que obtener el resultado. Por ejemplo, los valores inicial y final de la serie de
números a sumar, o el nombre del empleado cuya nómina se quiere calcular
y el mes al que corresponde, Por consiguiente, las operaciones de lectura son
fundamentales dentro de cualquier modelo de programación.

En Cx, los datos leídos han de ser guardados inmediatamente en variables
del programa. Por tanto, otra manera de asignar un valor a una variable
es almacenar en ella un valor introducido desde el exterior del computador
mediante el teclado u otro dispositivo de entrada de datos.

Las operaciones de lectura, al igual que las de escritura, pueden presentar
grandes diferencias dependiendo del dispositivo utilizado. Pero, también en
esto caso, existe en C+ un conjunto de procedimientos generales para la lectura
de datos, que son invocados siempre de la misma manera, con independencia
del dispositivo de entrada utilizado. Por defecto, el dispositivo de entrada
suele estar asociado al teclado del terminal por el que se accede al computador
Estos procedimientos están incluidos también en el módulo de librería stdio.

Los datos a leer se suministran externamente en forma de texto, es decir, como
una serie de caracteres seguidos (o pulsaciones de teclas) que pueden incluir
saltos de línea de vez en cuando. En el teclado, el salto de línea corresponde a.
la tecla marcada “INTRO” o “ENTRAR?” (en teclados ingleses, “RETURN”
o “ENTER”)
 

Constantes y Variables 65

 

3.6.1 El procedimiento scanf

El procedimiento scanf pertenece al módulo de librería stdio. Para leer datos
de entrada y almacenarlos en determinadas variables se escribi

 

 

scanfí cadena-con-formatos, gvariablel, Evariable2, ... GvariableN );

Es importante observar que los nombres de las variables a leer van precedidos
del carácter ampersand (8).

 

A continuación se presenta un ejemplo de uso de este procedimiento de lectura.
Declaración de variables int mes, dia; float saldo;

Datos de entrada. 123 4.5 6

Orden de lectura scan£( "%d X£ %d", Gmes, Gsaldo, Edia );
Resultado mes = 123; saldo = 4.5; dia = 6;

La cadena de caracteres con los formatos sigue las mismas reglas que la del
procedimiento printf del tema anterior. Debe contener un formato de consersión (%z) por cada variable a leer. Al ejecutarse el procedimiento scanf
=e van tomando caracteres del dispositivo de entrada, se ponen en corresponencia con los formatos indicados, y se extraen los valores correspondientes a
cada formato de conversión para asignarlos a cada variable de la lista, respectivamente.

Al igual que en el procedimiento printf, la cadena con los formatos puede
incluir también otros fragmentos de texto entremezclados con los formatos de
conversión. La ejecución de scanf consiste en analizar uno a uno los elementos
de la cadena con formatos, y actuar en consecuencia, avanzando en el texto
de entrada:

1. Un formato numérico (%d, %£, %g, ...) hace que se salten los siguientes
caracteres de espacio en blanco en la entrada, si los hay. A continuación
se leen los caracteres no blancos que formen una representación válida
de un valor numérico del tipo correspondiente al formato, y el valor numérico obtenido se asigna al siguiente argumento de la lista de variables
a leer.

2. Un formato %c hace que se lea exactamente el siguiente carácter de la
entrada, sea. o no espacio en blanco, y se asigne a la siguiente variable a
leer.

3. Un carácter de espacio en blanco en la cadena con formatos hace que
se salten los siguientes caracteres de espacio en blanco en el texto de
entrada, si los hay.

4. Un carácter no blanco en la cadena con formatos hace que se lea (y se
salte) el siguiente carácter de la entrada, que debe coincidir exactamente
con el carácter del formato.
66 Fundamentos de programación

 

Si alguna de las acciones anteriores no puede realizarse, porque el texto de
entrada no contiene los caracteres apropiados, la ejecución de scanf se interrumpe en ese momento, y no se lee más texto de entrada ni se asignan valores
a las variables que falten por leer.

Los formatos de conversión mumóricos pueden incluir la especificación del tamaño del dato, de forma similar a como se dijo para printf. Pero a diferencia
de los formatos para printf, en que ese tamaño era el mínimo número de caracteres a escribir, en scanf significa el tamaño máximo del dato de entrada
a leer. Por ejemplo:

 

Datos Formato Dato leído Datos restantes
12345xx %d 12345 xx
12345xx »3d 123 45xx
120345 %3d 2 xx345

3.6.2 Lectura interactiva

Cuando un programa se comunica con el usuario mediante un terminal de
texto se suele programar cada operación de lectura inmediatamente después
de una escritura en la que se indica qué dato es el que se solicita en cada
momento. Por ejemplo:

float saldo

printf( "¿Cantidad Pendiente? " );
scanf( "%f", saldo );

Tras ejecutar la escritura del texto de petición, en la pantalla se verá:

 

[¿cantidad Pendiente? m

En ese momento se inicia la ejecución del procedimiento de lectura, El símbolo
(m2) se utiliza aquí para indicar la posición del cursor en la pantalla, en espera
de la entrada del dato solicitado.

Cuando se introduce información por el teclado es ventajoso que se pueda
corregír el texto que se va tecleando en caso de cometer errores. Para ello la
lectura de teclado se suele hacer por líneas completas. Mientras se teclea el
texto de una línea se pueden hacer correcciones, y al pulsar la tecla de fin de
línea el texto se acepta y se procesa como dato de entrada. El texto aparece
en la pantalla al mismo tiempo que se va tecleando o corrigiendo. Todo esto
es automático, y se hace directamente al invocar el procedimiento de lectura
de Ct.
Constantes y Variables 67

 

  

En el ejemplo anterior, se tecleará el dato acabando con la tecla de fin de línea,
me representaremos como [Intro]:

 

 

 

 

 

 

tidad Pendiente? -45768|Intro]

 

 

 

 

  
    
  
   

-A1 pulsar [Intro] el cursor pasará a la siguiente línea, se procesará el dato de
exirada, y a la variable saldo se le asignará el nuevo valor -45768.

 

 

 

Si se quiere introducir más de un valor con la misma pregunta y en la misma.
lnea se puedo utilizar como separador de datos el espacio en blanco. Por
ejemplo:

saldo, gastos

int£( "¿Cantidad pendiente y Gastos? " );
scanf( "XfXÉ", saldo, égastos );

En la pantalla aparecerá el mensaje de petición, y luego se teclearán los datos
separados por uno o varios blancos y acabados con un [intra]:

 

 

 

 

 

 

 

 

 

p< pendiente y Gastos? -45768 10456. 5[Intro]

    
  
  

 

Al pulsar [mo] queda el cursor en la línea siguiente, la variable saldo toma.
el valor -45768 y la variable gastos el valor 10456.5. En este caso el espacio
en blanco intermedio entre los datos hace que termine la lectura del primer
salor y se pase a leer el segundo, saltando automáticamente dicho espacio y
los siguientes si los hubiera.

 

 

 

 

El mismo resultado se obtendría programando cada lectura como una sentencia
separada, o introduciendo los datos en varias líneas.

float saldo, gastos

printf( "¿Cantidad pendiente y Gastos? " );
scanf( "Xf", saldo );

scanf( "%f", Sgastos );

 

    

E
¿Cantidad pendiente y Gastos? -45768|Intro
10456. 5|Intro|

 

 

 

 

 

 

 

 

Cualquier combinación es válida: una sentencia única para leer dos valores o
dos sentencias para leer un valor cada una, e introducir los datos en una o dos
líneas, indistintamente.

 

 

 

 
 

68 Fundamentos de programación

 

3.7 Estructura de un programa con declaraciones

Antes de realizar muevos programas es necesario saber dónde se sitúan dentro
del programa los nuevos elementos introducidos en este tema. Las declaraciones de valores constantes y de las variables forman parte del bloque del
programa. Por tanto, ahora la estructura del bloque es la siguiente:

Bloqu

 

= £ Parte_declarativa Parte_ejecutiva +

 

Í Declaración Y
= [ Sentencia Y

Parte_declarativa 3%

 

Parte_ejecutiva *

 

Declaración ::=
Declaración de constante | Declaración de variable | ...

 

Sentencia 33= Llamado a procedimiento | Asignación |

 

El contenido de un bloque se organizará en dos partes. La primera de ollas
contendrá todas las declaraciones de constantes, variables, etc., y la segunda
incluirá las sentencias ejecutables correspondientes a las acciones a realizar.
Las declaraciones pueden hacerse en el orden que se quiera, con la limitación
de que cada nombre debe ser declarado antes de ser usado. Las sentencias
ejecutables deben escribirse exactamente en el orden en que han de ser ejecu
tadas.

NOTA: En C y C++ os posible mezclar las declaraciones con las sentencias ejecutables pero esto está absolutamente prohibido en C+ con una regla obligatoria del
Manual de Estilo y la sintaxis dol lenguaje C4 que está recogida en el apéndice A. La
separación de la parte declarativa y la parte ejecutiva de un bloque está incorporada
cn La pintas de ¡uucios lenguajes le programación (Pascal Modluls 2, Obioa, Adal
Smalltalk, etc.) y además es una regla de estilo bastante habitual en proyectos reales
para evitar problemas de uso y aumentar la claridad de los programas.

 

3.8 Ejemplos de programas

A continuación se presentan varios programas con los nuevos conceptos introducidos.

3.8.1 Ejemplo: Conversión a horas, minutos y segundos

En este ejemplo se trata de convertir a horas, minutos y segundos una cierta
cantidad de tiempo expresada en segundos. La variable segundos se utilizará
para leer la cantidad total de segundos y posteriormente para ir guardando
 
  
    
   
  
  

'antes y Variables 69

 

segundos restantes al descontar del total de segundos los que se hayan
rtido a horas o minutos completos. El listado del programa es el siguiente:

 

Programa: HorasMinutosSegundos */
Conversión a Moras, Minutos y Segundos
de los segundos introducidos como dato */

main() 4
int horas, minutos, segundos;

print£( "¿Segundos Totales? " );
scanf( "xd", esegundos );

horas = segundos / 3600;

segundos = segundos % 3600;

minutos = segundos / 60;

segundos = segundos % 60;

print£( "Equivalen a %2d horas X2d min. y Xd segAn",

horas, minutos, segundos );

 

 

La ejecución del programa introduciendo como dato 23459 segundos es la
siguiente:

 

 

¿Segundos Totales? 23459
Equivalen a 6 horas, 30 min. y 59 seg.

3.8.2 Ejemplo: Área y volumen de un cilindro

En este ejemplo se desarrolla un programa para el cálculo del área y el vohumen
de un cilindro genérico. Es decir, las dimensiones del cilindro serán variables y
se lecrán como datos. Además se declara como constante el valor de 7 lo que
evita tener que escribirlo más de una vez en todo el programa. El programa así
realizado es más general y más fácil de comprender y modificar que la versión
presentada en el tema anterior. El listado del programa es el siguiente:

 

/** Programa: Cilindro2 */
/* Cálculo del área y el volumen de un cilindro */

include <stdio.h>

 
70 Fundamentos de programación:

int main) (
const float PI = 3.14159265;
float radio, altura, area, volumen;

printf( "¿Radio del cilindro? " );

    

» Galtura );

area = 2.0 * PI * radio * (radio + altura);

volumen = PI * radio * radio * altura;

printf( "Area: %I5ginVolumen: %l5gin", area, volumen );

 

La ejecución del programa introduciendo como valor del radio 12,5 y como
altura 72,61 produce el siguiente resultado:

 

 

¿Radio del cilindro? 12.5
¿Altura del cilindro? 72.61
Area: 6684.52
Volumen: 35642.4

3.8.3 Ejemplo: Realización de un recibo

En este ejemplo se trata de confeccionar un recibo sencillo, correspondiente
a la compra de unos equipos. Como datos habrá que introducir el tipo de
equipo, indicado mediante un código de un carácter; la cantidad de equipos,
el precio unitario y el tipo de IVA aplicado. Los subtotales y totales se darán
en euros y céntimos.

El listado del programa completo es el siguiente.

 

/** Programa: Recibo */
/* Cálculo e impresión de un recibo */

*finclude <stdio.h>

int main() (
int cantidad, IVA;
char codigo;
float precio, totalIlVA, subtotal, total;

 
 

Constantes y Variables 71

 

printf( "¿Código del producto?
scanf( "%c", codigo );
printf( "¿Cantidad? " );
scanf( "%d”, Ecantidad );
print£f( "¿Precio unitario? " );
scan£( "%f", Kprecio );
print£( "¿IVA aplicable? "
scan£í "%d", RIVA );
subtotal = float(cantidad) * precio;
totalIVA = subtotal * float(IVA) / 100.0;

 

 

 

total = subtotal + totalIVA;
print£( "wn RECIBO de COMPRA" );
printf( "Cantidad Concepto Euros/unidad Totalin” );

print£( "x5d Producto: %c %12.2£%12.2ma",
cantidad, codigo, precio, subtotal );
print£( "%28d%% IVA %12.2finXn", IVA, totallVA );
/* se ha codificado %% para imprimir literalmente un % */
print£( TOTAL%14.2£%n", total );
y

 

 

A continuación se presenta un ejemplo de la ejecución del programa, mostrando
los datos leídos y los resultados escritos.

 

¿Código del producto? A
¿Cantidad? 12
¿Precio unitario? 2345
¿IVA aplicable? 16
RECIBO de COMPRA

Cantidad Concepto Euros/unidad Total
2 Producto: A 2345.00 28140.00

16% IVA 4502.40

TOTAL 32642.40

 
 

Tema 4

Metodología de Desarrollo de
Programas (I)

Aquí se tratan explícitamente los primeros conceptos metodológicos relaciosados con la programación en general y con la programación imperativa en
particular. Se presenta el desarrollo por refinamientos sucesivos, aunque limitado al empleo de la estructura secuencial, por el momento.

Como elementos complementarios, se hace explícita la necesidad de usar un
buen estilo de programación, que se concreta en sugerencias sobre el uso de
una notación apropiada para la representación de los elementos del programa
y la presentación de su estructura de forma clara.

 

4.1 La programación como resolución de problemas

La labor de programación puede considerarse como un caso particular de la
resolución de problemas. Resolver un problema consiste esencialmente en encontrar una estrategia a seguir para conseguir la solución. En la figura 4.1 se
plantea un problema sencillo.

Una estrategia se expresará como una colección de reglas o recomendaciones
que, si se siguen, conducirán a la solución. Por ejemplo, para resolver el
problema de obtener el área de un rectángulo del que se conocen las longitudes
de sus lados (base y altura), formularemos la estrategia:

multiplicar la base por la altura
74 Fundamentos de programación

 

Problema Solución
as eran
base

Figura 4.1 Problema: Área de un rectángulo.

Un programa en el modelo de programación imperativa se expresa como una.
serie de instrucciones u órdenes que gobiernan el funcionamiento de una máquina. La máquina va ejecutando dichas instrucciones en el orden preciso que
se indique. La estrategia del ejemplo anterior se expresaría en C+ como:

area = base * altura

Todo programa puede considerarse, de alguna forma, como la solución de un
problema determinado, consistente en obtener una cierta información de salida
a partir de unos determinados datos de entrada. La tarea de desarrollar dicho
programa equivale, por tanto, a la de expresar la estrategia de resolución del
problema en los términos del lenguaje de programación utilizado.

4.2 Descomposición en subproblemas

Algunos problemas, como el ejemplo anterior referente al área del rectángulo,
pueden resolverse o programarse de forma inmediata porque la estrategia se
puede expresar como una acción que se da por sabida, o como una sentencia en
el lenguaje de programación elegido. Los problemas resolubles de esta manera
serán, en general, problemas simples o triviales

 

Cualquier problema de cierta complejidad necesitará una labor de desarrollo
para expresar la solución. El método más general de resolución de problemas
no triviales consiste en descomponer el problema original en subproblemas
más sencillos, continuando el proceso hasta llegar a subproblemas que puedan
ser resueltos de forma directa.

Lo que se busca aquí es una analogía con la labor de desarrollo de programas.
Puesto que el proceso de ejecución de un programa imperativo consiste en la
realización de las sucesivas acciones indicadas por las órdenes que constituyen
el programa, analizaremos la resolución de problemas en que la estrategia de
solución consiste en realizar acciones sucesivas.
Metodología de Desarrollo de Programas (1) 75

Según esta idea, para desarrollar la estrategia de resolución, habrá que ir
identificando subproblemas que se resolverán ejecutando acciones cada vez
más simples, Consideremos el siguiente problema:

Problema : Obtener una caja de madera barnizada

Para expresar la estrategia de solución de forma imperativa comenzamos por
formular la solución como una acción global que consigue el objetivo propuesto.
En muestro caso será:

0) Construir una caja de madera barnizada

En este primer nivel de formulación nos encontramos con una acción a reakzar que es demasiado complicada para ejecutarla de forma inmediata. Será
necesario descomponer el problema original en subproblemas más sencillos,
que puedan ser resueltos mediante acciones más simples. Un primer paso de
descomposición sería:

1) Obtener las piezas de madera

2) Montar la caja

3) Barnizarla
El proceso de descomposición en subproblemas debe continuar hasta que los
subproblemas se puedan resolver mediante acciones consideradas directamente ejecutables por el agente que ha de proporcionar la solución. La expresión
fnal de la solución del problema debe tener en cuenta, por tanto, qué acciones particulares se consideran realizables de forma directa. Tenemos así una
analogía con la tarea de programación, que exige redactar el programa con los
elementos particulares del lenguaje de programación elegido.

En nuestro ejemplo habrá que decidir si el subproblema 1) ha de considerarse
resoluble mediante una acción simple o compuesta. Si podemos adquirir las
piezas directamente en una tienda de “bricolaje”, podremos considerar que el
subproblema es resoluble con una acción simple que no necesita descomponerse. Si en la tienda sólo podemos comprar un tablero de madera sin cortar,
tendremos que descomponer el problema de obtener las piezas en subproblemas más sencillos, tales como:

1.1) Obtener un tablero de madera
1.2) Dibujar sobre él la silueta de las piezas
1.3) Recortar el tablero siguiendo la silueta

De igual manera habría que proceder con los subproblemas planteados hasta
este momento: 1.1), 1.2), 1.3), 2) y 3), decidiendo si son resolubles de forma
inmediata o bien descomponiéndolos sucesivamente hasta llegar a acciones
simples.

 
76 Fundamentos de programación

 

4.3 Desarrollo por refinamientos sucesivos

La aplicación de las ideas anteriores a la construcción de programas conducea la técnica de desarrollo mediante refinamientos sucesivos. Esta técnica
es parte de las recomendaciones de una metodología general de desarrollo de
programas denominada programación estructurada, que se estudiará con más.
detalle en el tema siguiente, La técnica de refinamientos consiste en expresar
inicialmente el programa a desarrollar como una acción global, que si es necesario se irá descomponiendo en acciones más sencillas hasta llegar a acciones
simples que puedan ser expresadas directamente como sentencias del lenguaje
de programación.

Cada paso de refinamiento consiste en descomponer cada acción compleja en
otras más simples. Esta descomposición exige:

+ Identificar las acciones componentes.
+ Identificar la manera de combinar las acciones componentes para conseguir el efecto global.

La forma en que varias acciones se combinan en nna acción compuesta constituye el esquema de la acción compuesta. La programación estructurada recomienda el uso de esquemas particularmente sencillos, que se indicarán más
adelante. Por el momento presentamos un primer esquema que denominaremos esquema secuencial, que consiste en realizar una acción compuesta a base
de realizar una tras otra, en secuencia, dos o más acciones componentes. Este
esquema secuencial es el que se ha utilizado en el ejemplo del problema de
construir la caja de madera.

4.3.1 Desarrollo de un esquema secuencial

La metodología de refinamientos incluye el ir desarrollando a la vez las sentencias del programa que realizan las acciones de la parte ejecutable, y la
definición de las variables necesarias para almacenar la información manipulada por dichas acciones. Para desarrollar una acción compuesta según un
esquema secuencial se necesitará:

(a) Identificar las acciones componentes de la secuencia. Identificar las variables necesarias para disponer de la información adecuada al comienzo
de cada acción, y almacenar el resultado.

(b) Identificar el orden en que deben ejecutarse las acciones componentes.

Para ilustrar esta técnica consideraremos un caso simplo, tal como el de obtener
la suma de dos números enteros, Los dos números se introducirán como datos y
Metodología de Desarrollo de Programas (1) TT

 

el programa suministrará como resultado su suma. Aunque resulte un ejemplo
trivial, sirve perfectamente para ilustrar la metodología de desarrollo.

Procediendo paso a paso, describiremos de manera informal cada elemento del
desarrollo, seguido de su codificación en CE .

(a) Acciones componentes:
+ Cálculos: obtener la suma

| suna = datol + dato2
+ Operaciones de entrada: leer datos

print£( "Dar dos números: " );
scan£( "%d", Edatol );

scanf( "%d", gdato2 );
print£( "Yn” );

+ Operaciones de salida: imprimir resultado
|printfC "La suma esí10dn"”, suma) ;
Variables necesarias : datos y resultado
|int datol, dato2, suma;

(b) Orden de ejecución:
1) Leer los datos
2) Calcular la suma
3) Imprimir el resultado

Si nos limitamos a describir la manera en que la acción global del programa
se va descomponiendo en acciones cada vez más sencillas, podemos usar la
siguiente notación de refinamiento:

 

Acción compuesta —>
Acción 1
Acción 2
AR e

En esta notación se utiliza una flecha (—>) para indicar que una acción
complicada se descompone o refina en otras más sencillas. Aplicando esta
notación al ejemplo anterior, hasta llegar a sentencias de CE, tendremos:

Obtener la suma de dos números —
Leer los datos
Calcular la suma
Imprimir el resultado
78 Fundamentos de programación

 

Leer los datos ——>

printf( "Dar dos números: " );
scanf( "%d”, ádatol );
scanf( "%d", fdato2 );
printec a" y;

Calcular la suma —>

[suma = dato1 + dato2;

Imprimir el resultado —>
|print£f( "La suma esk10dWn", suma );
Uniendo todos los fragmentos finales de código en el orden adecuado, y aña
diendo las declaraciones de las variables necesarias, tendremos el programa
completo.

 

/** Programa: SumarDosNumeros */
/* Obtener la suma de dos números enteros */

finclude <stdio.h>

int main() £
int datol, dato2, suma;

printf( "Dar dos números: " )
scanf( "%d", Edatol );
scanf( "%d", £dato2 );
print£( "a" );

suma = datol + dato2;

printf( "La suma eskl0dWn", suma );

 

Un ejemplo de la ejecución de este programa sería:

 

 

Dar dos números: 37 143

La suma es 180

 
  

Metodología de Desarrollo de Programas (1) 79

4.3.2 Ejemplo: Imprimir la silueta de una silla

Aplicaremos la técnica de refinamientos a un programa sencillo en C£ que imprima de forma esquemática la silueta de una silla usando caracteres normales
de escritura, por ejemplo “1” y “=", de la siguiente forma:

 

 

 

21
1

La parte ejecutable del programa se planteará inicialmente como una acción
única, que trataremos de describir con una frase sencilla; por ejemplo.

Imprimir la silueta de una silla

Puesto que no parece fácil programar esta acción con ¡na única sentencia
de Ci, la descompondremos en acciones más simples. De forma intuitiva

podemos:

(a) Asociar las acciones componentes a la impresión de diferentes partes de
la silla: asiento, patas y respaldo.

(b) Seguir el orden de ejecución impuesto por el hecho de que la impresora
ha de ir imprimiendo las líneas de arriba a abajo.

El primer paso de refinamiento será:

Imprimir la silueta de una silla —>
Imprimir la silueta del respaldo
Imprimir la silueta del asiento
Imprimir la silueta de las patas

Ahora hay que determinar si estas acciones intermedias son ya expresables
directamente como sentencias en Ct o necesitan nuevas descomposiciones. No
hay reglas fijas sobre cuándo una acción puede considerarse simple y pasar
a escribirla en el lenguaje de programación. En este ejemplo consideraremos
simple la escritura de una línea de texto.

 

De acuerdo con ello podremos considerar como acción simple la impresión del
asiento, y refinar:

Imprimir la silueta del asiento —

|print£c

 

La impresión del respaldo se refinaría en la forma:

 

 
80 Fundamentos de programación

 

Imprimir la silueta del respaldo —>
Imprimir parte superior del respaldo
Imprimir parte inferior del respaldo

y cada una de estas partes conduciría a las mismas sentencias de Ci:
Imprimir parte superior o inferior del respaldo —>

|orint£( "An" )

De forma similar se refinaría la impresión de las patas de la silla. Omitimos
este paso para no hacer el ejemplo demasiado prolijo. Finalmente todos estos
refinamientos han de ser combinados en un programa único. Reuniendo todas
las sentencias en una única secuencia tendremos:

print£( "a" );

print£(
print£(
printf£(
printf(

 

4.4 Aspectos de estilo

Una buena metodología de desarrollo de programas debe atender no sólo a
cómo se van refinando las sucesivas acciones, sino a cómo se expresan las
acciones finales en el lenguaje de programación. El estilo de redacción del
programa en su forma final es algo fundamental para conseguir que sea claro
y fácilmente comprensible por parte de quienes hayan de leerlo.

En los apartados que siguen se darán diversas recomendaciones sobre la manera
de presentar adecuadamente un programa para facilitar su comprensión. Estas
recomendaciones forman parte del Manual de Estilo de Ct.

  

4.4.1 Encolumnado

Un programa aparece como un texto. Dicho texto puede ser visto como un documento técnico, organizado de una manera muy precisa. El estilo de presentación de dicho texto o documento debe destacar claramente su organización
en partes.

Un recurso de estilo de presentación es el encolumnado o sangrado (indent).
Ampliando el margen izquierdo para las partes internas del programa se puede
conseguir que el texto de un elemento compuesto ocupe una zona aproximadamente rectangular, y que el texto que representa cada uno de sus componentes
  
 
 
 
   
  
 
   
   
 
 
 
  
 
    
   
 
 
    
   

Metodología de Desarrollo de Programas (1) 81

ocupe también una zona rectangular dentro de ella. Gráficamente podemos
ilustrar esta idea con el esquema de la figura 4.2 en la que se ha marcado el
espacio de cada parte como un rectángulo, y se indica con línea doble cuál es
el margen izquierdo en cada momento.

[[ Etemento compuesto

   

Figura 4.2 Encolumuado de elementos compuestos.

Si aplicamos este recurso de estilo al esquema global de un programa en Ct,
Regaremos a escribir, ya completo, el ejemplo anterior de la siguiente manera:

<stdio.h>

main) (
printf(
printf(
print£(
print£(
print£(

 

En este caso, la función principal int main() (...) es el único elemen£o compuesto. Los elementos componentes son las sentencias de escritura
print£(...); que se encolumnan todas ellas dejando cierto margen en blanco
a la izquierda. En próximos temas se ilustrará el encolumnado de componentes y subcomponentes cuando se emplecn las sentencias estructuradas y los
"subprogramas.

4.4.2 Comentarios. Documentación del refinamiento

 
 

'Dtro recurso utilizable para mejorar la claridad de un programa es el empleo de
“eomentarios. Ya se ha indicado cómo el lenguaje Ct permite intercalar comenarios en el texto de un programa escribiéndolos entre la pareja de símbolos

MP? y *1.
 

82 Fundamentos de programación

 

Aunque el lenguaje permite emplear comentarios con toda libertad, es aconsejable seguir ciertas pautas para facilitar la lectura del programa. Estas pautas
corresponden a diferentes clases de comentarios, cada una con un propósito
diferente. Entre ellas podemos mencionar:

+ Cabeceras de programa
+ Cabeceras de sección

+ Comentarios-orden

+ Comentarios al margen

La cabecera de programa tiene como finalidad documentar el programa como
un todo. Puede incluir datos de identificación, finalidad, descripción general,
etc. Suele presentarse como una “caja” al comienzo del texto del programa,
ocupando todo el ancho del listado. A continuación se presenta una posible
cabecera para el programa de ejemplo de imprimir la silueta de una silla.
parrnnerccrrcrrrcrce arenas

* Programa: Silla

Autor: Fulano de Tal

Este programa imprime de forma esquemática la silueta

de una silla usando caracteres normales de la impresora.
AAA

.
* Descripción:
.
*

En este ejemplo la “caja” se ha delimitado con asteriscos, y se ha dejado
abierta en el lado derecho para facilitar la edición o modificación del texto de
la misma.

Las cabeceras de sección sirven para documentar partes importantes de un programa relativamente largo. Al igual que la cabecera del programa, se presentan
en forma de “caja” al comienzo de la sección correspondientes, ocupando todo
el ancho del listado. Un ejemplo trivial sería:

  

 

 

 

 

PARTE EJECUTABLE DEL PROGRAMA
ermano == === ==*/

En este ejemplo la “caja” se ha delimitado con signos “=” y se ha dejado
abierta a ambos lados.

Los comentarios-orden son un elemento metodológico fundamental, y sirven
para documentar los refinamientos empleados en el desarrollo del programa.
Si analizamos la redacción final del programa de ejemplo de la silla nos encontraremnos con que las acciones intermedias que se han ido identificando durante
Metodología de Desarrollo de Programas (1) 83

 

el proceso de desarrollo por refinamientos sucesivos no aparecen en ninguna
parte del texto del programa. Al hacerlo así se ha perdido una información de
gran importancia para realizar posteriormente modificaciones en el programa.

Para incluir la información de los pasos de refinamiento en el texto del programa se puede introducir un comentario con la descripción de cada acción
intermedia. Estos comentarios tienen, en cierta medida, la categoría de una
orden del programa imperativo; en efecto, si el lenguaje de programación lo
permitiese, el desco del programador sería escribir una sentencia que ejecutara
dicha acción, pero como no es posible, la acción se descompone en otras más
sencillas que dan lugar finalmente a sentencias del programa. El comentarioorden se debe encolumnar tal como se haría con una sentencia del lenguaje
que ejecutara la acción deseada. El comentario-orden delimita una acción
compuesta, y las acciones componentes se escribirán dejando un mayor margen a la izquierda, tal como se indicó en la sección anterior. En Ct la acción
compuesta puede escribirse entre llaves (). Como ejemplo, se repite aquí la
parte ejecutable del programa de imprimir la silueta de la silla, documentando
las acciones principales con comentarios-orden y acciones compuestas.

/*-— Imprimir el respaldo --*/ (

print£( "ln" );
print£( "ln" );

 

 

 

/*— Imprimir el asiento —*/ 1
printf( "=== :

3

/*-- Imprimir las patas —-*/ 1
print£( "! ;
print£( "1

3

 

 

En esto ejemplo se han utilizado caracteres fácilmente visibles “--" para marcar el principio y el final de los comentarios-orden y distinguirlos de comentarios de otro tipo.

Finalmente mencionaremos la posibilidad de emplear comentarios al margen.
Estos comentarios sirven para aclarar el significado de ciertas sentencias del
programa, que pueden ser difíciles de interpretar al leerlas tal como aparecen
escritas en el lenguaje de programación empleado. Una recomendación de
estilo es situar estos comentarios hacia la parte derecha del listado, en las
mismas líneas que las sentencias que se comentan, y alineados todos a partir
de una posición fija, hacia el comienzo del tercio final.
 

 

84 Fundamentos de programación

 

Los comentarios al margen se utilizan muchísimo para explicar el significado
de cada variable usada en un programa, poniéndolos en la misma línea en que
se declaran. Por ejemplo:

float base, altura; /* dimensiones en cm */

float area; /* área en cr */
int volumen; /* volumen en litros */
int dia; /* entre 1 y 31 */

Como resumen de todas las recomendaciones sobre empleo de comentarios,
se muestra a continuación el listado completo del programa de imprimir la
silueta de la silla, incluyendo comentarios de todos los tipos indicados. En un
programa tan sencillo como éste muchos de los comentarios resultan superfluos
y de hecho hacen el programa un tanto engorroso, pero se han incluido para
ilustrar la manera de presentar cada clase de comentario.

 

JARA

* Programa: Silla
+

 

 

Descripción:
Este programa imprime de forma esquemática la silueta

$ de una silla usando caracteres normales de la impresora.
AAA A AAA AAA AA

 

di
DIRECTIVA DE COMPILACIÓN

 

ffinclude <stdio.h>

   

/ 2
PARTE EJECUTABLE DEL PROGRAMA

 

int main() £
/*-— Imprimir el respaldo --*/ 4
print£( "Ma" );

 

 

print£( "Ma" );

+

/*-- Imprimir el asiento --*/ 4

print£( "

$

/*-— Imprimir las patas --*/ (
Mar);
ar);

 

 
 

Metodología de Desarrollo de Programas (1) 85

4.4.3 Elección de nombres

¡Otro aspecto de estilo, fundamental para la claridad de un programa, es una
elección correcta de los nombres o identificadores utilizados para designar sus
diferentes elementos. Los nombres que tenga que inventar el programador
deben ser elegidos con un criterio nemotécnico, de manera que recuerden fácilmente el significado de los elementos nombrados.

Para evidenciar la importancia de usar nombres adecuados, compararemos
dos redacciones de un mismo programa. La primera, con nombres carentes de
«significado sería:

<stdio.h>

   
  

 

scanf "Xd", ey);

z=x "y

print£( "Area = X104" ,z );
y

La segunda redacción del programa, con nombres significativos, podría ser:
¡include <stdio.h>

main() £
int base, altura, area;

scan£( "%d", Sibase );

scant( "Xd", Saltura );

area = base * altura;

print£f( "Area = X10d",area );
y

 

Comparando ambas redacciones es muy fácil darse cuenta de la ventaja de
la segunda, cuyo significado puede adivinarse fácilmente incluso con la total
“ausencia de comentarios explicativos en el programa.
Para que los nombres o identificadores resulten significativos hay que procurar que tengan la categoría gramatical adecuada al elemento nombrado. En
«concreto:

+ Los valores (constantes, variables, etc.) deben ser designados mediante

sustantivos.
+ Las acciones (procedimientos, etc.) deben ser designadas con verbos.
86 Fundamentos de programación

 

+ Los tipos deben ser designados mediante nombres genéricos.

En programas largos con muchos identificadores resulta a veces difícil inventar nombres significativos que distingan fácilmente entre valores y tipos. Un
recurso de estilo puede ser construir los identificadores de tipo usando sistemáticamente el prefijo Tipo o similar en todos ellos; por ejemplo TipoLongi tud
o bien T_longitud.

INOTA: En los lenguajes C y C++ es también habitual usar sufijos en lugar de

prefijos para distinguir diferentes categorías de identificadores. En particular el sufijo

¿E para los nombres de tipos, incluso en algún tipo predefinido como wehar_t en
++

Al usar verbos para nombrar acciones conviene emplearlos de manera uniforme
utilizando siempre el mismo tiempo gramatical. En inglés suelen aparecer en
imperativo. En español resulta quizá más natural emplear sistemáticamente el
infinitivo. De hecho en inglés el imperativo y el infinitivo coinciden en muchos
casos. Ejemplos:

 

 

Término inglés Imperativo Infinitivo
writeNumber escribeNumero escribirNumero
read_date lee_fecha leer_fecha
go_to_origin ve_al origen ir_al origen

A continuación se presenta un ejemplo de programa completo, incluyendo identificadores de diferentes clases elegidos según las recomendaciones anteriores.
En este ejemplo se ha supuesto que existe un módulo llamado Fechas que
define procedimientos para manipular datos de tipo fecha. El estilo seguido
para elegir los nombres inventados por el programador ha sido:

 

+ Los nombres de operaciones (procedimientos y programa principal) son
verbos en infinitivo:

CalcularDias LeerFecha EscribirFecha
+ Los nombres de valores ( funciones y variables ) son sustantivos:

DiasEntre Hoy  fechaCumple
fechaHoy — dias

+ Los nombres de tipo empiezan por el prefijo T_:

T_fecha
Metodología de Desarrollo de Programas (1) 87

 

 

ARA DEC DEDAADOREDOROERLODAEE

* Programa: CalcularDias

* Descripción:

* Este programa calcula los días que faltan para el

* cumpleaños de una persona.
nera
'sinclude <stáio.h>

include "fechas.h"

 

fe
En el módulo fechas.h están definidos:

T_fecha = Tipo de valor FECHA
Leerfecha = Procedimiento para leer una fecha
EscribirFecha = Procedimiento para escribir una fecha
DiasEntre = Función para calcular los dias que hay
entre dos fechas
Hoy = Variable en la que se mantiene actualizada la
fecha de hoy

 

in

int mainO) £
T_fecha fechaCumple; /* cumpleaños */
Tfecha fechaloy;  /* fecha de hoy */
int dias; /* días que faltan +/

/*-- Obtener la fecha del cumpleaños --*/ 1
print£( "¿Cuál es tu próximo cumpleaños? " );
LeerFecha(l fechaCumple );

 

y

/*-— Obtener la fecha de hoy —"/ 4
fechaoy = Hoy;

y

/*-- Calcular los días que faltan para el cumpleaños --*/ 4
dias = DiasEntre( fechaHoy, fechaCumple );

y

/*-— Imprimir el resultado --*/ 1

nFaltan4d”, dias);

días para tu cumpleaños” );

 
88 Fundamentos de programación

 

4.4.4 Uso de letras mayúsculas y minúsculas

Los lenguajes de programación que permiten distinguir entre letras mayúsculas
y minúsculas facilitan la construcción de nombres en programas largos, en que
es preciso inventar un gran número de ellos.

Por ejemplo, para marcar claramente a qué clase de elemento del programa se
está rofiriendo un nombre, se puede adoptar el criterio de que los identificadores
de ciertas clases de elementos empiecen siempre con mayúscula, y otros siempre
con minúscula, o que algunos muy especiales se escriban todo en mayúsculas.
En el ejemplo del apartado anterior se han seguido las siguientes reglas de
estilo para escribir los identificadores inventados por el programador:

  

+ Los nombres de tipos, procedimientos y funciones empiezan por mayúscula:

CalcularDias LeerFecha EscribirFecha
DiasEntre Hoy

+ Los nombres de variables y constantes empiezan por minúscula:

fechaCumple fechaHoy dias

 

+ Los nombres que son palabras compuestas usan mayúsculas intercaladas

al comienzo de cada siguiente palabra componente:

 

TipoLongitud TipoFecha  fechaHoy
CalcularDias LeerFecha  EscribirFecha
DiasEntre fechaCumple

En cualquier caso hay que limitar mucho el empleo de nombres escritos totalmente en mayúsculas, ya que en general hacen más pesada la lectura del texto
del programa. Sólo deberían escribirse así elementos que han de destacar entre
los demás.

Compárese el siguiente programa, escrito todo en mayúsculas, con el ejemplo
correspondiente del apartado 4.4.3. La lectura resulta ahora mucho más difícil.

*INCLUDE <STDIO.H>

INT MAIN() €
INT BASE, ALTURA, AREA;

SCANE("%D" ,8BASE) ;

SCANE("%D",8ALTURA) ;
AREA = BASE * ALTU!
PRINTE("AREA = %10D", AREA);

 
 

Metodología de Desarrollo de Programas (1) 89

 

 

NOTA: El programa anterior no es válido en Ct ni en Co C++, que requieren
escribir ciertas palabras en minúsculas. Se ha presentado sólo como ejemplo de la
dificultad de lectura que conlleva el uso excesivo o exclusivo de mayúsculas.

   

4.4.5 Constantes con nombre

La posibilidad de declarar constantes con nombres simbólicos puede aprovecharse para mejorar la claridad del programa. En lugar de usar directamente
walores numéricos en las expresiones de algunos cálculos, puede resultar ventajoso definir determinados coeficientes o factores de conversión con un nombre
simbólico que tenga un buen significado nemotécnico, y usar la constante con
ese nombre en los cálculos. Por ejemplo, para transformar una longitud de
pulgadas a centímetros, en lugar de escribir:

|longitudCm = longitudPul * 2.54

se podría poner
const float cmPorPulgada = 2.54;

longitudCm = longitudPul * cmPorPulgada

Esta segunda forma resultará más significativa para los que no recuerden de
memoria ese factor de conversión. Además se tiene una ventaja adicional en
el caso de que un mismo valor constante se use en varios puntos del programa;
al definirlo como constante con nombre el valor mmérico particular se escribe
sólo una vez, en la definición, en lugar de hacerlo tantas veces como se use, y
así se reducen las posibilidades de cometer errores de escritura.

Otra forma ventajosa de usar el mecanismo de definición de constantes con
nombre sc da en el caso de que el comportamiento de un programa venga dado
en función de ciertos valores gonerales, fijos, pero que quizá fuera interesante

 

cambiarlos en el futuro. Este tipo de valores se denominan a veces parámetros
del programa, y es conveniente que su valor aparezca escrito sólo una vez en
un lugar destacado del programa. Por ejemplo, un programa para reformar un
texto antes de enviarlo a la impresora puede tener como parámetros generales
el ancho de la línea de escritura, o el tamaño de la página. Podríamos escribir,
al comienzo del programa:

   

const int ANCHO_LINEA
const int LINEAS_PAGINA = 60;
90 Fundamentos de programación

 

De esta manera queda perfectamente destacada la parte del programa que hay
que modificar si se quieren cambiar las dimensiones útiles de la hoja impresa.

4.5 Ejemplos de programas

A continuación se desarrollan algunos programas sencillos mediante refinamientos sucesivos.

4.5.1 Ejemplo: Imprimir la figura de un árbol de navidad

Se trata de escribir un programa que imprima la silueta de un árbol de navidad
convencional, según aparece en el siguiente listado resultado de la impresión:

  

 

 

Para estructurar el programa trataremos de identificar las diferentes partes
de la figura del árbol. Podemos reconocer la copa (formada por tres pisos
de ramas), el tronco y la base. Teniendo en cuenta que las distintas partes
han de imprimirse de arriba a abajo, organizaremos los primeros pasos de
refinamiento:

Imprimir arbol —>
Imprimir copa
Imprimir tronco
Imprimir base

Imprimir copa —
Imprimir primeras ramas
Imprimir segundas ramas
Imprimir terceras ramas
 
  
  
  
   
  
  
  
  
  

Metodología de Desarrollo de Programas (1) 91

 

 

La impresión de cada parte se consigue directamente con sentencias de escritura sencillas. Podemos pasar ya a escribir el programa en Ct, documentándolo
de acuerdo con las reglas de estilo propuestas. El programa completo aparece
2 continuación.

 

ARALAR ROREDEDERELDEOSODAR

* Programa: Arbol
.

* Descripción:

* Este programa imprime la silueta de un árbol

* de navidad, hecha con asteriscos

ARA RARA RARA RRA AR

include <stdio.h>

int main()
1 /*-- Imprimir copa --*/ 4
/*-—— Imprimir primeras ramas --*/ 4
printf( " Nardi
printf("  **n" );
print£(" eran");
4
/*-— Imprimir segundas ramas —-*/ 1
primf( "An" );
printf( "+" );
print£( " **erse qn" );
J
/%-— Imprimir terceras ramas —-*/ 1
print£( " *teeAn" );
print£( " +een” );
primt£( “rep” );

y

,

/*-- Imprimir tronco--*/ £
printí( "o Ma);
print£( " ar);
printi( "o Mat);

E

/*-- Imprimir base -- */ 1
printi( een");
y
3

 

 
 

92 Fundamentos de programación

 

4.5.2 Ejemplo: Calcular el costo de las baldosas

 

Se trata de

 

“ular el costo total de las baldosas necesarias para enbrir el suelo
de una habitación rectangular. Se supone que las baldosas son cuadradas.
El programa lee como dato el lado de las baldosas, en centímetros, y las
dimensiones de la habitación rectangular en metros. También se suministra
como dato el precio unitario de cada baldosa.

El programa calcula cuántas baldosas hay que colocar a lo largo de cada dimensión de la habitación, incluyendo contar wma baldosa más si no es un número
entero y hay que romper algunas baldosas para cubrir exactamente hasta el
borde. A continuación se calcula el número total de baldosas y se multiplica
por el precio de cada una.

De forma abreviada, los primeros pasos de descomposición conducen a:

Calcular el costo de baldosas —>
Leer los datos
Culcular el número de baldosas
Calcular el coste total
Imprimir el resultado

Calcular el número de baldosas —
Calcular las baldosas a lo largo
Calcular las baldosas a lo ancho
Calcular el número total de baldosas

El programa completo, debidamente documentado, aparece en el siguiente
listado:

 

pa ARDE LDANEEDOnA

Programa: Baldosas

Descripción:
Este programa calcula el costo de las baldosas

necesarias para cubrir una habitación rectangular
eras AAA

finclude <stdio.h>

CS

 

int main() (£
int largo, ancho; /* Dimensiones de la habitación en m */

int lado; /* Lado de la baldosa en cm */
int nLargo; /* Número de baldosas a lo largo */
int nancho; /* Número de baldosas a lo ancho */
int baldosas; /* Número total de baldosas */

float precio; /* Precio de cada baldosa */
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
  

Metodología de Desarrollo de Programas (1) 93

 

float coste; /* Coste total */

/*-— Leer los datos --*/ 4
print£( "Dar el tamaño de la habitación, en mn" );
print£( "¿Largo, ancho? " );
scan£( "%d,%d",£largo,£ancho);

 

 

   

 

print£( "¿Lado de la baldosa, en em? " );
scanf( "%d", klado );

print£( "¿Precio de cada baldosa, en euros?
scanf( "%f", Sprecio );

/*--Calcular el núnero de baldosas--*/ [
/*--Calcular las baldosas a lo largo, por exceso-—*/ 4
nLargo = (largo*100 + lado - 1) / lado;
J
/*--Calcular las baldosas a lo ancho, por exceso--*/ (
nAncho = (ancho*100 + lado - 1) / lado;
E
/*--Calcular el núnero total de baldosas-—*/ £
baldosas = nLargo * nAncho;
F
y
/*-—Calcular el coste total--*/ 1
coste = baldosas * precio;
y
/*--Imprimir el resultado--*/ f
print£( "Total %5d baldosasin", baldosas );
printf( "Coste %8.2f eurosin", coste );

 

El resultado de una posible ejecución es el siguiente:

 

    
   
   

Dar el tamaño de la habitación, en m
¿Largo, ancho? 4, 6

¿Lado de la baldosa, en cm? 30

¿Precio de cada baldosa, en euros? 0.56
Total 280 baldosas

foste 156.80 euros

4.5.3 Ejemplo: Calcular los días entre dos fechas

Este ejemplo consiste en calcular la diferencia en días entro dos fechas. Para
simplificar, el cálculo se hace de forma aproximada, contando todos los meses
a razón de 30 días cada mno, y los años completos siempre con 365 días.

 
 

 

94 Fundamentos de programación

 

El cálculo se hace en dos partes. Primero se calculan para cada fecha los días
transcurridos desde el comienzo de su año. Luego se calcula la diferencia entre
fechas, pasando la diferencia en años a días y acumulando la diferencia en días
dentro del año. Los pasos de descomposición son relativamente sencillos:
Calcular la diferencia de fechas —>
Leer las fechas
Calcular la diferencia
Imprimir el resultado
Calcular la diferencia —>
Calcular los días desde principio de año
Calcular la diferencia total de días

El programa completo aparece en el siguiente listado:

 

PARRA AAA

* Programa: DiferenciaEnDias

* Descripción:

* Este programa calcula los días entre dos

* fechas, de forma aproximada, contando todos

* meses de 30 días, y los años de 365
AAA NA

ifinclude <stdio.h>

int mainO) £

int dial, mesl, annol; /* primera fecha */

int dia2, mes2, anno2; /* segunda fecha */

int diasFechal, diasFecha2; /* días desde inicio del año */
int diferencia; /* diferencia en días */

/*- Leer las fechas --*/ 1
print£( "¿Primera fecha (dd,mm,aaaa)? " );
scan£( "Xd, %d,%d", £dial, émesl, gannol );
print£( "¿Segunda fecha (dd,mm,aaaa)? " );
scanf( "Xd, Xd,%d", £dia?, gmes2, ganno2 );
J
/*— Calcular la diferencia --*/ 1
/*—Calcular los días desde principio del año--*/ 1
diasFechal = (mes1 - 1)*30 + dial;
diasFecha2 = (mes2 - 1)*30 + dia2;
J
/*--Calcular la diferencia total en días--*/ £
diferencia = (anno2 - anno1)*365
+ diasFecha2 - diasFechal;
 
  
 
 
 
 
 
 
 
  

lología de Desarrollo de Programas (1) 95

y

/*-—Imprimir el resultado—*/ £
print£( "Desde %2d/%2d/%4dWn", dial, mesl, anno1 );
print£( "hasta %2d/%2d/%4dn", dia2, mes2, anno? );
print£( "hay X5d díasin", diferencia);

,

 

resultado de una posible ejecución del programa es el siguiente:

 

imera fecha (dd,mm,aaaa)? 20,3,2009
la fecha (dd,mm,aaaa)? 14,1,2011
le 20/ 3/2009

ta 14/ 1/2011

664 días

   
  
   

 
  
 
    

ema 5

Estructuras Básicas de la
rogramación Imperativa

e tema se dedica a introducir las estructuras básicas de la programación
perativa: Secuencia, Selección e Iteración, indicando la manera de realizar
as estructuras en Ct. Aunque existen otras estructuras, que se introducen
temas posteriores, en este tema se ha preferido insistir fundamentalmente
los conceptos subyacentes en estas estructuras básicas, prescindiendo de los
ectos específicos de un lenguaje particular.

   
  
   
 
 
 
  
 
  
 
 
  
 
   
 
 
  

mente se presentan sólo las estructuras básicas IF-THEN-ELSE y
HILE, y su codificación en C£. Posteriormente se mencionan las estructuras
ulares IF-ELSIF-ELSE y FOR derivadas de las anteriores, justificándopor la comodidad de su uso.

1 Programación estructurada

programación estructurada es una metodología de programación que funda
almente trata de construir programas que sean fácilmente comprensible
programa no solamente debe funcionar correctamente, sino que además
e estar escrito de manera que se facilite su comprensión posterior.

 

almente en todos los programas se tienen que realizar algunas correccio0 modificaciones después de trascurrido un cierto tiempo. En ese momento
trata de evitar lo que a. veces llega a suceder, desgraciadamente: si el prono está claramente escrito, ni el mismo programador que construyó el
na es capaz de entender cómo funciona.

 
98 Fundamentos de programación

 

Esta metodología está basada en la técnica de desarrollo de programas por refinamientos sucesivos, tal como se ha expuesto en el tema anterior. Inicialmente,
se plantea la operación global a realizar por el programa, y se descompone en
otras más sencillas. A su vez, estas últimas vuelven a ser descompuestas nuevamente en otras todavía más elementales. Este proceso de descomposición
continúa hasta que todo se puede escribir utilizando las estructuras básicas
disponibles en el lenguaje de programación que se está empleando.

5.1.1 Representación de la estructura de un programa

La estructura de los programas imperativos se representa tradicionalmente mediante diagramas de flujo, llamados en inglés “flou-chart”. Estos diagramas
contienen dos elementos básicos, correspondientes a acciones y condiciones
(figura 5.1). Las acciones se representan mediante rectángulos, y las condiciones mediante rombos. Las condiciones equivalen a preguntas a las que se
puede responder “Sí” o “No”,

sI NO
Acción

Figura 5.1 Símbolos de acción y condición.

El flujo de control durante la ejecución del programa se refleja mediante líneas
o vías que van de un elemento a otro. Las acciones tienen una sola vía de
entrada o comienzo y una de terminación o salida. Las condiciones tienen una
vía de entrada, y dos vías de salida marcadas con “SP y “No”. Durante la
ejecución, cuando el flujo llega a la entrada de una acción, la acción se realiza
y el flujo se dirige a su salida, Cuando se llega a la entrada de una condición,
la condición se evalúa, y si resulta ser cierta se continúa por la salida “Sí”,
mientras que si es falsa se continúa por la salida “No”. La figura 5.2 contiene
un ejemplo sencillo de diagrama de flujo. En esta figura se indica también
cómo un fragmento del diagrama, que tenga un solo punto de entrada y uno
de salida, puede ser visto globalmente como una acción única, pero compuesta.

La parte de diagrama de flujo en el interior de una acción compuesta constituye la estructura o esquema de dicha acción. La programación estructurada
recomienda descomponer las acciones usando las estructuras más sencillas posibles, Entre ellas se reconocen tres estructuras básicas, que son: Secuencia,

 
 
  
 
   
  
    
  
   
 
   

Estructuras Básicas de la Programación Imperativa 99

 

 

a
Figura 5.2 Ejemplo de diagrama de flujo (a) y acción compuesta (b).

Selección e Iteración. Estas tres estructuras están disponibles en todos los
Jenguajes modernos de programación imperativa en forma de sentencias del
“Jenguaje. Combinando unos esquemas con otros se pueden llegar a construir
con una estructura tan complicada como sea necesario.

.2 Secuencia
estructura más sencilla para emplear en la descomposición es utilizar una

¡cia de acciones o partes que se ejecutan de forma sucesiva. En la figu5.3 se muestra una secuencia de acciones.

Figura 5.3. Secuencia.

estructura secuencial ya ha sido utilizada en los ejemplos realizados en
temas anteriores. Todos ellos han sido resueltos como una secuencia de
cias elementales del lenguaje.
100 Fundamentos de programación

 

5.1.3 Selección

La estructura de selección consiste en ejecutar una acción u otra, dependiendo
de una determinada condición que se analiza a la entrada de la estructura. En
la figura 5.4 se puede ver la estructura de selección. Si la condición analizada.
<?> da como resultado “Sí” se realiza la acción A y si el resultado es “No”
se realiza la acción B. Como se puede observar sólo tiene una única entrada y
una única salida.

 

Figura 5.4 Selección

5.1.4 Iteración

    

La iteración es la repetición de una acción mientras que se cumpla una determinada condición. La estructura de iteración más general es aquella en que la
condición se analiza a la entrada de la estructura y antes de iniciar cada nueva
repetición. En la figura 5.5 so muestra esta estructura de iteración. Cada vez
que se analiza la condición <?> se pueden dar dos resultados. Si el resultado
es “Sí” se ejecuta muevamente la acción. Una vez ejecutada la acción se vuelve a analizar la condición <?>. En el momento que el resultado es “No” se
alcanza el punto final de la estructura. También en este caso sólo existe un
punto de entrada y un punto de salida.

Puesto que el fhujo de ejecución vuelve hacia atrás siguiendo un camino cerrado,
la estructura de iteración se denomina también bucle.
Estructuras Bá;

 

¡cas de la Programación Imperativa 101

 

 

Figura 5.5 Iteración.

5.1.5 Estructuras anidadas

Cualquier parte o acción del programa puede a su vez estar constituida por
cualquiera de las estructuras descritas. Por tanto, el anidamiento entre ellas
puede ser tan complejo como sea necesario.

Mediante la técnica de refinomientos sucesivos se definen inicialmente las estructuras más externas del programa y en los pasos sucesivos se va detallando
la estructura de cada acción compuesta. Este proceso finalmente da lugar a
que todo el programa quede escrito utilizando las estructuras básicas descritas
en este apartado, anidadas unas dentro de otras.

5.2 Expresiones condicionales

 

Para poder utilizar las estructuras de selección e iteración es necesario expresar
las condiciones <?> que controlan ambas estructuras. Esto se realiza mediante
la construcción de expresiones condicionales. Estas expresiones sólo pueden
dar como resultado dos valores; “Sí” (cierto), cuando se cumple la condi
de la expresión, y “No” (falso), en caso de que no se cumpla.

 

Una primera forma de construir expresiones condicionales es mediante el empleo de operadores de comparación en expresiones aritméticas. Estos operadores permiten realizar comparaciones entre dos valores del mismo tipo. Es
muy importante resaltar que en el Manual de Estilo de esta asignatura no se
permite la comparación entre elementos de distinto tipo (por ejemplo: enteros
son caracteres, reales con enteros, fechas con colores, etc.). Las operaciones
de comparación disponibles y sus operadores en C+ son las siguientes:

 

 
 

102 Fundamentos de programación

 

 

Comparación Símbolo matemático Operador Ct
Mayor que >
Mayor o igual que >
Menor que <
Menor o igual que <
Igual a El
Diferente a +

 

Los símbolos de operadores C+k con dos caracteres deben escribirse precisamente en ese orden, y sin espacio en blanco entre ellos.

Veamos un ejemplo. Sean las variables declaradas siguientes:
int largo, ancho;

float presion, temperatura;
char letra, modelo;

Con los operadores de comparación se pueden formar expresiones condicionales
tales como las siguientes:

largo > 5

ancho == largo

presion <= 23.5

modelo = '2'

letra != modelo

presion != temperatura

Con los operadores de comparación sólo es posible realizar una única comparación entre dos valores. Sin embargo, es bastante normal que las condiciones
sean más complejas. Pueden construirse condiciones que impliquen a más de
dos valores como condiciones compuestas de varias condiciones simples.

Las condiciones compuestas se construyen como expresiones lógicas. Cada término de una expresión lógica podrá ser una expresión condicional simple. Las
operaciones lógicas entre dos expresiones simples Ey, Ez y los correspondientes
operadores disponibles en Ct son los siguientes:

 

Operación lógica Símbolo matemático Operador Ct
Conjunción (E; y Ez) A 88
Disyunción (E, o E>) v nl
Negación (no Ey) > !

La operación de conjunción El 84 E2 da resultado cierto si tanto El como
E2 son ciertos. En el lenguaje C£ para evaluar la operación de conjunción 48
siempre se empieza por evaluar la expresión simple El del primer operando, y
si su resultado es falso ya no se evalúa la expresión E2 del segundo operando.
Estructuras Básicas de la Programación Imperativa 103

 

Está claro que el resultado de la conjunción ya no depende del valor de E2 y
será siempre falso. Por este motivo se dice que el operador 88 se evalúa en
cortocircuito. Esta misma regla se aplica en el caso de realizar la conjunción de
m expresiones El ££ E2 ££ E3 €£ ... ££ En y sólo se continuará evaluando
na nueva expresión Ei cuando todas las anteriores hayan sido ciertas.

La operación de disyunción El || E2 da resultado cierto si una de las dos, El
2 E2,o ambas, son ciertas. También el operador | | se evalúa en cortocircuito
y en la disyunción de n expresiones El 11 E2 11 E3 Il... 11 Ensólo se
continua evaluando una nueva expresión Ei cuando todas las anteriores hayan
sido falsas.

El operador ! se aplica a un solo término y niega el resultado de dicho término.
Este operador unario se utiliza cuando una condición queda expresada de
manera más sencilla como complemento de otra. Por supuesto, el operador !
sólo se puede utilizar para negar elementos de tipo Sí(cierto)/No(falso)

Con estos nuevos operadores es posible construir condiciones complejas tales
como las siguientes:

(largo > 5) €£ (ancho < 7)

fmodelo == 'A') || (modelo == 'Z')

letra == 'Q')

fremperatura <= 123.7) £4 (presion < 12.3)

 

Su significado se puede deducir fácilmente. La razón del empleo de paréntesis
es indicar el orden preciso de ejecución de las operaciones: primero las comparaciones y posteriormente las operaciones lógicas. El empleo de paréntesis en
cualquier lenguaje de programación evita la ambigúedad en las expresiones.
Por el contrario, un uso excesivo de paréntesis para detallar el orden estricto
de ejecución puede llegar a resultar algo farragoso y disminuir la claridad del
programa.

Todos los lenguajes tienen definido un orden por defecto para la evaluación de
dos operadores en las expresiones complejas. Así, como se verá a continuación,
en el lenguaje Ct se realizan primero las operaciones de comparación y posteiormente las operaciones lógicas. Por tanto, en las expresiones anteriores se
podría prescindir de todos los paréntesis salvo para la negación de la tercera.

 

La complejidad de las expresiones puede ser tan grande como sea necesario;
el número de términos lógicos que pueden combinarse es ilimitado. Además,
sada valor numérico se puede obtener mediante una expresión aritmética. Por
ejemplo, son expresiones condicionales válidas las siguientes:
104 Fundamentos de programación

 

(largo < 3) 88 (ancho < 9) Ek (largo*ancho < 25)
((letra == '0Q' || letra == 'Z'))
(3.5*temperatura - presion/5.6) < 54.6

 

En la evaluación de estas expresiones complejas el orden por defecto que se
sigue viene fijado por el nivel de prioridad que tienen asignadas las distintas
operaciones. Es decir, cada operador tiene una prioridad determinada. Si no
se utilizan paréntesis, el orden de evaluación en el lenguaje Ct es el siguiente:

 

1. Operadores Unarios: Dg
2. Operadores Multiplicativos: —* / %

3. Operadores Aditivos: di

4. Operadores de Comparación: > >= < <=
5. Operadores de Igualdad: == |

6. Operador de Conjunción: 88

7.

Operador de Disyunción: Mi

Los operadores unarios + y - permiten indicar el signo del único operando al
que preceden y no se deben confundir con los operadores aditivos + y — que
necesitan dos operandos para calcular su suma o su resta respectivamente.

Dentro del mismo nivel de prioridad las operaciones se evalúan en el orden en
que están escritas en cada expresión concreta, de izquierda a derecha. Como
ejemplo escribiremos ahora sin paréntesis las anteriores expresiones:

largo < 3 88 ancho < 9 88 largo*ancho < 25

letra == 'Q' || letra == "Z'

3.5*temperatura — presion/5.6 < 54.6

Siguiendo los criterios de evaluación indicados, estas expresiones serían equivalentes a las que se indican a continuación, en las que se ha marcado con
paréntesis el orden de la evaluación por defecto:

(largo < 3) 88 (ancho < 9) €£ ((largo*ancho) < 25)

((letra) == 'Q') || (letra == 'Z')

((3.5*temperatura) - (presion/5.6)) < 54.6

 

 

Con es expresiones sólo se trata de mostrar las reglas de evaluación por
defecto, dado que como se puede observar, la segunda expresión está mal
construida, ya que no tiene ningún sentido hacer la negación de un carácter
lletra y después comparar el resultado con el carácter 'Q'. Por otro lado, es
interesante resaltar que las expresiones primera y tercera son completamente
correctas y equivalentes a las expresiones sin ningún paréntesis o bien a las
expresiones originales con paréntesis para explicitar el orden de ejecución:
primero comparar y luego realizar las operaciones lógicas.
 
  
 
 
 
    
   
  
  
  
   
  
  
   
  
  
  
   
    
   

Estructuras Básicas de la Programación Imperativa 105

 

Para formalizar estos conceptos, las reglas BNF que definen cómo se pueden
escribir expresiones aritméticas, condicionales y lógicas en el lenguaje C£ son
las siguientes:

 

Expresión ORÁ, Operador _OR Expresión _OR Y
Expresión _AND

 

 

Expresión _OR
( Operador_AND Expresión _AND Y

 

Expresión _AND 33= Expresión igualdad
[ Operador_igualdad Expresión igualdad ]
Expresión igualdad 33= Expresión numérica
Operador_comparación Expresión numérica ]

 

Expresión numérica Término É Operador_sumador Término Y

Término 33= FactorfÍ Operador multiplicador Factor Y
Factor 33= + Factor | - Enctor | 1 Factor | Identificador_de variable |
Identificador_de_constante | Valor_constante | (Expresión )

Operador OR *
Operador _AND *
Operador igualdad
Operador_comparación $
Operador_sumador 3

  
 

 

 

  

resumen de este apartado, dentro del Manual de Estilo que utilizaremos
asignatura so establecen las siguientes normas:

 

Es aconsejable utilizar paréntesis adicionales para evitar cualquier am
bigñiedad o dificultad de interpretación de la expresión.

2 Es aconsejable utilizar paréntesis adicionales siempre que se mejore la
claridad de la expresión.

No es aconsejable utilizar paréntesis adicionales en aquellas expresiones
que, aprovechando los niveles de prioridad por defecto del lenguaje, estén
ampliamente consensuadas y no planteen ninguna duda en su interpretación.

Xo están permitidas las comparaciones entre elementos de distintos tipos.
Los operadores lógicos ( 84 y || Jsólo se pueden utilizar con elementos
de tipo Sí(cierto)/No(falso)

 

 

 
 

106 Fundamentos de programación

 

5.3 Estructuras básicas en Ct

En este apartado se describen las sentencias de C+ que corresponden a las
estructuras básicas introducidas anteriormente. Además se mencionan algunas
posibilidades adicionales de estas sentencias, que permiten algunas variantes
de las estructuras básicas, y que simplifican la escritura de ciertos programas.

5.3.1 Secuencia

Esta estructura ya ha sido introducida en el tema 2 y utilizada en todos los
programas y ejemplos realizados hasta ahora. Para programar una secuencia
de acciones en Ci se escriben las sentencias que forman la secuencia de acciones
una tras otra. Así, la secuencia de la figura 5.3 se escribe simplemente de la
siguiente manera:

Acción A

Acción B

Formalmente, según se vio en el tema 2, la sintaxis de la estructura secuencia

 

 

Secuencia_de_sentencias [ Sentencia Y

5.3.2 Sentencia IF

En C2 la estructura de selección de la figura 5.4 se programa como una sentencia IF que tiene el siguiente formato:

if ( Condición ) 4
Acción A

F else (
Acción B

J

 

La ejecución de la sentencia 1£ consiste en evaluar la expresión de Condición,
y a continuación ejecutar o bien la Acción A (si se cumple la condición), o
bien la Acción B (si la condición no se cumple). Las palabras clave 1£ y else
separan las distintas partes de la sentencia. Por ejemplo:

if (largo > ancho) £
ladoMayor = largo;
J else £
ladoMayor = ancho;
$
 
  
   
 
    
  
    
  
 
   
 
  

turas Básicas de la Programación Imperativa 107

 

 
 
 

ocasiones no es necesario ejecutar nada cuando la Condición no se cumple,
estructura en estos casos queda reducida a la que se muestra en la figura 5.6.

 

Figura 5.6 Selección simple.

formato de la sentencia en Ct es ahora el siguiente:

€ Condición ) 4
Acción

este caso se ejecuta la Acción cuando la expresión Condición se cumple y en
contrario no se ejecuta nada. Así, el ejemplo anterior se puede programar
ién como:

 

yor = ancho;
(largo > ancho) [
ladoMayor = largo;

bastante frecuente realizar selecciones que dan lugar a más de dos posibis. Por ejemplo, ciertas tarifas pueden ser diferentes según la edad:

Niños de O a 6 años Gratis
Jóvenes de 6 hasta 18 años 50 %
Adultos de 18 hasta 65 años 100 %

Jubilados de 65 años en adelante 25 %

como se indicó anteriormente, es posible anidar varias estructuras de selecunas dentro de otras. Así, se podría realizar esta selección de la siguiente

 
108 Fundamentos de programación

if (edad < 6) £

tarifa = 0.0;
) else £

if (edad < 18) £
tarifa = 0.5;

) else (
if (edad < 65) 4

tarifa = 1.0;

) else (

tarifa = 0.25;
$

F

Si, como en este caso, la evaluación de las condiciones se hace en cascada,
atendiendo a una de ellas sólo si todas las anteriores han sido falsas, se puede
simplificar la escritura en C£ de la sentencia IP eliminando las llaves £...)
de las ramas else para expresar directamente una cadena de selecciones. El
formato general se representa gráficamente en la figura 5.7.

 

 

Figura 5.7 Selección on cascada.

El formato de la sentencia if para la selección en cascada es el siguiente:

if ( Condición 1) 4

Acción A
) else if ( Condición 2) 4
ión B

 

 
 

Estructuras Básicas de la Programación Imperativa 109

 

) else if ( Condición N ) 4
Acción J

j else (
Acción K

y

Con esta estructura la selección anterior se escribe en Ct de la siguiente manera:
Af (edad < 6) 4
tarifa = 0.0;
J else if (edad < 18) £
tarifa = 0.5;
J else if (edad < 65) (
tarifa = 1.0;
j else (
tarifa = 0.25;

Este formato resulta ahora mucho más elegante y fácil de entender.

Todas las sentencias presentadas son variantes de una única sentencia IF de
(Ct cuya sintaxis es la siguiente:

 

Sentencia_1F if ( Condición ) £ Secuencia_de sentencias Y
else if ( Condición ) £ Secuencia de sentencias +
else ( Secuencia_de_ sentencias y

5.3.3 Sentencia WHILE

En Ci la estructura de iteración de la figura 5.5 se consigue mediante la
sentencia WHILE, que tiene el siguiente formato:
sbile ( Condición ) £

Acción

y

El significado es que mientras la expresión Condición resulta cierta, se
la Acción de forma repetitiva. Cuando el resultado es falso finaliza la ejecución
de la sentencia. Si la Condición resulta falsa en la primera evaluación, la
Acción no so ejecuta nunca. Por ejemplo, el factorial de un número n se puede
calcular mediante la fórmula habitual:

 

ni=1x2xX3xX4X.xn

Este cálculo se puede programar en Ci utilizando una sentencia while de la
siguiente forma:

 
110 Fundamentos de programación

 

factorial = 1;
uhile (n> 1) (
factorial = factorial * n;
m3

3

Así, con la sentencia de autodecremento la variable n va disminuyendo su válor de uno en uno en cada repetición del bucle, al tiempo que esos valores se
van multiplicando sucesivamente, guardando el producto acumulado en fac—
torial, hasta que n se reduce a 1. Si inicialmente el valor de n es igual o
menor que 1, no se ejecutan munca las sentencias dentro del bucle, por lo que
la variable factorial termina con el mismo valor inicial igual a 1.

5.3.4 Sentencia FOR

Existen muchas situaciones en las que las repeticiones del bucle se controlan
mediante una variable que va contando las veces que se ejecuta. La cuenta
puede ser en sentido creciente, o decreciente. La Condición de la. iteración se
límita a comprobar si se ha alcanzado el límite correspondiente al número de
repeticiones previstas. Esto es lo que hemos hecho en el ejemplo del factorial
con la variable n. La variable n se decrementa en cada iteración y se comprueba
el número total de ejecuciones con la expresión condicional n > 1.

Debido a lo habitual de esta situación, en casi todos los lenguajes existen
sentencias que simplifican su construcción. En C+ se dispone de la sentencia
FOR, cuya forma para incremento creciente es la siguiente:
for (int Índice = Inicial ; Índice <= Pinal ; Índice ++) £

Acción

a

 

El símbolo punto y coma (;) separa los distintos elementos de control de
la sentencia, La actualización del índice se hace mediante la sentencia de
autoincremento.

La variable Índice sirve de contador para controlar el número de iteraciones a
realizar. Inicialmente la variable Índice toma el valor Inicial y se incrementa
automáticamente en una unidad con cada nuova ejecución de Acción. La
Acción se ejecuta repetidamente hasta que la variable Índice alcanza el valor
Final.

 

Ambos valores, inicial y final, pueden ser expresiones aritméticas. Estas expresiones se evalúan sólo una vez al comienzo de la sentencia FOR y no se
 
  
  
  
  
   
  
    
  
 
   
  
   
  
   
  
   
 
 
  
  

'uras Básicas de la Programación Imperativa 1

 

an durante toda su ejecución. Si el valor inicial es mayor que el valor
la Acción no se ejecuta nunca.

variable Índice puede ser utilizada dentro de Acción pero nunca debe ser
a, pues se perdería el control automático de las repeticiones. Esconstituye una norma del Manual de Estilo que es obligatorio aplicar a
er sentencia POR

variable Índice se declara dentro del propio FOR, y sólo existe mientras
ejecuta. Al terminar la ejecución la variable Índice ya no es visible en las
jentes sentencias del programa.

 

a se puede volver a escribir el cálculo del factorial de la siguiente manera:
orial =

(int indice = 2; indice <= n; indice++) 4

factorial = factorial * indice;

se fragmento de programa es más sencillo. Además, resulta evidente que
sa el cálculo del factorial se emplea un número de iteraciones conocido, que
depende de lo que se calcula con cada iteración. Como se puede observar
entro del bucle se utiliza la variable indice con el valor que toma en cada
la variable n mantiene su valor inicial. Para valores de n inferiores a
2 3 sentencias dentro del bucle no se ejecutan nunca.

sentencia FOR de C+ tiene una versión para decrementar el contador en
a repetición. En este caso el formato es el siguiente:
(int Índice = Inicial ; Índice >= Final ; Índice -) £

ora en cada iteración la variable Índice se decrementa en una unidad con
tada mueva ejecución de Acción mediante la sentencia de autodecremento. Por
“jemplo, se puede realizar el cálculo del factorial en sentido inverso de la
“manera siguiente:

orial =
(int indice = n; indice <= 2; indice--) (
factorial = factorial * indice;

La sintaxis completa de la sentencia FOR es, por tanto, la siguiente:

 

Sentencia_FOR +32 For_creciente | For_decreciente

 
112 Fundamentos de programación

 

For_creciente 11= for ( int Variable_éndice = Valor_inicial ;
Variable_índice <= Valor_final ; Variable _éndice ++ )
1 Secuencia_de sentencias Y

 

For_decreciente 335 for ( int Variable índice = Valor_inicial ;
Variable_índice >= Valor_final ; Variable_índice -- )
£ Secuencia_de_sentencias Y

= Identificador

 

Variable_índice 3

 

Valor_inicial

Valor_final +

Expresión

 

Eupresión

5.4 Ejemplos de programas

En este apartado se muestran varios ejemplos de programas completos que
utilizan las sentencias presentadas en este tema.

5.4.1 Ejemplo: Ordenar tres datos

Se trata de realizar un programa que lea 3 valores enteros y los ordene de
menor a mayor en las mismas variables en que se leen: el valor menor quedará
en la primera variable y el mayor en la última.

La ordenación se realiza en dos pasos: la primera parte se dedica a ordenar los
dos primeros valores y en la segunda se ordenará el tercero comparándolo con
los ya ordenados. Se utiliza una variable auxiliar para realizar los intercambios
de valores entre las variablos. El listado del programa completo esta recogido
a continuación.

 

A DREAD LLRELLLERER
+ Programa: Ordenar3

*

* Descripción:

* Este programa ordena tres valores y

*+ los guarda ordenados de menor a mayor

* en las mismas variables que se leen

AAA /

*tinclude <stdio.h>
uras Básicas de la Programación Imperativa 113

 

    
  
   
   
  
 
 
    
   
  
  
   
   
 
  
 
 
  

main() (
int valUno, valDos, valTres, auxiliar;

/*-—- Leer los dat
print£( "¿Datos?
scanf( "%d %d %d", dvalUno, ávalDos, évalTres );

 

Y

 
 

/*— Primer Paso: Ordenar los dos primeros datos --*/
if (valuno > valDos) £

auxiliar = valUno;

valUno = valDos;

valDos = auxiliar;

3

/*—- Segundo Paso: Situar el tercer dato -—-*/
Af (valTres < valuno) (

auxiliar = valIres;

valTres = valDos;

valDos = valUno;

valUno = auxiliar;

J else if (valTres < valDos) (

auxiliar = valDos;

valDos = valTres;

valTres = auxiliar;

 

+

/*-— Tercer Paso: Escribir el resultado --*/
printf( "Datos Ordenados = %sd %5d X5dWn", valUno, valDos, valTres);

 

ejecución del programa produce un resultado como el siguiente:

 

  

os? 567 123 89
Ordenados = 89 123 567

 
114 Fundamentos de programación

 

5.4.2 Ejemplo: Escribir un triángulo de dígitos

Con este programa se trata de escribir un triángulo de números entre el 1 y el
9. El nivel del triángulo se introducirá como dato. El resultado del programa
será semejante al mostrado a continuació

 

 

¿Altura del triángulo? 9
dl
m1
12321
1234321
123454321
12345654321
1234567654321
123456787654321
12345678987654321

Este es un problema típico en el que se pueden utilizar un número de iteraciones
conocidas:

+ Primeramente se necesita una iteración por cada línea de dígitos. El
número de líneas es un dato de partida que so introduce, por tanto, es
conocido,

+ Cada línea se puede realizar en dos mitades:

- 1% mitad: Una iteración creciente hasta el número de línea.
El número de iteraciones es conocido e igual al número de la
línea que se esta escribiendo. Por ejemplo para la sexta línea:

123456

— 2% mitad: Una iteración decreciente desde el número de lnea decrementada en uno, hasta uno. Por tanto, el número
de iteraciones es conocido. Por ejemplo para la sexta línea:

54321

La escritura del primer número se puede conseguir mediante otra iteración
que escribe caracteres en blanco. Si el triángulo está centrado en centro, el
primer número se tiene que escribir tantas posiciones delante del centro como
el número de línea que se esta escribiendo. Hay que tenor en cuenta que en
cada iteración, la altura del triángulo coincide con el número de línea que se
está escribiendo. El programa completo se muestra a continuación.

 
 
 
  
   
   
 
    
  

uras Básicas de la Programación Imperativa 15

 

 

ARANA AAA

Programa: TrianguloDeNumeros

Descripción:

Este programa escribe un triángulo de dígitos.

La altura se lee como dato y debe ser menor de 10
ARA AAA AAA

<stdio.h>

nO (

const int centro = 35; /* Posición del eje del triángulo */
const int inicial = 1; /* Dígito inicial: superior y laterales */
int nivel;

- /*— Leer los datos —Y/ 1
print£( "¿Altura del triángulo? "
scanfí "Xd", nivel );

y

/*— Una iteración por cada línea del triángulo --*/

for (int altura = inicial; altura <= nivel; altura++) (

 

/*-— Paso 1%: Situar primer número 'de cada línea
for (int indice
primtf("");

 

./
1; indice <= centro-altura; indice++) (

 

 

$
print£( "Xd", inicial );
3
/*-— Paso 2%: Primera mitad de la línea del triángulo
Escribir números consecutivos hasta altura --*/ (
for (int indice = inicial+1; indice <= altura; indice++) £
printf( "Xld",indice );
J
y
/*-— Paso 3%: Segunda mitad de la línea del triángulo.
Escribir números decrecientes hasta Inicial --*/ f
for (int indice = altura-1; indice >= inicial; indice--) (
print£( "1d", indice );
y
J
/*— Paso 4%: Saltar a una nueva linea --*/ (
print£( “wn”

  

 

 

 
 

 

116 Fundamentos de programación

5.4.3 Ejemplo: Elaboración de tickets y resúmenes

Este programa es un ejemplo simplificado del programa de una máquina de
expender tickets de entrada a un espectáculo. El precio del ticket dependerá
de la edad del espectador, según se indicó en el ejemplo del apartado 5.3.2,
agrupados en Niños, Jóvenes, Adultos y Jubilados. El programa acumulará
las entradas que se expenden y la cantidad total recaudada.

El programa dispondrá de un menú general para seleccionar la elaboración del
ticket, la elaboración del resumen o la finalización del programa. El programa
seguirá claborando tickets hasta que el taquillero dé por finalizada su tarea.
En los resúmenes se mostrarán los datos acumulados de tickets expendidos y
el total recaudado. El listado del programa es el siguiente:

 

PAOLO
* Programa: Ticket

* Descripción:

* Este programa elabora el ticket de entrada y los

* resúmenes de recaudación de un espectáculo.

* El precio del ticket depende de la edad del

* espectador (Niño, Joven, Adulto o Jubilado)

ARANA RARA RARA RARA RAR RARA REA AAA RRA

include <stdio.h>

int main() (
const float PrecioBase = 6.0; /* Precio de la butaca */
int butacas = /* Número de butacas vendidas */

 

  

int edad; /* Edad del cliente */

float totalEuros = 0.0; /* Total de euros recaudados */
float precio; /* Precio de cada butaca */
char opcion =" '; /* Opción del programa */

char tecla =' '; /* Tecla Si/No */

 

/*-- Bucle hasta opción F de fin --*/
while (opcion != 'F") 4
print£( "Opción (Ticket, Resumen o Fin) ? " );
opcion =*' *;
while ((opcion *T') 84 (opcion
scanf( "%e", dopcion );
3

   

*R') 88 (opcion

 

TDT
   
 
 
   
    

icturas Básicas de la Programación Imperativa 17

 

 
   
 

del Ticket

 

 

 

if (opcion = "T') £

tecla = 'S';

while (tecla == 'S') (
print£( "Edad? " );
scan£( "Xd", Sedad );
butacas++;
print£( o
print£( "| TICKET DE ENTRADA a"

 

if (edad < 6) € /* niño, gratis */

print£( "[Gratis " );

precio = 0.0;

else if (edad < 18) [ /* joven, 50% */

print£( "|Joven —" );

precio = PrecioBase / 2.0;

else if (edad < 65) £ /* adulto, tarifa completa */
print£( "[adulto " );

precio = PrecioBase;

 

   

j else ( /* jubilado, 25% */
print£( "|Jubilado" );
precio = PrecioBase / 4.0;
,
totalEuros = totalEuros + precio;
printf( Precio: %4.2f|Yn", precio );
print£( => Ama");
printf( "Otro Ticket(S/N)? " );
tecla =' ';

while (Crecla 1= 'S') 8% (tecla l= 'N')) 4
scanf( "%c", Stecla );

$
J

Y mmm
Elaboración del Resumen de la recaudación
if (opcion == 'R') (
print£( " RESUMEN DE VENTAS An" );
printf( " Me” ds
print£( "sad Butacas Wn", butacas );
printf( "Total Recaudado = %10.2£inin", totalEuros );
y

 

     

   

 

 

 

y

 

 
18 Fundamentos de programación

 

Una ejecución simplificada del programa da como resultado el siguiente:

 

Opción (Ticket, Resumen o Fin) 2 T
Edad? 13

1 TICKET DE ENTRADA 1
Joven Precio: 3.001

 

  

Otro Ticket(S/N)? S
Edad? 67

I TICKET DE ENTRADA !
IJubilado Precio: 1.501

 

  

Otro Ticket(S/N)? N

Opción (Ticket, Resumen o Fin) 7 R
RESUMEN DE VENTAS

2 Butacas
Total Recaudado = 4.50

Opción (Ticket, Resumen o Fin) ? F

 
   
   
   
   
    
  
    
   
   
   
   

ema 6

etodología de Desarrollo de
gramas (II)

objetivo de este tema es múltiple. En primer lugar se amplía la técnica
refinamientos sucesivos presentada en el tema 4 con la posibilidad de usar
esquemas de selección e iteración.

En segundo lugar se introduce la idea de verificación formal de programas,
“smque de una manera muy simplificada, en forma de razonamientos intuitivos
las estructuras utilizadas hasta el momento.

ente se trata por primera vez el problema de la eficiencia, y se introduce
“dle forma igualmente simplificada el concepto de complejidad algorítmica.

6.1 Desarrollo con esquemas de selección e iteración

En este apartado se ilustra el empleo de la técnica de refinamientos sucesivos
explicada en el tema 4, ampliada ahora con la posibilidad de utilizar las muevas
estructuras de selección o iteración. Con ello se tienen tres posibilidades a la
hora de refinar una acción compuesta:

 

 

+ Organizarla como secuencia de acciones.
+ Organizarla como 1 entre acciones alternativas.
+ Organizarla como iteración de acciones.

 

En el tema 4 se ha presentado ya la metodología para desarrollar esquemas
e secuencia. A continuación se amplía la metodología con recomendaciones
para desarrollar esquemas de selección e iteración.

 
Í
|

 

 

120 Fundamentos de programación

6.1.1 Esquema de selección

Recordaremos que un esquema de selección consiste en plantear una acción
compuesta como la realización de una acción entre varias posibles, dependiendo
de ciertas condiciones. Es decir, se trata de elegir una sola entre varias posibles
alternativas.

Para desarrollar un esquema de selección debemos identificar sus elementos

componentes. Por tanto habrá que

 

 

(a) Identificar cada una de las alternativas del esquema, y las acciones correspondientes.
(b) Identificar las condiciones para seleccionar una alternativa u otra.

Como ejemplo, aplicaremos estas recomendaciones al desarrollo de una acción
compuesta para calcular cuántos días tiene el mes de Febrero de un cierto año.
Reconoceremos que:

(a) Las alternativas son quo tenga 28 días o que tenga 29. Las acciones serán
asignar dicho valor a una variable que almacene el número de días.

[días = 28
o bien
[dias = 29

(b) La condición para elegir una acción u otra es que el año sea bisiesto.
De forma simplificada (pero válida para años entre 1901 y 2099) expresaremos la condición como equivalente a que el año sea múltiplo de
cuatro.

[anno % 4 = 0

Colocando cada elemento identificado en el lugar correspondiente del esquema,
tendremos:

if (anno % 4
dias = 2

) else £
dias = 28;

01

  

y

De manera similar se pueden desarrollar esquemas de selección simplificados,
con sólo una acción condicionada, o esquemas de selección en cascada en que
haya un número más o menos grande de alternativas. Por ejemplo, el esquema
anterior podría replantearse realizando primero el tratamiento más común, es
decir, que Febrero tenga 28 días, y luego corrigiendo este valor si es necesario.

 
“Metodología de Desarrollo de Programas (11) 121

 

= 28;
(anno % 4 == 0) (
dias = 29;

a

Como ejemplo de selección en cascada, desarrollaremos el cáleulo de los días
del mes, para cualquier mes del año. Las alternativas son:

Enero, Marzo, Mayo, Julio, Agosto, Octubre, Diciembre.
Abril, Junio, Septiembre, Noviembre

Febrero (año bisiesto).

Febrero (año normal).

 

Para simplificar las expresiones de condición, dejaremos para la última altersativa aquella en que la condición sea más compleja. En este caso sería la de
Jos meses de 31 días, que son los más numerosos. Las otras alternativas podeamos situarlas en un orden arbitrario. Al escribir las condiciones debemos tener
'Én cuenta que si hay que evaluar una de ellas es porque todas las anteriores
han resultado falsas:
((mes==2) ¿8 (anno % 4
dias = 29;
) else if (me
dias = 28;

 

01

 

 

6.1.2 Esquema de iteración

Una iteración o bucle consiste en la repetición de una acción o grupo de acsiones hasta conseguir el resultado deseado. Para desarrollar un esquema de
¿eración dentro de un programa deberemos identificar cada uno de sus elemenos componentes. Al hacerlo hay que identificar simultáneamente las variables
adecuadas para almacenar la información necesaria.

En líneas genorales se podría proceder de la siguiente manera:

(a) Identificar las acciones útiles a repetir, y las variables necesarias. Precisar el significado de estas variables al comienzo y final de cada repetición.

(b) Identificar cómo actualizar la información al pasar de cada iteración a
la siguiente. Puede ser necesario introducir nuevas variables.

 
122 Fundamentos de programación

 

(e) Identificar la condición de terminación. Puede ser necesario introducir
nuevas variables e incluso acciones adicionales para mantenerlas actualizadas.

(d) Identificar los valores iniciales de las variables, y si es necesaria alguna
acción para asignársolos antes de entrar en el bucle.

Además de los elementos anteriores, puede ser necesaria alguna acción adicional al comienzo o al final del bucle. Si son acciones muy simples, pueden
considerarse parte del esquema. de iteración como tal. Si son algo complejas
será mejor considerarlas como acciones anteriores o posteriores, siguiendo un
esquema secuencial.

El método explicado corresponde al caso general. En bastantes casos el desarrollo de un bucle es mucho más sencillo. Esto ocurre en particular cuando
se programan bucles con contador, si las acciones a repetir pueden expresarse
directamente en función del contador del bucle. En este caso los pasos b), c) y
d) se refunden en uno sólo, consistente en determinar los valores inicial, final
y el incremento del contador del bucle.

Desarrollaremos con la técnica indicada un fragmento de programa que imprima los términos de la serie de Fibonacci. Cada término de esta serie se
obtiene sumando los dos anteriores. La serie comienza con los términos 0 y 1,
que se suponen ya impresos antes del bucle. Se trata de calcular e imprimir
tantos términos como sea posible.

 

 

Procediendo paso a paso, describiremos cada elemento del desarrollo de manera informal, seguido de su codificación en C£.

(a) Acciones útiles a repetir: Imprimir un término.

"*10d1n", termino);

 

| printec
Variables necesarias: El término a imprimir.
[int termino;
Valor al empezar la repetición: Ultimo término impreso hasta el momento.
(b) Actualizar las variables al pasar de una, repetición a la siguiente: Antes

de imprimir, calcular el término actual a partir de los dos anteriores (se
necesita tener almacenado el penúltimo término).

 

aux = termino + anterior;
anterior = termino;
termino = aux;

 
 
  
   
 
 
 
 
 
 
 
   
 
    
 
   
  
   
  
   

lología de Desarrollo de Programas (II) 123

Variables adicionales: El penúltimo término, y una variable temporal.
int anterior;
int aux;

(c) Condición de terminación: El término siguiente excedería del rango de
los enteros. Hay que evaluar la condición sin calcular explícitamente el
valor de dicho término, porque se produciría “overflow”.

| INT_MAx-termino < anterior
(Obsérvese que esta expresión equivale en teoría a INI_ZMAX < termino+anterior)

ld) Valores iniciales de las variables: Los dos primeros términos, 0 y 1.

anterior =
termino =

  

El bucle completo sería:

termino;
anterior;

(INT_MAX-termino >= anterior) (
aux = termino + anterior;

anterior = termino;

termino aux;

print£("%10dW", termino);

6.2 Ejemplos de desarrollo con esquemas

A continuación se ilustra la técnica de desarrollo por refinamientos utilizando
los esquemas de selección e iteración sobre algunos ejemplos típicos.

6.2.1 Ejemplo: Imprimir el contorno de un triángulo

Se trata de imprimir con asteriscos el perímetro de un triángulo aproximada'mente equilátero, tal como se indica a continuación:

 

 
 

124 Fundamentos de programación

 

 

¡e .. e...

Como parámetro del problema se especificará la altura del triángulo. Si la
altura es N, habrá que imprimir N líneas, cada una con la configuración de
asteriscos que corresponda. El triángulo anterior tiene altura 7. Se pretende
además que el triángulo aparezca ajustado a la izquierda; es decir, el primer asterisco de la línea inferior deberá empezar exactamente en la primera posición
de esa línea. Las otras líneas empezarán con el espacio en blanco apropiado

El planteamiento inicial del programa será:

Imprimir el borde de un triángulo

 

El primer paso de refinamiento consistirá en decidir si esta acción compuesta
debe plantearse como una secuencia de acciones simples, o como selección
entre alternativas, o como bucle, Observando que hay tres clases de líncas a
imprimir, según el número de asteriscos que contienen, elegiremos la primera
opción, y escribiremos:
Imprimir el borde de un triángulo —>

Imprimir el vértice superior

Imprimir los bordes laterales

Imprimir el borde inferior
El orden en que deben realizarse las acciones viene determinado por el hecho
de que la impresora va imprimiendo las líneas sucesivas de arriba a abajo.

A continuación refinaremos cada una de estas acciones. Para ollo examinaremos con detalle los caracteres que hay que imprimir en cada línea, en función
de la altura del triángulo (en particular, los espacios en blanco intermedios).
Marcando con puntos los espacios en blanco, tendremos:

 

Línea 1 N-1 blancos

Línea 2 N-2 blancos, 1 blanco
Línea 3 N-3 blancos, 3 blancos
Línea k N-k blancos, 2k-3 blancos

 

Línea N  *,*,*,*,*,*.*  N asteriscos espaciados

El refinamiento de la primera acción será en forma de secuencia:
ología de Desarrollo de Programas (11) 125

 

  
  
    
  
   
   

Imprimir el vértice superior —>
Imprimir N-1 blancos
Imprimir un asterisco
Saltar a la línea siguiente

acción de imprimir los blancos será una iteración, que podemos escribir
tamente mediante un bucle con contador:
Imprimir N-1 blancos —>

for (int k = k <= N-1; k++) £
print£( "");

 

,
acciones de imprimir un asterisco y saltar a la línea siguiente se escriben
inmediatamente:

Imprimir un asterisco —>

print£( "*" )

Saltar a la línea siguiente —

print£( "Ma" );

En Ct resulta más natural que estas acciones se agrupen en la misma sentencia:
Imprimir un asterisco y Saltar a la línea siguiente —>

printi( An");

En el siguiente paso de refinamiento dotallaremos la impresión de los hor
des laterales. Intuitivamente podemos establecer una estructura de iteración
mediante un bucle con contador:

Imprimir los bordes laterales —>

for (int k = 2; k <= N-1; k+*+) 4
Imprimir los bordes de la línea k

 

3

Observaremos que la línea k-esima va precedida de N — k blancos, y tiene
2k — 3 blancos entre los bordes:
Imprimir los bordes de la línea k —

Imprimir N-k blancos

Imprimir un asterisco

Imprimir 2-3 blancos

Imprimir un asterisco

Saltar a la línea siguiente

 
126 Fundamentos de programación

 

Todas estas acciones han sido ya refinadas como sentencias de Ct. Finalmente
falta por plantear la impresión del borde inferior. Podremos distinguir la
impresión del primer asterisco y la del resto, y escribir:

Imprimir el borde inferior —>
Imprimir un asterisco
Imprimir N-1 asteriscos precedidos de blanco
Saltar a la línea siguiente

La acción central se escribirá como un bucle con contador:
Imprimir N-1 asteriscos precedidos de blanco —=

for (int k = 1; k <= N-15 kee) £
print£( " *" );
+

Reuniendo todos los fragmentos, añadiendo la parte declarativa necesaria, y
documentando cada elemento importante del programa, tendremos el programa completo, tal como se recoge en el listado de la versión inicial.

 

AAA AAA

* Programa: Triangulo (Versión inicial)

* Descripción:
* Este programa escribe el borde de un triángulo
* — aproximadamente equilátero, usando asteriscos.

RRA ARRE

itinclude <stdio.h>

int main() (
const int N =7; /* altura del triángulo */

/*— Escribir el vértice superior --*/
for (int k = 1; k <= N-1; ke) 4
printe( "o;

,
printf( “An”;

/*-- Imprimir los bordes laterales --*/
for (int k = 2; k

for (int j j

print£( "

  

y
print£( "*" );
 
  
   
 
 
   
 
  
 
 
 
   
   
    
  
   
  
  
  

Metodología de Desarrollo de Programas (11) 127

 

for (int
print£(

js 23; d+.) 4

 

+
print£( "a" );
3

/%-- Imprimir el borde inferior --*/

printf( "+" );

for (int k = 1; k <= N-1 3 k++) £
print£( "+" );

 

3
printf( "Wn" );

 

Este programa puede compilarse y ejecutarse, obteniendo el resultado puesto
anteriormente como ejemplo. Sin embargo no puede considerarse totalmente terminado. Una deficiencia es que la altura del triángulo aparece como
constante, cuando en realidad sería más razonable leerla como dato en cada
ejecución del programa. La solución será definir N como variable, y leer su
ssalor al comienzo.

Otra deficiencia es que no se tienen en cuenta algunos casos especiales, en que
el triángulo degenora y no tiene todos los elementos identificados. Esto ocurre
cuando la altura del triángulo es O, 1 6 2. En el primor caso se omiten todas las
líneas; en el segundo sólo existo el vértice superior, y en el tercero no existen
bordes laterales.

En esta versión inicial, para la altura igual a 2 no se obtienen resultados
“erróneos, ya que el bucle de líneas de los bordes laterales tal como está escrito so
ejecutaría O veces (pero esto se debe más a la casualidad que a un razonamiento
previo del comportamiento del programa). Por ejemplo, si cambiásemos el
parámetro de altura al valor 1:

 

tON = 1;

obtendríamos el resultado erróneo:

 

este mismo resultado se obtiene para N = O . La solución general será convertir
Én esquema de selección condicional la impresión del vértice superior y del
borde inferior:

 
128 Fundamentos de programación

Imprimir el vértice superior —>

if (190) (
Imprimir N-1 blancos
Imprimir un asterisco
Saltar a. la línea siguiente

y

Imprimir el borde inferior —

if (m1) £
Imprimir un asterisco
Imprimir N-1 asteriscos precedidos de blanco

 

3

La versión corregida del programa aparece en el siguiente listado:

 

 

  

JARA AA AAA

+ Programa: Triangulo? (Versión corregida)
+
Descripción:
Este programa escribe el borde de un triángulo
aproximadamente equilátero, usando asteriscos.
La altura del triángulo, en líneas de texto,
se lee como dato
AAA AA AA A ARA

*include <stdio.h>

int main() £
int altura; /% altura del triángulo */

 

/*-- Leer altura deseada --*/
print£( "¿Altura? " );
scant( "%d", Galtura );

/*-- Imprimir el vértice superior --*/
if (altura > 0) £
for (int k = 1; k <= altura-1; k++) 4
printf" ");
,
print£( "sa" );
+
 

Metodología de Desarrollo de Programas (11) 199

 

/*-—— Imprimir los bordes laterales --*/
for (int k = 2; k <= altura-1; k++) 4
for (int j j <= altura-k; je) 4
print£( "
y
printf( "*" )
for (int j=1; j <= 2*k-3; je) (
primet " "De;

 

  

d

3
print£c "a" );
3

/*— Imprimir el borde inferior --*/
i£ (altura > D) (
primt£( "e" )
for (int k = 1; k <= altura-1 ; ke) £
print£( "+" );

 

3
print£( "Ya" );
y

 

Algunos ejemplos de ejecución serian los siguientes:

 

¿Altura? 7
+

¿Altura? 1

6.2.2 Ejemplo: Imprimir el triángulo de Floyd

Se trata de desarrollar un programa que imprima el llamado triángulo de Floyd.
Este “triángulo” se forma imprimiendo los sucesivos números naturales 1, 2,
3, ... en filas sucesivas, colocando un número en la primera línea, dos en la
segunda, tros en la tercera, etc. Si fijamos un límite arbitrario de la serie de
'aúmeros (p. ej. 12), tendremos el triángulo:

 

 
 

130 Fundamentos de programación

 

6
9 10

Exsanpa
Bouw

1 1

Es fácil darse cuenta de que en general la línea k tiene l números, excepto
la última línea, que puede quedar incompleta. El programa de este ejemplo
deberá leer como dato el límite de la serie.

El primer paso de refinamiento será:

Imprimir el triángulo de Floyd —>
Leer el límite N de la serie
Imprimir el triángulo hasta. N

La primera acción puede desarrollarse en sentencias de C+ de forma inmediata:
Leer el límite N de la serie —>

print£( "Límite de la serie
scanf( "Xd",8N );

 

La parte principal del programa es la impresión del triángulo. Habremos de
refinarla en forma de un esquema de secuencia, selección o iteración. Puesto
que se trata de imprimir un número variable de líneas y valores, con acciones
similares para todos ellos, parece razonable usar un esquema de iteración. La
decisión a tomar será si plantear la iteración como bucle de números o de
líneas. Según la elección que hagamos tendremos dos esquemas de programa
diferentes, que desarrollaremos por separado.

6.2.2.1 Escritura mediante bucle de números

Elegiremos en primer lugar esta posibilidad, que facilita la codificación del
bucle, ya que puede plantearse como un bucle con contador:

Imprimir el triángulo hasta N —>

for (int k = 1; k <= N; ke) 4
Imprimir el número k

y

La impresión del número requiere acciones adicionales, ya que debe incluir el
saltar de línea al comienzo de cada nueva línea del triángulo. Puede plantearse
como secuencia de acciones, de la forma:
 
  
 
   
  
   
    
  
 
   
  
     
   
  
 
  
 
 
   
  
 
   

Metodología de Desarrollo de Programas (11) 131

 

Imprimir el número k —>

Saltar de línea, si es necesario
print£( "*5a",k );

En este planteamiento los saltos de línea no se producen en cuanto se llega al
£nal de la línca, sino cuando se va a escribir el siguiente valor. Esto quiere
decir que el último número impreso dentro del bucle no irá seguido de salto de
lnea, y que habrá que completar la última línea como acción de terminación,
fuera del bucle; es decir, la escritura del triángulo terminará con una acción
adicional:

 
 

Completar la última línea

Refinaremos la acción de saltar de línea en forma de esquema, de selección:

 

Saltar de línea, si es necesario —>
if (el número anterior fue el último de su línea)
printf£( "Ya" );
3

El refinamiento de la condición va a exigir introducir nuevos elementos. Para
“expresar dicha condición como una expresión en Ck necesitaremos mantener
“actualizada la indicación de cuál es el último valor de cada línea. En todo
'saso necesitaremos conocer enántos múmeros han de imprimirse en la línea en
'gurso (recordemos que en la línea £ habrá k números).

Usaremos una variable linea como contador de líneas y otra variable ultimo
para contener el último número de la línea. Estas variables habrán de actuali“zarse cada. vez que se cambie de línea. Reescribiremos el refinamiento anterior
de la forma siguiente:
Saltar de línea, si es necesario —>
if (k > ultimo) (

print£( "an" );

linea++;

ultimo = ultimo + linea;

3

Al mismo tiempo hay que ampliar la inicialización del bucle de escribir números
“izcluyendo el dar valores iniciales a las nuevas variables, en concreto:

   

¿Esta inicialización es la adecuada incluso en el caso de escribir O números, ya
que los valores corresponden al primer número que completa línea, tras el cual
habrá que saltar de línea si se imprimen más números.

 

 
132 Fundamentos de programación

 

No hay que olvidar desarrollar la acción de saltar de línea al final de la última
línea del triángulo, Esta acción será condicional si hemos de considerar el caso:
de que se manden escribir 0 números, en cuyo caso no existe esa última línea.

Completar la última línea —>

if N> 04
print£( "a" );
É

Con todo ello podemos ya redactar el programa Floyd1 completo, tal como
aparece a continuación, documentándolo de la manera habitual.

 

 

 

pre

+ Programa: Floyd1
* Descripción:

* Este programa imprime el triángulo de Floyd
* con los números correlativos de 1 a N

* El valor de N se lee como dato
arar

Hinclude <stdio.h>

 

AAA

int main() £
int N; /* último número a imprimir */
int linea = /* contador de líneas */
int ultimo = 1;  /* último número de la línea */

 

 

/*-— Leer límite de la serie --*/
printf( "¿Límite de la serie? " );
scant( "%d", EN );

/*-— Imprimir el triángulo mediante un bucle de números —*/
for (int k= 1; k <= N; k+*) £
/* saltar de línea, si es necesario --*/
if (k > ultimo) £
print£( "a" );
linea++;
ultimo = ultimo+linea;

y

/* imprimir el número k */
print£( "%5d", k );
y
 
  
 
 
 
 
  

Metodología de Desarrollo de Programas (HI) 133

 

/*-- Acabar la última línea --*/
if N>0(
print£( "Wa" );

 

Un ejemplo de la ejecución del programa sería la siguiente:

 

¿Límite de la serie? 12

  
    
  
  
   
  
    
  
   

i

2 3

4 5 6

7 8 9 10
u 1

2.2 Escritura mediante bucle de líneas

segunda alternativa de diseño consiste en plantear la escritura del triángulo
un bucle de imprimir líneas de números, una tras otra. El refinamiento
spondiente será:

Imprimir el triángulo hasta N —

while (quedan números) £
Imprimir la siguiente línea

y

ir imprimiendo cada línea necesitaremos conocer el rango de números
le corresponde a cada línea. Usaremos unas variables similares a las de
solución anterior para mantener el número de la línea, y el primer y último
de esa línea. Al comienzo del bucle estas variables tendrán los valores
jadientes a la última línea impresa. Así, los valores iniciales scrán:

 

 

linea = 0;

podemos refinar los elementos del bucle
quedan números —>

| ultimo < N
Imprimir la siguiente línea —=>

Actualizar los límites
Imprimir los números

  

 
134 Fundamentos de programación

 

Actualizar los límites —>
linea++;
primero = ultimo + 1;
ultimo = ultimo + linea;

Imprimir los números —>
for (int k = primero; k <= ultimo; k++) (
print£( "%5d",k );
3
print£( "a" );

Con esto se completa el programa; pero antes de presentarlo en su conjunto es.
preciso realizar alguna corrección. Dicha corrección es debida a que al calcular
los límites de una línea de números no se ha tenido en cuenta que la última
línea puede no estar completa. El último múmero de la línea no debe ser nunca
mayor que el último de la serie completa. Escribiremos, por tanto:
Actualizar los límites —=

linea++;

primero = ultimo + 1;

ultimo = ultimo + linea;

if (ultimo > N) (

ultimo = N;

)

Ahora sí se puede construir el programa Floyd2, y presentarlo debidamente
documentado tal como se hace en el siguiente listado. El resultado de la
ejecución de este programa es idéntico al de la variante anterior. Ambos
programas son equivalentes desde el punto de vista de su utilización.

 

PARAR RRA
* Programa: Floyd2

+

* Descripción:

* Este programa imprime el triángulo de Floyd

* con los números correlativos de 1 a N

* El valor de N se lee como dato

AAA ARA ARRRAARARARA/

include <stdio.h>

int main() [
int N; /* último número a imprimir */
int linea /* contador de líneas */
int primero /* primer número de la línea */
int ultimo = O /* último número de la línea */

 

 
 
  
 
   
 
     
   
   
 
   
  
  
  
   
   
  
   
   
  
   

Metodología de Desarrollo de Programas (11) 135

 

/*-- Leer límite de la serie --*/
printf( "¿Limite de la serie? " );
scan£( "Xd", EN );

 

/*-- Imprimir el triángulo mediante un bucle de líneas --*/
while (ultimo <N) £
/*-— actualizar los límites --*/

 

ultimo+1;

ultimo+linea;

i£ (ultimo > N) (
ultimo = N;

3

 

/*— imprimir los números --*/
for (int k = primero; k <= ultimo; kt) (
print£( "%5d", ko);

,
primtf( "a" y;

 

Verificación de programas

se ha indicado que uno de los objetivos de la programación es la correcUn programa es correcto si produce siempre resultados de acuerdo con
especificación del programa. Evidentemente sólo tiene sentido hablar de

«ción si antes de escribir el programa se ha, escrito de manera precisa la
ificación del comportamiento que se espera que tenga.

  

la práctica, la verificación de un programa se hace muchas veces mediante
. Un ensayo (en inglés, testing) consiste en ejecutar el programa con
datos preparados de antemano y para los cuales se sabe cuál ha de ser
resultado a obtener. Si al ejecutar el programa no se obtienen los resultaesperados, se sabrá que hay algún error, y el programa se examina para
inar la causa del error y eliminarla. Este proceso se llama depuración
inglés debugging).

Si la ejecución produce los resultados esperados, entonces el ensayo no sumiÉstra ninguna información acerca de la corrección del programa. Puede ser
el programa sea correcto, y no tenga errores, pero también puede ocurrir
 

136 Fundamentos de programación

lo se pongan de manifiesto con otros

 

que el programa. contenga errores que
datos de ensayo diferentes.

La única manera de verificar con seguridad la corrección de un programa es
demostrar formalmente que el programa cumple con sus especificaciones. Para
ello es necesario escribir esas especificaciones con toda precisión en forma de
expresiones lógicas, y luego realizar una demostración lógico-matemática de
que el programa las cumple, A continuación se exponen algunas ideas sobre
cómo puede ser este proceso de demostración.

De todas formas hay que comprender que la demostración formal de la corrección de un programa no significa necesariamente que el programa cumpla con
sus objetivos reales, ni que el resultado sea correcto desde el punto de vista:
del usuario. Las técnicas de demostración formal que se introducen en este:
tema sólo sirven para demostrar que el programa cumple con sus especificaciones. El que dichas especificaciones describan realmente el problema a resolver
es una cuestión aparte, mucho más difícil de asegurar, y que desde luego no
admite una demostración lógico-matemática,

No obstanto, los métodos formales de especificación, desarrollo y prueba de
programas han mostrado ser mucho más seguros que los basados en la intuición
de los desarrolladores o bien en ensayos con datos de prueba particulares.

6.3.1 Notación lógico-matemática

Las especificaciones formales utilizadas en este texto se basan en una notación
lógico-matemática convencional, con ciertas adaptaciones. Por ejemplo, se
usa la notación de vectores de Ct en lugar de subíndices, y se generalizan los
operadores sobre conjuntos para usarlos también con otros tipos de colecciones.

 

En el apéndice C se incluyo una descripción detallada de la notación empleada,
con sus particularidades.

6.3.2 Corrección parcial y total

Usando las expresiones y reglas de la lógica, y conociendo la semántica (significado) de las acciones, es posible demostrar si un programa es o no correcto
(respecto a una determinada especificación). Para programas que siguen el
modelo imperativo el proceso de demostración se realiza en dos partes:

 

1. Corrección parcial : si el programa termina el resultado es correcto.
2. Corrección total: lo anterior, y además para todo dato de entrada válido
el programa termina.
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
   
   
  
 
   
   
  
  
  
   

lología de Desarrollo de Programas (11) 137

 

base de la comprobación de corrección parcial

 

+ Anotar el comienzo y final del programa con aserciones o asertos (afirmaciones, formalizada como expresiones lógicas) correspondientes a las
condiciones iniciales y al resultado deseado. La condición al comienzo se
suele denominar precondición, y la del final postcondición. La precondición y la postcondición, conjuntamente, constituyen la especificación
formal del programa.

+ Anotar los puntos intermedios del programa con aserciones similares
respecto al estado del cómputo en ese punto.

+ Demostrar que si se cumple una aserción en un punto del programa y
se siguen cada una de las líneas de ejecución posibles hasta llegar a otro
punto con aserción, dicha aserción ha de cumplirso, según las reglas de
la lógica y de acuerdo con las acciones realizadas.

 

particular, la corrección parcial se consigue al demostrar que al llegar al
del programa ha de cumplirse la aserción correspondiente al resultado
o.

corrección total se consigue añadiendo la demostración de que todos los
del programa terminan tras un número finito de repeticiones. Para
rar la terminación se puede:

 

+ Asociar a cada bucle una función monótona (siempre estriotamente creciente o decreciente) llamada variante, y que debe tener un valor acotado
para que el bucle se repita.

esta manera tras un cierto número de repeticiones se alcanzará la cota o
te de dicha función, y el bucle terminará.

 

diferentes notaciones para escribir las aserciones que se pueden asoci.
punto importante del programa. En los ejemplos que siguen se usarán
iones lógico-matemáticas convencionales, encerradas entre comillas ti¡cas «...» para distinguirlas del código del programa en Cf. La notación
¡describe en el apéndice C

Razonamiento sobre sentencias de asignación

 

analizar el comportamiento de un fragmento de programa correspondien'a una sentencia de asignación, comenzaremos por anotar delante de dicha
cia todas las condiciones que sabemos que se cumplen inmediatamenjpntes de ejecutarla. A continuación anotaremos detrás de la sentencia las
mes que podamos demostrar que se cumplen después de su ejecución,
'que serán las siguientes:

 
138 Fundamentos de programación

 

+ Las condiciones anteriores en las que no intervenga la variable asignada.
+ La condición de que la variable tiene el valor asignado.

Por ejemplo (asumiendo que es cierto lo que se indica al comienzo de esta
sentencia):

«ASERTO: (2 >y)A(a>D) A(a > 2)»

a = 36;

«ASERTO: (2 >y) A (a =36)»

En la anotación final se han suprimido las condiciones iniciales (a > b) y
(a > 2), ya que en ellas interviene la variable a. Se ha conservado la condición
(2 > y), ya que estas variables no son afectadas por la asignación, y se ha
añadido la nueva condición (a = 36) impuesta por la ejecución de la sentencia
de asignación.

6.3.4 Razonamiento sobre el esquema de selección

Para analizar el comportamiento de un fragmento de programa correspondiente a un esquema de selección, comenzaremos por anotar delante de dicho
esquema las condiciones que sepamos que se cumplen inmediatamente antes
de examinar la condición.

  

Figura 6.1 Razonamiento sobre un esquema de selección.

Puesto que la condición de selección decide la continuación por una u otra
vía de las dos posibles, deduciremos que al comienzo de la alternativa “Sí” se
cumplirán las condiciones iniciales y además la condición de selección, y que al
comienzo de la alternativa “No” se cumplirán las condiciones iniciales y no se
cumplirá la condición de selección. La figura 6.1(a) refleja gráficamente estas
anotaciones.
  
 
   
 
  
 
   
    
  
  
   
 
 
   
  
   
 
  
 
   
  
   

Metodología de Desarrollo de Programas (II) 139

 

En la parte de terminación del esquema anotaremos las condiciones que se dednzcan de la ejecución de cada alternativa en particular; y anotaremos como.
'sondición a la salida que ha de cumplirse alguna de las condiciones de termización, correspondientes a las dos alternativas posibles, tal como se indica en
figura 6.1(b).

Aplicaremos esta técnica de razonamiento a un fragmento de programa que
en m el máximo de dos números a y b. Dicho fragmento podría ser:
(a>bD 4

2-a;

ando las aserciones al comienzo, tendremos:

(a>b)t

«ASERTO: a>b»

mando sobre cada sentencia de asignación, de acuerdo con las propiedades
'máticas del máximo de dos valores, tendremos:

ta>b) (
«ASERTO: a> bh»

: (a>B)A(m=a)» => «ASERTO: m= Mas(a,b)»
: a<ho

«ASERTO: (a<b)A(m=b)» => «ASERTO: m= Maz(a,b)»

ha utilizado el símbolo > para indicar que la segunda aserción se deduce de
primera, aplicando las propiedades de las operaciones lógico-matemáticas.
“a se puede escribir la aserción final como unión de las dos alternativas
en este caso coinciden):

(a> b) 4

*ASERTO: u>b»

2-a;

«ASERTO: (a>5)A(m=a)» > «ASERTO: m= Mas(a,b)»
 

140 Fundamentos de programación

 

) else £
«ASERTO: a<b»
m=b;
«ASERTO: (a<b)n(m=b)» => «ASERTO: m= Maza, bj»

J

«ASERTO: m= Max(a,b)vm= Mazx(a.b)» => «ASERTO: m= Max(a, bj=

Con lo que queda demostrado el funcionamiento correcto.

6.3.5 Razonamiento sobre el esquema de iteración: invariante,
terminación.

Para analizar cel comportamiento de un fragmento de programa correspondiente a un esquema de iteración habremos de identificar, por una parte, las
condiciones que deben cumplirse siempre inmediatamente antes de examinar
la condición de repetición. Estas condiciones constituyen el llamado invariante del bucle. En la figura 6.2 se representa el diagrama de fujo de un bucle
tipo WHILE, en que el invariante es la condición «p».

to?

sI

Figura 6.2 Razonamiento sobre un esquema do iteración.

 

Razonando como en el esquema de selección, deduciremos que al comienzo
de cada repetición de la acción del bucle habrá de cumplirse el invariante y
además la condición de repetición; y que al terminar las repeticiones y salir
del bucle se cumplirá el invariante y además no se cumplirá la condición de
repetición.

 

 

 

La identificación del invariante puede ser complicada. No se trata simplemente de anotar todas las condiciones que sabemos que se cumplen al llegar
al bucle por primera vez, sino precisamente aquellas que además se seguirán
  
 
  
  
  
 
   
  
 
   
  
   
 
  
 
   
   
   
  
   
  
   
  

Metodología de Desarrollo de Programas (11) 141

 

pliendo después de cada repetición. La denominación de invariante res'ponde al hecho de que estas condiciones no cambian al ejecutar la acción del
bucle.

Por otra parte, para garantizar la terminación hay que identificar una función
ictamente monótona y acotada que vaya cambiando con cada repetición
del bucle. Al ser acotada no podrá ir variando indefinidamente, y eso permite
“asegurar que el bucle terminará en un número finito de repeticiones. A esta
función se le denomina variante. Sin pérdida de generalidad se puede plantear
“que esta función debe tomar valores positivos enteros decrecientes, con el valor
Jero como cota inferior.

 

 

   
 

Como ejemplo, analizaremos un fragmento de programa para calentar en f el
Esctorial de un número n (n! =1x 2x3 x... x n). Para ello se usará un
'sontador k que vaya tomando los valores de 1 a m:

Usaremos como invariante «(k < n) A(f = kl)». Esto es válido para los

'gasos en que (n > 1). Como variante podremos usar la expresión n — k. Las
taciones en el bucle serán:

Mt:

=1;

INVARIANTE: (k<n)n(f=ki)» «VARIANTE

(k <n 4

«ASERTO: (k<n)n(f=k)»

ke;

«ASERTO: (k<n)A(f=(k-1))»

f=f*k;

«ASERTO: (k<n)n(f=k)»

 

'ERTO: (k<n)a(k2=n)n(f=k)» > «ASERTO: f=nb»

localización exacta del invariante (ver figura 6.2) no corresponde a un punto
'elaro en el código. En este ejemplo se ha escrito delante del bucle, marcándola
expresamente con el nombre INVARIANTE. Lamentablemente al ponerla cn
lugar no queda del todo claro que debe cumplirse no sólo al entrar en
el bucle por primera vez, sino también tras cada ejecución del bucle. Quizá
“an punto apropiado para esa anotación sería entre la palabra clave while y

 

 
142 Fundamentos de programación

1 (k < 1), pero esto también puede resultar algo

 

 

Ki)» (k <m £

La demostración de las anotaciones es relativamente sencilla, conociendo propiedades matemáticas tales como:

1 =1
(k<n) > (k+1<n)
kl=(k- 1)! xk

(k<n)A(k>n) = k=n
El análisis anterior sólo es válido si (n > 1). Falta comprobar la corrección para.
el caso (n= 0), ya que para (n < 0) el factorial no está definido. Sabiendo
que 0! = 1, y comprobando que si (n = 0) el bucle no se ejecuta nunca, y
la variable f conserva su valor inicial f = 1 = 0! tenemos la demostración
completa.

     

Los razonamientos anteriores corresponden sólo a la demostración de corrección parcial. Para demostrar la corrección total falta demostrar que la expresión variante debe tener valor positivo para que el bucle se repita, y que
decrece estrictamente con cada repetición. Y efectivamente, la expresión n—k
debe ser mayor que cero para que se cumpla la condición de repetición (k <
1), y además disminuye cada vez que se incrementa k dentro del bucle con la
sentencia k4+.

6.4 Eficiencia de programas. Complejidad

Ya se ha dicho que el objetivo prioritario de la programación es la corrección.
La eficiencia sólo debe tenerse en cuenta si es un factor decisivo o importante
en cada caso. Aunque en la primera redacción de un programa no conviene
prestar excesiva atención a los aspectos de eficiencia, tampoco debe descuidarse totalmente este aspecto. Por esta razón se presentan a continuación los
elementos básicos de la eficiencia de programas, y una descripción informal de
algunas técnicas para analizar dicha eficiencia.

6.4.1 Medidas de eficiencia

La eficiencia de un programa se define en función de la cantidad de recursos que
consume durante su ejecución. Un programa eficiente consume pocos recursos,
Metodología de Desarrollo de Programas (II) 143

 

mientras que un programa menos eficiente consumirá una mayor cantidad de
recursos. Esto quiere decir que establecer una medida de la eficiencia de los
programas equivale a establecer una medida de los recursos usados durante su
ejecución.

Las principales medidas de recursos empleados son:

+ El tiempo que tarda en ejecutarse un programa.
+ La cantidad de memoria usada para almacenar datos.

En muchos casos estos dos factores son mutuamente dependientes. Es decir, se
pueden desarrollar programas que obtengan los resultados en menos tiempo,
a costa de usar una mayor cantidad de memoria para almacenar datos, y
viceversa.

En lo que sigue atenderemos exclusivamente a la primera de las dos medidas
mencionadas. Un programa se considerará tanto más eficiente cuanto menos
tiempo tarde en ejecutarse. Los programas poco eficientes tardarán mucho
tiempo en dar los resultados. Hablaremos, por tanto, de la eficiencia en tiempo
de un programa.

El tiempo de ejecución de un programa depende, en la mayoría de los casos, de
los datos particulares con los que opera. Esto quiere decir que la eficiencia de
un programa debe establecerse no como una magnitud fija para cada programa,
sino como una función que nos dé el tiempo de ejecución para cada tamaño o
cantidad de los datos que deba procesar.

Esta idea nos lleva, por su parto, a la necesidad de establecer previamente ua.
medida del tamaño de los datos o tamaño del problema, para, en función de
ella, establecer la medida de la eficiencia del programa que los procesa.

El tamaño del problema se puede expresar bien por la cantidad de datos a
tratar, o bien por los valores particulares de los datos. Por ejemplo, para
un programa que obtenga el valor medio o la suma de una serie de datos,
el número de datos a sumar o promediar es una buena medida del tamaño
del problema. En cambio, para un programa que calcule una potencia de un
número, el tamaño significativo puede ser el valor del exponente.

La función que da el tiempo de ejecución según el tamaño del problema se dice
que mide la complejidad algorítmica del programa.

6.4.2 Análisis de programas

La determinación de la eficiencia (o complejidad) de un programa se hace
analizando los siguientes elementos:

 
144 Fundamentos de programación

 

1. Cuánto tarda en ejecutarse cada instrucción básica del lenguaje utilizado.
2. Cuántas instrucciones de cada clase se realizan durante una ejecución
del programa.

 

Para simplificar, consideraremos que cada operación elemental del lenguaje
de programación: suma, resta, lectura, escritura, asignación de valor, decisión
según condición, etc... dura una unidad de tiempo. Con esta simplificación,
el análisis de la eficiencia de un programa se centra en establecer cuántas
instrucciones se ejecutan en total, dependiendo del tamaño o cantidad de los
datos a procesar.

Al realizar el análisis mencionado nos encontraremos con que el número preciso
de instrucciones ejecutadas depende de los valores particulares de los datos,
incluso para un tamaño fijo del problema. En este caso se pueden adoptar al
menos dos criterios diferentes para realizar el análisis de eficiencia:

 

 

+ Analizar el comportamiento, en promedio.
+ Analizar el comportamiento en el peor

 

2180.
Utilizaremos el segundo criterio, por ser el más sencillo de aplicar, para analizar
algunos ejemplos de programas. Con este criterio el análisis de complejidad

(número de instrucciones ejecutadas) de los esquemas básicos de los programas
se basa en las siguientes reglas:

1. La complejidad de un esquema de secuencia es la suma de las complejidades de sus acciones componentes.

2. La complejidad de un esquema de selección equivale a la de la alternativa
más compleja, es decir, de ejecución más larga, más la complejidad de
la evaluación de la condición de selección.

3. La complejidad de un esquema de iteración se obtiene sumando la serie
correspondiente al número de instrneciones en las repeticiones sucesivas.

  

 

Veamos cómo es este análisis en algunos casos concretos. Tomemos como
ejemplo el siguiente fragmento de programa que obtiene el máximo de dos
números:
maximo = a;
if (a<b) 4

maximo = b;

3

 

El esquema global es una secuencia de dos acciones: una asignación, seguida
de un esquema do selección (if). Anotaremos el programa con el número
de instrucciones correspondientes a cada sentencia, para lo cual contaremos el
número de operadores (+, —, *, <, =, etc.) y decisiones (1£, else, while,
etc.). Aplicando las reglas para los esquemas tendremos:

 
Metodología de Desarrollo de Programas (11) 145

 

 

 

Código Número de instrucciones ejecutadas
maximo = a; y
if (a<b) ( 2
> maximo = 1 3 (Regla 2)

Total = 4 (Regla 1)
La complejidad en este caso es fija, y no depende de uma medida de tamaño
del problema.
A continuación analizaremos de manera similar un buclo que obtiene en f el

factorial de un número n. Anotaremos el programa con el múmero de instrueciones de cada sentencia:

 

Código Número de instrucciones ejecutadas
a.
k=1; 1
f=1; 1
while (k<n) [ 2
+ 1 (n-11 ¡Regla 3]
A :) S(n-1) — (Regla 3)
)

Total =  5n-3  (Regla1)
Para calcular el número de instrucciones del bucle se ha multiplicado el número de instrucciones en cada repetición por el número de repeticiones. La
complejidad aparece expresada en función del valor de n, que en este caso
sesulta una modida natural del tamaño del problema.

    
   
 
 
 
 
 
 
 
 
 
 
  
   

6.4.3 Crecimiento asintótico

En los análisis de eficiencia (o complejidad) se considera muy importante la
«manera como la función de complejidad va aumentando con el tamaño del
problema. Lo que interesa es la forma de crecimiento del tiempo de ejecución,
y no tanto el tiempo particular empleado.

Como ejemplo podemos comparar dos programas, uno que tarde un tiempo
100N en resolver un problema de tamaño N, y otro que tarde un tiempo N?,
La comparación puede hacerse escribiendo una tabla con los tiempos de cada
mo para diferentes tamaños del problema.

2) principio de la tabla el primer programa parece menos eficiente que el se“gundo, ya que tarda mucho más tiempo, pero a medida que aumenta el tamaño
del problema ambos programas llegan a tardar lo mismo (para tamaño 100),
146 Fundamentos de programación

y a partir de ahí el segundo programa demuestra ser ¿mucho menos eficiente
que el primero.

Tamaño 100N mM
1 100 1
2 200 4
3 300 9
10 1.000 100
100 10.000 10.000

1000 100.000 1.000.000

La menor eficiencia del segundo programa para tamaños grandes del problema
no cambia por el hecho de que se modifique el coeficiente multiplicador, Si el
primer programa tardase 10 veces más (1000N en lugar de 1001), acabaría
igualmente por resultar mejor que el segundo a partir de un cierto tamaño del
problema.

Lo que importa es la forma de la función, que en el primer caso es lineal, y
en el segundo es cuadrática. La forma en que crece la función para tamaños
grandes se dice que es su comportamiento asintótico, y se representa mediante
la notación:

 

O(s(m))
En dicha notación n indica el tamaño del problema, f la forma o función de
crecimiento asintótico, y O (que se lee O-grande) significa orden de erecimiento. Algunas formas de crecimiento típicas, y sus valoraciones habituales, son
las siguientes:

O(1) Complejidad constante. Ideal.

O(logm) Complejidad logarítmica. Muy eficiente.
On) Complejidad lineal. Muy eficiente.

O(n log n) Complejidad lineal-logarítmica. Eficiente.

O( rn?) Complejidad cuadrática. Menos eficiente.
O(n*) Complejidad polinómica. Poco eficiente.
O(2) Complejidad exponencial. Muy poco eficiente.

Las valoraciones indicadas son, por supuesto, muy imprecisas. Hay muchos
problemas que sólo pueden resolverse mediante programas de complejidad elevada, poco eficientes según esta valoración, pero adecuados para esos problemas. Los problemas que sólo pueden resolverse con programas de complejidad
exponencial se consideran problemas intratables en la práctica para tamaños
grandes.

 
   
    
  
  
 
   
   
   
  
  

Ejercicios sin resolver - 1

Hasta este momento se han presentados los conceptos básicos de programa¡ción con diversos ejemplos completamente resueltos. Es aconsejable que estos
sjercicios ya resueltos sólo sean consultados como procedimiento de autocorrecsión, después de intentar una solución propia. En todo caso, a continuación
se enuncian varios ejercicios sin resolver semejantes a los ya resueltos. Todos
sellos se pueden realizar utilizando las herramientas y metodología ya explicadas. Es muy importante que la realización de los ejercicios se lleve a cabo en
dos etapas:

 

1. Plantear sobre el papel la solución del ejercicio, empleando la técnica de
refinamientos sucesivos ya explicada.
2. Comprobar en el computador la solución adoptada.

Así como no es necesario buscar una solución propia a todos los ejercicios
'sesueltos, tampoco es necesario resolver todos estos ejercicios propuestos. El
yjetivo de todos ellos es facilitar el aprendizaje de una buena metodología de
programación.

¿Los enunciados de los ejercicios son los siguientes:

1. Realizar un programa que imprima la tabla de multiplicar por un número
leído como dato. Por ejemplo, si se quiere obtener la tabla de multiplicar
del 9 se tendría la siguiente hoja de resultados:
 

148

Fundamentos de programación

 

 

Numero? 9

Tabla de multiplicar por 9

 

9x1 9
9x 2= 18
9x 3 = 27
9x 4 = 36
9x 5= 45
9x6 = 54
9 x 7 = 63
9x 8 = 72
 = Y = 8l
9 x10 = 90

2. Realizar un programa para calcular el máximo común divisor de dos

números enteros. Por ejemplo:

 

Primer Numero? 655
Segundo Número? 1325

El máximo común divisor es: 5

3. Realizar un programa que escriba un rombo simótrico de asteriscos como

el que se muestra a continuación, tomando como dato el número de
asteriscos que tiene el lado.

 

Lado? 4

 

 
icios sin resolver - I 149

 

. Realizar un programa que calcule el número e mediante el desarrollo en

serie:
e=si+ Y?

at
con un error menor del introducido como dato. Por ejemplo:

 

 

 

Error ? 0.000001

Valor de e = 2.71828198

. Realizar un programa que lea la longitud de los tres lados de un triángulo
y analice qué tipo de triángulo es. Los resultados posibles serán los
siguientes:

+ No forman triángulo (un lado mayor que la suma. de los otros dos).

+ Triángulo equilátero (tres lados iguales).

+ Triángulo isósceles (dos lados iguales).

+ Triángulo escaleno (tres lados distintos).

+ Triángulo rectángulo (sus lados cumplen el teorema de Pitágoras).
.. Realizar un programa que analice un texto terminado con un punto (.)
y contabilice los siguientes aspectos:

» Número total de caracteres.

+ Número total de vocales utilizadas.

+ Total de veces utilizada la vocal “a” mayúscula o minúscula.

+» Total de veces utilizada la vocal “e” mayúscula o minúscula.
Total de veces utilizada la vocal “i” mayúscula o minúscula.
+ Total de veces utilizada la vocal “o” mayúscula o minúscula.
+ Total de veces utilizada la vocal “n” mayúscula o minúscula.
. Realizar un programa que dado un número N, introducido como dato,
escriba todos los números comprendidos entre 1 y 10000 que cumplan
las dos reglas siguientes:

+ Regla 1: La suma de sus cifras debe ser un divisor de N.

+» Regla 2: El producto de sus cifras debe ser un múltiplo de N.
Realizar un programa que a partir del capital (C), el tanto por ciento
de interés anual (1) y los años de amortización (A) de un crédito, introducidos como datos, calcule la anualidad fija a pagar a lo largo de los A
años. La formula para este cálculo es la siguiente:

 

 

 
 

150 Fundamentos de programación

 

IL

(MH)
Amuatidad=C— 2
(1-4) —1

 

100
El programa también debe calcular para todos los años la parte de la

anualidad dedicada al pago de intereses y la parte dedicada a la amortización de la deuda. Por ejemplo:

 

Capital? 1000000
Interés (%)? 15
Años? 3

Anualidad: 437977

Año Intereses Amortización
1 150000 287977
2 106804 331173
3 57127 380850
 

Tema 7

Funciones y Procedimientos

El concepto de subprograma es fundamental para poder desarrollar programas
grandes. Este tema y el siguiente se dedican por entero a introducir dicho
goncepto.

Las dos formas clásicas de subprogramas, disponibles prácticamente en cualquier lenguaje imperativo, son las funciones y los procedimientos. En este
tema se detalla cómo se definen y utilizan ambos tipos de subprogramas y las
«diferencias que existen entre ellos.

El tema. se complementa haciendo explícitas las principales dificultades de uso
que conlleva el empleo de subprogramas para los programadores principiantes,
y la necosidad de una adecuada disciplina de programación para soslayarlos.

7.1 Concepto de subprograma

Un subprograma, como su nombre indica, es una parte de un programa. Como
mecanismo de programación, un subprograma es una parte de un programa
que se desarrolla por separado y se utiliza invocándolo mediante un nombre
simbólico.

Desde el punto de vista de una buena metodología de programación, el mecanismo de subprograma debe utilizarse para. fragmentos del programa que
tengan un cierto sentido en sí mismos. Si se hace así, podríamos decir que, al
igual que un programa sirve para resolver un problema, un subprograma sirve
para resolver un subproblema.

El empleo de subprogramas, desarrollando por separado ciertas partes del
programa, resulta especialmente ventajoso en los easos siguientes:

 
 

152 Fundamentos de programación:

 

+ En programas complejos: Si el programa se escribe todo seguido resulta:
muy complicado de entender, porque se difumina la visión de su estruetura global entre la gran cantidad de operaciones que forman el código:
del programa (¡los árboles impiden ver el bosque!). Aislando ciertas par
tes como subprogramas separados se reduce la complejidad de la visión!
global del programa.

+ Cuando se repiten operaciones análogas: Definiendo esa operación como
subprograma separado, su código se escribirá sólo una vez, aunque luego
se use en muchos puntos del programa. El tamaño total del programa.
será menor que si se escribiera el código completo de la operación cada
vez que se necesita.

 

La técnica de refinamientos sucesivos sugiere descomponer las operaciones
complejas de un programa en otras más simples. En sucesivos pasos de refinamiento, cada operación se vuelve a descomponer hasta que todo el programa
se puede escribir utilizando las sentencias disponibles en el lenguaje empleado.

Hasta el momento hemos continuado los refinamientos hasta llegar a las sen=
tencias básicas de C+. Podemos ver ahora sobre un ejemplo cómo es el programa resultante si las operaciones intermedias se definen como subprogramas
en Ct.

Por ejemplo, consideremos un programa para calcular el perímetro del triángulo formado por tres puntos (A, B y C), según se muestra en la figura 7.1.

A

Cc
Figura 7.1 Perímetro de un triángulo.

Los primeros pasos del refinamiento serían los siguientes:

Calcular e imprimir el perímetro —>
Leer las coordenadas de los vértices
Calcular el perímetro
Imprimir el perímetro

A su vez, la operación de lectura de los puntos se puede descomponer en una
secuencia de lecturas de las coordenadas de cada uno de los tres puntos:
  
 
 
 
 
 
 
 
    
  
   
   
 
   
    
   
  
  
   
   
   
  

Funciones y Procedimientos 153

 

Leer las coordenadas de los vértices —>
Leer coordenadas del punto A
Leer coordenadas del punto B
Leer coordenadas del punto C
Definiendo cada subproblema como subprograma, el aspecto del programa, en
forma esquemática, sería el siguiente:
<stdio.h>

 

 

LeerVertices () £
LeerCoordenadas( A );
LeerCoordenadas( B );
LeerCoordenadas( C );

CalcularPerimetro() £

ImprimirPerimetro() (

main() (
LeerVertices();
 CalcularPerimetro(
ImprimirPerimetro();

 
  

 
 

este esquema del ejemplo vemos cómo los subprogramas para leer los vércalcular el perímetro e imprimir el perímetro aparecen descritos después
la directiva finclude y antes del inicio del programa principal indicado
liante int main(). En esta nueva zona del programa se deben describir
los subprogramas y el resto de elementos globales que se necesiten en el
llo del programa. Así, la estructura para describir un programa en Ct,
completa que la presentada en el tema 2, sería la siguiente:

Programa 33= É Include Y É Declaración global Y
int main() Bloque

Declaración global 33= Declaración _de_constante |
Declaración _de_variable | Declaración. de_tipo | Subprograma

 

Subprograma +3= Cabecera_subprograma Bloque

elementos globales de un programa completo en Ct se pueden declarar
tes y variables en la forma ya estudiada. También se podrán declarar
154 Fundamentos de programación

 

tipos como se verá en temas posteriores. Además y esto es lo importante en
este apartado, un programa completo en C+ es una colección de subprogramas
delimitados por su correspondiente cabecera. Cada subprograma está constituido por su propio Bloque de código de manera semejante a un programa
completo. En realidad un programa en Ct es el programa principal o “main”
enya cabecera es int main().

A continuación se estudian las dos formas fundamentales de subprogramas en
programación imperativa: funciones y procedimientos, y su manejo utilizando
el lenguaje C£.

7.2 Funciones

Cuando se diseña y desarrolla un programa aparecen con frecuencia operaciones significativas que dan como resultado un valor simple y único en función
de ciertos parámetros. Por ejemplo:

Potencia: pe
Volumen de un cubo: lado?
Area de un triángulo: (base x altura)/2

Distancia entre dos puntos: — ((e1—22)?+ (yl — y2)2)12

Estas operaciones se pueden considerar subprogramas y más exactamente funciones. Una función es un tipo de subprograma que calcula como resultado
un valor único a partir de otros valores dados como argumentos. En líneas
generales, una función se asemeja bastante a la idea matemática de función
F(x,y,...), con argumentos 2, Y, ...

7.2.1 Definición de funciones

El primer paso en el manejo de una función es declarar su interfaz. Esta declaración incluye su nombre, los argumentos que necesita con el correspondiente
tipo para cada uno de ellos, y el tipo de resultado que proporciona. En C£
esto se realiza escribiendo una cabecera de función de la siguiente forma:

TipoResultado NombreFuncion( Tipol argumento1, Tipo? argumento?, ... )

La declaración se inicia con el tipo de resultado que proporciona la función y a
continuación el nombre de la función, que debe ser un identificador. Seguidamente la lista de los argumentos, entre paréntesis, y separados por el carácter
coma (,). Las declaraciones de argumentos son similares a las declaraciones
 
  
    
  
  
  
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
  
    

Funciones y Procedimientos 155

 

de variables: por cada argumento se declaran su tipo y nombre, separados por
al menos un carácter blanco.

Las cabeceras de las funciones para los ejemplos anteriores serían las siguientes:
float Potencial float x, int n )

“int VolumenCubo( int lado )
float AreaTriangulo( float base, float altura )
float Distancial float xl, float yl, float x2, float y2 )

Estas cabeceras representan la interfaz entre la definición de la función y su
utilización posterior. Los argumentos que aparecen en la cabecera son los argumentos formales. No son variables del programa, sino sólo nombres simbólicos
que sirven para formalizar la definición posterior de la función, permitiendo
hacer referencia a los argumentos en la definición de los cálculos.

La definición completa de una función se compone de una cabecera seguida de
un cuerpo de función que tiene la misma estructura que un Bloque de programa
completo. Este bloque comienza con una parte declarativa y continúa con
una parte ejecutiva. En la parte declarativa se pueden declarar constantes y
sariables locales que sólo son visibles en el cuerpo de la función. La parte
ejecutiva estará constituida por una secuencia de sentencias,

 

 

En las sentencias que constituyen el cuerpo de la función se puede (y se debe) hacer uso de los argumentos formales declarados en su interfaz. Esto
permite parametrizar los cálculos de la función para los valores particulares
de los argumentos. Así, otra forma de ver las funciones es como expresiones
perametrizadas.

Por ejemplo, la definición completa de las funciones anteriores se realizaría de
la siguiente forma:

Potencial float x, int n ) (
float p = 1.0;

for (int k = 1; k <= nm; k++) £
p=p*x;

return p;
VolumenCubo( int lado ) 4

return lado*lado*lado;
y

 

 
156 Fundamentos de programación

 

float AreaTriangulo( float base, float altura ) (
return (base * altura) / 2.0;

J

float Distancia( float x1, float yl, float x2, float y2 ) f
float deltaX, deltaY;

deltaX = x2 — x1;

deltaY = y2 - yl;

return sqrt£( deltaX*deltaX + deltaY*deltaY );
J

En estos ejemplos se observa la existencia de una nueva sentencia de Ct,
iniciada con la palabra clave return. Esta sentencia sirve para devolver como
valor de la función el resultado de los cálculos realizados. Esta sentencia tiene:
la siguiente estructura:

 

 

return expresión;

y provoca la finalización inmediata de la ejecución de la función. El resultado
de la expresión debe ser un valor del tipo indicado en la declaración de la
función. Dicho valor es el que se devuelve como resultado de la función.

La sentencia return se puede insertar en cualquier punto de la parte ejecutable
de la función. Además, es posible utilizar más de una sentencia return en una
misma función. La ejecución de la función acaba cuando se ejecuta cualquiera
de las sentencias return.

A continuación se muestra la definición de una función con varias sentencias
de retorno.
int Maximo2(int x, int y) (
if (> yt
return Xx;
) else £
return y;
y
3

7.2.2 Uso de funciones

Para usar una función en los cálculos de un programa se invoca dicha función
endo su nombre y a contimiación, entre paréntesis, los valores concretos
de los argumentos, separados por comas. Esta invocación de la función reprosenta un valor del tipo de la función, que podrá ser usado como operando en

 

esc

 

 
¡Funciones y Procedimientos

 

“ama expresión aritmética, o en general en cualquier parte del programa en que
válido escribir una expresión de ese tipo.

Al invocar una función es obligatorio que los valores suministrados para los
jentos (los argumentos reales) correspondan en número y tipo con los
“argumentos en la definición (los argumentos formales). La correspondencia
tipo significa que el tipo del argumento en la invocación sea compatible en
“asienación con el tipo de argumento formal. Por ejemplo:

umenCubo( ladoCubo ) > 27
'orPotencia = Potencial base, exponente );
= AreaTriangulo( Distancia( xA, yA, xB, yB ), medidaAltura ) )

El resultado del volumen del eubo es un valor entero y se debe comparar con
== valor entero (27). La variable valorPotencia tendrá que ser de tipo real,
Él argumento base debe ser de tipo real y cl argumento exponente debe ser
¡de tipo entero.

El resultado del cálculo de la distancia entre los puntos A y B es de tipo real.
En el cálculo del área del triángulo, el argumento para la base debe ser de
po real. Por tanto, el resultado de la distancia entre A y B se puede utilizar
como base del triángulo. La variable medidaAltura también debe ser de tipo
cal.

El efecto de la invocación de una función puede describirse de forma simplifisada de la siguiente manera:

1. Se evalúan las expresiones de los valores de los argumentos.

2. Se asignan dichos valores a los correspondientes argumentos formales.

3. Se ejecuta el código de la definición de la función, hasta alcanzar una
sentencia de retorno.

4. El valor retornado se usa en el punto donde se invocó la función.

Otros posibles efectos de la invocación de una función o procedimiento se
escriben más adelante.

7.2.3 Funciones predefinidas

Se consideran funciones predefinidas las que forman parte del propio lenguaje
de programación. Estas funciones están siempre disponibles en cualquier programa. Algunos lenguajes de programación tienen un repertorio más o menos
amplio de estas funciones, en particular los que usan funciones con nombre
somo alternativa a operadores matemáticos para evitar la proliferación de
símbolos especiales.

 
158 Fundamentos de programación

Los lenguajes C y C++ disponen de pocas funciones predefinidas (a cambio
ofrecen una gran variedad de operadores). Además estas funciones predefinidas
sólo resultan útiles en un uso avanzado del lenguaje. Por ejemplo:

int sizeof( tipo ) Tamaño en bytes de un dato del tipo indicado

Las funciones predefinidas son, en general, seudofunciones. Esto es particularmente cierto para las funciones que usan tipos como argumentos o en las que
el tipo del argumento no está totalmente determinado (por ejemplo, admiten
cualquier tipo numérico).
En Ci se prescinde del uso de funciones predefinidas, por las consideraciones
indicadas anteriormente.

7.2.4 Funciones estándar

A] realizar programas en Ct podremos utilizar funciones que estén definidas en
módulos ya redactados de antemano. Algunos módulos constituyen librerías
estándar y están disponibles en la mayoría de los compiladores de C/C++,
tal como ya se dijo al hablar de la operaciones de lectura y escritura o para el
manejo de caracteres.

Las funciones definidas en módulos estándar se denominan funciones estándar
y pueden ser utilizadas sin necesidad de escribir su definición, pero a diferencia
de las funciones predefinidas hay que indicar expresamente que se van a utilizar
dichos módulos de librería mediante la directiva +include del correspondiente
módulo que las contenga.

 

Por ejemplo, tal y como ya se comentó en el tema 2, mediante la directiva
ttinclude <ctype.h> se pueden utilizar funciones que facilitan el manejo de
las diferentes clases de caracteres. Este módulo de librería incluye funciones
tales como:

 

n

Indica si e es una letra
Indica si e es un carácter ASCII

Indica si c es un carácter de espacio o
tabulación

Indica si e es un dígito decimal (0-9)
Indica si e es una letra minúscula

Indica si e es espacio en blanco o salto de
línea o página

Indica si c es una letra mayúscula
Devuelve la minúscula correspondiente a
Devuelve la mayúscula correspondiente a €

bool isalpha( char
bool isascii( char e

bool isblank( char e

bool isdigit( char e
bool islower( char c

bool isspacel char c

bool isupper( char e
char tolower( char e
char toupper( char e

 
 
  
    
   
   

iones y Procedimientos 159

 

tipo de resultado boo] sirve para indicar si un resultado es SI/NO y se
ucirá formalmente en el próximo tema 9.

 

lo referente a funciones matemáticas, se dispone del módulo estándar math.
utilizar sus funciones habrá que incluir la directiva +include <math.h> al
1nzo del programa. Este módulo dispone de un gran número de funciones

¡áticas con nombres distintos dependiendo del tipo del argumento y el
de resultado, algunas do ellas son las siguientes

float sqrt£( float x ) raíz cuadrada de z

 

 
  
  
   
  
  
   
   
 
 
   
   
  
   
 
 
  
 
  
    
   
 
 
 
    

float expf( float x ) exponencial e?

float logf( float x ) logaritmo neperiano de x
float powf( float x, float y ) potencia 2%

float sinf( float x ) seno de 1

float cosf( float x ) coseno de z

float tanf( float x ) tangente de z

float atanf( float x ) arcotangente de Y

float roundf£( float x ) valor de x redondeado a entero

sqrtf ya ha sido utilizada en este mismo tema para la definición
¡ón Distancia. Para los objetivos de esta asignatura es suficiente
conocer las funciones aquí relacionadas. En el caso de necesitar alguna
1 matemática adicional se deberá consultar el correspondiente manual

'¡fueda fuera del ámbito de este libro la enumeración de todos los módulos y
'Eznciones de librería existentes en C/C++. Algunas de ellas se irán presentado
sm el momento en que se introduzcan los correspondientes conceptos. Para
srzalquier consulta adicional se debería hacer uso de un manual de C/C++.

7.3 Procedimientos

Ln procedimiento es un subprograma que realiza una determinada acción.
A diferencia de las funciones, un procedimiento no tiene como objetivo, en
al, devolver un valor obtenido por cálculo.

procedimiento es una forma de subprograma que agrupa una sentencia o
“grupo de sentencias que realizan una acción, y permite darles un nombre por
“sl que se las pueden identificar posteriormente. Estas sentencias, al igual que
en las funciones, se pueden parametrizar mediante una serie de argumentos.
Así, otra forma de ver a los procedimientos es como acciones parametrizadas.

 

 

Por ejemplo, durante el desarrollo de un programa podemos identificar accioes tales como:
160 Fundamentos de programación

 

Trazar una, línea de longitud dada
Imprimir el resultado

Ordenar dos valores

Leer las coordenadas de un punto

Si nos interesa, podremos definir estas acciones como procedimientos, y luego
invocarlas en el programa cuando se necesite.

7.3.1 Definición de procedimientos

La definición en Ct de un procedimiento es prácticamente igual a la de una
función:

 

void NombreProcedimiento( Tipo! argumi, Tipo2 argum2, ... ) Bloque

La diferencia principal es que no se declara el tipo de valor del resultado, ya
que no existe dicho valor. La palabra reservada void es la que indica que no
hay resultado de ningún tipo. Además, con cierta frecuencia interesa definir
procedimientos sin argumentos. En estos casos sólo es necesario dar el nombre,
y no habrá lista de argumentos entre los paréntesis.

  

Como ejemplo, podemos dar posibles definiciones de procedimientos que corespondan a las dos primeras acciones citadas anteriormente:

 

void Trazarlinea( int longitud ) 1
for (int k = 1; k <= longitud; k++) 4
printf( "-" );
y

 

3

void EscribirResultado() (
printf( "Resultado:X10fin", resultado );
3

En el primer caso se trata de un procedimiento para trazar una línea horizontal de cualquier longitud, a base de imprimir guiones. El resultado de este
procedimiento no es un valor determinado, sino la acción de trazado de la
línea. En el segundo caso el procedimiento se utiliza solamente para imprimir
con un formato concreto un resultado ya calenlado

Si se desea, en la definición de un procedimiento pueden usarse también sentencias de retorno, pero con un significado algo diferente que en el caso de las
funciones. La sentencia

return;

 
  
 
 
 
 
   
   
  
 
 
   
  
  
  
   
  
  
 
   
 
   
  
  
   
  

Funciones y Procedimientos 161

 

“se escribe ahora simplemente así, sin ninguna expresión que la acompañe,
“52 que no hay ningún valor que devolver. Esta sentencia sirve simplemente
para terminar la ejecución del procedimiento en ose momento, y volver al
anto siguiente a donde se invocó. Por ejemplo, otra posible definición del
imiento de imprimir un resultado sería:
vid EscribirResultado() 4
if (resultado < 0) 4
print£( "Problema no resuelto” );
return;
,
printf( "Resultado:*10fin", resultado );

este caso si la condición de la sentencia 1f resulta cierta la sentencia final
ie escritura no se ejecutará, ya que la sentencia de retorno termina la acción
el procedimiento de forma inmediata.

7.3.2 Uso de procedimientos

usar un procedimiento hay que invocarlo. Dicha invocación o llamada.
tuye por sí sola una sentencia de Ct, cuyo formato es;

NombreProcedimientol argumentol, argumento2, ... );

puede observarse, un procedimiento se invoca escribiendo su nombre y

«continuación, si los hay, los valores de los argumentos particulares en esa

ada, separados por comas. Los valores de los argumentos pueden darse,

general, mediante expresiones. Si no hay argumentos no se suprimen los
tesis,

argumentos en la llamada (argumentos reales) deberán ser compatibles
a los indicados en la declaración (argumentos formales), tal como se dijo
sa las funciones. Por ejemplo, los procedimientos declarados anteriormente
drían invocarse de la forma:

arlinea( 3*Lado );

birResultado(

Con la primera llamada se trazará una línea con el triple de la longitud del
Con la segunda llamada se escribirá el resultado según el formato pro“amado on la definición de este procedimiento.

forma simplificada, la invocación de un procedimiento produce un efecto
álogo a la secuencia de acciones siguientes:

 

 
162 Fundamentos de programación

 

- Se evalúan las expresiones de los valores de los argumentos.

. Se asignan dichos valores a los correspondientes argumentos formales.

3. Se ejecuta el código de la definición del procedimiento, hasta alcanzar el
final del bloque o una sentencia de retorno.

4. El programa que invocó al procedimiento continúa en el punto siguiente

a la sentencia de llamada.

ww

7.3.3 Procedimientos estándar

Al igual que para las funciones, en los módulos estándar asociados a cada compilador de C/C++ se dispone de diversos procedimientos estándar que pueden
utilizarse sin más que hacer uso de la directiva include del correspondiente
módulo.

En particular ya se han mencionado y utilizado los procedimientos estándar
de lectura de datos o escritura de resultados, que están disponibles tras incluir
la cabecera <stdio.h>. Otros procedimientos estándar se irán introduciendo
en los siguientes temas, o pueden consultarse en un manual de C/C++.

7.4 Paso de argumentos

La manera fundamental de comunicar información entre las sentencias de un
subprograma y el programa que lo utiliza es mediante los argumentos. En Ct
existen dos formas distintas de realizar esta comunicación, que se denominan
paso de argumentos por valor y paso de argumentos por referencia, que se
describen a continuación.

7.4.1 Paso de argumentos por valor

Esta es la forma utilizada en los ejemplos que se han mencionado hasta el
momento. Los argumentos representan valores que se transmiten desde el
programa que llama hacia el subprograma. En el caso de las funciones hay
además un valor de retorno, que es el valor de la función que se transmite
desde el subprograma hacia el programa que lo llamó.

Los argumentos reales en la llamada al subprograma pueden darse en general en forma de expresiones, cuyos tipos de valor deben ser compatible en
asignación con los tipos de los argumentos formales.

El modo de paso por valor implica que los elementos usados como argumentos
en la llamada al subprograma no pueden ser modificados por la ejecución de
  
 
 
    
   
 
 
 
   
   
   
 
 
 
   
 

iones y Procedimientos 163

 

 
 

sentencias del subprograma. Esto es cierto incluso en el caso de que en el
grama se ejecuten asignaciones a los argumentos formales, considerados
variables locales dentro del subprograma.

paso de argumentos por valor puede describirse de la siguiente manera:

1. Se evalúan las expresiones de los argumentos reales usados en la llamada.
2. Los valores obtenidos se copian en los argumentos formales.

3. Los argumentos formales se usan como variables dentro del subprograma.
Si a estas variables se les asignan nuevos valores, no se estará modificando
el argumento real, sino sólo la copia.

ejemplo, se puede modificar la definición de la función para el cálculo de
distancia entro dos puntos de la siguiente forma:

Distancial float x1, float yl, float x2, float y2 ) (

x= x2- xl;

yl = y2 - yl;

return sqrt( x1*x1 + yl*yl );

Lomo puede verse, dentro del procedimiento se asignan nuevos valores a algu“mos de los argumentos. Pese a ello, un fragmento de programa tal como:

= 23.5; yA = 12.3;

= 5.7; YB = 2.6;

anciaAB = Distancia( XA, yA, xB, yB );

 

  
   
   
 
   
    
   
  
    

mo modifica las variables externas xA e yA usadas como argumentos, que man'enen los valores que tenían antes de la llamada.

o que la reasignación de valor a un argumento pasado por valor resulta
algo confusa, es preferible evitar esta circunstancia todo lo posible. Esta es
uma regla recomendable en el Manual de Estilo de esta asignatura.

7.4.2 Paso de argumentos por referencia

En ciertos casos es deseable que el subprograma pueda modificar las varia
bles que se usen como argumentos. Esto permite producir simultáneamente
“varios resultados y no sólo uno. El mecanismo de paso por valor no permite
“ape el subprograma modifique directamente una variable pasada como argumento. Para conseguirlo hay que usar el otro modo de paso de argumentos,
denominado paso de argumentos por referencia.

El paso de un argumento por referencia se indica en la cabecera del subprograza, anteponiendo el símbolo £ al nombre del argumento formal, de la siguiente
manera:
164 Fundamentos de programación

 

TipoResultado Nombre( TipoArgumento € argumento, ... )

Si un argumento se pasa por referencia ya no será válido usar como argumento real una expresión. El argumento real usado en la llamada debe ser
necesariamente una variable del mismo tipo. Esta variable será utilizada en
el subprograma como si fuera suya, es decir, la asignación de nuevo valor al
argumento modifica realmente la variable externa pasada como argumento.

El paso de argumentos por referencia puede describirse de la siguiente manera:

1. Se seleccionan las variables usadas como argumentos reales.

2. Se asocia cada variable con el argumento formal correspondiente.

3. Se ejecutan las sentencias del subprograma como si los argumentos formales fuesen los argumentos reales.

Ahora se pueden

 

ibir las definiciones como subprograma de las. restantes
acciones puestas como ejemplo al hablar de procedimientos en el apartado 7,3.

Ordenar dos valores
Leer las coordenadas de un punto

 

En ellas necesitamos utilizar argumentos pasados por referencia en los que se
puedan dejar los valores ordenados o las coordenadas leídas.

 

void OrdenarDos( int £ y, int£ z )
int aux;

if(y>2D 4
aux

 

 

void LeerCoordenadas( char Punto, float £ x, float 8 y ) £
print£( "Punto %cXa",Punto );
print£( "¿Coordenada X 2" );
scan£( "KÉ",8x);
print£( "¿Coordenada Y ?"
scanf( "%£",8y );
print£( "a" );

 

lb

Un ejemplo de uso sería:

OrdenarDos( A, B );
LeerCoordenadas( *

 

» XA, yA );
  
 
 
 
 
 
  
   
   
  
  
 
  
   
   
  
    
  
   
    
  
   
   
 
   
 
  
   
    

ciones y Procedimientos 165

 

notación € usada en las cabeceras de subprogramas para indicar el paso
referencia es una novedad de C++ respecto al lenguaje C, y evita tener
hecurtital uo explicito de punteros para permitir:el paso portreféreneia;
plificando así las invocaciones de los suprogramas.

ionalmente, en los ejemplos de este libro se usan algunos subprogramas
tándar de C, en particular el procedimiento predefinido de lectura scanf
sl módulo stdio, que sí requieren el paso de punteros como argumentos.
sérvese que este caso hay que usar explícitamente el operador € (que obtiene
dirección de una variable) cada vez que se invoca ese subprograma. Los
eros se introducirán en el tema 13 de este libro.

 

T.5 Visibilidad. Estructura de bloques

Como norma general, en un punto determinado de un programa se pueden
todos los elementos definidos con anterioridad. Podemos decir que
un punto del programa. se pueden “ver” los elementos definidos hasta
momento. Esta regla sencilla de visibilidad se amplía con nuevas limitacuando se definen subprogramas. La definición de un subprograma está
mada por uma cabecera o interfaz, y un bloque de código que es el cuerpo del
bprograma. Ese bloque de código constituye una barrera de visibilidad que
ce que los elementos declarados en el interior del cuerpo de un subprograma
"ao sean visibles desde el exterior.

 

 

 

decir, la definición de un subprograma construye un nuevo elemento, utilie en el resto del código, y al mismo tiempo realiza una ocultación de sus
les de realización. Un programa que contenga subprogramas tiene, por
, una estructura de bloques que marcan ámbitos de visibilidad, tal como
muestra en cl ejemplo de la figura 7.2, donde so han marcado los diferentes
Bloques y algunos puntos concretos dentro de ellos.

 

 

"Los elementos definidos en el ámbito más externo son elementos globales, mien“tras que los elementos definidos en el interior del bloque de un subprograma
son elementos locales a dicho subprograma. Cada bloque es complotamente
'spaco desde el exterior y se puede considerar como una caja negra. Los ele“mentos locales de un bloque son invisibles desde el exterior del bloque y dejan

 

La cabecera de un subprograma se encuentra en la frontera entre el interior y
el exterior de dicho subprograma, y es parcialmente visible desde el exterior.
Desde el interior del subprograma la cabeera es visible en todos sus detalles.
Desde el exterior es visible el nombre y tipo del subprograma, y el tipo de cada

 

 

 
 

166 Fundamentos de programación

 

 

 

 

 

include <stdio.h> —- global
const float Pi = 3.1416;
<a>
void Cambiar( int 4 vl, int £ v2) ( -- Cambiar int temp;
<B>
temp = vl;

v2;

    

 

return fac; <D>

int Factorial( int numero ) ( -- Factorial --.
int fac = 1; !

!

for (int k=2; k<=numero; k++*) £ = for =---. |
fac = fac * k; <c> Lo

3 l

1

int main() (
float r;

 

print£( "Area = %f, AreaC( r ) );

I
I
scanf( "*£”, 1); 1
1

+

 

 

 

Figura 7.2 Ejemplo de bloques en un programa en C£.

argumento, pero no su nombre particular. La vista externa de la cabecera es
realmente la interfaz del subprograma. El contenido lógico de la interfaz es lo
que se denomina signatura del subprograma, que es suficiente para comprobar
si la invocaciones son consistentes con su definición:

 

Cabecera (código real) Signatura (vista lógica)
void Cambiar( int € vl, int € v2 ) void Cambiar( int £, int 4 )
int Factorial( int numero ) int Factorial( int )

Finalmente hay que mencionar el caso especial de la sentencia for de Ct. En
ella se declara la variable contador del bucle en la misma sentencia, y establece
un ámbito local limitado en el cual es visible dicha variable contador. De hecho:
al terminar la ejecución del bucle la variable contador desaparece.
 
  
 
 
   
   
 
 
 
 
  
    
  
  
 
   
  
   
  
   
 
 
   
  
   
  

iones y Procedimientos 167

 

mo resumen, y para ilustrar con un ejemplo concreto las reglas de visibiliá, en la tabla siguiente se recogen las listas de elementos que son visibles en
concretos del programa de ejemplo de la Figura 7.2:

Elementos visibles
Pi
Pi, Cambiar, vl, v2, temp
Pi, Cambiar, Factorial, numero, fac, k
Pi, Cambiar, Factorial, numero, fac
Pi, Cambiar, Factorial
Pi, Cambiar, Factorial, main, r

y
HEDow»5
S

7.6 Recursividad de subprogramas

caso especial que no ha sido considerado hasta este momento es la posidad de que en un subprograma se haga uso de ese mismo subprograma.
lo un subprograma hace una llamada a sí mismo se dice que es un subma recursivo. Un estudio más detallado y completo del concepto de
ividad queda fuera de los objetivos de este libro y sería objeto de estudio
un curso más avanzado.

ilustrar de manera sencilla la recursividad utilizaremos el algoritmo para
cálculo del factorial de un número natural. En el tema 5 se decía que el
al de un número n se puede calcular mediante la fórmula:

 

n=1x2x3x4x..xn

cálculo se puede también expresar de manera recursiva mediante el sie algoritmo (para el caso general):
ni=nx (n-1)!

ejecución de un algoritmo reenrsivo debe terminar en algún momento. Paello hace falta que las llamadas recursivas, internas, del subprograma a sí
smo deben estar controladas en una estructura condicional. Se distinguen
erentes casos on la invocación del subprograma dependiendo de los valores
etos de los argumentos. En algunos casos, denominados casos minimala solución se obtiene directamente, sin necesidad de llamadas recursivas.
el resto de los casos, que denominaremos casos generales, se necesitan
iones recursivas para obtener la solución.

 

Tn el cálculo del factorial los casos minimales corresponden a:
0=1 y  1=1
 
   

168 Fundamentos de program

 

A continuación se muestra el listado de un programa recursivo para el cál
del factorial utilizando la función recursiva FactorialRecursivo.

 

 

A

Programa: FactorialRecursivo

 
 

Descripción:
Este programa calcula el factorial de los primeros
números naturales, de forma recursiva

RANA RAS AR ARANA A A

include <stdio.h>

A

int FactorialRecursivo( int n ) 4
if (n <= 1)
return 1;
) else £
return n * FactorialRecursivo( n-1 );
+
3

int main() £
for (int i =0; i <= 10; i++) £
print£( "%x2d! vale:%10dn", i, FactorialRecursivo( i) );
y
J

 

La ejecución del programa produce el siguiente resultado:

 

0! vale: 1
1! vale: A
2! vale: 2
3! vale: 6
4! vale: 24
5! vale: 120
6! vale: 720
7! vale: 5040
8! vale: 40320
9! vale: 362880

10! vale: 3628800

 

17.7 Problemas en el uso de subprogramas

   

El empleo de funciones y procedimientos, las dos formas de paso de argumentos, las reglas de visibilidad entre bloques, ete., ofrecen interesantes posibi 
  
  
  
 
  
  
   
  

iones y Procedimientos 169

 

fades para el desarrollo de los programas. Sin embargo, un uso incorrecto
estas posibilidades puede dar lugar a ciertos problemas. En este apartado
analizan algunos de estos problemas y se dan las directrices para poderlos

7.1 Uso de variables globales. Efectos secundarios

se ha comentado que uno de los objetivos de la programación es la claridad
el código desarrollado, es decir, que sea fácil de entender. En el caso de los
programas una cualidad deseable para. ello es lo que se denomina transpaia referencial, que consiste en que ol efecto de una llamada al subprograma
eda predecirse simplemente con la información contenida en el código de la
ada. Dicho de otro modo, siempre que se invoque al subprograma con los
mos valores de los argumentos se debe obtener el mismo resultado,

 
  

 
  
    
 
  
   
  
 
   
  
    
   
   
 
  
 
  

transparencia referencial se garantiza si el código del subprograma utiliza
mente elementos mencionados en la lista de argumentos o definidos coo elementos locales. La posibilidad de utilizar directamente por su nombre
iables globales, que no se mencionan en la lista de argumentos, permite
eribir subprograma que carecen de transparencia referencial. Cuando un
bprograma modifica alguna variable externa, se dice que está produciendo
Eetos secundarios o laterales (en inglés side effects). El uso de subprogramas
n efectos secundarios debe hacerse con precaución.

transparencia referencial es descable tanto para las finciones como para
procedimientos. Sin embargo, para las funciones es una cualidad casi im
indible. Resulta muy difícil de justificar y comprender que se produzcan
ción dentro de una expresión. Idealmenbass tonorlsermatos 1 le Eonacnss depen pasasepobalos
do que el único resultado deseable de la función es devolver el valor de la
sopia función. Una función que no produzca efectos laterales y todos sus
pasen por valor se dice que es una función: pura.

acceso directo a variables globales puede suplantar el nso de argumentos,
manera que en un caso extremo podemos escribir subprogramas sin ningún
teumento:

 

base, altura;

float ArcaRectangulo () £
return base * altura;

 
 

170 Fundamentos de programación

 

base = 3.0;
altura = 2.5
printf( "Xf", AreaRectangulo() );

En general es preferible mencionar expresamente en la lista de argumentos todos los elementos externos que intervienen en la operación de un subprograma.
El ejemplo anterior resulta mucho más natural si escribirmos:

float AreaRectangulo( float base, float altura ) (
return base * altura;
J

print£( "Xf", AreaRectangulo( 3.0, 2.5 ) );

Aunque la transparencia referencial es claramente deseable, hay algunos casos
en que el uso directo de variables globales puede tener alguna ventaja. Esto ocurre, en general, si algunos de los argumentos son siempre los mismos
en prácticamente todas las llamadas al subprograma. Si esos argumentos se
almacenan en variables globales y se eliminan de la lista de argumentos, el código de las llamadas se simplifica. Como ejemplo plantearemos ir acumulando
una serie de valores. El código normal sería:

void Acumular( float £ suma, float valor ) (
suma = suma + valor;

y

float total;

total = 0;

Acumular( total, 3.5 );

Acumular( total, 0.2 );

Acumular( total, 2.7 );

Acumular( total, 1.5 );

printf( "%d", total );

Usando una variable global las llamadas resultan algo más sencillas:
float total;

void Acumular( float valor ) £
total = total + valor;

y

total = 0;

Acumular( 3.5

Acumular( 0.2 );

  
  
   
   
  
 
 
 
 
 
 
 
 
 
 
 
  
   
 
   
 
  
   
   
  
 
   
  
   

Funciones y Procedimientos 171

 

ular( 2.7 );
ular( 1.5 );
int£( "%d", total );

Conviene insistir en que el empleo de subprogramas con efectos laterales debe
Bacerse siempre con precaución, y limitarlo a casos especiales como el de este
ejemplo, en el que el primer argumento del código normal, sin efectos laterales,
sería siempre exactamente el mismo. Las siguientes secciones muestran con
«laridad algunos peligros del uso directo de variables globales.

7.7.2 Redefinición de elementos

Dentro de cada bloque se pueden definir elementos locales dándoles el nombre
que se considere más adecuado en cada caso. Los nombres locales no afectan
al código fuera del bloque, ya que no son visibles. Incluso es posible repetir el
mismo nombre para elementos diferentes definidos en distintos bloques. Por
'sjemplo, es habitual utilizar las variables de nombres á, j, k, oto. para los
de las sentencias de iteración. Si estos nombres repetidos están en
«distintos bloques no existe ningún problema pues en cada uno de ellos estas
“wariables tienen un carácter local que no afecta a las definiciones de los otros

bloques

embargo cuando en el interior de un bloque se define un elemento local
el mismo nombre que otro elemento global la situación es algo distinta.
acuerdo con las reglas de visibilidad, cualquier bloque tiene acceso a todos
elementos globales. Sin embargo, al dar un nombre ya utilizado como
a un nuevo elemento local del bloque se está redefiniendo dicho nombre,
automáticamente se pierde la posibilidad de acceso al elemento global del
ésmo nombre. Se dice que el nombre local oculta o “hace sombra” (en inglés
010) al nomibre global. Por ejemplo, en el siguiente programa:

 

Programa: Shadow */
Ejemplo de ocultación de nombres globales */
le <stdio.h>

Global;
Exterior = 50;

Interior) £
const int Exterior = 30;

|
| Global = Exterior*Exterior;
172 Fundamentos de programación

 

[void Secundario() £
Interior();
Exterior = Global/2;

+

void Primario( int £ Exterior, int 8 Interior ) (
Secundario();
Interior = Exterior — 5;

+

int main) (
int Interior = 40;

Primario( Interior, Interior );
print£( "«sdx5dksdin", Global, Exterior, Interior );
J

 

el cálculo de Global en el procedimiento Interior utiliza su constante local Exterior con valor igual a 30. El procedimiento Secundario utiliza el
procedimiento Interior y la variable global Exterior. Solamente dentro del
procedimiento Primario se tiene acceso a los argumentos Interior y Exterior del mismo, que están ocultando la variable global Exterior y el procedi
miento Interior. La variable Interior del programa principal inicializada a
40 oculta el procedimiento Interior y además se modifica en la llamada con
doble referencia al procedimiento Primario

 

Aunque el programa es bastante extraño es completamente correcto. Como
ejercicio, resulta interesante hacer un análisis paso a paso de su ejecución. Para
la correspondiente comprobación, la ejecución del programa da el siguiente
resultado:

 

900 450 35

Es evidente que el empleo de elementos diferentes con el mismo nombre aumenta la complejidad del programa y se dificulta mucho su comprensión. Por
otro lado, se abre una. vía de errores no siempre detectables en compilación.
Aunque se pretenda utilizar un símbolo como local, si se olvida que es un
nombre redefínido se asumirá incorrectamente el significado dado como símbolo externo. Por tanto, salvo que sea imprescindible, no se debe utilizar la
redefinición de elementos
 
  
  
   
 
 
 
 
 
   
   
   
 
   
  
  
  
   
 
  
    
   

Funciones y Procedimientos 173

 

7.7.3 Doble referencia

Se produce doble referencia (en inglés aliasing) cuando una misma variable se
referencia con dos nombres distintos, cosa que puede ocurrir en la invocación
de subprogramas con argumentos pasados por referencia. Fundamentalmente,
sto puede ocurrir en dos situaciones muy concretas:

1. Cuando un subprograma utiliza una variable externa que también se le
pasa como argumento.

2. Cuando para utilizar un subprograma se pasa la misma variable en dos
o más argumentos.

Habitualmente, un subprograma se escribe pensando que todos sus argumentos
son distintos y que nunca coincidirán con ninguna variable externa ya utilizada
entro de él. La doble referencia produce resultados incomprensibles a primera
ssista. Consideremos, por ejemplo, el siguiente fragmento de programa:

global;

 

 

 

Cuadrado( int € dato ) 4
global = 5;
dato = dato * dato;

 

 

>

 

 

al = 3;
ado( global );

Después de la ejecución del procedimiento Cuadrado( global ) la variable
global tiene un valor igual a 25. Esto es debido a que el procedimiento
Euadrado utiliza directamente como dato la variable global pasada por rofe“sencia. En el momento del cálculo del producto, el valor de dicha variable es
5 y por tanto el producto por sí misma es 25.

Una situación similar se puede producir con el siguiente procedimiento:

CuadradoCubo( int £ x, int £ x2, int8x3)(

adoCubo( A, A, B );

después de la ejecución de este fragmento, los valores de las variables son A

igual a 16 y B igual a 4096.

 
 

174 Fundamentos de programación:

 

Como conclusión se puede decir que no se debe utilizar la doble referencia,
salvo que el subprograma se diseñe pensando en esa posibilidad. Esto último
deberá quedar claro en los comentarios del subprograma.

7.8 Ejemplos de programas
Para finalizar este tema se muestran tres programas completos y sus corres
pondientes resultados. Estos programas utilizan algunas de las funciones y
procedimientos que han sido desarrollados a lo largo de todo este tema.

7.8.1 Ejemplo: Raíces de una ecuación de segundo grado

Con este programa se trata de calcular las raíces de una ecuación de segundo
grado:

 

añ br+e=0

las raíces pueden ser reales o imaginarias. Los coeficientes a, b y e serán reales
y se leerán del teclado. El programa tendrá en cuenta los siguientes casos:

   

a, b y e son iguales a cero: Se considerará una ecuación no válida.
+ Sia y bon iguales a cero: La solución es imposible.

+ Si a cs igual a cero: Una única raíz

+ Sia, b y eson distintos de cero: Dos raíces reales o imaginarias.

  

En este último caso, el cálculo de las raíces se realiza mediante la fórmula:
—b+vb"-4ac

2a
Para la lectura de los coeficientes conviene utilizar un procedimiento, y así se

pueden leer los 3 coeficientes de igual manera. En el siguiente programa está
recogido el listado completo.

raices=
 

PA AAA AN AAA

* Programa: Raices
.

* Descripción:

* Este programa calcula las raíces de una

% ecuación de segundo grado: ax? + bx+c

RARA ARANA RAR AAA Ana AAA R Aden RARA RIA /
Hinclude <stdio.h>

*include <math.h>
 
  
 
 
   
  
   
  
  
   

Funciones y Procedimientos 175

 

'/** Función para calcular el discriminante */

«float Discriminante( float a, float b, float c ) (
return b*b - 4.0*a*c;

y

'* Procedimiento de lectura de un coeficiente */
LeerValor( int grado, float £ valor ) £
printf( "¿Coeficiente de grado %ld? ", grado );
scant( "%£",gvalor );

y

* Programa principal */

main() 4

float valorA, valorB, valorC; /* Coeficientes de la ecuación */
float parteUno, parteDos; /* Variables intermedias de cálculo */
float valorD; /* Discriminante de la ecuación */

LeerValor( 2, valorA );
LeerValor( 1, valorB );
Leervalor( 0, valorC );
if (valora
if (valorB
if (valorC
print£( "Ecuación no válidala" );
) else [
print£( "Solución imposibleXn" );
y
J else (
print£( "Raíz única = X10.2£in", -valorC/valorB );
3
J else [
partelno = - valorB/(2.0*valora);
valorD = Discriminante( valora, valorB, valorC );
if (valorD >= 0.0) £
parteDos = sqrt(valorD)/(2.0*valorA);
print£( "Raíces reales :1n" );
print£( "%10.2f y Y", parteUno+parteDos );
printf( "%10.2f An", parteUno-parteDos );
) else (
parteDos = sqrt(-valorD)/(2.0*valorA);
printf( "Raíces complejas ¿Yn" );
printf( "Parte real = %10.2f yin", partelno );
printf( "Parte imaginaria = %10.2f An", parteDos );
3
3

  

 

 

 

 
176 Fundamentos de programación

 

El resultado obtenido por el programa para la ecuación 1? +21 +2=0 es el
siguiente:

 

¿Coeficiente de grado 2? 1.0
¿Coeficiente de grado 1? 2.0
¿Coeficiente de grado 0? 2.0
Raíces complejas :

Parte real = -1.00 y
Parte imaginaria = 1.00

7.8.2 Ejemplo: Ordenar tres valores

Este programa es una versión mejorada del mostrado en el tema 5. En este caso
se utiliza el procedimiento para la ordenación de dos datos que fue desarrollado
en el apartado 7.4 de este mismo tema. Además, se utiliza un procedimiento
para leer uno a uno los tres datos a ordenar. El programa permanece en un
bucle hasta que se indica que no se necesita ordenar más datos.

A continuación se recoge el listado completo.

 

e]

* Programa: Ordenar3b
* Descripción:

* Este programa ordena 3 valores

AA AAA

*+include <stdio.h>
include <math.h>

 

/** Procedimiento para ordenar dos datos */
void OrdenarDos( float € y, float £ z ) 1
float aux;

if (y>2t
aux = y;

 

/** Procedimiento para leer un dato */
void LeerDato( int indice, float £ dato ) (
printf( "¿Dato %1d? ", indice );
scanf( "%f",Gdato );
es y Procedimientos 177

 

Programa principal */

main() (

float valorUno, valordos, valorTres; — /* valores a ordenar */
char tecla; /* tecla de opcion */

   
   
 

tecla = 'S';
while (tecla != 'N') £
/*-- Leer los datos --*/ 1
LeerDato( 1, valorUno );
LeerDato( 2, valorDos );
LeerDato( 3, valorTres );
3
/*-- Ordenar los datos --*/ (
OrdenarDos( valorUno, valorDos );
OrdenarDos( valorUno, valorTres );
OrdenarDos( valorDos, valorTres );
3
/*-—- Escribir resultados --*/ 4
print£( "WnDatos Ordenados = An" );
print£( "%7.2f %7.2f 47.2£n", valorUno, valorDos, valorTres );
J
/*-- Comprobar si se contimúa —*/ [
tecla = * *;
printf( "An¿Desea continuar(S/N)? " );
while ((tecla l= 'S') 8 (tecla != 'N')) £
scanf( "%c", gtecla );

 

 

 

 

  
    
  
  
  

¡Datos Ordenados =
3.00 12.00 89.00

¿Desea continuar(S/N)? S
¿Dato 1? 9
¿Dato 2? 34
¿Dato 3? 2

 
 

178 Fundamentos de programación

 

Datos Ordenados =
2.00 9.00 34.00

¿Desea continuar(S/N)? N

7.8.3 Ejemplo: Perímetro de un triángulo

Este programa ha sido desarrollado casi completamente a lo largo de este tema. En este apartado se trata solamente de mostrar su estructura global, en
la que se aprecia el uso de variables globales entre los distintos procedimientos y funciones y el programa principal. A continuación se recoge el listado
completo.

 

 

RODADO

= Programa: Perimetro

* Descripción:

* Programa para calcular el perímetro de un

* — triángulo dado por sus tres vértices
AAA
*include <stdio.h>

*include <math.h>

 

[tm +
Variables globales

 

 

 

AA */
float XA, yA, xB, yB, xC, yC;  /* Coordenadas de los puntos */
float perimetro; /* Valor del perimetro */

/

 

Procedimiento para leer las coordenadas X e Y de un punto.
Para facilitar la identificación del punto, se tiene que
pasar la letra que lo identifica como argumento

V
void LeerCoordenadas( char Punto, float 4 x, float £ y ) (

print£( "Punto %cAn",Punto );

print£( "¿Coordenada X ? " );

scan£( "XÉ", 8x );

print£( "¿Coordenada Y ? " );

scanfí "%£", Ey );

print£( "a" );

 

=*/

 

 
  
  
   
   
  
  
  
     
  
  
     
   
  
    
   
  
   
   
   
   

ciones y Procedimientos 179

 

y
Procedimiento para leer las coordenadas de los 3 vértices
=*/
LeerVertices() [

LeerCoordenadas( 'A', xA, yA );

LeerCoordenadas( 'B', xB, yB );

LeerCoordenadas( 'C', xC, yC );

y

y"
Función para calcular la distancia que hay
entre dos puntos (x1,y1) y (22,y2)

 

 

e”
¡float Distancia( float x1, float yl, float x2, float y2 ) £
float deltaX, deltaY;

deltaX = x2 - xl;

deltaY = y2 - yl;

return sqrt( deltaX*deltaX + deltaY*deltaY );
3

3
Procedimiento para calcular el perímetro de un triágulo
NOTA: Se utilizan variables globales dado el excesivo
número de argumentos necesarios: Total 7 argumentos:
3 puntos x 2 coordenada = 6 argumentos por valor
Resultado en perimetro = 1 argumento por referencia
v Y
void CalcularPerimetro() (
float ladoAB, ladoAC, ladoBC;

 

 

ladoAB = Distancia( XA, yA, xB, yB );
ladoAC = Distancia( XA, YA, XC, yC );
ladoBC = Distancia( XB, yB, xC, yC );
perimetro = ladoAB + ladoAC + ladoBC;

 

 
 

180 Fundamentos de programación

 

 

y

Programa principal

 

7

int main() 4
LeerVertices();
CalcularPerimetro();
ImprimirPerimetro();

Ñ

 

Un ejemplo del resultado de su ejecución es el siguiente:

 

 

 

Punto A
¿Coordenada X
¿Coordenada Y

Punto B
¿Coordenada X ? 0.0
¿Coordenada Y ? 0.0

Punto C
¿Coordenada X ? 0.0
¿Coordenada Y ? 4.0

El Perímetro es igual a 12.00
  
  
   
  
  
   
 
 
 
   
 
     
   

ema 8

etodología de Desarrollo de
ogramas (IIT)

tema completa el anterior, ampliando la metodología de desarrollo por
'sefinamientos sucesivos con la posibilidad de usar subprogramas como técnica
de abstracción.

 

A nivel metodológico, las funciones y procedimientos introducen la posibilidad
de descomposición de un problema en subproblemas realmente independientes.
Por el momento se mantiene la visión del programa como una sola unidad de
'sompilación (un solo módulo). Más adelante, en el tema 15, se explicará
la manera de descomponer un programa en varios módulos compilables por
separado.

 

8.1 Operaciones abstractas

Los subprogramas constituyen un primer paso hacia la metodología de pro'gramación basada en abstracciones. Los subprogramas permiten definir opezaciones abstractas. El siguiente paso será la definición de tipos abstractos de
datos, que se introducirán brevemente más adelante, en el tema 14.

 

Una abstracción es una visión simplificada de una cierta entidad, de la que
sólo consideramos sus elementos esenciales, prescidiendo en lo posible de los
detalles. Las entidades que podemos abstraer para materializarlas como subprogramas son, en general, operaciones. Con la palabra, operación englobamos

 

 

 
182 Fundamentos de programación

 

8.1.1 Especificación y realización

Al plantear operaciones abstractas habremos de definir dos posibles visiones.
La visión abstracta o simplificada, y la visión detallada, completa. La visión
abstracta es la que permite usar dicha operación sin más que conocer qué
hace dicha operación. La visión detallada es la que define cómo se hace dicha
operación, y permite que el procesador la ejecute. La primera visión representa
el punto de vista de quienes han de utilizar la operación. Se dice que esa visión
abstracta es la especificación o interfaz de la operación. La visión detallada
representa el punto de vista de quien ha de ejecutar dicha acción, y se dice
que expresa su realización o implementación. Resumiendo:

Especificación: Qué hace la operación (punto de vista de quien la invoca).
Realización: Cómo se hace la operación (punto de vista de quien la ejecuta).

En su forma más sencilla la especificación o interfaz consiste simplemente en
indicar cuál es el nombre de la operación y enáles son sus argumentos. En C+
la especificación puede ser simplemente una cabecera de subprograma.

Esa forma simplificada de especificación indica solamente cuál ha de ser la
sintaxis o forma de uso de la operación. La especificación completa debe
establecer también cuál es la semántica o significado de la operación. Para
ello podemos añadir un comentario en que se indique qué relación hay entre
los argumentos y el resultado de la operación.

La realización, por su parte, debe suministrar toda la información necesaria
para poder ejecutar la operación. En C£ la realización o implementación será
la definición completa del subprograma, en forma de bloque de código.

Tomemos como ejemplo una función que calcule el máximo de dos números:

      
 

int Maximo2( int a, int b)( Especificación

/* Maximo2(a, b) es el Máximo de a y b */ Especificación: Semántica

 

if (a>b)(

'
'
) else ( Realización l
I
1

 

y =

Conociendo sólo la especificación podemos invocar la función, aunque no sepamos el detalle de cómo se realiza. Por ejemplo, podemos escri

|alturaTotal = Maximo2( altural, altura? );

 
Metodología de Desarrollo de Programas (III) 183

 

Si ahora sustituimos la realización de la función Maximo2 por otra diferente,
tal como:

“int Maximo2( int a, intb)41
int m;

m= a;
d£ (b>m 4

la especificación de la función sigue siendo la misma. La sentencia anterior
que usaba la función sigue siendo correcta:

JalturaTotal = Maximo2( altural, altura? );

Con ello se pone de manifiesto la idea de que la especificación es una visión
abstracta de qué hace la función, con independencia de los detalles de cómo lo
hace. Precisamente las reglas de visibilidad de G+ permiten usar subprogramas
como operaciones abstractas, con ocultación de los detalles de realización.

Es importante comprender que si describimos la semántica en lenguaje humano, impreciso, tendremos sólo una especificación informal. Si se necesita
mayor rigor se puede recurrir a expresiones lógico-matemáticas para especificar formalmente las condiciones que relacionan los datos de entrada y los
resultados, La especificación formal evita ambigiledados, pero también suele
resultar más costosa de escribir y más difícil de leer, Por ello conviene que vaya
acompañada siempre de una especificación en lenguaje humano. En el apéndice C se describe la notación utilizada en este libro para las especificaciones
formales.

La especificación formal del máximo de dos valores podría ser:
Maximo2(a,b) = (a >b= alo)

En esta especificación se ha usado una expresión condicional. El primer ejemplo de código de esta sección usa como realización una transcripción directa de
esta especificación formal. Podemos repetir ahora dicho ejemplo anotándolo
con la PRECONDICIÓN y POSCONDICIÓN correspondientes a su especificación formal :
int Maximo2( int a, int b) 1

«PRE: »

«POST; Marimo2(a, b) es el Máximo de a y b »

«POST: Marimo2a,b) =(a>b => alb) »

 
  
    
 
  
  
  
  
  
  
  
  
  
  
  

184 Fundamentos de programación

 

if (a>b) 4
return a;
J else (
return b;
,
+

La PRECONDICIÓN está vacía (se asumo que siempre es cierta) porque no
hay restricciones en los valores aceptables de los argumentos. El valor del
máximo está definido para toda pareja de valores enteros. La POSTCONDICIÓN se ha escrito dos veces, primero en lenguaje natural, informal, y luego
de manera formal.

 

8.1.2 Funciones. Argumentos

En programación la idea de función surge al aplicar el concepto de abstracción a
las expresiones aritméticas. Una expresión representa un nuevo valor obtenido
por cálculo a partir de ciertos valores ya conocidos que se usan como operandos.

Por ejemplo, el cubo de un número Z se puede calcular multiplicando el número
por sí mismo, de la forma Z x Z x Z. De esta manera se puede obtener, por
ejemplo, el volumen de un cubo escribiendo:

[volumen = lado * lado * lado;

La expresión lado * lado * lado suministra el valor del cubo del Lado al
evaluarla. Esta expresión puede verse de manera abstracta como una función.
siendo lado el dato de partida y el cubo el resultado obtenido. La abstracción
de dicha expresión tendrá asociado un nombre que podamos identificar con el
significado del cálculo, y que, obviamente, podría ser Cubo. Esto nos conduciría
a la especificación:

float Cubo( float z ) Especificación: Sintaxis

 

/* Cubolz) = 2? */ Especificación: Semántica

 

A

 

O bien, de manera formal:

float Cubo( float z )
«PRE: »
«POST: Cubo(z) = 2»

Con esta especificación, el cálculo del volumen se reescribiría como:
Metodología de Desarrollo de Programas (II) 185

 
 
  
  
 
 
  
  
   
   
   
  
  
  
      
   
   
    
 
 
   
   
  

 

lumen = Cubo( lado )

Esta visión abstracta prescinde de los detalles de cómo se calcula el resultado,
con tal de que sea correcto, es decir, que se obtenga el cubo del argumento.
La realización puede ser tan sencilla como:

1t Cubo( float z ) (
return z *z*z2z;

 

9 tan artificiosa como:

Los operandos que intervienen en el cálculo del valor de la función y que
pueden cambiar de una vez a otra se especifican como argumentos de dicha
función. La función aparece así como una expresión parametrizada.

En el tema anterior se han mencionado ya las dos formas disponibles en Ch
para el paso de los argumentos al subprograma que realiza el cálculo de la
función. Si buscamos que el concepto de función en programación se apro“xime al concepto matemático de función, el paso de argumentos debería ser
siempre por valor. El concepto matemático de función es una aplicación entre
'sonjuntos, cuyo cómputo se limita a suministrar un resultado, sin modificar el
ssalor de los argumentos.

Aunque algunas veces, por razones de eficiencia, pueda ser aconsejable pasar
¡por referencia argumentos de funciones, seguirá siendo deseable, para mantener la máxima claridad en el programa, que la llamada a la función no
modifique el valor de los argumentos.

"Desde el punto de vista de claridad del programa, y con independencia de cuál
'sea el mecanismo de paso de agumentos empleado, la cualidad más deseable
al utilizar funciones es conseguir su transparencia referencial. Tal como se
mencionó anteriormente, la transparencia referencial significa que la función
devolverá siempre el mismo resultado cada vez que se la invoque con los mismos
argumentos.

La transparencia referencial se garantiza si la realización de la función no
satiliza datos exteriores a ella. Es decir, si no emplea:
  

186 Fundamentos de programación

 

+ Variables externas al subprograma, a las que se accede directamente por
su nombre, de acuerdo con las reglas de visibilidad de bloques.

+ Datos procedentes del exterior, obtenidos con sentencias de lectura.

+ Llamadas a otras funciones o procedimientos que no posean transparencia referencial. Las sentencias de lectura son en realidad un caso
particular de éste.

Estas restricciones se cumplen en el ejemplo anterior del cálculo del cubo de un
número. Las funciones que cumplen la cualidad de transparencia referencial y
que no producen efectos laterales o secundarios se denominan funciones puras.

8.1.3 Acciones abstractas. Procedimientos

De manera similar a como las funciones pueden ser consideradas como expresiones abstractas, parametrizadas, los procedimientos pueden ser considerados
como acciones abstractas, igualmente parametrizadas. Un procedimiento representa una acción, que se define por separado, y que se invoca por su nombre.

Como acciones abstractas, podemos tener dos visiones de un procedimiento.
La primera es la visión abstracta o especificación, formada por la cabecera del
procedimiento y una descripción de qué hace dicho procedimiento, y la segunda
es la realización, en que se detalla, codificada en el lenguaje de programación
elegido, cómo se hace la acción definida como procedimiento.

Como ejemplo, definiremos la acción abstracta de intercambiar los valores de
dos variables. La especificación podría ser:

  

void Intercambiar( int £ a, int € b)

/* (a*,b') = (b,a) */

Esta especificación es realmente formal, ya que equivale exactamente a:
void Intercambiar( int 8 a, int £ b)

«PRE: »
«POST: (a, Y)=(b,a) »

Para escribir esta especificación hemos necesitado distinguir los valores de los
argumentos (pasados por referencia) en dos momentos diferentes: al comienzo y al final de la ejecución del procedimiento. Los nombres con prima (')
representan los valores finales. La expresión:

(a, 1) =(b,a)
  
 
  
    
   
   
 
 
   
   
   
   
 
 
 
   
 
   
  
  
  
    
   
  
    

etodología de Desarrollo de Programas (III) 187

 

ifica que la pareja de valores de los argumentos a y b, por este orden, al
nar la ejecución del subprograma, coincide con la pareja de valores de b
5 a, por este orden, al comienzo de la ejecución del subprograma.

Conociendo la especificación podemos ya escribir algún fragmento de programa
utilice este procedimiento. Si queremos ordenar dos valores de menor a
yyor, podríamos escribir:

p>n1t
Intercambiar( p, q );

a escribir este fragmento de programa no hemos necesitado saber cuál es
realización del procedimiento de intercambiar. Por supuesto, para tener un
ograma completo, que se pueda ejecutar, necesitamos escribir una realización
álida. Por ejemplo:

d Intercambiar( int £ a, int £b)(

dnt aux;

aux = a;
a=b;
b= aux;

Al definir procedimientos no podemos limitarnos a usar sólo el paso de arguentos por valor. En programación imperativa las acciones consisten habi'tmalmente en modificar los valores de determinadas variables. Por esta razón
considera normal que los procedimientos usen argumentos pasados por reencia.

todas maneras conviene seguir una cierta disciplina para que los programas

sulten claros y fáciles de entender. Para ello podemos recomendar que los

limientos se escriban siempre como procedimientos puros, entendiendo

or ello que no produzcan efectos laterales o secundarios. Con esto se consigue

que la acción que realiza un procedimiento se deduzca en forma inmediata de

la invocación de dicha acción. Se garantiza que un procedimiento cumple con

esta cualidad si su realización no utliza:

+ Variables externas al subprograma, a las que se accede directamente por
su nombre, de acuerdo con las reglas de visibilidad de bloques.

+ Llamadas a otros subprogramas que no sean procedimientos o funciones
puras.

Comparando esta lista de restricciones con la que se estableció para las funcio
'zes puras, se observa que hemos suprimido la exigencia de que el procedimiento

 
 

188 Fundamentos de programación

 

no lea datos del exterior. En general esta lectura puede considerarse como una
asignación de valor, que puede quedar suficientemente bien reflejada en la llamada, si los dispositivos o ficheros de entrada se mencionan explícitamente
como argumentos.

Do todas maneras es difícil establecer una disciplina precisa con recomendaciones sobre la definición y uso de procedimientos. Hay muchas situaciones en
las que la claridad del programa aumenta, de hecho, si se usan procedimientos en los que se accede a variables globales. Así es posible evitar que haya.
que escribir repetidamente argumentos iguales en cada una de las llamadas
al procedimiento. En particular, algunos de los procedimientos de lectura (o
de escritura) del módulo stdio omiten pasar como argumento el fichero de
datos de entrada (o de salida), y asumen por defecto una entrada y una salida
principales de datos, predefinidas (teclado y pantalla, respectivamente).

8.2 Desarrollo usando abstracciones

La metodología de programación estructurada puede ampliarse con la posibilidad de definir operaciones abstractas mediante subprogramas, A continuación
so describen dos estrategias de desarrollo diferentes, según qué se escriba primero, si la definición de los subprogramas, o el programa principal que los
utiliza,

8.2.1 Desarrollo descendente

La estrategia de desarrollo descendente (en inglés, Top-Down). es simplemente
el desarrollo por refinamientos sucesivos, teniendo en cuenta además la posibilidad de definir operaciones abstractas. En cada etapa de refinamiento de
una operación habrá que optar por una de las alternativas siguientes:

 

+ Considerar la operación como operación terminal, y codificarla mediante
sentencias del lenguaje de programación.

+ Considerar la operación como operación compleja, y descomponerla en
otras más sencillas.

+ Considerar la operación como operación abstracta, y especificarla, escribiendo más adelante el subprograma que la realiza.

 

Para decidir si una operación debe refinarse como operación abstracta habrá
que analizar las ventajas que se obtengan, frente a la codificación directa o
descomposición de la operación en forma de un esquema desarrollado en ese
punto del programa.
  
 
 
 
  
  
 
   
 
   
  
 
   
  
    
  
  
 

Metodología de Desarrollo de Programas (II) 189

 

 

En genoral resultará ventajoso refinar una operación como operación abstracta, que se define en forma separada, si se consigue alguna de las ventajas
siguientes.

+ Evitar mezclar en un determinado fragmento de programa operaciones
con un nivel de detalle muy diferente.

+ Evitar cscribir repetidamente fragmentos de código que realicen operaciones análogas.

El beneficio obtenido es, como cabría esperar, una mejora en la claridad del
programa. Hay que decir que esto implica un costo ligeramente mayor en
términos de eficiencia, ya que siempre se ejecuta más rápidamente una opera1 si se escriben directamente las sentencias que la realizan, que si se invoca
un subprograma que contiene dichas sentencias. La llamada al subprograma
'sepresenta una acción adicional que consume un cierto tiempo de ejecución.

 

Por el contrario, hay un aumento de eficiencia en ocupación de memoria si
se codifica como subprograma una operación que se invoca varias veces en
distintos puntos del programa. En este caso el código de la operación aparece
sólo una vez, mientras que si se escribiesen cada vez las sentencias equivalentes
el código aparecería repetido varias veces.

8.2.2 Ejemplo: Imprimir la figura de un árbol de navidad

Retomamos aquí el ejemplo desarrollado en el tema 4. El objetivo es imprimir
la silucta del árbol, tal como aparece a continuación:

 

 

aer
ARRERARAR
*
*
ao...

Los primeros pasos de refinamiento eran:

 

 
 

190 Fundamentos de programación

Imprimir árbol —>
Imprimir copa
Imprimir tronco
Imprimir base

Imprimir copa —>
Imprimir primeras ramas
Imprimir segundas ramas
Imprimir terceras ramas

Podemos observar la existencia de operaciones análogas, correspondientes a la
impresión de los distintos fragmentos. Es relativamente sencillo darse cuenta
de que cada una de las “ramas” de la copa del árbol es una figura trapezoidal.
Por ejemplo, las “segundas ramas” aparecen dibujadas así:

 

+42
ena
AR

Esta figura geométrica es un trapecio simétrico. Lo mismo puede decirse
de las otras “ramas”. Puesto que cada vez se imprime una figura diferente,
podremos definir esta acción como parametrizada, dando como argumentos la
información necesaria para distinguir cada “rama” particular. Por ejemplo,
podemos decidir que el único parámetro necesario es la anchura de la base
superior, ya que todas las “ramas” tienen 3 líneas de altura, y cada una de
estas líneas añade siempre un asterisco más a cada lado.

La especificación la impresión de una “rama” como procedimiento se podrá
redactar de la forma:

e

 

 

 

Especificación Semántica: Procedimiento para
imprimir 3 líneas seguidas con:
ancho,
ancho + 2
y ancho + 4 asteriscos

 

void ImprimirRama( int ancho ) /* Especificación Sintáctica */

En cuanto a la impresión del tronco y la base, también cabe la posibilidad
de considerarlas como operaciones análogas, en ambos casos un rectángulo
de asteriscos. Los parámetros serían en este caso la anchura y altura del
rectángulo. La especificación sería:
lología de Desarrollo de Programas (III) 191

 

  
 
   
   
   
   
   
 
 
 
   
   
    
  

 

Especificación Semántica: Procedimiento para
imprimir un rectángulo de ancho x alto asteriscos
mp

 

ImprimirRectangulo( int ancho, int alto )
Especificación Sintáctica */

esto se podría escribir ya el programa principal, en el que podemos agrupar
impresión de las ramas en un esquema de bucle.

Imprimir copa --*/

= 1;

(int k = 1; k <= 3; k++) 4

ImprimirRama( rama );

rama = rama + 2;

'— Imprimir tronco --*/
imirRectangulo( 1, 3 );

Imprimir base --*/
“imirRectangulo( 5, 1);

 

, se puede establecer una relación entre la impresión de las “ramas
tronco o la base, En efecto, un rectángulo puede considorarse como un
particular de un trapecio, Tanto la operación de ImprimirRama como la
ImprimirRectangulo se pueden apoyar en una operación común de ImirTrapecio especificada de la forma siguiente:

Procedimiento para imprimir un trapecio de asteriscos

con la base superior "ancho", altura "alto” y "avance”

asteriscos más a cada lado en cada nueva línea

a]
ImprimirTrapecio( int ancho, int alto, int avance )

operación la desarrollaremos mediantes refinamientos:
Imprimir trapecio —>

for (int k = 1;k <= alto; k++) (
Imprimir una línea del trapecio

y

 
 

192 Fundamentos de programación

 

Imprimir una línea del trapecio —>
Imprimir los blancos iniciales
Imprimir los asteriscos

Para mantener la información del número de asteriscos en cada línea usaremos
una variable anchura, que tomará inicialmente el ancho de la línea superior,
y se irá incrementando después de imprimir cada línea. Los blancos iniciales
se calculan cada vez, fijando como parámetro constante la posición del centro
de la línea.

Al desarrollar este procedimiento se observa una analogía entre la operación de
escribir los espacios en blanco y la de escribir los asteriscos. Ambas operaciones
so rofinan como la operación abstracta de imprimir un mismo carácter un cierto
número de veces. Para ello se especifica el procedimiento:

a

Procedimiento para imprimir N veces seguidas el carácter 'c'

 
 

 

ed
void ImprimirN( char c, int N )

El programa completo, incluyendo todos los procedimientos, es el siguiente:

 

 

DAA OLEA AAA

* Programa: ArbolDeNavidad

* Descripción:

* Este programa imprime la silueta de un árbol

* de Navidad, hecha con asteriscos.

AA ON LLLSL Gba

*include <stdio.h>

pe

 

Constante global

 

4
const int centro = 20;  /* Centro de cada línea */

 

Procedimiento para imprimir N veces seguidas el carácter 'c'

 

void ImprimirN( char c, int N )¿
for (int k =1; k <= N; k+*) (
print£( "X%e", e );

y

   

3
 
   
 
  

"Metodología de Desarrollo de Programas (III) 193

 

Procedimiento para imprimir un trapecio de asteriscos
con la base superior "ancho", altura "alto" y "avance"
asteriscos más a cada lado en cada nueva línea

     
       
    
         
     
   
        
   
   
   
  

  

 

se /
ImprimirTrapecio( int ancho, int alto, int avance ) £

int anchura; /* número de asteriscos */

 

 

  

anchura = ancho;

for (int k = k <= alto; K++) 1
ImprimirN( ' *, centro - anchura/2 );
ImprimirN( '*', anchura );
print£( "Ma" );
anchura = anchura + 2*avance;

 

 

Procedimiento para imprimir 3 líneas seguidas
con: ancho

ancho+2

y ancho+4 asteriscos

 

Imprimirkama( int ancho ) (
ImprimirTrapecio( ancho, 3, 1);

    
 
     

Procedimiento para imprimir un rectángulo
de ancho x alto asteriscos

      
    
   
    
  

 

 

*/
ImprimirRectangulo( int ancho, int alto ) £
ImprimirTrapecio( ancho, alto, 0 );

  

Programa principal

 
    
   
   
     

mainO)
int rama; /* Ancho de rama */

/*%-- Imprimir copa --*/

 

for (int k = 1; k <= 3; ke*) (
ImprimirRama( rama );
rama = rama + 2;
 

  

194 Fundamentos de programación

3

/*— Imprimir tronco --*/
ImprimirRectangulo( 1, 3 );

/*— Imprimir base --*/
ImprimirRectangulo( 5, 1);

 

   
 
 
  
 
  
 
 
  
   
 
 
 
 
 
 
 
   

Comparando esta redacción del programa con la que se había desarrollado en
el tema 4, se observa que el programa resulta ahora más largo, aunque cada.
parte separada del programa es más sencilla. En la versión anterior la parte
ejecutable del programa principal era más compleja que ahora.

Con esta nueva redacción se obtiene una ventaja adicional, que se ha producido como efecto de la labor de abstracción realizada para especificar los
subprogramas. Operaciones que antes se consideraban por separado, ahora
se han refundido en una sola operación abstracta y paramotrizada. La parametrización tiene la ventaja de que se facilita la modificación posterior del
programa.

En efecto, si quisiéramos cambiar el programa para imprimir una figura de
árbol algo diferente, en la versión inicial habría sido necesario cambiar casi:
toda la parte ejecutable del programa, sentencia por sentencia. Ahora la mayor
parte del programa está constituida por las definiciones de las operaciones.
abstractas, que se pueden mantener sin cambios, y sólo hay que rectificar la
parte de código del programa principal, que es relativamente corta.

 

Por ejemplo, podemos modificar el código del programa principal para imprimir un árbol más grande, tal como se indica en el programa ArbolGrande,
donde los cambios se han destacado con un recuadro [x].

 

 

 

 

 

Con la versión inicial del programa habríamos tenido que escribir de nuevo al:
menos unas 13 líneas del programa. Ahora no ha sido necesaria ninguna línea.
nueva y tan sólo hemos tenido que retocar 3, y sólo para modificar los val
de los tamaños.

 

AAA AREA

* Programa: ArbolGrande de Navidad

AAA ARAS

/* Usa las mismas definiciones de procedimientos
que el programa anterior */

 
logía de Desarrollo de Programas (111) 195

 

   
 
    
   
  
   
 
 

main() (
Tama; /* Ancho de rama */

'— Imprimir copa más alta--*/
=1;

(ánt k = 1; k <- [5); ke) 4
ImprimirRama(rama
Tama = rama + 2;

 

 

3

/*—- Imprimir tronco más grueso y alto —-*/
ImprimirRectangulo(3], [5)»;

 

 

/*-— Imprimir base más ancha y alta --*/
-ImprimirRectangulo(| 9), [2|);

 

 

 

 

 

 

 

resultado de la ejecución del programa ArbolGrande es el siguiente:

 

*
re.
are.
a.
anno”
anne
anno
ar
ere
e

 
 

 

196 Fundamentos de programación

8.2.3. Ejemplo: Imprimir una tabla de números primos

En el ejemplo anterior se buscó de manera insistente la analogía entre operaciones, y su especificación como operaciones parametrizadas. En este ejemplo
se atenderá fundamentalmente a la limitación on el nivel de detalle.

El objetivo de este programa de ejemplo es imprimir una tabla con los números
primos hasta un límite dado, formando varias columnas de números a lo ancho
del listado. Si decidimos imprimir los múmeros primos hasta 100, a cuatro
columnas de 15 caracteres de ancho cada una, el resultado deberá ser el que
aparece a continuación:

 

an 2 3 5
7 u 13 17
19 23 29 31
37 41 43 47
53 59 61 67
71 73 79 83
89 97

Los primeros pasos de refinamiento serán:
Imprimir la tabla de números primos de 1 a N—=>

for (int k 5 K <= Nk) (
Imprimir k, si es primo

   

 

+

Imprimir k, sí es primo —>

if ( hesprimo ) 4
Imprimir k, tabulando

 

+

Ahora decidimos limitar el nivol de detalle, y definir como oper
tractas las que faltan por refinar. Sus especificaciones serían:
q

Función para ver si un valor

 

 

es un núnero primo
no

 

 

bool EsPrimo( int k )
«PRE: k>0»
«POST: k no tiene divisores distintos de él mismo y la unidad »
«POST: EsPrimo(k) = Vd € (2.k— 1) e modulo(k,d) 40 »
 
 
 
  
   
   
  
  
   
   
  
    
 
  
  
   
   
  
 
 
   

iología de Desarrollo de Programas (III) 197

 

 

Procedimiento para imprimir tabulando
2 4 columnas de 15 caracteres

ImprimirTabulando( int k >)

 

 

*7

TA: El tipo predefinido bool, que se introducirá cu el próximo tema, sólo puede
ar dos valores posibles: true y false, que son los denominados hasta ahora
'NO como posible resultado de una condición.

función EsPrimo se especifica formalmente (y también informalmente, para
itar el comprender la expresión formal). Se omite la especificación formal
procedimiento ImprimirTabulando, ya que es más difícil de redactar. De

ifícil formalizar las operaciones de lectura y escritura, en general,
“que exigiría especificar formalmente la representación externa de los datos
resultados.

   

continuación podemos desarrollar la realización de estos subprogramas. La
ión que determina si 1m número es primo puede realizarse sencillamente
ollando su especificación formal, es decir, probando todos los divisores
íbles. Esta realización es poco eficiente, pero muy sencilla de programar.
única optimización es que en cuanto se encuentra un divisor d ya no se
ban otros, puesto que eso garantiza que el predicado Vd € ... no puede
plirse.

   

Función para ver si un valor "k" es un núnero primo

 

"
EsPrimo( int k ) 4

/* d es un posible divisor */
for (int d d <= k-1; d++) (
if ((x% d) 01
return false;
y
y
return true;

  

4

Para desarrollar la realización del procedimiento de imprimir tabulando hay
'que analizar algunas cuestiones previas. La especificación se ha establecido pa'sando como argumento solamente el número que hay que imprimir, reflejando
de esta manera la forma natural en que se ha descrito esta acción abstracta.
Sin embargo esta información es insuficiente para realizar la acción, ya que
198 Fundamentos de programación

 

es necesario saber qué columna toca imprimir para poder decidir si hay que
saltar de línea o no.

En este ejemplo se decide usar una variable global columna para mantener
dicha información. La variable contendrá en cada momento el número de la

columna en que aparecería escrito el próximo número si previamente no se
saltase de línea.

 

El refinamiento de esta operación será el siguiente:

Imprimir k, tabulando —>
Saltar de línea, si es necesario
Imprimir k y actualizar la columna

Saltar de línea, si es necesario ——>

if (columna > 4) £
columna = 1;
print£( "a" );
7

EL programa. completo, incluyendo la definición de todos los subprogramas
necesarios, es el siguiente:

 

JARRARAAARAAA RARA

* Programa: Primos

 

* Descripción
+ Este programa imprime una tabla de números

* primos, tabulando a cuatro columas
A A AAA AAA AAA AA

*tinclude <stdio.h>

e

 

Constante global

 

7
const int N = 100; /* rango de números */

ya

 

Variable global

 

int columna; /* columna a imprimir */
 
 
 
  

jología de Desarrollo de Programas (III) 199

 

 
    
 
  
 
 
 
 
     
  

Función para ver si un valor "k" es un múmero primo
== tf
EsPrimo( int k ) £
For (int d = 2; d <= k-1; d++) 4

if ((Kk % d) =0) (

return false;

+
+
return true;

 

 

Procedimiento para imprimir tabulando
a 4 columnas de 15 caracteres

ImprimirTabulando( int k ) 4
if (columna > 4) (
columna
print£( "Wn'
y
print£( "X15d", k );
columa++;

    
 
 
 
 
   
   
   

 

 

d

 

Programa principal

  

main() (
columna =
for (int k = 1; k <=
if (EsPrimo(k)) £

ImprimirTabulando( k );
3

   

ke) 4

y
print£( "a" );

 

    
   
 

8.2.4 Reutilización

La realización de ciertas operaciones como subprogramas independientes fasilita lo que se llama reutilización de software. Si la operación identificada
somo operación abstracta tiene un cierto sentido en sí misma, es muy posible
que resulte de utilidad en otros programas, además de en aquél para el cual
   
 
   
  
   
 
 
 

200 Fundamentos de programación

 

se ha desarrollado. La escritura de otros programas que utilicen esa misma
operación resulta más sencilla, ya que se aprovecha el código de su definición,
que ya estaba escrito.

Aplicaremos esta idea a los subprogramas desarrollados para imprimir el árbol
de Navidad. Las operaciones abstractas definidas allí permiten imprimir con
bloques de asteriscos figuras trapezoidales, o simplemente rectangulares, de
dimensiones variables. Cualquier figura que pueda descomponerse en secciones
de estas formas se podrá imprimir fácilmente usando los procedimientos ya

definidos.

Por ejemplo, podremos imprimir la figura de una casa de juguete, tal como la
siguiente:

 

 

«e
e
eee
ran
Re
ee

Para ollo sólo tendremos que escribir un fragmento de programa así:
int mainQ) (

/*— Imprimir chimenea--*/

InprimirRectangulo( 2, 2 );

 

/*-— Imprimir tejado —
ImprimirRama( 9 );

/*-- Imprimir cuerpo de la casa--*/

ImprimirRectangulo( 9, 3 );
+

Por supuesto, tendremos que copiar en la parte de declaraciones las definicio:
de los procedimientos ya desarrollados en el programa del árbol de Navidad.

A continuación se presentan más ejemplos, que aprovechan subprogram
desarrollados de antemano.

8.2.5 Ejemplo: Tabular la serie de Fibonacci

El procedimiento de imprimir tabulando desarrollado en el ejemplo de im;

 

mir la tabla de números primos, puede aprovecharse para imprimir en fo
 
  
  
  
  
 
  
  
 
   
   
   
   
  
 
 
  
   
   
   
   
  

¡ología de Desarrollo de Programas (III) 201

 

tabla otras series de valores. Por ejemplo, podemos tabular la serie de Fibo, que ya se describió en el tema 6. Lo que necesitamos ahora es sustituir
sentencias de escritura usadas en aquel ejemplo

EC "LOAN", termino );
una llamada al procedimiento

imirTabulando( termino );

falta copiar en la parte de declaraciones la definición del procedimiento
tabular y añadir al comienzo del programa la inicialización del contador de
nas. El programa completo aparece listado a continuación:

 

 

AAA NA

Programa: Fibonacci

Descripción:
Este programa imprime todos los términos

de la serie de Fibonacci dentro del rango de
valores positivos del tipo int: (1 .. INI_MAX)
Se imprime tabulando a cuatro columnas
ARANA eta /
<stdio.h>

<limits.h>

Variable global

a

columna; /* columna a imprimir */

 

Procedimiento para imprimir tabulando
2 4 columnas de 15 caracteres
ImprimirTabulando( int k ) (
Af (columna > 4) £

columna = 1;

print£( “Wn" );

 

 

7
print£( "X%15d", k );
columna++;
202

fs
Programa principal

 

 

 

/*-— Iniciar la tabulación

columna = 1;

/*— Generar el comienzo de la serie

anterior
termini

 
  

ImprimirTabulando( anterior );
ImprimirTabulando( termino );

ye

while (INT_MAX — ti
aux = termino +
anterior = termi
termino = aux;

 

ImprimirTabulando( termino );

y
print£( "Yn” );

Generar el resto de la serie
anterior) (

ermino >=
anterior;
no;

 

Fundamentos de programación

 

 

E

 

/* término de la serie */
/* término anterior */

 

El resultado de la ejecución en una máquina con números enteros de 32 bi

(INT_MAX = 2.147.483.647) es el siguiente:

 

 

o

3

21

144

987

6765
46368
31781
2178309
14930352
102334155
701408733

1

5

34

233

1597
10946
75025
514229
3524578
24157817
165580141
1134903170

1

8

55

377

2584
17711
121393
832040
5702887
39088169
267914296
1836311903

2

13

89

610

4181
28657
196418
1346269
9227465
63245986
433494437
 
  
  
   
 
 
  
 
  
 
    
 
 
 
  
 
  
   
 
   
 
   
 
   
  
  

odología de Desarrollo de Programas (III) 203

 

6 Desarrollo para reutilización

a aplicar de manera eficaz las técnicas de reutilización de software es preciso
ar en las posibles aplicaciones de un cierto subprograma en el momento de
ificarlo, con independencia de las necesidades particulares del programa
se está desarrollando en ese momento.

a estrategia de desarrollo tiene ventajas e inconvenientes. La principal venfa es que se amplía el conjunto de aplicaciones en que se podrá reutilizar
s adelante el subprograma que se está desarrollando ahora. Su principal
weniente es que será más costoso hacer el desarrollo del subprograma
¡teado como operación de uso general, que planteado como operación parar, hecha a medida del programa que lo utiliza en este momento.

 

el ejemplo del árbol de Navidad, nos encontramos con que al buscar analoentre distintas operaciones para resolverlas con un subprograma común,
mos generalizando al mismo tiempo dichas operaciones, estableciendo
etros que permitían particularizarla para cada caso.

 
 

el caso de subprogramas planteados simplemente con el in de limitar el
el de detalle en una sección determinada de un programa, no se siente esta
ad de generalizar, y es más facil plantear la operación particularizada
las necesidades de ese momento.

el ejemplo de tabular las series de valores, se ha planteado de entrada la
ación de tabulación de manera que impone tanto el número de columnas
o el ancho de cada una. Si queremos escribir un subprograma de tabulade resultados que sea realmente de uso general, convendría dejar libertad
ra fijar las características del listado como parámetros modificables, que se
an particularizar para cada caso.

esta manera se podría haber ampliado el campo de aplicación del subproa de tabular si el número de columnas y el ancho de cada una fuesen
rámetros variables. Además, para simplificar el uso del procedimiento de
¡ón se podrían agrupar todas las acciones de inicialización en una sola
abstracta, invocada como subprograma, en que se fijen los parámetros
ticulares del listado. La especificación de esta acción inicial podría ser:

 

Procedimiento para iniciar la tabulación
zon los parámetros indicados

ME */
IniciarTabulacion( int columas, int ancho )

    
   
 
 

ra ilustrar esta técnica, modificaremos el programa de tabular la serie de
de acuerdo con lo expuesto, decidiendo ol formato del listado (6 co
 
   
 

204 Fundamentos de programación

lumnas de 11 caracteres) desde el programa principal. El programa modificado
es el siguiente:

 

 

AAA AA AAA

* Programa: Fibonacci2

 

* Descripc.
* — Este programa imprime todos los términos

* de la serie de Fibonaci, dentro del rango de

* valores positivos del tipo int: (1 .. INI_MAX)
+ Se imprime tabulando a siete columnas

AORERRR nana ERRE E RRA NANA RARAS
ftinclude <stdio.h>

ftinclude <limits.h>

 

 

 

 

 

fm
Variables globales
7
int TABcolumn: /* columna a imprimir */
int TABultima; /* última columna */
int TABancho; /* ancho de cada columna */
e
Procedimiento para iniciar la tabulación
con los parámetros indicados
7
void IniciarTabulacion( int columnas, int ancho ) 4
TABultima = columnas;
TABancho ancho;
TABcolumna
y
a

 

 

 

Procedimiento para imprimir tabulando
a TABultima columnas
de TABancho caracteres
void ImprimirTabulando( int k ) (
if (TABcolumna > TABultima) [
TABcoluma = 1;
printf( "Ya" );

 

ida

 

 

E
printf( "%*d",TABancho, k );
TABcolumna++;

y

 

 
lología de Desarrollo de Programas (111)

 

Programa principal

main() (
int termino; /* término de la serie */
ánt anterior; /* término anterior */
ánt aux;

/*— Iniciar la tabulación --*/
IniciarTabulacion( 6, 11 );

/*— Generar el comienzo de la serie -—-*/
anterior

termino = 1:

IsprimirTabulando( anterior );
IsprimirTabulando( termino );

/*— Generar el resto de la serie --*/
abile (INT_MAX - termino >= anterior) £
aux = termino + anterior;
anterior = termino;
termino = aux;
ImprimirTabulando( termino );
y
print£( "a" y;

 

resultado de la ejecución es el siguiente:

 

o 1 1 2 3 5

8 13 21 34 55 89

144 233 377 610 987 1597

2584 4181 6765 10946 170 28657

46368 75025 121393 196418 317811 514229

832040 1346269 2178309 3524578 5702887 9227465

14930352 24157817 39088169 63245986 102334155 165580141
114296 433494437 701408733 1134903170 1836311903

viene comentar algunos aspectos de estilo utilizados en este ejemplo. Las
les globales para la tabulación se han nombrado empezando sus nombres

el profijo TAB, para establecer que están todas ellas relacionadas y que
visibles desde todos los subprogramas. Sin embargo, las variables para
'gálculo de la scrie de Fibonacci están declaradas como locales al programa

ipal y se pasan como argumentos al procedimiento de ImprimirTabulan
 
206 Fundamentos de programación

 

do separando así el cálculo de la serie y la reutilización de la impresión de uz
número cualquiera tabulando.

En realidad esto es un recurso artificioso para separar las distintas partes
programa. Este recurso se utilizará más ampliamente y de manera natural
cuando se presenten los tipos abstractos de datos mediante módulos separados
en C£. Usando el mecanismo de módulos se pueden desarrollar subprogramas:
reutilizables, escritos en forma realmente independiente, de una manera mucho
más sencilla y adecuada.

  
  
 

8.2.7 Desarrollo ascendente

La metodología de desarrollo ascendente (en inglés Bottom-Up) consiste en ir
creando subprogramas que realicen operaciones significativas de utilidad para
el programa que se intenta construir, hasta que finalmente sea posible escribir
el programa principal, de manera relativamente sencilla, apoyándose en los
subprogramas desarrollados hasta ese momento.

La técnica tiene una cierta analogía con el desarrollo de subprogramas pensando en su reutilización posterior. Al hablar de desarrollo para reutilización se
ha dicho que los subprogramas podían surgir en el proceso de refinamiento de
un programa concreto, al identificar ciertas operaciones, pero debían definirse
pensando en futuras aplicaciones. En este caso se trata de que la identificación:
de las operaciones no surja de un proceso de descomposición o refinamiento de
alguna acción en particular, sino simplemente pensando en el programa que
se desarrolla, casi como una más de las posibles aplicaciones futuras.

Como ejemplo desarrollaremos un programa que opere como una caleuladora, pero con fracciones. Una fracción se compondrá de un numerador y un
denominador enteros. La calenladora podrá sumar, restar, multiplicar o dividir fracciones, y los resultados los presentará con la fracción simplificada,
dividiendo por los factores comunes al numerador y al denominador.

Con independencia de los detalles de operación de la calculadora, pueden desarrollarse inicialmente procedimientos útiles para esta aplicación; en particular
procedimientos para realizar cálculos con fracciones, así como leerlas o imprimirlas. En el siguiente listado se presenta una colección apropiada de proce=
dimientos, sobre los cuales se podrá desarrollar luego el programa principal de
la calculadora.

 
 
 
 
    
   
    
   
 
   
      
   
    
  
    
   
      
  
  
   

a) 207

Procedimiento para simplificar
la fracción n/d
[void ReducirFraccion( int € n, int d) 4
int divisor = 2;

 

== /

 

while ((divisor <= n) € (divisor <= d)) £
while ((n % divisor == 0) 66 (d % divisor
n =n / divisor;
d = d / divisor;
y

divisor++;

 

Procedimiento para sumar fracciones
n3'/d3* = n1/d1 + n2/d2

 

 

ao /

SumarFracciones( int nl, int dl, int n2, int d2,
int £ n3, int 4 d3)(

m3 = n1*d2 + n2*d1;

d3 = d1*d2;

ReducirFraccion( n3, d3 );

 

 

Procedimiento para restar fracciones
n3"/d3" = n1/d1 - n2/d2

 

 

==: /

RestarFracciones( int nl, int dl, int n2, int d2,
int 4 n3, int 8 d3)4(

SumarFracciones( nl, dl, -n2, d2, n3, d3 );

Procedimiento para multiplicar fracciones
n3"/d3" = n1/dl = n2/d2
e
MultiplicarFracciones( int nl, int dl, int n2, int d2,
int 4 n3, int £ d3) (

= n1*n2;

= d1*d2;

“irFraccion( n3, d3 );

 
 

208 Fundamentos do programación

Y
Procedimiento para dividir fracciones
n37/d3

 

 

n1/d1 / n2/d2

 

.22*/
void DividirFracciones( int nl, int dl, int n2, int d2,
int 8 n3, int 8 d3) (

 

n3 = n1*d2;

d3 = dl*n2;

ReducirFraccion( n3, d3 );
,

  

Procedimiento que lee una fracción
y la simplifica

 

z,

void LeerFraccion( int € n, int£ d)4
scanf( "%d/%d", €n, 6d );
ReducirFraccion( n, d );

$

pia
Procedimiento que escribe
una fracción como n/d

 

 

Y)

void EscribirFraccion( int n, int d) 41
print£( "%d/xdin", n, d );

cd

Contando con esos procedimientos se puede ahora desarrollar el programa!
principal de la calculadora, que se presenta en el programa Fraccion. En este
ejemplo se supone que cada operación se realiza: entre un valor acumulado
y un nuevo operando. La operación se inicia con una tecla de operación, y
a continuación se introduce el valor del operando. Las operaciones previstas
son +, =, *, /. Además habrá teclas de operación para imprimir el resultado
acumulado (=) y para iniciar una nueva serie de operaciones (N). La tecla E
marcará el in del funcionamiento del programa.

AAA

 

Programa: Fracciones

Descripción:
Este programa es una calculadora que suma,

E resta, multiplica y divide fracciones

   

 
 
 
 
   
   

"Metodología de Desarrollo de Programas (III) 209

 

Jude <stdio.h>

... definiciones de los procedimientos, omitidas ...*/

Programa principal

 

 

main() (

nt num = 0; /* Acumulador: Numerador */

int den /* Acumulador: Denominador */

int nn, dd; /* Nuevo operando a utilizar */
char operacion = * /* Tecla de operación a realizar */

 

 

 

while (operacion
print£( ">> " );
scanf( " %c", fSoperacion );

ELE

if (operacion = '+') £
LeerFraccion( mn, dd );
SumarFracciones( num, den, nn, dd, num, den );

) else if (operacion == *-') £
leerFraccion( nn, dd );
RestarFracciones( num, den, nn, dd, num, den );

J else if (operacion == "*')
LeerFraccion( mn, dd );
MultiplicarFracciones( num, den, nn, dd, num, den );

) else if (operacion == '/') £
LeerPraccion( nn, dd );
DividirFracciones( num, den, nn, dd, num, den );

J else if (operacion == 'N') [ /* Nuevos cálculos */
LeerPraccion( num, den );

 

) else if (operacion == '=") (
printf( " 0
EscribirFraccion( num, den );

 

j else if (operacion != 'F') £
printf£( "Pulse +, -, *, /, N, =, 0 Fin" );
+
F

 
210 Fundamentos de progr

 

Un posible ejemplo de la ejecución del programa es el siguiente:

 

>> N 5/20
”»
1/4
> + 3/5
>» - 2/4
>»

7/20
> * 5/6
»
7/24
> F

     
  

En esta aplicación de la técnica de desarrollo ascendente se puede apreciar q;
el desarrollo inicial de procedimientos para realizar cáloulos con fracciones
ha permitido disponer de una extensión del lenguaje C, equivalente a definir.
el tipo FRACCIÓN. Podríamos decir que los procedimientos de cálculo consti
tuyen en conjunto una máquina virtual de operar con fracciones, sobre la cual
se ha desarrollado el programa de la calculadora. El desarrollo es ascendente
porque primero se han construído los subprogramas, de nivel inferior, y luego
el programa que los usa, de nivel superior.

8.3 Programas robustos

La corrección de un programa exige que los resultados sean los esperados, |
siempre que el programa se ejecute con unos datos de entrada aceptables. La
cuestión que nos ocupa en este momento es: ¿cuál debe ser el comportamiento
del programa si los datos son incorrectos?.

 

Un programa se dice que es un programa robusto si su operación se mantiene
en condiciones controladas aunque se le suministren datos erróneos.

8.3.1 Programación a la defensiva

La postura más cómoda desde el punto de vista del programador es declinar
toda responsabilidad en el caso de que los datos no sean válidos. Si los datos de
entrada no cumplen con los requisitos previstos, el programa puede entonces
hacer cualquier cosa. Es frecuente que un programa se escriba sin tener en
cuenta la posibilidad de que los datos no sean los esperados, pues con ello se
simplifica su desarrollo.
  
 
 
 
 
 
 
 
    
  
 
   
 
 
 
 
  
   
   
  
   
 
 
 
  
  
 
 
    
  
  
 
    
  

Metodología de Desarrollo de Programas (HI) 211

 

Sin embargo esta postura no es admisible en la práctica. Como cualquier otra
actividad humana, la escritura y nso de programas está sujeta a errores, y es
importante conseguir que las consecuencias de esos errores no sean demasiado
'graves. Por ejemplo, un programa de gestión de un almacén deberá prever que
¡se notifique la retirada de más cantidad de un producto que la anotada como
existencias. En este caso el programa deberá hacer algo “razonable”, tal como
“emitir un mensaje de aviso y obligar a repetir la operación, o simplemente
“asumir que el valor de las existencias estaba equivocado, y preguntar por el
“valor real de las existencias, o alguna otra cosa similar. Lo que no parece
“razonable” es anotar un valor negativo para las existencias sin dar ningún
“aviso, o, en general, seguir operando con valores manifiestamente erróneos
que podrían dar lugar más adelante a una parada indeseada del programa
aborto”) al intentar ejecutar alguna instrucción de máquina inadmisible con

o ejemplo ilustrativo puede ser el de un programa para calcular el valor
edio de una serie de datos, dividiendo la suma de todos por el número de
os introducidos. Cabe la posibilidad de que no se introduzca ningún dato,
cual dará lugar a un intento de realizar una división por cero, que en muchos
s produce el “aborto” del programa. Si el cálculo de la media es lo único
hace el programa, el efecto no parece muy grave, pero si este cálculo es
e de las operaciones que realiza, por ejemplo, el programa de control de
central nuclear, los resultados pueden conducir a una catástrofe mundial.
p realmente importante es detectar los errores en cuanto se produzcan, y
así programar operaciones de corrección o tratamiento apropiadas para
situaciones excepcionales.

 

llamada programación a la defensiva (en inglés, defensive programming)
ste en que cada programa o subprograma esté escrito de manera que
nfíe sistemáticamente de los datos o argumentos con que se le invoca, y
uelva siempre como resultado:

la) El resultado correcto, si los datos son admisibles, o bien
) Una indicación precisa de error, si los datos no son admisibles.

que no debe hacer nunca el programa es devolver un resultado como si
normal, cuando en realidad es erróneo, ni “abortar”. Esto da lugar a una
agación de errores, que puede aumentar la gravedad de las consecuencias,
cer que la identificación del fallo del programa resulte mucho más difícil,
que el efecto se puede manifestar sólo más adelante, en otra parte del
relación aparente con la que falló.

 

mejora de la robustez del programa tiene como contrapartida una cierta
la de eficiencia, al tener que hacer comprobaciones adicionales. Si la
  

Fundamentos de program:

  
 
   
   

eficiencia es un factor decisivo, algunas de estas comprobaciones pueden
minarse en la versión final del programa, cuando se determino con seguri
que el programa no contiene errores.

Consideremos el caso de una función para calcular el factorial de un núme

ARTETA

 

La especificación de dicha función podría ser:
int Factorial( int n );
«PRE: n>0»
«POST: Factorial(n) = (n=0=> 1/n x Factorial(n — 1)»

Esta especificación nos indica que el factorial sólo está definido para valores
h positivos, incluido cero, cuyo factorial por convenio vale 0! =1. El £
de un número positivo no mulo se defino a partir del anterior. Para valo
negativos el factorial no está definido.

 

     
  
 
 
  
    
     

Una realización sencilla de la función podría ser:

int Factorial( int n) f
int f=1;

for (ánt k = 2; k <= nj; ke) 4
E=i*k

y

return £;

,

Esta función no es robusta. Para valores negativos el factorial no está defini
y sin embargo la función codificada de la forma anterior devuelve resultado
que sólo sería el resultado correcto correspondiente a 0! ó 11.

 

Lo que hace falta es devolver una indicación clara de error para argument:
negativos. Una forma de hacerlo podría ser devolver un resultado cero e
negativo en estos casos, ya que ese resultado no puede coincidir con el factori:
de ningún número. La función se recodificaría como se indica a continuación.
Como vemos, el código evalúa explícitamente la precondición. Si no se cumple
devuelve un resultado fuera de rango, como indicación de error, y si se cumple!
devuelve el valor correcto:

int FactorialPositivo( int n ) (
int f;
 
  
   
 
 
 
   
   
   
  
 
 
  
  
   
 
 
   
   
  
 
 
 
    
   

odología de Desarrollo de Programas (111) 213

for (int k = 2; k <= n; k++) 1
t=f*EÉ

y

y

return £;

realidad la función sigue sin ser del todo robusta, ya que no se ha previsto
posibilidad de que el factorial que se intenta calcular exceda del rango adisible de valores del tipo int. Esto ocurre fácilmente incluso para valores restivamente pequeños del argumento (p.ej., 20! = 2,432.902.008.176.640.000).
En la sección siguiente se presenta una versión más robusta de esta función.

2. Tratamiento de excepciones

la posibilidad de errores en los datos con que se opera, hay que considerar
s actividades diferentes.

1. Detección de la situación de error.
2. Corrección de la situacion de error.

una operación se ha escrito como subprograma, la programación a la desiva recomienda que la primera actividad (detección del posible error) se
ga dentro del subprograma, sin confiar en que quienes usen el subprograma
invoquen siempre con datos correctos.

ten varios esquemas de programación posibles para tratamiento de erroUn modelo recomendado es el modelo de terminación. En este modelo,
se detecta un error en una sección o bloque del programa, la acción de
miento del error reemplaza al resto de las acciones pendientes de dicha
cción, con lo cual tras la acción correctora se da por terminado el bloque. En
nos lenguajes de programación, tales como el lenguaje Ada, Java y C++,
sten construcciones o sentencias adecuadas para programar este esquema.
] estudio profundo de las construcciones y mecanismos para tratamiento de
epciones quedan fuera de los objetivos de este libro.

También en Ci, como subconjunto de C++, existen sentencias especiales para.
manejo de excepciones. A continuación se muestra mediante un ejemplo
llo la utilidad básica de dichas sentencias y los distintos pasos para el

 
  
  
  
   
   
   
 
 
   

214 Fundamentos de programación

 

tratamiento de exceptiones. Un subprograma desarrollado siguiendo el modelo
de terminación podría programarse en Ct según el siguiente esquema:

 

void Operacion ( argumentos ) (

. acción] ...
if ( errorl ) (

throw excepcion1 /* Terminación con excepción1 */
3

. acción2 ...
i£( error2 ) (

throw excepcion2 /* Terminación con excepción2 */
y

¿a

La sentencia throw provoca la terminación del subprograma de manera se
jante a una sentencia return. Sin embargo, ambas terminaciones son distix
tas: con return se realiza una terminación normal y con throw se realiza.
terminación por excepción. La sentencia throw puede devolver cualquier tij
de resultado en excepcion. Además, la sentencia throw es la encargada
indicar que se ha detectado una situación de error (actividad 1) y lanzar el
canismo de tratamiento de excepciones. Quien utiliza el subprograma será
encargado de realizar la corrección de la situación de error (actividad 2). A;
caremos este esquema a una variante mejorada de la función para calcular
factorial de nn número, detectando la situación de exceso de capacidad (0%
flow) lanzando una excepción con el valor del múmero cuyo factorial pro
el overflow. Además, también se lanza una excepción con valor cero cu:
se le pide a la función el factorial de un número negativo.

int FactorialRobusto(int n) f
int f =

 

for (int k = 2; k <= n; ke) (
df (£ > INTMAX/IO
throw k;
  
 
  
 
   
   
  
  
  
  
   
  
   
  
    
 
 
  
  
   
    
 
 
 
 
 
    
   
  

odología de Desarrollo de Programas (111) 215

 

ta función opera de manera robusta sea cual sea el rango de enteros de la.
Si se sabe de antemano cuál es dicho rango, se podría aumentar
p la eficiencia determinando por anticipado cuál es el mayor valor para el
se puede calcular el factorial, y detectando directamente si el valor del
nto excede de dicho límite, definido como parámetro constante.

segunda actividad, sin embargo, no puede realizarse, en general, dentro
subprograma, ya que el tratamiento adecuado de la situación excepcional
drá ser diferente en cada invocación. Lo que ha de hacer el subprograma es
olver una indicación precisa. del error, y dejar que sean los programas que
invocan quienes decidan cómo actuar frente al error en cada caso.

las herramientas convencionales de un lenguaje de programación, el esa típico para el tratamiento de excepciones sería el siguiente:

o del Problema (inicio);

ionRobusta( argumentos );

(Excepcion) 4
Tratamiento de la Excepción

 

o del Problema (continución)

esquema tiene el inconveniente de que hay que insertar el tratamiento
la excepción en medio del código del algoritmo del problema que se está
olviendo. Esta mezcla del código normal y el código excepcional disminuye
claridad del programa. Las sentencias disponibles en CE para el manejo de
pepciones permiten separar ambos códigos siguiendo el siguiente esquema:

 

Algoritmo del Problema. (ini
Operación Robusta( argumentos );
Algoritmo del Problema (continuación);

 

 

 

C

cepción) £
Tratamiento de la Excepción

sentencia try agrupa el bloque de código en el que se programa el algoritmo
problema a resolver sin tener en cuenta las posibles excepciones que se
an producir. A continuación, la sentencia catch agrupa el código para
el tratamiento de la Excepción que se declara entre parentesis. Dentro del
10 bloque try se pueden producir excepciones de distintos tipos para las
se tendrian que programar las correspondientes sentencias catch. En el
sgrama completo que figura a continuación se muestra como se programa el
miento de las excepciones que genera la función FactorialRobusto en el
oque que la utiliza.

 
216 Fundamentos de programación

 

 

 

/** Programa: FactorialRobusto */

include <stdio.h>
include <limits.h>

int FactorialRobusto( int n )
int f=1;

ifo<0Dt
throw 0;
3
for (int k = 2; k <= nm; kt) (
1£ (£ > INTMAX/O £
throw k;

3
LEAR

3
return f;
E

void EscribirFactorial( int num ) 4
try t
print£( "2d! vale:%10dn", num, FactorialRobusto(num) );
+
catch (int e) £

 

print£( "42d! excepción: ", num );
if (e 04

print£( "Factorial de número negativoln" );
J else (

print£( "Superado límite al evaluar %2d!Wn", e );

y
y

int main () (
for (int i=5; i>=
EscribirFactorial( i
y
print£( "Wn" );
for (int i=6; i <= 15; d++) (
EscribirFactorial( i );

J

 

A

 

 

 
logía de Desarrollo de Programas (III) 217

 

  
  

procedimiento EscribirFactorial captura todas excepcionos y el trata:o consiste en escribir el correspondiente mensajo de error. En este caso,
programa principal sólo se utiliza como programa de prueba. Los resultados
la ejección se muestran a continuación:

 

vale: 120
vale: 24
vale: 6
vale: 2
vale: 1
vale: 1

excepción: Factorial de número negativo
excepción: Factorial de número negativo

vale: 720
vale: 5040
vale: 40320

%l vale: 362880
l vale: 3628800
vale: 39916800
1 vale: 479001600
excepción: Superado límite al evaluar 13!
excepción: Superado límite al evaluar 13!
excepción: Superado límite al evaluar 13!

 
Tema 9

Definición de tipos

Después de haber sido introducidos todos los mecanismos fundamentales para
la construcción de programas, ahora se pasa a estudiar las estructuras de
datos. En este tema se indican las primeras formas en que el programador
puede definir sus propios tipos de datos.

En primer lugar se estudian los tipos escalares simples definidos por enumeración y cómo se utilizan. Como caso especial de tipo enumerado ya predefinido
se hace especial mención del tipo bool, precisando su importancia dentro de
la programación.

A continuación se estudia la definición de tipos estructurados y las dos formas
más importantes para la estructuración de datos: array o formación y struct
o registro. En este tema sólo se introducen los conceptos básicos de ambas
estructuras de datos. También en este tema y como ejemplo de formación se
estudian las cadenas o vectores de caracteres.

Para finalizar, se presentan varios ejemplos que emplean los tipos introducidos
y muestran las posibilidades que ofrecen.

9.1 Tipos definidos

Una de las ventajas fundamentales de los lenguajes de alto nivel es la posibilidad que ofrecen al programador de definir sus propios tipos de datos. Los tipos
predefinidos: int, char y £loat, ya presentados en el tema 2, nos han pormitido la elaboración de programas para la realización de cálculos o el manejo
de caracteres. Sin embargo, si se trata de realizar un programa para jugar al
ajedrez resulta mucho más adecuado utilizar datos que representen de manera

 

 

 
 

 

220 Fundamentos de programación

 

más directa a los peones, caballos, torres, alfiles, reyes y damas del tablero
Razonamientos similares se pueden hacer si se quieren realizar programas que
manejen días de la semana, deportes, colores, alimentos, etc.

Mediante la definición de nuevos tipos de datos por el programador se consigue
que cada información que maneja el computador tenga su sentido específico
El tipo establece los posibles valores que puede tomar ese dato. Además, al
igual que sucedía con los tipos predefinidos, a cada nuevo tipo que se define se
asocian un conjunto de operaciones que se pueden realizar con él. Por tanto,
la definición de tipos supone crear un nuevo nivel de abstracción dentro del
programa.

  

En C£ la declaración de los tipos se realiza, junto a la declaración de las
constantes y variables, dentro de las Declaraciones del programa principal o en
cualquiera de sus procedimientos o funciones. Asimismo, en C+ la declaración
de cada nuevo tipo siempre se inicia con la palabra clave typedef. Por ejemplo;
typedef int  TipoEda:

typedef char TipoSexo;
typedef float TipoAltura;

 

 

En estas declaraciones se definen nuevos tipos dándoles un nombre o identifcador y hacióndolos equivalentes o sinónimos de otros tipos ya definidos (en
este caso, los predefinidos int, char y float). Quizá en estos ejemplos la
declaración de tipo no cubre todos los objetivos señalados anteriormente, pues
no establece ninguna especificidad. Esto es, convendría establecer que la edad
no puede ser negativa ni superior a un valor determinado o que el sexo sólo
puede tomar determinados valores. En algunos lenguajes de programación,
tales como Pascal, Modula-2 o Ada, se puede acotar el rango de valores de un
tipo de datos a partir de otro en el momento de la declaración. Lamentablemente, en CE sólo cs posible acotar el rango de valores de un dato haciendo
las correspondientes comprobaciones dentro del código del programa.

 

Es importante señalar que igual que se han utilizado los tipos predefinidos, en
la definición de un nuevo tipo se pueden utilizar (y normalmente se utilizan)
otros tipos definidos previamente, según veremos a lo largo de este tema,
Precisamente esta característica es la más importante de la posibilidad de
declarar muevos tipos.

La definición de tipos es solamente una declaración do los esquemas do datos que se necesitan para organizar la información de un programa. Para
almacenar información es necesario declarar y utilizar variables de los correspondientes tipos, de la misma forma que se hace con los tipos predefinidos.

 

Por ejemplo, se podrían usar los tipos sinónimos anteriores de la forma:
  
 
   
  
   
 
  
  
  
  
   
  
   
   
 
   
    
 
    
  
  
  
   

ición de tipos 221

 

lad edadl, edad2;
exo Sexo;
Itura altura;

= edadl + 5;
y
a = 1.75;

 

manera formal, la sintaxis de la declaración de tipos es la siguiente:
Declaración _de_tipo 33= Tipo_sinónimo | Tipo_enumerado

Tipo_array | Tipo_ struct | Tipo_unión | Tipo_puntero

 

tipo sinónimo ya ha sido utilizado en los ejemplos anteriores para introducir
concepto de tipo de dato. Formalmente la declaración de un tipo sinónimo
es la siguiente:

 

Tipo_sinónimo *
typedef Identificador_de_tipo Identificador_de_tipo_nuevo ;

El tipo sinónimo puede parecer trivial o meramente teórico, sin embargo, tiene

“ma utilidad bastante importante como mecanismo de parametrización del

'programa. Al igual que sucedía con las constantes con nombre, en un programa

se pueden utilizar sólo tipos con nombres propios. Por ejemplo:

 

lef int entero;
char caracter;
float real;

Estos nuevos tipos entero, caracter y real sustituyen a los predefinidos
del lenguaje y son los únicos que se utilizarán en nuestro programa. Cuando
se cambia de compilador para transportar el programa a otra plataforma o
se quiere cambiar la precisión de los cáleulos sólo es necesario modificar en
estas sentencias de parametrización los tipos haciéndolos sinónimos de otros
diferentes.

En los apartados siguientes de este mismo tema so indica la manera de definir
los tipos enumerados, formación y tupla. En tomas posteriores so explicará
cómo se definen y para qué sirven los tipos unión y puntero.

  

9.2 Tipo enumerado

Aparte de los valores predefinidos básicos (números, caracteres, etc.) en Ci se
pueden definir y utilizar nuevos valores simbólicos de la manera que se indica
a continuación.

 
222 Fundamentos de programación

 

9.2.1 Definición de tipos enumerados

Una manera sencilla de definir un nuevo tipo de dato es enumerar todos los posibles valores que puede tomar. En C+ el nuevo tipo enumerado se define detrás
de la palabra clave enum mediante un identificador del tipo y a continuación
se detalla la lista con los valores separados por comas (,) y encerrados entre
llaves £....). Cada posible valor también se describe mediante un identificador. Estos identificadores al mismo tiempo quedan declarados como valores
constantes. Por ejemplo:
typedef enun TipoDia (

Lunes, Martes, Miercoles, Jueves,

Viernes, Sabado, Domingo
5
typedef emm TipoMes £

Enero, Febrero, Marzo, Abril, Mayo,

Junio, Julio, Agosto, Septiembre,

Octubre, Noviembre, Diciembre

typedef enum TipoEstadoCivil [ Casado, Soltero, Viudo, Divorciado );

enum TipoColor £ Rojo, Amarillo, Azul y;

typedef enum TipoFrutas [ Pera, Manzana, Limon, Naranja, Kiwi );
enum TipoOrientacion [ Norte, Sur, Este, Oeste );

typedef enum TipoPieza [ Rey, Dama, Alfil, Caballo, Torre, Peon );

La enumeración implica un orden que se establece entre los valores enumerados. En Ci este orden se define de forma implícita e impone que el primer
elemento de la lista ocupa la posición 0, el siguiente la 1, y así sucesivamente
hasta el último, que ocupa la posición N-1, siendo N el número de elementos
enumerados. Los tipos de datos enumerados forman parte de una clase de ti
pos de Ct denominados tipos ordinales, a la cual pertenecen también los tipos
int y char, pero no el tipo float.

La sintaxis exacta de la declaración de los tipos enumerados es la siguiente:

 

Tipo_enumerado *3= typedef enum Identificador_de_tipo_nuevo
£ Lista_de_identificadores Y;

Identificador Í , Identificador )

 

Lista_de_ identificadores

9.2.2 Uso de tipos enumerados

Los tipos enumerados se emplean de manera similar a los tipos predefinidos.
El identificador de tipo se puede emplear para definir varinbles de ese tipo, y
 
  
 
 
   
  
  
  
  
   
     
  
  
   
 
    
  
 
 
   
 
  

Definición de tipos 223

 

los identificadores de los valores enumerados se emplean como las constantes
con nombre. Usando las definiciones anteriores podremos escribir:

ipoDia diaSemana;

ipoColor colorCoche = Rojo;

“TipoMes mes;

diaSemana = Lunes;
scolorCoche = Azul;
= Marzo;

Como se puede observar, en la misma definición de la variable colorCoche
se ha inicializado al valor Rojo, de forma semejante a cualquier otra variable.
Puesto que entre los valores enumerados existe un orden definido, podremos
emplear con ellos los operadores de comparación para programar sentencias
del tipo:

¡3f£ (mes >= Julio) f..

 

,
ile (diaSemana < Sabado) 4...)
(colorCoche = Rojo) (...y

Al igual que para el resto de los tipos ordinales, con los tipos enumerados se
puede utilizar la notación int(e) para obtener la posición de un valor en la
Esta de valores del tipo. Por ejemplo, se cumple que:

(Casado) == 0
(Kiwi) == 4
(Diciembre) == 11
La operación inversa, que permita conocer qué valor enumerado oenpa una.

determinada posición, se consigue mediante la notación inversa que hace uso
del identificador del tipo enumerado y que se invoca de la siguiente forma:

 

TipoEnumerado(N)

que devuelve el valor que ocupa la posición N en la colección de valores del
tipo TipoEnumerado. En los ejemplos anteriores se cumple que:

ipoEstadoCivil(0)
ipoFrutas(4) i

 

 

Hay tipos enumerados, tales como el TipoColor o el TipoFrutas, en que la
'smumoración sólo sirve para reflejar los valores posibles sin que el orden de la
definición tenga ninguna relevancia. Sin embargo, como sucede en los casos

 
 

     
    
   

224 Fundamentos de programación:

 

de TipoDia y TipoMes, el orden es muy importante y habitualmente se quiere
utilizar en los programas para manejar los valores anteriores o posteriores.
Cuando se crea un nuevo elemento en un programa es responsabilidad del
programador dotarle de todas las características y atributos que se consideren
necesarios. Así, para disponer de las operaciones anterior /posterior de
nuevo tipo que se defina es necesario programarlas y para ello siempre se
aprovecharán las operaciones ya disponibles. Por ejemplo, para pasar al día
siguiente de la semana y al mes anterior se podría programar de la siguiente.
forma:

diaSemana = Jueves;

diaSemana = TipoDia(int(diaSemana)+1);

mes = Marzo;

mes = TipoMes(int(mes)-1);

El resultado será:

diaSemana = Viernes

mes == Febrero

Sin embargo estas operaciones no están completas. Si se hace esto mismo
cuando el día de la semana es domingo:

diaSemana = Domingo;

diaSemana = TipoDia(int(diaSemana)+1);

se obtendrá un error, ya que no existe el día siguiente a Domingo. A continuaIn se resuelve este problema programando una función específica.

 

Un dato de tipo enumerado se puede pasar como argumento de procedimientos
o funciones y puede ser el resultado de una función. Por ejemplo, si conocemos
el día de la semana de Hoy y queremos calcular qué día de la semana será dentro
de N días, podemos emplear la siguiente función:
TipoDia SumarDias(TipoDia Hoy, int N) £
const int DiasSemana =
int aux;

 

aux = (int(Hoy) + N) % DiasSemana;
return TipoDia(aux);
,

Como se puede observar, primero se calcula el ordinal del nuevo día entre 0 y 6,
según el orden establecido en la definición de TipoDia y finalmente se devuelve
este ordinal convertido al tipo correspondiente mediante TipoDia(aux). De
la misma manera habría que realizar la función para restar días y para sumar
y restar meses.
Definición de tipos 225

 

9.3 El tipo predefinido bool

  

Al introducir las estructuras de selección o iteración se han descrito sentencias
de Ct que utilizan expresiones lógicas o de condición. En ese momento se
dijo, de manera informal, que el valor de ima condición podía ser cierto o
falso. De manera más precisa podemos indicar ahora que on C+ existe el tipo
predefinido bool que responde a la siguiente definición, análoga a la de un
tipo enumerado:

¡xypedef enun bool ( false, true );

 

 

Esta definición no es necesario escribirla ya que está implícita en el lenguaje
El nombre bool es el identificador del tipo (abreviatura de dooleano), y las
constantes simbólicas false y true corresponden a los valores de verdad falso
y cierto, respectivamente. Como tipo ordinal se cumple:

int(false) == 0
int(true) 1

  

A partir del tipo predefinido bool, ahora es posible declarar variables de este
tipo y utilizarlas, de forma similar al resto de variables, para guardar resultados
de expresiones condicionales. Por ejemplo

bool bisiesto;
bisiesto = (anno % 4) == 0; /* válido entre 1901 y 2099 */

Asimismo, es posible realizar operaciones entre ellas. En concreto, entre ope
zando booleanos (variables o no) es posible realizar las operaciones lógicas ya
indicadas en el tema 5 para formar expresiones lógicas y enyos operadores son
los siguientes:

 
   

Disyunción (A o B)
Negación (no A) !

 

Esto permite formar expresiones y sentencias tales como la siguiente:

Af (bisiesto 8% (mes > Febrero) (
totalDias = totalDias + 1;

y

Los resultados de las expresiones lógicas para los distintos operandos y opezadores son los siguientes:

 

 
 

226 Fundamentos de programación

 

a b a be b allb la
true true true true false
true false false true false
false true false true true
false false false false true

El tipo booleano, como cualquier otro tipo emumerado, se puede pasar como
argumento de un procedimiento o función y puede ser devuelto como resultado
de una función. De hecho es frecuente definir funciones cuyo resultado es un
valor booleano cuando se quiere realizar un test sobre los argumentos de la
función. Este tipo de funciones se denominan predicados. Un ejemplo de este
tipo de funciones son algunas de las introducidas en el tema 7 para el manejo
de caracteres y que se recuerdan a continuación:

 

Indica si c es una letra
Indica si c es un carácter ASCII

 

bool isalpha( char c
bool isascii( char c

 

bool isblank( char e ) | Indica si e 0s un carácter de espacio o
tabulación

]
2
2
bool isdigit( char c ) | Índica si e es un dígito decimal (0-9)
)
)
)

 

 

bool islower( char e ) | Índica si e es una letra minúscula
Indica si e es espacio en blanco o salto de
línea o página

Indica si e es una letra mayúscula

 

bool isspace( char e

 

 

 

 

bool isupper( char c

 

Conviene recordar que para poder usar estas funciones predicado es necesario
incluir la cabecera de librería <ctype.h> al comienzo del programa.

9.4 Tipos estructurados

Todos los tipos de datos presentados hasta este momento se denominan tipos
escalares, y son datos simples, cn el sentido de que no se pueden descomponer.
En general, no tiene sentido tratar de reconocer fragmentos de información
independientes dentro de un valor entero, o un carácter, o el valor simbólico
de un día de la semana o el número de un día del mes.

En muchas aplicaciones resulta conveniente, o incluso necesario, manejar globalmente elementos de información que agrupan colecciones de datos. Por
ejemplo, puede ser apropiado manejar como un dato único el valor de una
fecha que incluye la información del día, el mes y el año como elementos componentes separados. Con este objetivo, los lenguajes de programación dan la
posibilidad de definir tipos de datos estructurados.
 

Definición de tipos 227

 

Un tipo estructurado de datos, o estructura de datos, es un tipo cuyos valores
se construyen agrupando datos de otros tipos más sencillos. Los elementos de
información que integran un valor estructurado se denominan componentes.
Todos los tipos estructurados se definen, en último término, a partir de tipos
simples combinados.

En los próximos apartados se hace una primera introducción de los tipos estructurados formación y tupla.

9.5 Tipo formación y su necesidad

Las estructuras de datos de tipo Jormación son quizá las más básicas, o al
"menos las que se introdujeron primero en los lenguajes de programación imperativos. Puede afirmarse que no hay ningún programa real interesante que
20 use estructuras de esta clase,

En el tema 5 se realizó un programa para ordenar 3 datos. El interés de la
ordenación de cualquier tipo de dato (números, nombres, fechas, etc.) resulta
más evidente cunado la cantidad de datos a ordenar os de cientos o miles de
datos, el trabajo de ordenación resulta tedioso y es más adecuado realizarlo
utilizando un computador.

Si se quiere realizar un programa, de ordenación con las estructuras de datos
presentadas hasta este momento sería necesario declarar tantas variables del
mismo tipo como datos se tratan de ordenar. En el programa del tema 5
se necesitaron tres variables: valorUno, valorDos y valorTres. Además
el tratamiento de cada variable se debe realizar por separado: dentro del
texto del programa se tienen que hacer las correspondientes comparaciones e
intercambios entre cada una de las parejas de variables. Por ejemplo, en el
mencionado programa se tenía el siguiente fragmento:

 

/*-- Primer Paso: Ordenar 2 primeros datos --*/
if (valorUno > valorDos) f

auxiliar = valorUno;

valorUno = valorDos;

valorDos = auxiliar;
y
/*-- Segundo Paso: Situar el 3% dato --*/
if (valorTres < valorUno) (

auxiliar = valorTres;

valorTres = valorDos;

valorDos = valorUno;

valorUno = auxiliar;

 
 

 

228 Fundamentos de programación

 

J else if (valorTres < valorDos) í

   

auxiliar = valorDo:
valorDos = valorTres;
valorTres = auxiliar;
+

Evidentemente esta forma de realizar el programa es imposible de generalizar
para la ordenación de un número cualquiera de datos. Además, este mismo
problema se reproduce en enalquier programa en el que se trate de manejar una
cantidad razonable de datos, todos del mismo tipo. Si tenemos en cuenta que
uno de los primeros objetivos de los computadores fue precisamente manejar
grandes cantidades de información, se comprende fácilmente porqué ya en
los primeros lenguajes de programación se disponía de estructuras de datos
para resolver estos problemas. Estas estructuras se denominan genéricamente
formaciones (en inglés array), y permiten la generalización de la declaración,
referencia y manipulación de colecciones de datos todos del mismo tipo. En
el signiente apartado se estudian los vectores como la forma más elemental de
formación y sus característi

   

9.6 Tipo vector

Como se muestra en la figura 9.1, un vector está constituido por una serie de
valores, todos ellos del mismo tipo, a los que se les da un nombre común que
identifica a toda la estructura globalmente. Cada valor concreto dentro de la
estructura se distingue por su índice o número de orden que ocupa en la serie.
En la figura 9.1 se ha adoptado el convenio que se utiliza en Ct por el que el
índico del primer elemento siempre es el cero

 

Nombre común; Vector

Indice:

Elementos:

 

Figura 9.1 Estructura voctor

Como se puede observar, esta estructura es análoga al concepto matemático.
de vector, en el que el vector completo se identifica por un nombre único y
cada elemento partienlar mediante el correspondiente subíndice:

V= (Vo, Vi, Va, Va, «<> Vn=2) Vn-1)
 

Definición de tipos 229

 

En cuanto al aspecto de programación se puede establecer un paralelismo entre
la estructura de programación en la que se repite la misma acción un número
de veces determinado: sentencia for, y la estructura de datos vector en la que
también se repiten un número de veces determinado el mismo tipo de dato,
Como se verá posteriormente, la sentencia for es la que mejor se adecúa al
manejo de los vectores y en general de todo tipo de formaciones.

 

9.6.1 Declaración de vectores

En C+, una estructura de tipo vector se declara de la siguiente forma:
typedef TipoElemento Tipo Vector[ NumeroElementos];

donde Tipo Vector es el nombre del muevo tipo de vector que se declara y
NumeroElementos es un valor constante que indica el número de elementos que
constituyen el vector. Por tanto, la variabilidad del índice de un vector siempre
estará comprendida entre 0 y NumeroElementos -1. Finalmente TipoElemento
corresponde al tipo de dato de cada uno de los elementos del vector y puede ser
cualquier tipo de dato predefinido del lenguaje o definido por el programador.
Indudablemente, cualquiera de los nuevos tipos de datos estructurados que se
vayan presentado en este tema y los próximos, también podrán ser elementos
de un vector. Los siguientes ejemplos utilizan los tipos predefinidos y algunos
tipos definidos por enumeración:
«typedef enum TipoDia (

Lunes, Martes, Miercoles, Jueves,

Viernes, Sabado, Domingo
E
typedef enum TipoColor ([ Rojo, Amarillo, Azul );
typedef float TipoMedidas[3];
typedef TipoColor TipoPaleta[5];
typedef char TipoCadena[30];
typedef TipoDia TipoAgenda[7];
typedef bool TipoEstados[8];
typedef int TipoVector[10];

En muchos casos el tamaño del vector es un parámetro del programa que
podría tener que cambiarse al adaptarlo a nuevas necesidades. Si es así, resulta aconsejable que la declaración del número de elementos se realice como
una constante con nombre. Por ejemplo, estas constantes podrían haber sido
declaradas previamente de la signiente forma:

 
230 Fundamentos de programación

 

const int NumeroEstados
const int LongitudAgenda = 7
const int Numeroletras = 30;
const int NumeroElementos = 10;

  

typedef char TipoCadena[NumeroLetras];
typedef TipoDia TipoAgenda[LongitudAgenda];
typedef bool TipoEstados[NumeroEstados];
typedef int TipoVector[NumeroElementos];

De esta manera, el programa queda parametrizado por dichas constantes. En
las modificaciones posteriores, si se quiere adaptar el tamaño del vector sólo
es necesario modificar esta constante. Además, como se verá posteriormente,
es habitual utilizar el número de elementos del vector en las operaciones de
recorrido y búsqueda de los vectores, que se pueden entonces programar en
función de la misma constante.

Para poder utilizar los tipos declarados es necesario declarar a su vez, posteriormente, las correspondientes variables. Por ejemplo:

TipoAgenda agendaUno, agendaDos;

TipoCadena frase;

TipoEstados estadoMotor, estadoPanel;

TipoVector vectorUno, vectorDos;

Hay que recordar que en el lenguaje Gt es obligatorio que todas las variables
se declaren precedidas del identificador de un tipo predefinido del lenguaje o
bien definido previamente en el programa. Tanto en la sintaxis de C£ como en
el Manual de Estilo está expresamente prohibido la declaración de variables
de tipo anónimo. Se dice que una variable es de tipo anónimo cuando su estructura se detalla en la misma declaración de la variable, como si se estuviera
declarando un tipo de datos anónimo para esta única variable.

 

NOTA: En C/C++ sí os posible declarar variables de tipo anónimo aunque también
es bastante frecuente que se aconseje o incluso so obligue en el Manual de Estilo que
no se nsen tipos anónimos para facilitar la comprensión del programa.

La sintaxis exacta de la declaración de los tipos formación es la siguiente:

Tipo_formación 3 3= typedef Identificador_de_tipo_clemento
Identificador_de_ tipo_ formación Dimensiones ;

 

 

Dimensiones 35 Tamaño É Tamaño )

 

Tamaño 33= [ Número_de_elementos

En esta sintaxis está incluida la posibilidad de declarar formaciones multidimensionales o matrices que se explicarán en el tema 11.
RON Y Ea”

 

  
   
 
    
  
  
  
    
  
    
 
  
   
  
   
    
    
   
  
   
   
 
   

2 Inicialización de un vector

se explicó en el tema 3, en Ct cuando se declara una única variable de
uier tipo siempre es posible darle un valor inicial. En el caso de un vector
¡alización afecta a todos sus elementos y por tanto la notación es algo
al y en ella se indica el valor inicial de todos los elementos agrupándolos
llaves £...) y separándolos por comas (+). A continuación se declaran
ente alguna de las variables anteriores incluyendo su i:

    

 

enda agendaUno = (
Lunes, Viernes, Domingo, Martes,
Martes, Martes, Sabado

Estados estadoMotor = f

true, false, true, true, false,

false, false, true

Vector vectorUno = [ 12, 7, 34, -5, 0, 0, 4, 23, 9, 11 );
Vector miVector = f 1, 1, 1, 1, 1,0, 0, 0,0, 0 y;

9.6.3. Operaciones con elementos de vectores

La mayoría de las operaciones interesantes con vectores hay que realizarlas
ssperando con sus elementos uno por uno. La referencia a un elemento concreto
de un vector se hace mediante el nombre del vector seguido, entre corchetes,
del índice del elemento referenciado. Por ejemplo:

'wectorUno[0]
frase[13]
estadoMotor[5]
'miVector[3]

Un elemento de un vector puede formar parte de cualquier expresión con
constantes, variables u otros elementos. Paras estas expresiones se tendrá en
cuenta el tipo de los elementos del vector y las reglas de compatibilidad. Por
ejemplo:

miVector[3] = 3*vectorUno[0] + 2*vectorDos[0];

frase[13] = 'A
estadoMotor[5] = true;

 

Los elementos de los vectores miVector, vectorUno y vectorDos son todos
del mismo tipo int y por tanto, la primera de las expresiones anteriores es
totalmente correcta.

 
232 Fundamentos de programación

 

Como índice para designar un elemento de un vector se puede utilizar una
variable o expresión, siempre que sean de tipo entero. Por ejemplo:

const int Alarma = 0;

int, j;

int origen, indice;

miVector[j] = 3*vectorUno[i] + 2*vectorDos[i+3];
frase[origensindice] =* ';
estadoPanel[Alarma] = false;

La posibilidad de utilizar variables o expresiones para el cálculo del índice de:
un vector es fundamental en cualquier programa que utilice vectores, como
se verá a lo largo de este y los próximos temas. Sin embargo, siempre se
debe comprobar exhaustivamente que no existe ninguna posibilidad de que
por error el índice calculado por la expresión o guardado en la variable se
salga fuera del rango entre 0 y NumeroElementos-1 para cada vector. No.
obstante, si esto ocurre el resultado será totalmente impredecible dado que
estaremos haciendo referencia a un clemento del vector que no tiene existencia
real. En esta situación, y dependiendo del compilador, se podrá producir un
error de ejecución y/o la parada del programa.

Es especialmente importante insistir en que al usar lenguajes como C, C++ 0
Ct la comprobación de que el índice para acceder a un elemento de vector está
dentro del rango permitido es responsabilidad del programador. Muchos
ataques informáticos aprovechan la falta de previsión de esta comprobación
para alterar el funcionamiento normal de un programa suministrándole datos
de mayor tamaño que el previsto y provocar lo que se denomina en inglés
buffer overrun.

 

 

 

9.6.4 Operaciones globales con vectores
En lenguajes tales como Pascal, Modula-2, Ada, etc. existe la posibilidad de
realizar una asignación global de un vector a otro, siempre que estos sean compatibles entre sí. En cualquiera de estos lenguajes, para realizar una asignación
global basta escribir:

 
 

  

vectorDos := vectorUno; [lenguaje Pascal)

 

El símbolo :=.es el operador de asignación, similar al operador = de Ct. Esta
operación efectúa ma copia de todos los elementos del vector vectorUno en
el vector vectorDos .

 
 
  
   
    
   
  
   
  
   
  
 
 
 
 
  
  
 
    
 
   
  

efinición de tipos 233

 

in embargo, en C< no existe esta posibilidad y la asignación se tiene que
“amar explícitamente mediante un bucle que realice la copia elemento a
emento, tal y como se recoge en el siguiente fragmento de programa:

(int i= i < NumeroElementos; 1++) (
wectorDos[i] = vectorUno[i];

 

10 se puede observar en el fragmento de programa anterior, se utiliza una
entencia for con condición de terminación i < NumeroElementos que no
gue la sintaxis de ninguna de las dos variantes presentadas en el tema 5.
on formaciones resulta bastante habitual realizar, como en este caso, un
ido por todos sus elementos. Tal y como se ha dicho anteriormente,
a una formación de N elementos, en Ct los índices siempre van desde O
sta N-1 y la forma más natural de expresar la condición de terminación del
ecorrido será indice < N. Para facilitar el trabajo con las formaciones, en C+
dispone de esta tercera variante de for. Así, la sintaxis completa de esta
¡sentencia es la siguiente;

 

Sentencia_FOR 33% For_creciente | For_ereciente_menor |
For_decreciente

For_creciente ¿12 for ( int Variable_índice = Valor inicial ;
Variable_índice <= Valor final ; Variable_índice ++ )
£ Secuencia_de_sentencias +

For_creciente_menor for ( int Variable_índice = Valor inicial ;
Variable_índice < Valor_final ; Variable_índice ++ )
1 Secuencia de sentencias Y

For_decreciente or ( int Variable_éíndice = Valor.
Variable_índice >= Valor_final ; Variable_índice
4 Secuencia_de sentencias )

 

 

 

    

nicial ;
)

 

9.6.5 Paso de argumentos de tipo vector

tra manera habitual de operar globalmente con los vectores es utilizarlos
como argumentos de procedimientos o funciones. Por razones históricas y
gún se explicará en próximos temas, el manejo de toda clase de formaciones
C y C++ tiene ciertas peculiaridades. Debido a que muestro lenguaje Ct es
subconjunto de C++, también tiene algunas de esas mismas peculiaridades.
sí, en Ct el modo por defecto de paso de argumentos de tipo formación, y
s concretamente de tipo vector, es el paso por referencia, Por ejemplo, si
“tenemos las siguientes declaraciones:
 

   
  
 
 
 
 
  
 
  
  
  
 
  
    
     
   

234 Fundamentos de programación

 

void LeerVector( TipoVector v ) (...)
void ConocerEstado( TipoEstados e ) (...)

Cuando se invocan estos procedimientos, además de emplear en la llamada
argumentos reales que deben ser compatibles con el correspondiente argumento
formal, hay que tener en cuenta que el argumento real puede ser modificado.
Por ejemplo, con la siguiente invocación de los procedimientos anteriores:

LeerVector( vectorUno );
ConocerEstado( estadoMotor );

las variables vectorUno y estadoMotor podrán quedar modificadas después de
ejecutar el correspondiente procedimiento. Es importante recordar que, según
se explicó en el tema 7, para el resto de tipos de datos la opción por defecto
es que el paso de argumentos es siempre por valor, los parámetros reales de
la llamada pueden ser expresiones y los parámetros reales nunca se modifican
Por otro lado, también hay que recordar que en Ct, exceptuando el caso de las:
formaciones, cuando un argumento formal se quiere pasar por referencia debe
ir precedido del símbolo € en la cabecera de declaración del subprograma.

 

Por el contrario, en CE, cuando se utilizan argumentos de tipo formación y
no se quiere que se modifiquen los parámetros reales en la llamada al procedimiento, los argumentos formales debon ir precedidos de la palabra clave
const. Por ejemplo:

void EscribirVector( const TipoVector v ) (
void PintarEstado( const TipoEstados e ) (.

,
y

 

Con estas declaraciones, si se invocan los procedimientos anteriores con
siguientes sentencias:

EscribirVector( vectorDos );
PintarEstado( estadoPanel );

las variables vectorDos y estadoPanel permanecerán inalteradas después
ejecutar el correspondiente procedimiento. Por tanto, cuando declaramos
argumento de tipo formación o vector precedido de la palabra clave const
equivalente al paso de dicho argumento por valor.

Para ser exactos, esta forma de paso de argumentos es más restrictiva que
paso por valor. En realidad el vector se pasa por referencia, pero se pro
usar asignaciones a sus clementos en el cuerpo del subprograma. En el
por valor de otros tipos de datos el argumento formal se ve como varii
local dentro del subprograma, y de hecho es una copia que puede modific
 
  
  
   
   
     
    
 
  
  
   
   
    
  
  
    
  
 
 
  
 
  

Definición de tipos 235

 

sin alterar el argumento real usado en la llamada. En cambio los argumentos de tipo vector declarados como const se ven como constantes dentro del
subprograma, y sus elementos no pueden ser modificados en modo alguno.

En C y C++ la compatibilidad entre los argumentos formales y reales de tipo
sector so limita a que tengan el mismo tipo de los elementos. Así, en los ejemplos
“anteriores los procedimientos Leervector y EscribirVector podrían ser llamados
¡gon vectores de elementos enteros, sea cual sea la forma en que se han declarado y su
“tamaño. Esto introduce una clara inseguridad en el código. Por eso en Ct se exige que
el argumento real sea exactamente del mismo tipo vector que el argumento formal,
“amnque esta restricción se suaviza, en parte, con el empleo de vectores abiertos, tal
"somo se verá en el tema 11. Las cadenas de caracteres que se describen en el apartado
siguiente se tratan de hecho como vectores abiertos, y eso permite operar con cadenas
diferentes longitudes.

.7 Vector de caracteres: Cadena (string)

ido a su uso tan frecuente, en el tema 2 ya fueron presentadas las constantes
tipo cadena (en inglós, string). Sin embargo, hasta ahora no hemos podido
ar variables de este tipo. Esto se debe a que en realidad las cadenas son
es de caracteres y los vectores no han sido estudiados hasta este tema.
embargo, en todos los lenguajes es habitual que las cadenas de caracteres
ciertas peculiaridades que no tienen el resto de los vectores y por esta
1 son objeto de este apartado específico.

Ci cualquier tipo vector cuya declaración sea de la forma:
char Nombre[ N ]

considera una cadena o string, con independencia de su longitud particular,

es, del valor de N. Por tanto, el tipo definido en el apartado anterior

'adena es una cadena. La característica peculiar de las cadenas es la

jente:

Una cadena de caracteres (en inglés string) es un vector en el que se pueden
almacenar textos de diferentes longitudes (si caben). Para distinguir
la longitud útil en cada momento se reserva siempre espacio para un
carácter más, y se hace que toda cadena termine con un carácter mulo
*N0' situado al final.

tanto, para declarar una cadena de un máximo de veinte caracteres se

hacer de la siguiente forma:

char Cadena20[21];

declaración de variables de este tipo se hace de la forma habitual:

 
  
   
     
   
 
 
   
  
  
 
   
  
    
 

236 Fundamentos de progra

 

TipoCadena idioma = "inglés
Cadena20 nombre, apellido;
TipoCadena direccion = "Gran Vía 23";

 

En este caso la inicialización se hace mediante una cadena constante semej:
a las utilizadas en el tema 2 y no elemento a elemento separados por co
como para el resto de vectores. Como se puede observar, en la inicialización
es necesario asignar una cadena con los diecinueve, veinte o treinta caracte
Los caracteres asignados ocupan posiciones seguidas desde el principio, y
continuación del último se sitúa el carácter nulo 'YO* de final de cadena.
carácter es especial y no se puede escribir. Lo que nunca se puede hacer
asignar Mm steres de los declarados pues se rebasarían los limites previ:
y se provocaría un error,

    

 

Como la utilización de cadenas de caracteres es bastante habitual, el le
C (y C2) dispone de la librería string (cabecera <string.h>) que facilita
manejo de las cadenas. Esta librería incluye una gran variedad de funciones
de ellas las más comunes son las siguientes:

 

strepy( el, e2 ) | Copia c2 en el

streat( cl, c2 ) | Concatena c2 a continuación de cl
strlen( cl ) Devuelve la longitud de c1
Devuclve un resultado cero si c1 y e2 son iguales;
menor que cero si el precede a e2 en orden
alfabético, y mayor que cero si e2 precede a cl en
orden alfabético

 

 

 

stremp( cl, e2 )

 

 

 

Al igual que con cualquier otro tipo de vector, no es posible realizar asi
ciones globales entre cadenas. Por ejemplo:

apellido = "González";  /* ERROR en Ct */
nombre = apellido; /* ERROR en Ct */

Para realizar esta operación usando el procedimiento general se program:
un for que copie elemento a elemento tal como se ha explicado en el apart:
anterior. Sin embargo, esta operación se puede realizar utilizando la funci
de librería strcpy tal y como se muestra a continuación:

strcpy( apellido, "González" );
strcpy( nombre, apellido );

Al igual que las constantes, también cualquier variable de tipo cadena se pu
utilizar como argumento de procedimientos o funciones. Más concrotament
Detinición de tipos 237

 

en el procedimiento de escritura printf se pueden utilizar constantes o varíables de cadena empleando el formato de escritura %s para string o cadena.
Por ejemplo:

iprintf("Datos: %s — %s : %s XsAn", idioma, direccion, "José", apellido);

produco un resultado similar al siguiente:

 

Íbatos: inglés - Gran Vía 23 : José González |

El procedimiento de escritura sólo escribe el contenido de la variable hasta el
primer carácter nulo "NO".

También os posible utilizar variables de tipo cadena con el procedimiento de
lectura scanf utilizando también el formato de lectura Xs para stringo cadena.
Por ejemplo, sea el signiente fragmento de código:

 

print£("Nombre y Apellido? ");
scanf("%s%s", ¿nombre, Sapellido);

Un ejemplo de la ejecución (en pantalla) puede ser:

 

ÍNombre y Apellido? José González

Con ello se guardan en las variables nombre y apellido las cadenas "José"
y "González" introducidas por teclado. Hay que tener en cuenta que con
el formato %s para lectura, el carácter blanco sirve para separar las cadenas
introducidas por teclado. La comprobación del valor que tienen las variables
nombre y apellido cs el resultado del procedimiento de escritura anterior.

Para finalizar este apartado, a continuación se nuestra un programa. muy
sencillo que ilustra la utilización de las funciones anteriores para manejo de
cadenas

 

| /** Programa: Cadenas */
1/* Ejemplo de manejo de cadenas de caracteres */

¡include <stdio.h>
'Sinclude <string.h>

¡typedef char TipoCadena[20];

lint main O £

|| TipoCadena nombre, apellido;
typedef char TipoTexto[100];

| TipoTexto texto;
int resul;

 
238 Fundamentos de program:

 

print£( "Nombre y Apellido? " );
scan£( "%sks", nombre, apellido );
print£( "Datos: %s - %s An", nombre, apellido );
print£( "Longitudes: %4d%adin"”, strlen(nombre), strlen(apellido) );
strepy( texto, nombre );
print£( "Texto copiado: Xsin", texto );
strcat( texto, apellido );
print£( "Texto concatenado: Xsin", texto );
resul = stremp( apellido, nombre );
if (resul == 0) (
printf( "Nombre y Apellido igualesin” );
) else if (resul > 0) [
printf( "%s es anterior a %sin", nombre, apellido );
y

  

 

  
 

,

 

  

Como se puede observar en el listado ha sido necesario incluir la cabecera de
librería <string.h> al comienzo del programa. El resultado de una posible
ejecución se muestra a continuación:

 

 

Nombre y Apellido? Sara Saramago
Datos: Sara - Saramago
Longitudes: 4 8

Texto copiado: Sara

Texto concatenado: SaraSaramago
Sara es anterior a Saramago

9.8 Tipo tupla y su necesidad

Otra forma de construir un dato estructurado consiste en agrupar elementos
de información usando el esquema de tupla o agregado. En este esquema el
dato estructurado está formado por una colección de componentes, cada uno
de los cuales puede ser de un tipo diferente.

Por ejemplo, una fecha se describe habitualmente como un dato compuesto
de los elementos día, mes y año. Un punto en el plano cartesiano se describe
mediante dos números, que son sus coordenadas. El nombre completo de una
persona es la colección formada por el nombre de pila y sus dos apellidos.
Como ejemplos concretos podemos poner:

 
 
  
   
    
   
   
  
 
   
   
    
 
   
  

Definición de tipos 239

 

Dato Valor

fecha < 12, Octubre, 1992 >

punto <4,-2>

nombre_completo  < Fernando, Jiménez, Rodríguez >
¡En estos ejemplo se ha supuesto un orden implícito entre las componentes. En
la fecha se ha escrito primero el día, luego el mes, y luego el año. Es imporidentificar claramente a qué componente corresponde cada elemento de
información. El punto <4, -2> es distinto del punto <-2, 4>.

En realidad el orden es hasta cierto punto arbitrario. Normalmente cada
¡ponente se identifica mediante un nombre simbólico. En los ejemplos
“anteriores podríamos nombrar las componentes de la forma:

Dato Valor
fecha < día: 12, mes: Octubre, año: 1992 >
punto <x: 4 y: -2>
< nombre: Fernando, apellido1: Jiménez,
apellido2: Rodríguez >
“Identificando cada componente por su nombre, se pueden escribir en el orden

convenga:

Dato Valor
fecha < mes: Octubre, día: 12, año: 1992 >
punto <x 4 y -2>
< apellidol: Jiménez, apellido2: Rodríguez,
nombre: Fernando >

 

 

nombre_completo

 

nombre_ completo
s las consideraciones anteriores, podríamos dar una definición de este es“quema de datos:

Tupla: Colección de elementos componentes, de diferentes tipos, cada uno de
los cuales se identifica por un nombre.

 
   
  
    
 
   
   

Un aspecto importante del empleo de datos estructurados corresponde al punde vista de abstracción. Una tupla, como cualquier otro dato compuesto,
verse de forma abstracta como un todo, prescindiendo del detalle de sus
ponentes. La posibilidad de hacer referencia a toda la colección de elemenmediante un nombre único correspondiente al dato compuesto simplifica
muchos casos la escritura del programa que lo maneja.

 

 

.9 Tipo registro (struct)

 

esquemas de tupla pueden usarse en programas en Ci definiéndolos como
icturas del tipo registro o struct. Un registro o struct es una estructura

 
 

240 Fundamentos de programación

 

de datos formada por una colección de elementos de información llamados
campos.

9.9.1 Definición de registros

La declaración de un tipo registro en Ci se hace utilizando la palabra clave
struct de la siguiente la forma:
typedef struct Tipo-registro 1
Tipo-campo-1 nombre-campoTipo-campo-2 nombre-campo-'

 

 

Tipo-campo-N nombre-campo-N;
de

 

Cada una de las parejas Tipo-campo y nombre-campo, separadas por punto y
coma (;), define un campo o elemento componente y su correspondiente tipo.
Además hay que tener en cuenta que la estructura acaba siempre con punto y
coma (;) Como ejemplos de definiciones tenemos:

typedef enum TipoMes (
Enero, Febrero, Marzo, Abril, Mayo,
Junio, Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre

»

typedef struct TipoFecha [
int dia;
TipoMes mes;
int anno;

5

typedef struct TipoPunto f

float x;

float y;

»

La sintaxis de la declaración de los tipos registro es la siguiente:

 

Tipo_registro
£ Lista.

= typedef struct Identificador_de_tipo_nuevo
campos +;

 
 

Campo ; É Campo ; )
Tdentificador_de tipo Identificador_de_campo

Lista_de_campos

 

 

 

Campo +3
 
  
  
  
   
 

Definición de tipos 241

 

9.9.2 Variables de tipo registro y su inicialización

Como siempre, para declarar variables de tipo registro es necesario haber
sealizado previamente la definición del tipo del registro. Hay que recordar que
sl Manual de Estilo de Ct no permite declarar variables de tipo anónimo. A

  
  
  
   
   
  
 
 
  
  
 
   
 
 
  
  
  
 
   
   
    

Fecha ayer, hoy;
oPunto puntol, punto2;

Pambión estas variables se pueden inicializar en la declaración de una manera
emejante a las formaciones agrupando los valores iniciales entre llaves (... .y
"y separándolos por una coma (,), pero teniendo en cuenta el tipo de dato de
a campo. A continuación se declaran nuevamente alguna de las variables
eriores incluyendo su inicialización.

spoFecha hoy = f 12, Marzo, 2009 );

EipoPunto puntol = ( 12.5, -76.9 );

9.3 Uso de registros

 

«manejar datos estructurados de tipo registro se dispone de dos posibilidades

ar con el dato completo, o bien operar con cada campo por separado. Las
lidades de operar con el dato completo son bastante limitadas. La única
ión admisible es la de asignación. El valor de un dato de tipo registro
e asignarse directamente a una variable de su mismo tipo. Por ejemplo,
las definiciones anteriores es posible escribir:

102 = puntol;

estas asignaciones debe cumplirse la compatibilidad de tipos. Dos estructuson compatibles en asignación si son del mismo tipo, o de tipos sinónimos.
es suficiente la llamada compatibilidad estructural; es decir, dos estructucon los mismos campos no son compatibles si sus definiciones se hacen por

abién es posible pasar como argumento un dato de tipo registro a una
ón o procedimiento. Por ejemplo, podemos especificar los subprogramas
tes:

Leer el día, mes y año */
LeerFecha( TipoFecha € fecha ) £..

 

Distancia entre pl y p2 */
Distancia( TipoPunto pl, TipoPunto p2 ) (...)

 
 

   
 
 
   
     
  

242 Fundamentos de programación

 

Las operaciones de tratamiento de estructuras registro consisten normalmente
en operar con sus campos por separado. La forma de hacer referencia a um
campo es mediante la notación:

registro. campo

Cada campo se puede usar como cualquier otro dato del correspondiente tipos
es decir, se pueden usar los valores de los campos en expresiones aritméticas, se
puede asignar valor a cada uno de los campos de una variable de tipo registra,
y se pueden pasar los campos como argumentos en llamadas a subprogramas.
Como ejemplo daremos una posible definición de los subprogramas anteriores:

/* Leer el día, mes y año */
void LeerFecha( TipoFecha € fecha ) £
int aux;

scanf( "%d", faux );

if (( aux>0) 48 ( aux <- 31 )) 4
fecha.dia = aux;

) else (
fecha.dia

,

LeerMes( fecha.mes );

scanf( "%d”, faux );

fecha.anno = aux;

 

)

/* Distancia entre pl y p2 */
float Distancia( TipoPunto pl, TipoPunto p2 ) í
float dx, dy;

dx = p2.x — pl.x;
dy = p2.y - pl.y;
return sqrt( dx*dx + dy*dy );

 

,

También es posible devolver como resultado un valor estructurado de
registro. Por ejemplo, es mucho más claro y natural esc

 
 
  
   
 
    
 
  
 
 
  
 
 
  
  
   
   
  
   
 
    

ición de tipos 243

 

ito PuntoMedio( TipoPunto p1, TipoPunto p2 ) £
TipoPunto m;

mx = (pl.x + p2.x) / 2.
m.y = (pl.y + p2.y) / 2.
return m;

 

Punto a, b, centro;

= PuntoMedio( a, b );

.10 Ejemplos de programas

finalizar este tema se recogen en este apartado varios ejemplos que utili“zan los nuevos tipos introducidos.

9.10.1 Ejemplo: Cálculo del día de la semana de una fecha

Con este programa se calcula qué día de la semana corresponde a una feha cualquiera que se introduce como dato. Existen algoritmos que mediante
an cálculo matemático inmediato, permiten obtener el día de la semana para
cualquier fecha del calendario (ver algoritmo de congruencia de Zeller). Sin
“embargo, este ejemplo es un ejercicio de programación y se utilizarán directamente las reglas con las que se conforma cada calendario. Para el cálculo se
ne conocido que el día 31 de Diciembre de 1988 fue Sábado. El programa
sirve para fechas desde el año 1989 hasta el año 2088.

Las declaraciones de los días de la semana y los meses son las empleadas en
Jos apartados anteriores. Asimismo, se utiliza la función SumarDias descrita
en el apartado 9.2.2 para calcular el día de la semana que será dentro de N
días conociendo el día de hoy.

La función DiadelaSemana realiza el cálculo del día de la semana teniendo en
.gnenta los siguientes aspectos:

 

+ El desfase en días de la semana que se introduce para cada mes, respecto
al mismo día del mes de Enero. Por ejemplo, el mes de Febrero son 3,
el mes de Marzo 3, .., el mes de Julio 6, etc.

+ Los años bisiestos son los múltiplos de 4.

Si el año es inferior a 89 se considera que es posterior al 2000.

Cada año bisiesto pasado incrementa en 1 día el desfase.

 
244 Fundamentos de programación

 

El procedimiento EscribirDia escribe el tipo de día resultante. El listado del
programa completo es el siguiente:

 

 

paa

* Programa: Calendario
*

ANAIS

 

* Descripción:
+ — Programa para el cálculo del día de la semana
+ — que corresponde a una fecha comprendida entre:
* 1/1/1989 y 31/12/2088

ARA OEDRAAA

finclude <stdio.h>

typedef enum TipoDia (
Lunes, Martes, Miercoles, Jueves,
Viernes, Sabado, Domingo

E

typedef enum TipoMes 4
Enero, Febrero, Marzo, Abril, Mayo,
Junio, Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre

h

typedef struct TipoFecha (
int dia;
TipoMes mes;
int anno;

 

 

 

     

   

 

fm aaron oo ===

Función para sumar días de la semana cíclicamente

a

TipoDia SumarDias( TipoDia dia, int n ) (

const int DiasSemana = 7;

int aux;

aux = (int(dia) + n) % DiasSemana;

return TipoDia(aux);
J

Función para calcular el día de la semana

que corresponde a una fecha

AS = A

 

TipoDia DiaDeLaSemana( TipoFecha fecha ) (
const int OrigenA = 89;
TipoDia TreintaUnoDiciembreg8 = Sabado;
  

ición de tipos 245

 

bool bisiesto;

int IncreBisis, IncreAnnos, IncreDias;
TipoMes M = fecha.mes;

int A = fecha.anno;

Af (M == Enero) (
IncreDias = 0;
J else if (M =

IncreDias = 3
J else if (M
IncreDias = 3;
J else if (M
IncreDias
J else if (M
IncreDias = 1
J else if (M
IncreDias = 4;
) else if (M
IncreDias
) else if (M == Agosto) (
IncreDias = 2;
J else if (M
IncreDias = 5;
) else if (M Octubre) (
IncreDias =
) else if (M == Noviembre) (
IncreDias =

 

Febrero) £

 

 

Marzo) 1

Abril) 4

 

   

Mayo) £

 

 

Junio) (

Julio) 4

 

 

 

Septiembre) £

 

 

) else (
IncreDias = 5;
J
bisiesto = (A % 4) == 0;
Af (A < Origena) £
A =A + 100; /* Año posterior al 2000 */
J
IncreAmnos = A - OrigenA; /* Años pasados desde el 89 */

IncreBisis = IncreAnnos/4; /* Bisiestos pasados */
IncreDias = IncreDias + fecha.dia + IncreAmnos + IncreBisis;
if (bisiesto 88 (M > Febrero) £

IncreDiast+;
J
return SumarDias( TreintaUnoDiciembre88, IncreDias );
246 Fundamentos de programación

 

 

Procedimiento para escribir el día de la semana

 

*
void EscribirDia( TipoDia S )

if (S == Lunes) (
print£( "Lunes" );

) else if (S == Martes) (
printf( "Martes" );

) else if (S == Miercoles) (
printf( "Miércoles" );

) else if (S == Jueves) (
print£( "Jueves” );

) else if (S == Viernes) £
printf( "Viernes" );

) else if (S == Sabado) £

 

 

 

print£( "Sábado" );
) else £
print£( "Domingo" );

 

Procedimiento para leer una fecha (mes en número)

 

me

 

void LeerFechal TipoFecha € fecha ) 4
int mes;

scan£( "%d/%d/%d", dfecha.dia, gmes, áfecha.anno );
fecha.mes = TipoMes( mes-1 );
if (fecha.anno >= 100) £
fecha.anno = fecha.anno % 100;
y
y

po

 

Procedimiento para escribir una fecha

 

void EscribirFecha( TipoFecha fecha ) (
printf( "x02d/x02d/x02d", fecha.dia, int(fecha.mes+1), fecha.anno );
y

 
247

 

   
 

Programa principal

  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
   
  

main() (£

TipoFecha fecha; /* fecha a manejar */
char tecla; /% tecla pulsada */
TipoDia Hoy;

TipoMes Pasado;

Hoy = Miercoles;
Pasado = Noviembre;
tecla =
while (tecla l= 'N') (

printf( "¿Dia Mes Año(DD/MM/AA)? " );

LeerFecha( fecha );

print£( "Fecha: " );

EscribirFecha( fecha );

 

print£( " Día de la semana: " );
EscribirDia( DiaDeLaSemana( fecha ));
tecla =' ';

print£( "Wn¿Otra Fecha(S/N)? " );
while ((tecla != 'S') 6% (tecla l= 'N')) £
scanf( "%c", ttecla );
y
J

 

 

resultado de la ejecución del programa es el siguiente:

 

Mes Año(DD/MM/AA)? 1/4/1993
: 01/04/93 Día de la semana: Jueves

 
   
   
   
   
  

a Fecha(S/N)? S
ia Mes Año(DD/MM/AA)? 25/7/97
1a: 25/07/97 Día de la semana: Viernes

a Fecha(S/N)? S
la Mes Año(DD/MM/AA)? 29/2/2000
ha: 29/02/00 Día de la semana: Martes

ra Fecha(S/N)? S
ia Mes Año(DD/MM/AA)? 1/3/0
ha: 01/03/00 Día de la semana: Miércoles
248 Fundamentos de program:

 

¿Otra Fecha(S/N)? S
¿Dia Mes Año(DD/MM/AA)? 13/3/2009
Fecha: 13/03/09 Día de la semana: Viernes

¿Otra Fecha(S/N)? N

9.10.2 Frases palíndromas

    
 
   
   
  

Este programa ilustra el uso de vectores de caracteres. Se trata de compa
bar si una frase es un palíndromo, esto es, si las letras de las que consta
leen igual hacia adelante que hacia atrás. Para ello se define un procedimie
LeerTexto, capaz de leer un vector de hasta 100 caracteres. Este procedimi
to sólo guarda las letras válidas de la “a? a la 'z' incluyendo la “1? (mayúsc
o minúsculas) y finaliza cuando se introduce un punto “o se llena el ve
pasado como argumento. Este procedimiento utiliza scanf leyendo carácter
carácter dando el tratamiento específico que se desea, en el que sólo se guar
los caracteres mencionados.

 

 

La función predicado Simetrico es la encargada de comprobar que el contené
do del vector, pasado como argumento por valor, es simétrico. Primeramente.
se busca el punto de final del texto a analizar o el final del vector. La posi
final se decrementa en uno después do la búsqueda para apuntar al primer
carácter válido. Después, se comprueba si coinciden los caracteres de un ex
tremo con los del otro. Esta comprobación acaba o bien cuando se ernzan.
los índices y todos los caracteres han sido iguales o bien cuando no coinciden
algunos de ellos.

 

  

El listado completo del programa es el siguiente:

 

 

AAA NOR

* Programa: Palindromo

* Descripción:

* Este programa comprueba si una frase es

* un palíndromo
Aa /
+include <stdio.h>

tinclude <ctype.h>

  
 

const char Fin /* carácter final de la frase */
const int Maximo = 100; /* máxima longitud de la frase */
typedef char TipoCadena[Maximo] ;

 
 
  
 
 
 
 
     
   
 
 
 
 
 
 
 
 
 
   
  
  
 
  

Definición de tipos 249

 

o.
Procedimiento para leer una frase acabada
en punto (.) y dejarla en el argumento.
Sólo se guardan en el vector argumento las
letras a..z mayúsculas o minúsculas
incluyendo la ñ y Ñ y el punto final.

 

  

 

'woid LeerTexto( TipoCadena texto ) í
int longitud = 0;
char caracter =' ';

/%-- Leer y guardar sólo las letras de la frase --*/

printf( "¿Frase acabada en punto(.)2Wn" );

while ((caracter l= Fin) 48 (longitud < Maximo)) £
scanf("%c",kcaracter);

 
 
   

="a') 88 (caracter<="z")) 11

2D 11

(caracter= 1
(caracter=="N")) (

texto[longitud] = toupper(caracter);

longitud++;

 
   

Función que comprueba si coinciden las letras en
posiciones simétricas: La frase es un palínáromo
1 Simetrico( const TipoCadena Texto ) [
ánti, j;

/*-- 19: Buscar el punto final --%/

j=0;

while ((Texto[j] != Fin) 8% (j<Maximo)) £

je

do

/*-—- 2%: Comprobar igualdad entre simétricos --*/
i=0;
while ((i < j) 88 (Texto[i] == Texto[j1)) 1

ES

 
250 Fundamentos de programaci

/*— 3%: Es palíndromo si coincide todo --*/
return 1 >= j;

3

inma
Programa principal
a
int main() £
TipoCadena frase;
LeerTexto( frase );
if (Simetrico( frase )) £
print£(" Es PalindromoW");
J else (
print£(" No es PalindromoWn");
J
+

 

El resultado de la ejecución del programa es el signiente:

 

¿Frase acabada en punto(.)?
Dabale arroz a la zorra el abad.
Es Palíndromo

9.10.3 Ejemplo: Cálculos con fracciones

Como ejemplo de empleo de registros, se reescribe completo el programa del
tema 8 para realizar cálculos con fracciones. La nueva versión utiliza siempre
funciones para devolver un resultado de tipo registro. Esta solución es más
natural y nos introduce el concepto de nuevo de tipo de dato (TipoFraccion) y
sus operaciones. El listado completo del programa se muestra a continuación:

 

PARA RRA RARA RRA RARA
* Programa: Fracciones?

»

* Descripción:

* Este programa es una calculadora que suna,

* resta, multiplica y divide fracciones.

Solución utilizando registros y funciones.
ARRRARARARA ARAN AA ARRARAARA NOAA RRA RADAR AA

*include <stdio.h>

typedef struct TipoFraccion (
int numerador;
int denominador;

$

 
 
  
 
    
   
   
 
 
 
 
 
 
    
  

Definición de tipos 251

 

 

pa
Procedimiento para simplificar una fracción.
Devuelve la fracción f reducida
ReducirFraccion( TipoFraccion 4 £ ) 4
int divisor = 2;

 

.

while ((divisor <= f.numerador) 48
(divisor <= f.denominador)) f
while ((f.numerador % divisor == 0) tk
(£ denominador % divisor 01
f.numerador = f.numerador / divisor;
f.denominador = f.denominador / divisor;
y
divisor++;

y

 
  
  
  
 
   
  
    
   

Función para sumar fracciones.
Devuelve reducida la suma de f1 y f2

as = /
“accion SumarFracciones( TipoFraccion f1, TipoFraccion £2 ) 1
TipoFraccion suma;

 

suma.numerador = f1.numerador*f2.denominador +
£2.numerador*£1. denominador;

suma.denominador = f1.denominador*f2.denominador;

ReducirFraccion( suma );

return suma;

Función para restar fracciones.
Devuelve reducida la resta de f1 y £2
al

accion RestarFraccionesí TipoFraccion f1, TipoFraccion f2 ) 4

 

 

- £Z.numerador = - f2.numerador;
return SumarFracciones( f1, f2 );
252 Fundamentos de prograr

 

 

Función para multiplicar fracciones.
Devuelve reducido el producto de £1 y £2

 

E
TipoFraccion MultiplicarFracciones( TipoFraccion £1, TipoFraccion £2 )
TipoFraccion producto;

producto.numerador = f1.numerador * £2.numerador;
producto.denominador = f1.denominador * £2.denominador;
ReducirFraccion( producto );

return producto;

po

 

Función para dividir fracciones.
Devuelve reducido el cociente de f1 y f2

 

“Z
TipoFraccion DividirFracciones( TipoFraccion f1, TipoFraccion £2 ) 4
TipoFraccion cociente;

cociente.numerador = f1.numerador*f2.denominador;
cociente.denominador = f1.denominador*f2.numerador;
ReducirFraccion( cociente );
return cociente;

3

Ya
Procedimiento que lee una fracción.
Devuelve reducida la fracción leída
as ./
void LeerFraccion( TipoFraccion € f ) (
scan£( "xd/%d", £f.numerador, €f.denominador );
ReducirFraccion( £ );

 

 

y

 

ya
Procedimiento que escribe
una fracción £

 

*/
void EscribirFraccion( TipoFraccion f ) 4

print£( "xd/%din", f.numerador, f.denominador );
+

 

 
253

 

    

main() (

Fraccion acumulador = í 0, 0); /* acumulador = 0/0 */
Fraccion operando; /* muevo operando a utilizar */
operacion = ' *; /* tecla de operación */

   
  
    
    
  
  
   
 
 
 
 
 
 
    
  
 
 
 
 
 
 
 
   
 
    
  

le (operacion != 'F') (
print£( >>");
scanf( " %c", operacion );

Af (operacion == '+') (
LeerFraccion( operando );
acumulador = SumarFracciones( acumulador, operando );

 

) else if (operacion == '-') 4
LeerFraccion( operando );
acumulador = RestarFracciones( acumulador, operando );

) else if (operacion == '**) (
LeerFraccion( operando );
acumulador = MultiplicarFraccionesí acumulador, operando );

 

) else if (operacion Yao
LeerFraccion( operando );
acumulador = DividirFracciones( acumulador, operando );

) else if (operacion == 'N') [ /* Nuevos cálculos */
LeerFraccion( acumulador );

 

) else if (operacion
print£("
EscribirFraccion( acumlador yA

004

 

 

) else if (operacion != 'F') (
printf£( "Pulse +, =, *, /, N, =, o Fa" );
3
3

 

este ejemplo cada fracción se almacena como un registro con dos campos,
:pondientes al numerador y al denominador, respectivamente. Compalo esta versión con la del tema 8 se aprecia que las cabeceras de los submas, y por tanto las llamadas, son ahora más sencillas y naturales. El

 

 
254 Fundamentos de programación

 

precio a pagar es una ligera complicación al tener que hacer referencia a los
valores de numerador y denominador como campos de registros, y no directamente como argumentos separados.

El resultado de una ejecución de ejemplo se muestra a continuació;

 

 

>» j
Pulse +, -, *, /, N, =, 0 F
>> N 45/78
>=
15/26
>> +6/9
>=
97/78
>> -4/5
>» =
173/390
> "2/3
> =
173/585
> F
   
  
  
   
  
   
  
  
   
 
 
 
 
 
   
    

ema 10

Ampliación de estructuras de
ontrol

tes de pasar al estudio de las estructuras de datos complejas, se completa
repertorio de estructuras de control más frecuentes en los lenguajes impeivos, detallando las construcciones adoptadas en CE.

Se presentan algunas variantes para realizar la iteración y la selección, deriva“das de las estructuras fundamentales, mostrando la posibilidad que existe de
amarlas en función de ellas.

10.1 Estructuras complementarias de iteración

omo se explicó en el tema 5, la programación estructurada propone la utiEzación del WHILE como estructura iterativa fundamental. Esta estructura
a para poder realizar cualquier programa. Sin embargo, en el mismo tema
5 también fue introducida la estructura FOR cuya utilidad fundamental es
«programar un número de iteraciones que se conoce a priori y que no depende la evolución de los cálculos realizados en cada iteración. La razón de
exista el FOR prácticamente en todos los lenguajes, es precisamente lo
uente de este tipo de iteraciones y la facilidad que proporciona su uso en
casos.

Las estructuras iterativas que se explican en este apartado están también dis.ponibles habitualmente en todos los lenguajes y pretenden facilitar la progra“mación de situaciones concretas y frecuentes. Utilizaremos en las explicaciones
las sentencias disponibles en Ci para programar las nuevas estructuras.

 
   
   
  
   
  
     
    

256 Fundamentos de program:

 

Será objeto de un apartado especial la sentencia continue de Ci que se pi
utilizar con cualquier tipo de bucle. Esta sentencia salta a la siguiente i
ción, lo que es necesario cuando no tiene sentido completar todos los cál
previstos en la iteración en curso.

10.1.1 Repetición: Sentencia DO

 

A veces resulta más natural comprobar la condición que controla las iteraci
al finalizar cada una de ellas, en lugar de hacerlo al comienzo de las mis
En este caso, como se muestra en la figura 10.1, siempre se ejecuta al me
una primera iteración.

 

Figura 10.1 Repetición.

El formato de la estructura de repetición en Ci es el siguiente:
do (

Acción
) while ( Condición );

La Condición que controla las repeticiones es una expresión cuyo resultado
un valor de tipo bool. Si el resultado es true se vuelve a ejecutar la Acción y
cuando el resultado es false finaliza la ejecución de la estructura.

Una situación típica en que resulta cómodo el empleo de esta sentencia es la
que se produce cuando al finalizar cada iteración se pregunta al operador Í
desea continuar con una nueva. En todos estos casos, el programa siempre
ejecuta la primera iteración y pregunta si se desea o no realizar otra más. Por
ejemplo:
 
  
   
  
 
   
 
 
  
   
 
  
  
  
  
 
   
  
  
   
   
   
   
    
   

liación de estructuras de control 257

 

printf£( "¿Otra operación (S/N)?" );
scanf( " %c", gtecla );
while ( tecla so);

 

En todos los programas realizados en los temas anteriores se ha podido prograsr esta forma de operar utilizando la sentencia while. Sin embargo, en los
rogramas desarrollados ha sido necesario forzar la primera iteración inicialilo la variable que controlaba la iteración a un valor igual al necesario para
iteración. Para el mismo ejemplo anterior, esto se realizaría de la siguiente

 

 

pela = 'S";
(tecla == 'S') (

Operación

printf( "¿Otra operación (S/N)?" )
scanf( " %e", gtecla );

a solución es menos elegante y además tiene como inconveniente la necede inicializar la variable de control, con lo que en caso de olvido, la
ión puede ser impredecible. Como se sabe, las variables pueden tomar
satoriamente cualquier valor inicial y, dependiendo del mismo, se ejecuta
o no la primera iteración. Para estas situaciones es muy aconsejable la
ión de una estructura de repetición que evita todos estos problemas.

 

ién resulta adecuado el empleo de la repetición cuando solamente son vás unos valores concretos para una determinada respuesta. Si la respuesta
es correcta se solicitará de muevo y no se continuará hasta obtener una resesta dentro de los valores válidos. La filosofía en este caso es prácticamente
misma del caso anterior, por ejemplo:

1

printf( "¿Mes Actual?" );

scanf( "Xd", gmes );

while ((mes < 1) || (mes > 12));

dentemente la utilidad de la repetición no está ligada exclusivamente a
casos indicados. En general, es aconsejable su uso cuando se sepa que al
s es necesaria una iteración y por tanto utilizando la sentencia while cs
rio forzar las condiciones para que dicha iteración se produzca.

 
258 Fundamentos de programación

 

10.1.2 Sentencia CONTINUE

La sentencia continue dentro de cualquier clase de bucle (while, for o do)
finaliza la iteración en curso e inicia la siguiente iteración. A veces, dependiendo de la evolución de los cálculos realizados en una iteración, no tiene
sentido completar la iteración que se está realizando y resulta más adecuado
iniciar una mueva. Esto puede suceder cuando alguno de los datos suministrados para realizar un cálculo es erróneo y puede dar lugar a una operación
imposible (división por cero, raíz de un número negativo, etc.). En este caso lo
adecuado es detectar la situación y dar por finalizada la iteración e iniciar una:
nueva iteración con nuevos datos de partida. Por ejemplo, supongamos que
tenemos un vector de N coeficientes por los que hay que dividir al realizar un
cierto cálculo salvo obviamente cuando uno de los coeficientes sea cero. Esto
se programaría de la siguiente manera:

 

For (int i=0; 1 <N; i++) 4

if ( vectorCoeficientes[i] == 0) £
continue;

y
calculo = calculo / vectorCoeficientes[i];
y

Como se puede ver en el ejemplo, la sentencia continue siempre estará incluida
dentro de otra sentencia condicional puesto que en caso contrario nunca se
ejecutaría la parte de la iteración posterior a la sentencia continue. En un
for, tal como el del ejemplo anterior, al finalizar la iteración se comprueba la
condición de terminación 1 < N y si no es cierta se incrementa el índice i++
antes de iniciar la siguiente iteración. En los otros bucles sólo se comprueba
la condición de finalización para vor si procede seguir con una nueva iteración.

10.2 Estructuras complementarias de selección

Para la selección entre varias alternativas es suficiente disponer de la estruotura IF, estudiada en el tema 5. De hecho, existen lenguajes en los que la única
sentencia disponible para la selección es la propuesta por la programación estructurada, que permite solamente la selección entre dos alternativas. La falta
de claridad cuando se utilizan varias selecciones anidadas aconseja disponer
de una sentencia de selección en cascada como la estudiada en el tema 5,

 
  
 
  
   
  
   
   
  
 
 
  

Ampliación de estructuras de control 259

 

Por las mismas razones de claridad y sencillez es habitual disponer de una
¡sentencia que permite una selección por casos. Este apartado está dedicado
exclusivamente a dicha sentencia, estudiando la sintaxis y semántica que tiene
en Ct.

10.2.1 Sentencia SWITCH

 

¡Cuando la selección entre varios casos alternativos depende del valor que toma
“ma determinada variable o del resultado final de una expresión, es necesario
realizar comparaciones de esa misma variable o expresión con todos los valores
“que puede tomar, uno por uno, para decidir el camino a elegir. Así, en el
programa para el cálculo del día de la semana del tema anterior con la variable
' que guarda el mes teníamos:

Enero) £
IncreDias = 0;
else if (M
IncreDias = 3;
else if (M
IncreDias = 3
else if (M
IncreDias =

   
    
  
  
  
  
  
 
   
   
   
  

 

Febrero) (

 

Marzo) £

Abril) (

 

else if (M == Octubre)
IncreDias
Noviembre) 4

IncreDias =

 

 

“Esto supone una sentencia larga y reiterativa, si se tiene en cuenta que además
para algunos casos, por ejemplo los meses de Febrero, Marzo y Noviembre, se
“repite la misma acción.

 
 

Silo que se necesita es comparar el resultado de una expresión, dicha expresión
se reevaluará tantas veces como comparaciones se deben realizar (a menos que
“se disponga de un compilador optimizante). En este caso y por razones de
«simplicidad y eficiencia es aconsejable guardar el resultado de la expresión en
“ana variable auxiliar y realizar las comparaciones con dicha variable utilizando
el esquema de selección por casos mostrado en la figura 10.2.

 
 

Si el tipo de valor que determina la selección es un tipo ordinal: int, char o
'emumerado, se dispone en Ct de la sentencia switch cuya estructura permite
 

260 Fundamentos de programación

  
 

default

Figura 10.2. Selección por casos.

agrupar los casos que tienen el mismo tratamiento y en la que se evalúa solamente una vez la expresión x. La sintaxis se ilustra con el siguiente ejemplo.
que muestra cómo las distintas vías de ejecución se asocian a grupos de valores
que pueda tomar la expresión o variable x: acciónA con el valor v,, acciónB!
con los valores de vw, v3 y v4, acciónC con los valores 15 y %, y establecien
do como vía alternativa la acción!1 para el resto de valores distintos de los
anteriores:

 

switch (expre
case valor!
acciónA;
break;
case valor2:
case valor3:
case valorj:
acciónB;
break;
case valoró:
case valoró:
acciónC;
break;

n) t

 

 

 

default:
acción HH;
,

La sentencia comienza con la palabra clave switch y a continuación, entre
paróntosis, se indica la expresión o variable cuyo valor determina los casos
que se quieren analizar, seguida del símbolo de abrir llave (£). Para cada
vía de ejecución posible se detallan primeramente los valores que debe tomar
la expresión, precedidos por la palabra clave case y seguido por dos puntos

 
 
  
   
  
  
   
   
   
    
 
   
   
   

liación de estructuras de control 261

 

. La correspondiente acción como una secuencia de sentencias se detalla a
tinuación de los correspondientes valores.

 

Manual de Estilo para CE impone que cada acción finaliza siempre con la
cia break para que finalice la sentencia switch después de cada acción.
Si por error se omite la sentencia break, se continuaría ejecutando la acción
siguiente o siguientes casos. Aunque en C/C++ el uso del break es opsonal, en C+ es obligatorio para lograr 1na programación estructurada fácil
de entender y verificar. Además, se evita la ambigúiedad de si la ausencia del
break es intencionada o es una omisión por error.

 

La alternativa para el resto de los valores es opcional, y va precedida de la
palabra clave default. La sentencia finaliza con el símbolo de cerrar llave ())

Esta sentencia no se puede utilizar cuando la variable o el resultado de la
expresión que controla la selección sea de tipo float u otro tipo no simple.
En estos casos no queda más remedio que emplear la sentencia de selección
general o en cascada.

Como ejemplo se reescribe la selección anterior, según ol mes:

eh (Mm) 4
case Enero:
case Octubre:
IncreDias =
break
case Mayo:
IncreDias
break;
case Agosto:
IncreDias
break;
case Febrero:
case Marzo:
case Noviembre:
IncreDias
break;
case Juni:
IncreDias =
break;
case Septiembr:
case Diciembre
IncreDias
break;
defaul:
IncreDias =

 

 

 

 

 

 

 

 

 

 

 

 

 

 
 

|
|
|
|

 

 

   
       
  
  
 
   
   
 
 
 

262 Fundamentos de progri

 

Evidentemente esta sentencia da lugar a un fragmento de programa más
y fácil de entender.

En la sentencia switch se deben incluir todos los posibles valores que pl
tomar la variable o expresión. Cuando se obtiene un valor que no está as

a ninguna vía (y no hay alternativa default), el programa finaliza por
Si lo que sucede es que existen valores para los que no se debe realizar ni
acción, entonces estos valores se deben declarar asociados a una acción
Por ejemplo:

switch (M) £
case Enero:
case Febrero:
case Marzo:
case Abril:
case Mayo:
case Julio:
case Agosto:
case Septiembre:
case Octubre:
case Noviembre:

 

 

case Junio:

case Diciembre:
sueldo = sueldo + extra;
break;

y

Otra forma de conseguir esto mismo es mediante una alternativa def:
vacía utilizando sólo un punto y coma (;). Por ejemplo:
switch (M) 4
case Junio:
case Diciembre:
sueldo = sueldo + extra;
break;
default:

)

La diferencia entre ambas es que en el primer caso se produciría un error
finalizaría la ejecución del programa si por cualquier causa la variable M tox
un valor fuera del rango de meses declarado de Enero ... Diciembre.

el segundo caso no se distingue la situación errónea de la que no lo es, Si
programa está completamente probado, es muy probable que tal situación
se produzca nunca. Sin embargo, cuando un programa está todavía en
 
  
 
 
   
   
 
 
  
  
 
  
  
    
   
  
   
   
  
  
   
 
  

Ampliación de estructuras de control 263

 

de prueba es importante conocer todos los errores para analizar sus causas y
seorregirlos.

Para acabar este apartado se detalla la sintaxis formal de la sentencia switch
de Ct:

Sentencia_SWITCH

 

= switch ( Expresión ) ( Lista_de_cosos y

Lista_de_casos 332 Caso Í Caso Y
[ default: Secuencia_de_sentencias ]

 

 

Caso 33= Lista_de_opciones Secuencia_de_sentencias break ;

Lista_de_opciones *3= case Valor : Í case Valor : )

tipo del resultado de la Expresión y cada Valor de la. lista deben ser com¡patibles.

0.3 Equivalencia entre estructuras

¡Como ya ha sido explicado, las estructuras básicas estrictamente necesarias
la programación estructurada son la selección entre dos alternativas 1£ y
iteración while. Éstas se pueden considerar las estructuras primarias. El
, que denominaremos estructuras secundarias, son en general más comyjas y tienen como objetivo lograr programas más sencillos en situaciones
iculares.

quiera de las estructuras secundarias siempre puede ser expresada en funde las primarias. Sin embargo, no siempre es posible expresar una sentenprimaria en función de una secundaria. Por ejemplo, no se puede realizar
iteración while condicionada por más de una variable de tipo simple mete una estructura for de C£. Tampoco es posible realizar una selección
condicionada por los valores que toma una expresión real mediante una
ura switch.

que a lo largo de las explicaciones del tema 5 y en este mismo tema se
ido mostrando ciertas transformaciones y equivalencias entre estructuras,
este apartado a modo de resumen se muestra cómo cualquier estructura
ndaria se puede realizar mediante las estructuras primarias.

.3.1 Selección por casos

estructura también se puede realizar mediante selecciones en cascada.
la la estructura siguiente:

 

 
 

   

264 Fundamentos de progr

 

switch (Expresión) (
case vi:
SentenciasA
break;
case v2 :
case v3 :
case vá :
SentenciasB
break;
case v5 :
case v6 :
SentenciasC
break;
default
SentenciasH
)

se puede realizar de la siguiente forma:

valor = Expresion;

if (valor == v1) (
SentenciasA

Y else i£ ((valor
SentenciasB

J else i£ ((valor == v5) || (valor = v6) £
SentenciasC

   

v2) || (valor

 

v3) || (valor == v4)) 4

J else
SentenciasH
J

Esta construcción se puede poner a su vez en función de la estructura básica.
1£, de forma anidada.

10.3.2 Bucle con contador

Esta estructura se puede hacer mediante un control explícito del contador del
bucle. Sea la estructura siguiente:

for (int indice = Inicial; indice <= Final; indice++) (
Sentencias

)

Cuando el incremento es positivo se puede realizar de la siguiente forma:
 
  
  
   
   
    
   
   
    
    
  
  
   
  
   
 
 
  
   

Ampliación de estructuras de control 265

indice = Inicial;

ile (indice <= Final) £
Sentencias
indice++;

  

a

'euando el incremento es negativo la comparación se debe hacer por mayor o
gual en lugar de por menor o igual.

10.3.3 Repetición

sentencia do se puede transformar en while forzando la ejecución incondisonal de la primera iteración. La estructura:

1

Sentencias

(Condición);

puede convertir en esta otra:

tencias
(Condición)
Sentencias

bien, usando una variable auxiliar para almacenar el valor de la condición:
= true;

(seguir) £

Sentencias

seguir = Condición;

0.4 Ejemplos de programas

este apartado se recogen algunos programas completos que utilizan las esturas estudiadas. Algunas partes de estos programas ya han sido utilizadas
los ejemplos presentados a lo largo de este tema.

 

4.1 Ejemplo: Imprimir tickets de comedor

trata de confeccionar un ticket mensual de comedor con la cantidad a pagar
'ndiendo de los días laborables de cada mes y descontando las ausencias

 
 

 
 

   
 
   
 

266 Fundamentos de progri

 

de cada persona. El objetivo fundamental es ilustrar el uso de la selección
casos en función del tipo enumerado de los meses del año. La selección
mes se realiza mediante una sentencia de repetición que controla que el
este comprendido entre 1 y 12. Asimismo, el programa permite confecci
todos los tickets necesarios hasta indicar que no se quiere continuar medi
un bucle repetitivo controlado por una respuesta del tipo Si/No. El lis
completo del programa es el siguiente:

 

 

pe

* Programa: Comedor
*

* Descripción:

* Programa para realizar el ticket

* de pago de un comedor
AAA AAA

include <stdio.h>

int main() 4
const float Menu
const float IVAMenu

/* precio del menú */
/* 7% IVA del menú */

 

typedef enum TipoMes (
Enero, Febrero, Marzo,
Abril, Mayo, Junio,
Julio, Agosto, Septiembre,
Octubre, Noviembre, Diciembre
»

TipoMes mes; /* mes a pagar */
int dias, diasPagar, diasFaltas, aux;
float total, totalIVA;

char tecla;

/*-- Leer y validar el mes leído --*/
do 1

primt£( "¿Mes? " );

scant( "%d", Saux );
) while ((aux < 1) || (aux > 12);
mes = TipoMes( aux-1 );

/*-— Calcular días según el mes --*/
switch (mes) (
case Agosto:
dias = 0;

  
Ampliación de estructuras de control 267

 

case Enero:

case Abril:

case Diciembre:
dias = 17;
break;

case Febrero:

case Septiembre:
dias = 20;
break.

case Junio:

case Noviembre:
dias = 21;

 

 

 

case Mayo:
case Octubre:
dias

 

/*-- Confeccionar los tickets a partir de las ausencias --*/
do (

printf( "¿Total de Ausencias? " );

scanf( "Xd", tdiasFaltas

 

 
 

  

 

 

print£( Anto);

diasPagar = dias - diasFaltas;

total = diasPagar*Menu;

totalIVA = total*IVAMenu/100.0;

printf( RECIBO de COMEDORAn" );

printf( "Comidas — Precio Total" );

print£( "%4d%11.2£%13.2£Wn", diasPagar, Menu, total );
printf" %3.1£ %% IVA %6.2£in", IVAMenu, totalIVA );
print£( " Total Recibo %8.2£ Eurosin", total+totalIVA );
printf( Mad

tecla =' ';

print£( "¿Otro Recibo(S/N? " );
mile (Ctecla l= 'S') 88 (tecla l= "N')) £
scanf( "%c", étecla );

y
) while (tecla != "N');

 

 
    
   
  
   
  
   

268 Fundamentos de progr

 

 

ejemplo del resultado de la ejecución del programa es el siguiente:

 

¿Mes? 4
¿Total de Ausencias? 5

 

RECIBO de COMEDOR
Comidas Precio Total
2 8.50 102.00
7.0 % IVA 7.14
Total Recibo 109.14 Euros

¿Otro Recibo(S/N)? S
¿Total de Ausencias? 7

 

 

RECIBO de COMEDOR
Comidas Precio Total
10 8.50 85.00

7.0 % IVA 5.95

Total Recibo 90.95 Euros

¿Otro Recibo(S/N)? N

 

10.4.2 Ejemplo: Gestión de tarjetas de embarque

Este programa realiza la gestión automática de los asientos de un avión
imprime las tarjetas de embarque. Cuando varios pasajeros solicitan junt
las tarjetas de embarque se les asignan asientos de la misma fila, Sino exis
asientos de la misma fla se ocupan los huecos libres. El múmero de tarjetas
embarque que se pueden solicitar simultáneamente es como máximo de 6.
asientos se gestionan como un vector de filas al que inicialmente se le asignam:
un determinado número de asientos por fla.

El procedimiento BuscarPlazas es el encargado de realizar cl algoritmo para
situar las plazas solicitadas. En un primer intento se trata de asignar las nuevas
plazas en la misma fila. Como segundo intento se asignarán las plazas en filas
distintas. Cuando no hay suficientes plazas disponibles se dará un mensaje
Este procedimiento actualizará las plazas disponibles y el número total de
plazas libres después de la asignación. Otro procedimiento es el encargado de
imprimir las tarjetas de embarque cuando se ha encontrado sitio.

 

 

Para comprobar la. situación de los asientos libres se dispone de un procedi
miento que imprime las plazas libres y las ocupadas. El programa consiste
en un menú que utiliza el procedimiento para la búsqueda y el procedimiento
 
  
    
   
  
   
    
   
  
   
  
  
 
   
 
 
 
 
 
 
 
 
 
 
 
  
   
    

liación de estructuras de control 269

 

mostrar la situación según elección del operador. Todo el programa está
izado en base a las constantes del aforo, y el tamaño de la fla. Cualquier
ño de avión de un mismo formato se puede gestionar cambiando estas
constantes. El listado completo del programa es el siguiente:

 

 

DADO

Programa: Mostrador

 

.

Descripción:

Este programa confecciona tarjetas de embarque

y asigna plazas en la misma fila si es posible
AAA RNA /

lude <stdio.h>

 

int Aforo = 60; /* total asientos */
int AsientosFila = 6; /* asientos por fila */

int Filas = Aforo/AsientosFila;
int Pasillo = AsientosFila/2;

f int Plazas[Filas];

Mostrar ocupación del avión */
PintarPlazas(const Plazas P) £
for (int i =0; 1 < Filas; i++) £
for (int j= AsientosFila; j >= 1; j—=) €
if (j == Pasillo ) (
printf" "oy;

 

y

if (j> PD
printf(" ()

) else (
printf( " ()

 

 

J
y
print£( “n" );
y

Imprimir una "tarjeta de embarque” */
id ImprimirTarjeta( int fila, int asiento ) 4

 

 

 

printí( " Na");
print£( "| TARJETA DE EMBARQUE ar y;
print£( "| Fila :%3d", fila );

print£( Asiento asiento );
print£( " a)

 
 

270 Fundamentos de progr

 

y

/** Buscar plazas libres contiguas */
void BuscarPlazas( int nuevas, int $ libres, Plazas sitios ) (
int ind, nue, dispo, aux;

if (nuevas <= libres) 4
/*-- Buscar plazas en la misma fila --*/
ind = 0;
nue = nuevas;
while ((ind < Filas) 66 (nue > 0)) f
dispo = sitios[ind];
if (nue <= dispo) (
aux = AsientosFila - dispo;
for (int i= 1; i <= mue; i++) (
ImprimirTarjeta( ind+l, aux+i );
E
sitios[ind] = sitios[ind] - nue;
libres = libres - nue;
nue = 0;
y
ind++;

y

/*-- Buscar plazas en cualquier fila --*/
ind = 0;
while (nue > 0) (
dispo = sitios[ind);
if (dispo > 0) (
aux = AsientosFila - dispo;
for (int i = 1; i <= dispo; i++) 1
ImprimirTarjeta( ind+l, aux+i );

sitios[ind] = sitios[ind] - dispo;
libres = libres - dispo;
nue = nue — dispo;
y
ind++;
J
) else (
print£( "No hay plazas suficientesta” );
y
3
liación de estructuras de control 271

 

Programa principal */
main() (

Plazas pasaje;

int sitiosLibres = Aforo;
char tecla;

ánt aux;

    
      
   
 
 
  

for (int i =0; i< Filas; i++) £
pasaje[i] = AsientosFila;

do (
print£( "Wn¿Opción (Tarjetas, Pasaje, Fin)? " );
scanf( " %c”, gtecla );
switch (tecla) (
case 'T':
do [
printf( "¿Número de plazas (1 a 6)? " );
scanf( "%d", faux );
) uhile (aux < 1 || aux > 6);
BuscarPlazas( aux, sitiosLibres, pasaje );
break;
case 'P':
PintarPlazas( pasaje );
break;
default:
y
3 while (tecla != 'F');

 

continuación se muestra un fragmento de la ejecución del programa:

 

ión (Tarjetas, Pasaje, Fin)? P

y 0 2) 0 Ey €)
pS 0 4) (2 (13 (2
E) (0) 4) CY) () CJ
E) Cc (2 EY € €)
E) E 7 € €) 47
E) CC) (3) CY) 1) E)
E) €) €) €) (Y El
E) Y) (2 (1 tt) E)
E) €) (2 CY) (Y) €)
E) LT) 03 EY (Y :C€2
 

272 Fundamentos de progri

 

¿Opción (Tarjetas, Pasaje, Fin)? T
¿Número de plazas (1 a 6)? 5

 

I TARJETA DE EMBARQUE |
| Fila 4 Asiento

 

 

1 TARJETA DE EMBARQUE li
| Fila 4 Asiento

   

 

CO 00 0) cd Y €)
O O + £d Ux El
0 2) (1) (Y £2
Ey) (Y 6) Y Y tl
£) C) () (0) 6) €)
E) CI € (Y) €% El
6) CY) €) (YX E E)
cd 6) €) 1 € El
() EY €) (3) €Y CA
CY) Y) () (1 €) Cl

¿Opción (Tarjetas, Pasaje, Fin)? T
¿Número de plazas (1 a 6)? 2

 

| TARJETA DE EMBARQUE
| Fila 2 Asiento 4

 

| TARJETA DE EMBARQUE |
| Fila: 2 Asiento: 5 |

 
 
  
    
 
   
 
 
  
  
   
  
   
  
   
  
   
 
  

liación de estructuras de control 273

 

ión (Tarjetas, Pasaje, Fin)? P

0 0 MN (1
O 00 EY 2
0 e) CY E)
QU 0 9) 4 2
cl E) £) €) (7
cd CS E NS
tY €) EY) EY (3
ta €) 2) € E)
co.) C) €) €)
(0d) 0 L) €) €)

ión (Tarjetas, Pasaje, Fin)? F

4.3 Ejemplo: Calculadora

programa simula una pequeña calculadora que realiza las cuatro opemes aritméticas básicas (suma, resta, multiplicación y división), tiene 4
iciones de memoria (A, B, C y D) para guardar resultados intermedios y
indica los errores que se producen al escribir las operaciones a reali- El programa es un ejemplo de combinación compleja de estructuras de
ol de diferentes clases: selección sencilla o múltiple, bucles normales o
nidos, con salida intermedia, etc.

programa. lee como entrada líneas de texto con las operaciones a realizar.
línea de entrada puede contener una o varias expresiones terminadas
punto y coma (;). Cada expresión está formada por una secuencia de
dos y operadores, que se evalúan estrictamente de izquierda a derecha.

operando puede ser cualquiera de las 4 posiciones de memoria o un valor
érico. Los valores numéricos se indican mediante una secuencia de dígitos
0 al 9 sin blancos ni ningún otro carácter entre ellos. Es decir, los operannuméricos literales son valores enteros, pero los cálculos se realizan con
es reales, de manera que un cociente puede dar un resultado con parte
onaria.

operador puede ser el símbolo de una operación aritmética (+, =, *, /).
ás el resultado en un punto cualquiera se puede guardar en una posición
memoria indicándolo mediante el signo igual (=) seguido de la posición (A,
CoD).
final del programa se indica usando un punto (+) al final de la última
esión, en lugar de un punto y coma.

   
  
 

 

    
 
 

ejemplos de expresiones válidas las siguientes:
274 Fundamentos de programación

 

1232 * 456 = A;
A+34=B-! AB+75

 

El procedimiento LeerCaracter lee el siguiente carácter de la entrada y hace
eco por la salida. También permite releer el carácter anterior si no se ha
procesado efectivamente, sino que sólo se ha leído para detectar el final de uz
valor numérico. Además detecta el final del texto de entrada, devolviendo uz
carácter nulo en ese caso.

El procedimiento LeerSimbolo es el encargado de convertir grupos de carac
teros de entrada en el símbolo eurrespondiente. Si es un operando numérica
calcula además su valor.

El procedimiento LeerOperando lee el siguiente símbolo, comprueba que es uz
operando mumérico o referencia a memoria, y en ese último caso recupera el
valor almacenado.

El programa se plantea como un bucle indefinido en el que se analizan y
ejecutan las operaciones que se introducen hasta el punto final, o hasta agotar:
el texto de entrada. Se detectan los errores en los operandos, en los operadores
y la falta de alguno de los símbolos necesarios. En caso de error se ignora el
resto de la expresión y se continúa con la siguiente, si la hay. El listado
completo es el siguiente:

 

RRE
* Programa: Calculadora

* Descripción:

* Este programa simula una calculadora con las

* cuatro operaciones básicas (+,-,*,/) y cuatro

* posiciones de memoria. Analiza y evalúa las

* expresiones e indica los errores que contengan,
* si los hay
ARA RARA RA
*include <stdio.h>

*include <stdlib.h>

typedef enum TipoSimbolo (
Numero, Memoria, Operador, Terminador, Desconocido
»
char e =*' '; /* carácter leído */
bool releer; /* ya leído de antemano */
TipoSimbolo simbolo; /* símbolo leído y */
float nunero; /* su valor numérico */
char caracter; /* 0 de texto */
bool primero; /* primer símbolo de una operación */

 
pliación de estructuras de control 275

float TipoMemoria[4];
ia memoriaABCD; /* 4 memorias */

Leer siguiente carácter y hacer eco
Devuelve nulo al final del fichero
LeerCaracter() (
if (primero) £ /* leer saltando espacios */
primero = false;
releer = false;
c= "o
scanf( " %e", de );
) else if (releer) ( /* ya estaba leído de antemano */
releer = false;
return;
) else £ /* lectura normal */
c= "0
scanf( "%c", 6c );

 

“/

 

 

 

y
printf( "%c", c); /* hacer eco */

    
 

yo

 

Procedimiento para reconocer el siguiente símbolo
y dejarlo en 'simbolo*, 'numero' y *caracter”

 

¡void LeerSimbolo() £
do [
LeerCaracter();
) mhile (c
caracter =c;

 

 

case 'D':
simbolo = Memoria;
break;
 

 

276

 

 

Fundamentos de progra

case '9':
simbolo = Numero;
numero = 0.0;

do (
numero = 10.0*numero + float( int(c)-int('0') );
LeerCaracter();

) while ((c >= '0') 88 (c <= 90);

releer = true;

break;
case 'Wn':
case 'Wr*

simbolo = Terminador;

print£( "n** Error: expresión incompletaln” );

break
case 'M0*

simbolo = Terminador;

print£( "n** Error: fin de la entradain" );

break;
default:

simbolo

caracter

print£( "Wn** Error: símbolo no reconocidoWn" );

 

 

 
Ampliación de estructuras de control 277

 

ya
Reconocer y obtener un operando con su valor

 

 

 

Y
'woid Leer0perando( float £ valor, bool € error ) 4

error = false;
LeerSimbolo();
if (simbolo == Numero) 4

valor = numero;
) else if (simbolo == Memoria) f

valor = memoriaABCD[int(caracter)-int('A')];

) else (
error = true;
if (caracter > ' ')4
print£( "Wn** Error: se necesita operando" );
y
3
3

 

Programa principal

 

int main() £
float operando, resultado;
char operador;
bool seguir, error;

for (int k=0; k<4; kt1) (
memoriaABCD[k] = 0.0;
z

/%-- Bucle de procesar expresiones --*/
do (

printf£( "Cálculo: * );

resultado = 0.0;

/* Leer y procesar el primer operando */
primero = true;
Leer0perando( resultado, error );
 

 

 

278 Fundamentos de programación

 

/* Leer y procesar el resto de la expresión */
seguir = lerror;
while (seguir) £ /* bucle indefinido */

/*%-- Leer operador o fin de expresión --*/
LeerSimbolo();
switch (simbolo) £

case Operador:
/%-- Operaciones aritméticas o asignación —*/
operador = caracter;
Leer0perando( operando, error );
if (error) £
seguir = false;
continue;  /* se da por terminada la expresión */
3
switch (operador) (
case +:
resultado = resultado + operando;
break.
case '-t:
resultado = resultado - operando;
break;
case '*';
resultado = resultado * operando;
break;
case '/':
resultado = resultado / operando;
break;
default:  /* guardar en memoria */
if (simbolo == Memoria) £
memoriaABCD[int(caracter)-int('A')] = resultado;
j else £
print£( "Yn** Error: Se necesita A, B, Co Din" );
error = true;
seguir = false;
continue; — /* se da por terminada la expresión */

 
pliación de estructuras de control 279

case Numero:
case Memoria:
/*— Operador no válido --*/
print£( "Yn** Error: se necesita operadorin" );
error = true;
break;

default:
/*-- Fin de la expresión --*/
seguir = false;
error = (caracter l= ';' 8% caracter l='

 

,
seguir = seguir 84 !error;
3 /* fin del bucle del resto de la expresión */

if (lerror) £
/*-— Escribir resultado --*/
printf( "> Resultado: %gin", resultado );
J else if (c!="X0') 1
/*-—- Saltar hasta fin de expresión, de línea o de fichero —-*/
printf( "<<" );
while (c!=";" 88 cl="." 88 c!="Yn' 88 cl="X0') £
LeerCaracter();

,
printf( "Ya" );

)
primt£( "Na" );
) while (c !="." 66 c l= 'N0'); /* fin del bucle principal */

  
   
 

y

 

A continuación se muestra un ejemplo de ejecución. El texto de entrada contiene las siguientes expresiones:

 

   
  
   
 
  

22 + 33 =A- 25 = B; A; B*2;
358 * (5 - A); 44

A = 33 +7; 9/7+5;
+22; final.

Y el resultado obtenido es:

 
280 Fundamentos de progri

 

 

 

 

Cálculo: 22 + 33 =A- 25 =
>> Resultado: 30

 

Cálculo: A;
>> Resultado: 55

Cálculo: B*2;
>> Resultado: 60

Cálculo: 3;
>> Resultado: 3

Cálculo: 8 * (
+* Error: símbolo no reconocido
< 5-0;

Cálculo; 44
** Error: expresión incompleta
<<

Cálculo: A = 33
** Error: Se necesita A, B, CoD
< +7;

Cálculo: 9 / 7 + 5;
>> Resultado: 6.28571

Cálcul:
+* Error: se necesita operando
<< 22;

 

Cálculo: f
** Error: simbolo no reconocido
<< inal.

 
Ejercicios sin resolver - II

  

A continuación se enuncian un segundo bloque de ejercicios sin resolver. Todos ellos pueden y deben ser realizados en Ct utilizando las herramientas y
metodología explicada hasta este momento. Los enunciados de los ejercicios
son los siguientes:

1. Realizar una función que devuelva un valor booleano cierto o falso si
el número que se le pasa como argumento es “perfecto”. Para que un
número sea “perfecto” es necesario que su valor sea igual a la suma
de todos sus divisores incluyendo al 1 y sin incluirle a él mismo. Por
ejemplo, los divisores de 6 son el 1, el 2 y el 3; su suma es igual a 6,
luego el número 6 es “perfecto”. Utilizando la función anterior realizar
un programa. que escriba la lista de números “perfectos” hasta uno dado,
introducido como dato al programa.

2. Realizar un procedimiento que lea una letra, compruebe que es una de
las utilizadas para escribir los números romanos y devuelva su valor,
según la siguiente tabla:

T-1t Cc - 100
Vos D - 500
XxX - 10 M - 1000
L - 50 Resto - 0

Utilizando el procedimiento anterior, realizar otro procedimiento que
lea un número romano y devuelva su valor entero correspondiente. Este
procedimiento tendrá en cuenta las reglas de escritura de los números
romanos. Finalmente, utilizando este último procedimiento realizar un
programa que lea dos números romanos e indique cuál de ellos es mayor.

3. Realizar un programa que escriba todas las permutaciones posibles que
se pueden obtener a partir de las 4 letras: A, B, C y D.

4. Realizar una función que devuelva el día de la semana cuando se le pasan como argumentos el día, el mes y el año de una fecha cualquiera.
Utilizando la función anterior escribir un programa al que se le introdu282 Fundamentos de progra:

 

 

   
       
 

cen como datos el mes y el año y devuelve como resultado la hoja
calendario de dicho mes. Por ejemplo:

 

Mes? 1
Año? 2018

ENERO 2018
LU MA MI JU VI SA DO
1 2 3 4 5 6 7
8 9 10 11 12 13 14
15 16 17 18 19 20 21
22 23 24 25 26 27 28
29 30 31

5. Realizar un programa que analice un texto terminado con un punto (.)
y clabore las siguientes estadísticas:
+ Número total de palabras del texto
+ Número de palabras que utilizan N o más vocales diferentes
+ Número de palabras que utilizan M o más consonantes diferentes.
Los valores de N y M se leerán como datos del programa.
6. Realizar un programa para controlar las plazas de un aparcamiento.
El aparcamiento dispone de 25 plazas de dos tamaños diferentes: 15
pequeñas y 10 grandes con la disposición que se muestra a continuac!

 

 

P P plefe|e
5 7 10 | 11 12 [13

La asignación se realizará automáticamente según el tamaño del vehículo
que se quiere aparcar con el siguiente algoritmo:

+ Cada vehículo solamente ocupará una plaza.
Un vehículo pequeño siempre ocupará una plaza pequeña, salvo que
estén todas ocupadas y exista alguna grande libre.
Un vehículo grande sólo puede aparcar en una plaza grande. Si
todas están ocupadas no podrá aparcar aunque estón todas las pequeñas libres.
De todas las plazas libres, siempre se ocupará primero la de número
menor.

 
Ejercicios sin resolver - IT 283

 

El programa tendrá 3 opciones básicas:
+ Entrada: es necesario indicar el tamaño de coche ( P/G ).
+ Salida: es necesario indicar la plaza que se deja libre. Por ejemplo:
PS
+ Situación del aparcamiento: indicando las plazas libres y las ocupadas.

 
  
  
   
   
    
   
   
   
  

Tema 11
Estructuras de datos

En el tema 9 se han introducido mecanismos básicos para la definición de
nuevos tipos, incluyendo tipos estructurados: formaciones o vectores (arrays)
y tuplas (struct). En este tema se introducen nuevas estructuras de datos
que aportan posibilidades adicionales.

En particular se generaliza la estructura vectorial mediante el uso de vectores abiertos y matrices o formaciones de varias dimensiones, así como los
tipos unión, conjuntos, y estructuras de datos complejas que combinan varias
estructuras más sencillas,

11.1 Argumentos de tipo vector abierto

Si un subprograma debe operar con un vector recibido como argumento, necesita toda la información del tipo de dicho vector, es decir, el tipo y número de
sus elementos. Por ejemplo, en el tema 9 aparecían los siguientes fragmentos
de código:

¡const int NumeroElementos = 10;

"typedef int TipoVector[NumeroElementos];

Escribirvector( const TipoVector v ) (f...)

Vector vectorUno, vectorDos;

ribirvector( vectorDos );

El código del procedimiento EscribirVector puede redactarse con seguridad,
ya que se conoce toda la información del tipo del argumento:

 
        

286 Fundamentos de program:

void EscribirVector( const TipoVector v ) £
for (int i = 0; i < NumeroElementos; i++) [
print£( "Xx10d", v[il )»;
3
print£( "a" );
,

 

Si ahora necesitamos trabajar con vectores de otro tamaño, tendremos que:
definir un nuevo tipo y, lamentablemente, también un nuevo procedimiento de
escritura (recordemos que en Ci el argumento real debe ser exactamente del
mismo tipo que el argumento formal)

const int NumeroElementosLargo = 100;
typedef int TipoVectorLargo[NumeroElementosLargo];

void EscribirVectorLargo( const TipoVectorLargo v ) f
for (int i = 0; i < NumeroElementosLargo; 1++) £
printf( "%*10d", v[i] );
y
printf( “Ya” );
$

Como vemos, el código del nuevo procedimiento de escritura es idéntico al del
anterior, salvo por la referencia al número de elementos. En la práctica no
tiene sentido tener que duplicar el código sólo porque cambia el valor de una
constante. Más razonable es escribir un procedimiento general de escritura de
vectores de números enteros, y pasar como parámetro el tamaño del vector.
Para eso hace falta un mecanismo para expresar que un argumento de tipo
vector puede tener un tamaño cualquiera, es decir, indefinido. Los vectores
con un tamaño indefinido se denominan vectores abiertos.

En Ci los argumentos de tipo vector abierto se especifican de manera similar
a una declaración de tipo vector, omitiendo el tamaño explícito pero no los
corchetes ([J). Ejemplo:
void EscribirVectorAbierto( const int v[], int numElementos ) (

for (int i= 0; i < numElementos; i++) f

print£( "10d", v[i] );

J

print£( “n" );
F

Ahora podemos usar este procedimiento para escribir vectores de cualquiera
de los tipos anteriores:
 
  
  
  
  
  
    
  
  
   
  
   
  
 
 
  
  
   
    
  
  
  

icturas de datos 287

 

Vector vectorino, vectorDos;
VectorLargo vectorLargo;

ibirVectorabierto( vectorDos, NumeroElementos );
ibirVectorAbierto( vectorLargo, NumeroElementosLargo );

precio que hay que pagar por disponer de esta facilidad es tener que pasar
pre la longitud concreta del vector como argumento, en cada llamada.

 

supuesto, hay otras alternativas al paso explícito de la longitud del vector.
subprogramas estándar para operar con cadenas de caracteres (strings)
la técnica de almacenar un carácter nulo al final del valor efectivo de
'gada cadena. Esto exige disponer siempre de espacio para un carácter más, al
108, pero evitan tener que pasar la longitud como argumento. A continuase muestra un ejemplo de esta técnica.

 

11.1.1 Ejemplo: Contar letras y dígitos

Este ejemplo analiza un fragmento de texto y cuenta el número de caracteres,
letras, dígitos y espacios en blanco de los que consta. Se usa un subprograma
que recibe el fragmento de texto como vector abierto, y analiza uno a uno
sus caracteres hasta encontrar el carácter nulo que marca el final. El listado
“completo del programa es el siguiente:

 

A DADA

* Programa: ContarletrasyDigitos
e

+ Descripción:
* Programa que analiza fragmentos de texto y
* cuenta las letras y dígitos lo componen
ARARA RARA RARA RARA RAR AN RRA RR RARA RAR ERE RARAS
¡finclude <stdio.h>

include <ctype.h>

/** Analizar el texto */

woid AnalizarTexto( const char texto[] ) €
int letras = 0;

int digitos

   
 
288 Fundamentos de program:

 

while (texto[posi] != '10') 4
if (isalpha(texto[posil)) £
letras++;
) else if (isdigit(texto[posil)) (
digitost+;
J else if (isspace(texto[posil)) (
blancos++;
+
posi++;
J

printf( "Texto: %sAn", texto );

print£(
"Longitud: %2d Letras: %2d Digitos: %2d Blancos: %2diwmWn"”,
posi, letras, digitos, blancos );

/** Programa principal */

int mainO 4
AnalizarTexto( "12 de Octubre de 1492" );
AnalizarTexto( "2001, una odisea del espacio" );
AnalizarTexto( "" );

3

 

y el resultado de la ejecución es el siguiente:

 

 

Texto: 12 de Octubre de 1492
longitud: 21 Letras: 11 Digitos: 6 Blancos: 4

Texto: 2001, una odisea del espacio
Longitud: 28 Letras: 19 Digitos: 4 Blancos: 4

Texto:
longitud: 0 Letras: 0 Digitos: 0 Blancos: 0

11.2 Formaciones anidadas. Matrices

En esta sección se generaliza el concepto de vector para disponer de formaciones de más de una dimensión. Para simplificar, la exposición se centra en
matrices de dos dimensiones, pero la notación y técnicas de uso se pueden
extender a formaciones de más de dos dimension:

 
Estructuras de datos 289

11.2.1 Declaración de matrices y uso de sus elementos

Las matrices son estructuras de tipo formación (array) de dos o más dimensiones. Una forma sencilla de plantear la definición de estas estructuras
considerarlas como vectores cuyos elementos son a su vez vectores (o matrices). La figura 11.1 muestra la estructura de una matriz de dos dimensiones,
formada por filas o columnas.

 

Matrizl1J1i1
Matrizlil1]

Matristili)

 

   

Figura 11.1 Matriz de dos dimensiones.

En la figura se presenta la matriz como un vector cuyos elementos son las filas
de la matriz, que a su vez son vectores de elementos de la matriz. Usando
directamente declaraciones de tipos vector podríamos escribir la declaración
de una matriz de números enteros de la siguiente manera:

¡const int NumFilas = 10;

¡const int NumColumas = 15;

typedef int TipoElemento;

'[eypedef TipoElemento TipoFila[NunColumas];
¡typedef TipoFila TipoMatriz[NumPilas];

Para designar un elemento de la matriz se usará un doble subíndice:

¡TipoMatriz matriz;

 

triz[3][5] = 27;

La declaración de una matriz puede simplificarse en cierta medida respocto a
la notación anterior dado que no es necesario declarar un tipo intermedio para
las filas de la matriz. Por ejemplo:

 
  
  
    
    

290 Fundamentos de progr:

 

const int NumFilas = 10;

const int NumColumnas = 15;

typedef int TipoElenento;

typedef TipoElemento TipoMatriz[NunFilas] [NunColumas] ;

TipoMatriz matriz;

Como recordatorio, repetiremos aquí las reglas sintácticas de la definición
formaciones, de una o varias dimensiones.

 

Tipo_formación 333 typedef Identificador_de_tipo_elemento
Identificador_de_tipo_formación Dimensiones ;

Dimensiones 132 Tamaño Í Tamaño Y

Tamaño ++= [ Número_de_elementos 1

11.2.2 Operaciones con matrices

Las operaciones con elementos individuales de una matriz pueden hacerse
rectamente, de forma análoga a la operación con variables simples de ese tá
En cambio las operaciones globales con matrices han de plantearse de
similar a las operaciones globales con vectores. En general habrá que
elemento a elemento, o a lo sumo por filas completas

Por ejemplo, para imprimir matrices del tipo declarado anteriormente
mos escribir;

void EscribirMatriz( const TipoMatriz m ) [
for (int i =0; i < NumFilas; 4++) (
for (int j =0; j < NunColumas; j++) (
print£( "%10d", m[i][31 3;

+
print£( "a" );
7
y

En este ejemplo se ha operado directamente con cada elemento de la
usando un doble bucle para recorrerla. También es posible operar con la
por filas completas, y detallar por separado cómo se opera con cada fila.
supuesto, esto requiere haber definido explícitamente el tipo de las filas:
 
  
  
   
 
   
   
   
   
 
   
   
 
 
   
   
 
  
 
 
  
  

Estructuras de datos 291

 

EscribirFila( const TipoFila f ) (
for (int i ; i < NumColumnas; i++) £
print£( "*10d", £[i] );

 

,
print£( "Ya" );

EscribirMatriz( const TipoMatriz m ) £
for (int i = 0; i < NumPilas; i++) (
EscribirFila( m[i] );

 

comienzo de este tema se ha mencionado la posibilidad de definir arguitos de tipo vector como vectores abiertos, de tamaño indefinido. Podemos
en generalizar ese mecanismo y permitir el uso de argumentos de timatriz abierta. Lamentablemente los lenguajes Co C++, y por lo tanto
no lo permiten. El siguiente fragmento de código provoca un error de
pilaci
EscribirMatrizAbierta( const int m[1[], /* <-— ERROR */
int filas, int columnas )

 

supuesto, si se manipula una matriz como vector de vectores sí se pueusar el mecanismo de vector abierto, pero limitado a formaciones de una
sión cuyos elementos tienen un tipo explícito de tamaño conocido. A
'inuación se repite el código de ejemplo anterior ligeramente modificado
usar en lo posible el mecanismo de vector abierto, aunque de hecho no
ninguna ventaja importante:

EscribirFila( const TipoElemento f[], int columnas ) f

for (int i = 0; i < columas; i++) £

print£( "x10d", £[1] );

3
printf( "wn" );

EscribirMatriz( const TipoFila m[] ) £

for (int i = 0; i < NumPilas; i++) (
EscribirFila( m[i], NunColumnas );

3

 

realmente se necesita definir operaciones genéricas con formaciones de diiones indefinidas hay que recurrir al uso explícito de punteros, tal como
verá en el tema 13.
 

   
 
    
    

292 Fundamentos de programación.

 

11.23. Ejemplo: Contrastar una imagen

Las imágenes almacenadas por puntos (pizels) son un ejemplo típico de e=tructura matricial. Este programa trabaja con una imagen monocroma en
que cada punto puede tener un nivel de gris que varía de 0 a 5. La imagen
introduce como dato en forma de matriz de caracteres numéricos, con una
por línea de texto, y a continuación se constrasta convirtiéndola a imagen
sólo niveles de blanco o negro puros. La imagen se presenta a la salida tame
bién como matriz de caracteres, usando caracteres apropiados para aproxi
visualmente los distintos niveles de gris. El listado completo del programa
el siguiente:

 

 

 

e
* Programa: Contrastar

* Descripción:

+ — Este programa convierte una imagen digitalizada
+ a niveles de blanco y negro puros

A RA AAA

tffinclude <stdio.h>

 

const int Ancho
const int Alto

const int Blanco
const int Negro

4 anchura de la imagen */
2 altura de la imagen */

0;  /* nivel bajo de grises = blanco */
5;  /* nivel alto de grises = negro */

 

mua

typedef int Imagen_t[Alto][Ancho];

/** Leer la imagen */
void LeerImagen( Imagen_t imagen ) (
char c;

for (int i=0; i<Alto; i++) (
for (int j=0; j<Ancho; j++) €
scanf( " %e", be );
imagen[i][J] = ánt(c) - int('0");

 
Contrastar la imagen */
Contrastar( Imagen_t imagen, int nivel ) [
for (int i=0; i<Alto; i++) (
for (int j=0; j<Ancho; j++) £
if (imagen(i][j] <= nivel) (
imagen[i][j] = Blanco;
J else (
imagen[i][j] = Negro;

  

22 Imprimir la imagen */
Imprimir( const Imagen_t imagen ) £
const char Punto[6] = ([' ', *.',

  

for (int i=0; i<Alto; 1++) (
for (int j=0; j<Ancho; je) 4
print£( "%c", Punto[imagen[i1[j1] );
y
primt£("
3

 

y

        
 

/** Programa principal */
int main()
Imagen t imagen;

LeerImagen( imagen );
print£f( "Imagen inicial:Ya" );
Imprimir( imagen );

Contrastar( imagen, 3 );
print£( "AnImagen contrastada:Xn" );
Imprimir( imagen );

 

A continuación se presenta un ejemplo de la ejecución de este programa. Los
datos de entrada contienen un carácter por cada punto de la imagen, y simulan
una rejilla. Los datos son:

 

 
 

294

 

Fundamentos de programación:

 

 

0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212344
5432101234543210123454321012345432101233
4543212345454321234545432123454543212344
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432
0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212345
5432101234543210123454321012345432101234
4543212345454321234545432123454543212345
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432

El resultado de la ejecución del programa es el siguiente:

 

 

 

Imagen inicia

AER ANA AR AAN
AR CUA AA ACA
ARS NC OS AO RAR
AMEN OC O RR O oo pe
HA ARA A ACRO A
HA ARA A AO A
HA ARA A ONO
AMA mc oo o po occ
AAA RN O GO
AX OR A AC AICA

ARA A AO AN
AR OU AU AO
ARO EA ONO NC ANO RNORA
ARA A O o e
FA AO ORO A ANA OA
MNR ARA A ARA A
FR AAN OU ACA OA
XRO RANA NOAA
ARE ARO CEC RIORAA
ANTAS BA AO CNA

 
Estructuras de datos 295

 

Imagen contrastada:
qe sd 444 44
ARA AA Aud HR
PARAR AA AA RAR
EBRO RRRAA AAA HA
... ARA Aun ARA ud
.. ql sel Hu
+. id HneeA AN 44
FER HAN RA da AE
BAR a0A AR RAR AA AR A A
q HEAR Het HR
q. e sn q
de HA Hee AA
HER ANA HGARAR RA RAR AR A
id
+ AAA, HA A +.
+ a +“. dad *
se qe HR A *.
FERRAN RARA RA
ENACARR HR AAA HARO RRA
HANA ee AAA AMARA

11.3 El esquema unión

Hay aplicaciones en las que resultaría deseable que el tipo de un dato variase
según las circunstancias. Si las posibilidades de variación son un conjunto
finito de tipos, entonces se puede decir que el tipo del dato corresponde a un
esquema que es la unión de los tipos particulares posibles. Cada uno de los
tipos particulares constituye una variante o alternativa del tipo unión. Representaremos simbólicamente este esquerna de forma similar a las alternativas
en las reglas de sintaxis BNF:

 

 

tipo_unión = variante | variante ..

Como situaciones típicas en las que se pueden aplicar los esquemas unión
tenemos, entre otras, las siguientes:

+ Datos que pueden representarse de diferentes maneras.
+ Programas que operan indistintamente con varias clases de datos.
+ Datos estructurados con elementos opcionales.

Algunos ejemplos concretos serían:

número_general 3 entero | fracción | real

 
 

296 Fundamentos de programación

 

coordenadas = coordenadas cartesianas | coordenadas polares

figura = punto | círculo | cuadrado | rectángulo | rombo | triángulo |
clipse

datos_persona = datos_soltero | datos_menor | datos casado

El primer caso correspondería a 1m programa que opere indistintamente com
números de diferentes clases. Los números enteros son datos simples, al igual
que los reales, aunque las colecciones de valores son diferentes. Los números
fraccionarios se representan como dos números enteros (numerador y denoménador).

En el segundo caso tenemos dos sistemas de coordenadas diferentes para repre
sentar los puntos del plano. Las coordenadas cartesianas son dos longitudes.
mientras que las polares son una longitud y un ángulo.

 

En el tercor caso tenemos un programa que maneja un repertorio limitado de
elementos gráficos. Para cada figura se necesitará conocer una colección de
parámetros diferentes.

En el último caso, los datos de un soltero mayor de edad constituirían la
información básica de una persona. Los menores deberían tener además un
tutor o persona responsable de ellos, y los casados deberían tener uma fecha
de matrimonio y un cónyuge.

11.3.1 El tipo union

Los esquemas unión pueden utilizarse en programas en C+ definiéndolos como
tipos union. Un tipo union se define como una colección de campos alternativos, de tal manera que cada dato particular sólo usará uno de esos campos
en un momento dado, dependiendo de la alternativa aplienble. La definición
es similar a la de un agregado o struct, usando ahora la palabra clave union.
Por ejemplo:

typedef struct TipoFraccion (
int numerador;
int denominador;

 

typedef union TipoNumero 4
int valorEntero;
float valorReal;
TipoFraccion valorRacional;

 
turas de datos 297

   
 
  
  
   
 
   
  
  
  
 
  
  
   
  
  
  
   
   
 
   
 
 
  

 

referencia a los elementos componentes se hace también como en los tipos
Ct:

Numero numero, otro, fraccion1, fraccion2;

:ro.valorEntero = 33;
'o.valorReal = float(numero.valorEntero);
'cion2.valorRacional = fraccion1.valorRacional;

una variante de una unión es a su vez otra tupla o unión habrá que usar
tos cualificadores para designar los campos anidados:

iccion1.valorRacional.numerador = 33;
Íccion1.valorRacional.denominador = 44;

mo se ha dicho, sólo una de las variantes puede estar vigente en un momento
lo. Si asignamos valor a una de ellas será ésta la que exista a partir de ese
mento, al tiempo que dejan de existir las demás:

 

 

|, fraccion1.valorEntero ); /% Correcto */
intf( "Xd", fraccion1.valorRacional.denominador ); /* ERROR */

Es fácil darse cuenta de que un dato de un tipo unión no contiene en sí mismo
información de cuál es la variante activa en nn momento dado. Dicha información debe estar disponible de forma clara por otros medios. Si no es así,
será muy fácil que se produzcan errores. Por ejemplo, al redactar un procedimiento para imprimir un dato del TipoNumero deberíamos pasar también
como argumento una indicación de la variante aplicable:

¡typedef enum ClaseNumero (Entero, Real, Fraccion);

   

 

'woid EscribirNumero( TipoNumero n, ClaseNumero € ) 4

switch (c) (

case Entero.

print£( "%d
break;

case Real:

print£( "%f", n.valorReal );

break;

case Fraccion:

print£f( "%d/x%d", n.valorRacional.numerador, n.valorRacional.denominador );

break;

default:

print£( "2222" );

 

, n.valorEntero );

)
y

 
 

  
   
    
   

298 Fundamentos de programación:

11.32 Registros con variantes

El hecho de que un dato de tipo unión deba ir acompañado de inform
complementaria para saber cuál es la variante aplicable hace que los ti
unión aparezcan casi siempre formando parte de estructuras más complejas.

Un ejemplo frecuente es lo que se denominan registros con variantes. Se t
de agregados o tuplas en los que hay una colección de campos fijos, aplical
en todos los casos, y campos variantes que se definen según el esquema unión.
Además suele reservarse un campo fijo para indicar explícitamente cuál es
variante aplicable en cada momento. A dicho campo se le llama discrimina:

A continuación se recodifica el ejemplo anterior usando esta técnica:
typedef enun ClaseNumero (Entero, Real, Fraccion);

typedef struct TipoFraccion (
int numerador;
int denominador;

E

typedef union TipoValor (
int valorEntero;
float valorReal;
TipoFraccion valorRacional;

typedef struct TipoNumero (
ClaseNumero clase; /* discriminante */
TipoValor valor;

E

void EscribirNumero( TipoNumero n ) f
switch (n.clase) 4
case Entero:
printf£( "%d", n.valor.valorEntero );
break;
case Real:
printf( "Xf", n.valor.valorReal );
case Fraccion:
printf( "*d/xd", n.valor.valorRacional.numerador,
n.valor.valorRacional.denominador );
break;
default:
print£( "2
,

 
   
  
   
 
 
 
 
 
  
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
 
  

Estructuras de datos 299

 

pb

Si el tratamiento de los registros con variantes se hace sólo mediante subprogramas que comprueban siempre el discriminante antes de operar, el código
resulta mucho más seguro. Esta garantía de seguridad compensa perfectamente el esfuerzo adicional que representa definir y usar estructuras anidadas,
como en este ejemplo. Además el uso de los subprogramas de manipulación es
ahora más sencillo, ya que basta pasar como argumento sólo el propio dato,
que tiene en sí mismo toda la información necesaria.

11.4 Esquemas de datos y esquemas de acciones

Una vez presentadas las estructuras de datos de tipos formación y registro,
incluidos los registros con variantes, es interesante hacer notar la analogía que
puede establecerse entre los esquemas de acciones y los esquemas de datos.

La programación estructurada recomienda usar los esquemas más sencillos
posibles para organizar un elemento complejo de un programa a partir de
elementos más simples. Recordaremos que estos esquemas básicos eran la
secuencia, la selección, y la iteración, en el caso de acciones compuestas.

Estos esquemas se corresponden, respectivamente, con los esquemas tupla,
unión y formación, definidos para las estructuras de datos. La analogía se pone
de manifiesto si describimos dichos esquemas de forma generalizada, común a
los datos y acciones.

Tupla - Secuencia: Colección de elementos de tipos diferentes, combinados
en un orden fijo.

Unión - Selección: Selección de un elemento entre varios posibles, de tipos
diferentes.

Formación - Iteración: Colección de elementos del mismo tipo.

Todavía puede manifestarse la analogía con más intensidad si observamos que
el tratamiento de las componentes de una estructura de datos se realiza fácilmente con una acción compuesta de tipo análogo. Por ejemplo:

/* ESQUEMAS DE DATOS */

Esquema Tupla */
typedef struct TipoTupla (
char uno, dos, tres; :
h
TipoTupla agregado;
 

  
    
   

300 Fundamentos de progra

 

/* Esquema Unión */
typedef union TipoUnion 4
int alfa;
float beta;
TipoUnion variante;
bool numeroEntero;

/* Esquema Formación */
typedef int TipoFormacion[10];
TipoFormacion vector;

/* ESQUEMAS DE ACCIONES */

/* Secuencia para imprmir los campos una Tupla */
print£( "%c", agregado.uno );
printf( "%c", agregado.dos );
print£( "%c", agregado.tres );

 

/* Selección para imprimir las variantes de una Union */
if (numeroEntero) £
print£( "%d", variante.alfa );

 

) else (
print£( "%£", variante.beta );
y
/* Iteración para imprimir una Formación */
for (int k=0; k<10; k++) 4
print£( "%d", vector[k] );

y

Para imprimir el contenido de cada estructura de datos se ha utilizado
samente la acción compuesta de estructura análoga.

11.5 Estructuras combinadas

Como en cualquier otro lenguaje de programación actual, en CE se
combinar entre sí los esquemas tupla, nión y formación para definir
turas de datos complejas, exactamente igual a como se combinan la s
selección e iteración para construir el código de acciones complejas, De
ya se ha hecho así en algún ejemplo anterior
   
 
 
    
   
  
 
 
 
 
  
 
  
  
  
   
 
   
  
  
 
  
  
 
   
   

Estructuras de datos 301

 

Una característica de los lenguajes de programación modernos es que se pueden
combinar con bastante libertad elementos de la misma naturaleza. Esto ocurre
en Ci con las sentencias estructuradas, que permiten anidar esquemas de tipo
secuencia, selección e iteración unos dentro de otros.

Con las estructuras de datos ocurre algo similar. Se pueden definir estructuras
cuyas componentes son a su vez estructuras, sin límite de complejidad de los
esquemas de datos resultantes.

 

11.5.1 Formas de combinación

La manera de combinar las estructuras de datos es hacer que los elementos de
una estructura scan a su vez otras estructuras, sin limitación en la profundidad
de anidamiento. Podemos analizar algunos ejemplos:

typedef struct TipoPunto (
float x, y;

typedef TipoPunto TipoTriangulo[3];

const int MaxPuntos = 100;
typedef TipoPunto TipoPuntos[MaxPuntos];

typedef struct TipolistaPuntos (
int numeroPuntos;
TipoPuntos puntos;

¡typedef TipoListaPuntos Poligonal; /* línea abierta */
TipoListaPuntos Poligono; /* línea cerrada */

En estos ejemplos tenemos la representación de un triángulo como una formación de tres puntos, que son registros. La lista de puntos se estructura
“somo un registro, uno de cuyos campos es una formación de puntos, que son
asu vez registros. Las últimas declaraciones definen tipos sinónimos de la
'a de puntos, general, con nombres particulares para ser usados en casos
"particulares.

s siguientes ejemplos definen registros que contienen campos que son cadede caracteres. El último ejemplo es un registro que contiene a su vez otro
istro anidado.

char TipoNombre[20];
char TipoApellido[301;
 

 

302 Fundamentos de program:

 

typedef char TipoLineaTexto[40];
typedef enum TipoProvincia 1
SinProvincia, Alava, Albacete,
... Zaragoza
+
typedef struct TipoNombreCompleto 4
TipoNombre nombre;
TipoApellido apellido1, apellido;
5

typedef struct TipoDomicilio (
TipolineaTexto calle;
int numero;
TipolineaTexto zona, poblacion;
int codigoPostal;
TipoProvincia provincia;

 

3

typedef struct TipoDatosPersonales £
TipoNombreCompleto nombreyApellidos;
TipoDomicilio domicilio;

 

3

      
 

Cuando se utilizan estructuras combinadas, para hacer referencia a una come
ponente en particular hay que usar los selectores apropiados, encadenados uno
tras otro. Como ejemplos de uso de las estructuras definidas en este apartado.
podemos poner:

Tipolriangulo pieza;
TipoListaPuntos camino;
TipoDatosPersonales empleado;

pieza[0].x = 2.33;
pieza[0].y = -3.45;
pieza[1].x = pieza[1].y;
pieza[1].y = 88.3;

camino .numeroPuntos
camino.puntos[0].x = 5.67;

camino -puntos[0)].y = 7.21;
camino.puntos[1] = pieza[2];
camino-puntos[2] = camino.puntos[1];

 
 

 

strcpy( empleado.nombreyApellidos.nombre, "Alberto");
print£( "%s", empleado.domicilio.calle );
if (empleado.domicilio.poblacion[0] == 'N0') 4

 
 

Estructuras de datos 303

 

printf( "Sin domicilio” );
3

En estos ejemplos aparecen combinados los selectores de campo de registro
y de componente de formación. La combinación es admisible cuando una
componente de una estructura es a su vez una estructura de datos. A cada
estructura se debe aplicar el selector que le corresponda.

11.5.2 Tablas

Aunque el estudio de las estructuras de datos excede del ámbito de este libro,
resulta interesante mencionar algunos esquemas típicos que se obtienen combinando estructuras básicas. Este es el caso del esquema de tabla, que puede
plantearse como una formación simple de registros. En otros contextos se le
da también el nombre de diccionario o relación. Los esquemas de tabla son el
fundamento de las bases de datos relacionales, aunque su implementación es
muy diferente de las estructuras simplificadas que se presentan aquí.

Por ejemplo, podemos definir una tabla destinada a contener la identificación
de las provincias:

typedef enum TipoProvincia (
SinProvincia, Alava, Albacete,
..- Zaragoza
+
const int MaxProvincias = int(Zaragoza);
typedef char TipoSiglas[2);
typedef char TipoNombre[30];

typedef struct TipoDatosProvincia (
TipoSiglas siglas;
TipoNombre nombre;
int codigo;

5

typedef TipoDatosProvincia TipoTablaProvincias[MaxProvincias+1];

TipoTablaProvincias provincias;

En esta tabla se podrán almacenar los valores apropiados, asignándolos a. los
correspondientes campos, Por ejemplo:

provincias[Cadiz].siglas[0] = 'C';
provincias[Cadiz].siglas[1] = 'A*
strcpy( provincias[Cadiz].nombre, "Cádiz”);
provincias[Cadiz].codigo = 11;

  
  
   
  
  
   
     
  

304 Fundamentos de programación:

 

Estos datos podrán ser usados luego en programas que manejen direcci
postales, matrículas de coches, etc.

Pueden construirse estructuras de datos bastante complejas combinánd:
de manera que en algunas de ellas hagamos referencia a datos almacenados.
en otras. Una forma de hacer referencia a los datos de una. tabla es usanda:
el índice correspondiente a la posición de cada registro. A continuación se
muestra un ejemplo para manejo de figuras geométricas definidas a partir de:
puntos:
typedef struct TipoPunto (

float x, y;
5
const int MaxPuntos = 1000;
typedef int TipolndicePunto;
typedef TipoPunto TipoTablaPuntos [MaxPuntos];

      

typedef TipoIndicePunto TipoTriangulo[3];

typedef struct TipoCirculo (
TipolndicePunto centro;
float radio;

E
TipoTablaPuntos puntos;

En este ejemplo, la tabla puntos almacena las coordenadas de todos los puntos
utilizados para definir cualquiera de las figuras geométricas que se manejan.
Las figuras se definen almacenando referencias a los puntos de la tabla, em
lugar de almacenar directamente las coordenadas de los puntos. Un triángulo
T definido por tres puntos A, B y C se podría registrar, por ejemplo, almacenando los puntos, arbitrariamente, en las posiciones 10, 11 y 12 de la tabla de
puntos:

Tipolriangulo trianguloT;
LeerPunto( puntos[10] ); /* punto A */

LeerPunto( puntos[11] ); /* punto B */
LeerPunto( puntos[12] ); /* punto C */

 

trianguloT[1] = 10; /* punto A */
trianguloT[2] = 11; /* punto B */
trianguloT[3] = 12; /* punto C */

 

 
Estructuras de datos 305

 

Como se decía, la tabla de puntos combina la información de todos los puntos
de todas las figuras. Por ejemplo, se pueden definir círculos centrados en los
vértices del triángulo T:

TipoCirculo cl, c2, c3;

el.centro = 10; /* punto A */
cl.radio = 3.3;
c2.centro = 11
c2.radio = 3.3;
e3.centro = 12; /* punto C */
|c3.radio = 3.3;

/* punto B */

 

El centro del círculo 1 es exactamente el mismo punto que el vértice A del
triángulo, Si desplazamos esc punto se moverán a su vez el vértico y el círculo:

puntos[10].x
Ipuntos[10] .y

puntos[10].x + 2.5;
puntos[10].y + 4.3;

11.53. Ejemplo: Gestión de tarjetas de embarque

Este programa es una nueva versión más completa del ya presentado en el tema
10 para realizar la gestión de las plazas de un avión e imprimir las tarjetas de
embarque. Ahora se puede asignar una plaza del avión de manera individual.
También se puede reservar un grupo de dos a seis plazas de forma automática
asignando asientos de la misma fila cuando sea posible. Antes de que las plazas
asignadas antomáficamente pasen a estar ocupadas se solicita confirmación de
la operación.

Las plazas se gestionan como una tabla o vector de filas. Cada fila es un
registro con un vector con el estado de cada asiento, e información precalculada
del múmero y posición de las plazas contiguas que haya, con o sin pasillo en
medio. Cada plaza puede estar vacía, ocupada o reservada. El estado de
reservada es transitorio hasta que se confirma la asignación automática y pasa
a estar ocupada, o no se confirma y vuelve a quedar libre. También se mantiene
actualizado un contador del número total de plazas libres.

 

El procedimiento PintarPlazas es el encargado de mostrar la situación de
todas las plazas del avión. El procedimiento ImprimirTarjeta os el encargado
de escribir la tarjeta de embarque de una plaza del avión.

La función BuscarPlazas es la encargada de realizar el algoritmo para situar
las plazas solicitadas. En un primer intento se trata de asignar las nuevas
plazas en la misma fila y lado del pasillo. Como segundo intento se asignarán

 
306 Fundamentos de programación

 

plazas correlativas en la misma fila aunque tengan el pasillo en medio, Si
eso tampoco es posible se irán asignando los asientos de uno en uno según
haya sitios libres empezando por la primera fila. Cuando no hay suficientos plazas disponibles se dará un mensaje. Esta función utiliza las funciones
MarcarPlazasJuntas, MarcaPlazasJuntasConPasillo y MarcarPlazas que
implementan respectivamente cada una de las preferencias indicadas.

El procedimiento ConfirmarPlazas es el encargado de pasar las plazas reservadas bien a ocupadas o bien a vacías dependiendo de si se confirman o no las
reservas. Además, este último procedimiento es el encargado de actualizar el
número total de plazas libres después de la asignación.

 

El programa consiste en nn menú con cuatro opciones (Plaza, Grupo, Estado y
Fin). La opción de Plaza permite elegir y ocupar una plaza concreta si no está
venpada. La opción Grupo utiliza la función BuscarPlazas para la búsqueda
de 2 a 6 plazas libres y reservarlas. Estas plazas deben ser confirmadas con el
procedimiento ConfirmarPlazas. Para mostrar la situación de la ocupación
del avión se dispone de la opción Estado.

Todo el programa está realizado en base a las constantes del número de filas
NumPilas, y los asientos por fila AsientosFila. Cualquier tamaño de avión
con el mismo formato se puede gestionar cambiando estas dos constantes. El
listado completo del programa es cl siguiente:

 

AAA A DAA

* Programa: Mostrador?

* Descripción:

Este programa confecciona tarjetas de embarque

* — y asigna plazas en la misma fila si es posible
aa Rana na er n Are nana

sinclude <stdio.h>

+include <ctype.h>

 

const int NumFilas = 10; /* número de filas */
const int AsientosFila = 6; /* asientos por fila */
const int Pasillo = AsientosFila / 2;

typedef enum TipoEstado (vacio, ocupado, reservado);
typedef TipoEstado TipoOcupa[AsientosFila];
typedef struct TipoFila (

Tipo0cupa asientosOcupados;

int juntas; /* plazas seguidas al mismo lado */

int desde;  /* desde ésta */

int juntasP; /* plazas seguidas con pasillo en medio */
Estructuras de datos

 

int desdeP; /* desde ésta */
typedef TipoFila TipoPlazas[NumFilas];

/** Mostrar ocupación del avión */
void PintarPlazas( const TipoPlazas P ) f
const char DibujoAsiento[3] =4f * *, '*!, 'R' Dd;

print£('n A Bo oc DOE Fm;
for (int i =0; i < NunFilas; i++) (
printf( "X3d", 1 +1);
for (int j=0; j< AsientosFila; j+) £
if (j == Pasillo) £
primt£(”  ");

y
printf( " (%c)”, DibujoAsiento[P[i].asientosOcupados[¿]] >;

$
print£( “Wa” );

y
print£(a");
,

/%* Imprimir una "tarjeta de embarque" */
void InprimirTarjetal int fila, int asiento ) 4
primt£(
print£( TARJETA DE EMBARQUE
print£( "| Pila :X3d", fila );
printf( " Asiento :%3c |Yn", asiento );
primt£( "tm - ato);
y

/** Calcular múnero y posición de plazas contiguas */
void CalcularPlazasJuntas( TipoFila € fila ) £

int juntas = 0;

int juntasP =

fila. juntas =
fila.juntasP = 0
for (int j = 0; j < AsientosFila; j+s) (
if (j = Pasillo) (
juntas = 0;

if (fila.asientosOcupados[j] == vacio) (
juntas++;
juntasP++;
if (juntas > fila.juntas) (

 

 
 

308 Fundamentos de programación

 

fila.juntas
fila.desde =

juntas;
j - juntas + 1;

 

 

J

i£ (juntasP > fila.juntasP) (
fila.juntasP = juntasP;
fila.desdeP = j - juntasP + 1;

  

de
) else (
juntas = 0;
Juntas? =
y
3
+

 

/** Reservar plazas contiguas al mismo lado de la fila */
bool MarcarPlazasJuntas( int numero, TipoFila € fila ) £
if (fila.juntas < numero) £
return false;
) else 4
for (int j= 1; j <= numero; j+*) 4
fila.asientosOcupados[fila.desde+j-1] = reservado;
,
return true;
3
y

/** Reservar plazas contiguas a uno u otro lado de la fila */
bool MarcarPlazasJuntasConPasillo( int numero, TipoFila € fila ) £
if (fila. juntas? < numero) £
return false;
J else £
for (int j = 1; j <= numero; j+*) (
fila.asientos0cupados[fila.desdeP+j-1] = reservado;
7
return true;
y
3

/** Reservar plazas contiguas o no en la fila */
void MarcarPlazas( int £ numero, TipoFila € fila ) (
int j

 

while ( numero > 0 8£ j < AsientosFila )
fila.asientosOcupados[j] = reservado;
numero--;

y
  
 
 
 
 
 
   
   
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
    
   
   
 
 
   

Estructuras de datos 309

3

/** Buscar plazas contiguas o próximas */
bool BuscarPlazas( int nuevas, int libres, TipoPlazas plazas ) [
int fila;

if (nuevas <= libres) (
/*-- Buscar plazas juntas en la misma fila --*/
fila = 0;
while (fila < NunFilas) (
if (MarcarPlazasJuntas( nuevas, plazas[fila]) )
return true;
+
filare;
3
/*-— Buscar plazas seguidas en la misma fila --%/
fila = 0;
while (fila < NumFilas) £
if (MarcarPlazasJuntasConPasillo(nuevas, plazas[fila])) (
return true;
J
fila++;
J
/*-— Ocupar plazas de una en una desde la primera fila —-*/
fila = 0;
while (muevas > 0) (
MarcarPlazas( nuevas, plazas[fila] );
,
return true;
J else
print£("No hay plazas suficientesin");
y
return fal:

 

* Confirmar o liberar plazas reservadas */
id ConfirmarPlazas( bool ok, TipoPlazas plazas ) £
bool cambio;

for (int i =0; i < NunFilas; i++) 4
cambio = false;
for (int j= 0; j<AsientosFila; j++) £
if (plazas[i].asientosOcupados[j] == reservado) £
if (ok) £
plazas[i].asientosOcupados[j] = ocupado;
ImprimirTarjeta(i + 1, char(int('A') + 5));
 

 

    

310 Fundamentos de progr:

cambio = true;
) else (
plazas[i].asientosOcupados[j] = vacio;
,
y

y
if (cambio) £
CalcularPlazasJuntas( plazas[i] );
+
E
y

/** Programa principal */
int main() (£
TipoPlazas pasaje;
int sitiosLibres;
char car;
int aux, fil, col;
bool seguir;

/*%- Iniciar todo vacío --*/
sitiosLibres = NunFilas * AsientosFila;
for (int i = 0; i < NumFilas; 4++) (
for (int j =0; j < AsientosFila; j+) (
pasaje[i].asientosOcupados[j] = vacio;

 

CalcularPlazasJuntas( pasaje[i] );

3

/*— Bucle de operaciones --*/
seguir = true;
while (seguir) £
printf( "¿Opción (Plaza, Grupo, Estado, Fin)?
scanf( " %c", ácar );
car = toupper(car);
switch (car) €

 

/*— Asignar una plaza determinada --*/
case 'P":
do (
print£( "¿Fila (1 a 10)? " );
scanf( "%d", daux );
) while (aux < 1 || aux > 10);
do (
print£( "¿Asiento (A a E)? " );
scan£( " %c", car );

 

 
:ructuras de datos

 

car = toupper(car);

) while (car < "A! || car > "E);

fil = aux - 1;

col = int(car - 'A');

if (pasaje[fi1].asientosOcupados[col1] == vacio) £
pasaje[fi1].asientosOcupados[co1] = ocupado;
sitiosLibres--;
CalcularPlazasJuntas( pasaje[fi1] );
ImprimirTarjeta(fil + 1, char(int('A') + col));
else (
print£("** Plaza OCUPADANn");

a
break;

/*-- Asignar automáticamente plazas contiguas --*/
case 'G' ;
do [
print£( "¿Número de plazas (2 a 6)? ");
scanf( "%d", baux );
) mhile (aux < 2 || aux > 6);
if (BuscarPlazas( aux, sitiosLibres, pasaje )) (
PintarPlazas( pasaje );
print£( "¿Confirmar (S/N)? ");
scanfí " %c", 8car );
if (toupper(car) == 'S') 4
ConfirmarPlazas( true, pasaje );
sitioslibres = sitiosLibres - aux;
) else (
ConfirmarPlazas( false, pasaje );

/*-- Dibujar estado de ocupación --*,
case 'E' :

PintarPlazas( pasaje );

break;

/*-— Fin del programa --*/
case 'F' :

seguir

break;

 

 
 

312 Fundamentos de programación

 

A continuación se muestra un fragmento de la ejecución del programa:

 

¿Opción (Plaza, Grupo, Estado, Fin)? p
¿Fila (1 a 10)? 4

¿Asiento (A a FJ? €

| TARJETA DE EMBARQUE |

| Fila: 4 Asiento: C |

 

A B Cc D E y

10M (650.00 td (1 009

2 000 0 MP
300010) 1) a PM

4 (90M cr Y

| 5 (19 6% €) CC) 1 E)
| 681) (001)
| ATA) 67010)
| 8 (1) 0) (y Cd €) (>
| 98 (3) (0) €) (3 0) ()
| 10 (3 41 (Y) (014)

¿Opción (Plaza, Grupo, Estado, Fin)? g
¿Número de plazas (2 a 6)? 4

A B e D E y
10064) 0 MM
2 0 € 4) O E)
3 (M4 4) 0 O +)
4 0) (1) CY €) €)
5 MM BM (1) ()
6 (9) E) (3) O (00)
TC) CD (7 EY (y €)
8 (9) (0) ()2 CY) () €)
8 (9) CY (J CY (Y €)
to (1 Ed EJ (3) (00)

¿Confirmar (S/N)? s

 

I TARJETA DE EMBARQUE |
| Fila: 5 Asiento: A |

      
 

 
 

313

 

      
 

TARJETA DE EMBARQUE |
| Fila: 5 Asiento: D |

 

ión (Plaza, Grupo, Estado, Fin)? g
ro de plazas (2 a 6)? 5

A BOC DOE F
0 0 (0 00 0)
O a 0 00 (m
0 a mM.
€) (1) Y (9) (1 Ca
0 Y) E) 0.1.6 0%
(R) (R) (R) (BR) (R) ()
EY (1 £I () €) €l
EY (9) €) Cd) 6% 67
SY €1 TD tc) EY El
ES €Y €) (ER

1 TARJETA DE EMBARQUE '
| Fila 6 Asiento : A |

 

| TARJETA DE EMBARQUE |
| Fila: 6 Asiento: E |

 

¿Opción (Plaza, Grupo, Estado, Fin)? g
¿Número de plazas (2 a 6)? 3

00
«0 (0
0) 0
Cr) (mm

An
Bossuonawna
>

 
 

 

 

 

314

¿Confirmar (S/N)? s

 

L-— TARJETA DE EMBARQUE |
| Fila: 4 Asiento: D |

 

 

1 TARJETA DE EMBARQUE |
| Fila: 4 Asiento: E |

 

1 TARJETA DE EMBARQUE |
| Fila: 4 Asiento: F |

¿Opción (Plaza, Grupo, Estado, Fin)? f

Fundamentos de programación
Tema 12

Esquemas típicos de operación
con formaciones

Cuando se trabaja con colecciones de datos es habitual que las operaciones
globales sobre la colección se realicen a base de operar con los elementos uno
a uno. Esto exige el empleo de esquemas de programas en los que se recorren
los elementos de la colección en un orden adecuado.

De momento se han introducido las estructuras de tipo formación (vectores
y matrices) para almacenar colecciones de datos. En este tema se introducen los esquemas típicos de operación con formaciones, incluyendo recorrido,
búsqueda, inserción y ordenación así como ciertas técnicas particulares que
facilitan su programación tales como centinelas y matrices orladas. Además,
para los esquemas básicos se realiza previamente su especificación formal y
se razona sobre la corrección de las implementaciones empleando los conceptos de precondición, postcondición, invariante y variante ya utilizados en los
temas 6 y 8.

 

Al igual que entonces, se emplea una notación lógico-matemática convencional,
con algunas simplificaciones y adaptaciones para hacerla más asequible a los
usuarios de lenguajes de programación C, C++ y similares. La notación se
describe de manera más precisa en el apéndice C.

 

 

En cualquier caso conviene recordar que las expresones lógico-matemáticas
no triviales son relativamente difíciles de leer, por lo que siempre deberían ir
acompañadas de una descripción en lenguaje natural que aclare el significado
esperado.
 

316 Fundamentos de programación

 

12.1 Esquema de recorrido

El esquema de recorrido consiste en realizar cierta operación con todos y cada
uno de los elementos de una formación (en algunos casos con parte de ellos
Evidentemente el esquema de recorrido se puede aplicar a formaciones de
cualquier dimensión tales como matrices con dos o más índices. Sin embargo,
para facilitar la compresión las explicaciones se circunscriben al caso de un
vector (una dimensión).

 

La forma más general del esquema de recorrido sería:
iniciar operación
while (quedan elementos sin tratar) 4

elegir uno de ellos y tratarlo

y

completar operación

 

La corrección de este esquema, en términos generales, está garantizada por
su propia construcción. Al final del bucle la condición de repetición (quedan
elementos sin tratar) habrá dejado de cumplirse, y por tanto se cumplirá
su complemento (todos los elementos han sido tratados). Por otra parte la
terminación del bucle while está garantizada, ya que el número de elementos
que faltan por tratar es un valor finito no negativo, que va disminuyendo en
cada iteración, es decir, la expresión variante es simplemente el (número de
elementos sin, tratar).

 

Si es aceptable tratar todos los elementos en el orden de sus índices, el esquema
de recorrido se puede concretar como un bucle for, más sencillo de entender.
Para el caso de un vector v (una dimensión) con un número N de elementos
(los índices van de O a N-1):

const int N = 0

typedef ... T_Elemento ...;
typedef T_Elemento T_Vector[N];
T_Vector v;

   

iniciar operación

for (int i<N; de) 4
tratar vfi]

Si

completar operación

 

Como ejemplo, la siguiente función calcula la suma de los elementos de un
vector abierto de números reales. Para razonar su corrección, el código se ha
anotado con las aserciones correspondientes a. la precondición, postcondición
Esquemas típicos de operación con formaciones 317

 

y un invariante adecuado para el bucle. No es necesario identificar explícitamente la variante del bucle, ya que todo bucle for de CE tiene garantizada su
terminación.

float SumaV( const float v[], int N )4

 

   

«PRE: »
float suma =
«INVARIANTE: suma= YD u(0
for (int 1-0; iN; i++) £

 

suma = suma + v[i];

+

return suma;
«POST: SumaV(w,N) =D of0 .. N— 1)»
y

En este ejemplo la precondición queda vacía (vale siempre “cierto”), porque
siempre sc puede obtener la sama de los elementos del vector, incluso aunque
tenga tamaño 0. La inicialización de la operación global consiste en poner a
cero la variable suma. El invariante indica que la variable suma al comienzo de
cada iteración contiene la suma de los elementos ya procesados. La termina
de la operación no exige ninguna acción adicional. La postcondición expresa
que la variable suma al terminar la operación contiene la suma de todos los
elementos del vector. Esto se deduce del hecho de que al final del recorrido
todos los elementos han sido procesados.

 

Otro ejemplo ilustrativo es obtener el valor máximo de los números almaconados en un vector. En este caso el esquema es algo más complejo porque
el máximo sólo existe si hay al menos un elemento, y además el tratamiento del primer elemento es diferente al de los demás. Si tratamos de seguir
directamente el esquema inicial tendríamos lo siguiente:

 

|float MaximoV( const float v[], int N ) f
«PRE: N>0»
float max;

«INVARIANT =0V maz =mazimo(ul0 .. i— 1)»
for (int 1=0; ixN; d+) £
i£ (i=0 || vlilmax) £
max = v[il;
F

 

3

return max;
«POST: MascimoV(v, N) =maximo(v(0 .. N—1])»
,
318 Fundamentos de programación:

 

El invariante contiene una doble condición. En general nos dice que la vari:
max contiene en todo momento el valor máximo de los clementos que ya ham
sido procesados (maz = mazimo(v[0..i — 1))), y por tanto al final tendrá
el valor máximo de todos los clementos del vector. Como caso especial al:
comienzo del bucle (¿ = 0) no se impone ninguna restricción al valor de
variable max, ya que el máximo no está definido para una colección de cera:
elementos.

   

 

Si queremos evitar la doble condición (i==0 || v[iJ>max) dentro del bucle.
podríamos tratar el primer elemento por separado, fuera del bucle, y recorrer”
iterativamente los restantes elementos a partir del segundo:
float MaximoV( const float v[], int N )£

«PRE: N>0»
float max;

max = v[0];
«INVARIANTE : max =mazimo(vÍ0 .. i—1))»
for (int i=1; i<N; i++) (
if (vlipmaod (
max = v[i];

 

y
y
return max;
«POST: MarimoV (o, N) = mazimo(v[0 .. N— 1)»
y

12.1.1 Recorrido de matrices

Si la formación es de tipo matriz, para hacer el recorrido se necesitan tantos
for anidados como dimensiones tenga la formación. Por ejemplo, el recorrido
es la operación típica que se debe realizar con una formación cuando se quieren
inicializar todos sus elementos. El siguiente fragmento de código muestra cómo.
inicializar a cero todos los elementos de la una matriz z de números enteros. Se
prescinde de formalizar los razonamientos de corrección por ser trivial en este
caso, ya que el tratamiento de cada elemento es completamente independiente
del de los demás, y no hay variables intermedias que vayan acumulando el
resultado de cada repetición.

const int N=...;

typedef int TMatriz[N][N];

TMatriz z;
   
 
   
   
  
  
  

uemas típicos de operación con formaciones 319

 

Cint d=0; i<N; i++) (
for (int j=0; ¿N; Jn) 1

211103]
$

  
 

Si se quieren escribir los valores de la matriz z, por filas, se puede utilizar el
mismo esquema, en el que al finalizar cada fila se salta a una nueva línea:
print£( "Ya" );
(int i=0; i<N; i++) 4
for (int j=0; ¿eN; je) tí

print£( "%sd", 21i](3] );

 

y
print£( “Ya” );

La multiplicación de dos matrices x e y para dejar el resultado en la matriz z es
un ejemplo muy interesante de recorrido. Primero se inicializa cada elemento
de la matriz z[1] [3] a cero utilizando el esquema anterior. A continuación,
al mismo elemento inicializado se le van sumando los productos de cada uno
de los elementos de la fila i de la matriz x por los correspondientes elementos
de la columna j de la matriz y . Este cálculo de los productos para cada
elemento se consigue mediante otro recorrido anidado al de inicialización, sobre
los elementos de la fila/columna afectados:
for (int i=0; i<N; 1++) €
for (int j=0; ¿<N; j++) (
2111031
for (int

zli]13]
+

  

K<N; k++) 4
2131051 + x05J0:J*y0KJ03];

y

El razonamiento de corrección de los bucles externos es trivial. El razonamiento del bnele interno es similar al del ejemplo anterior de sumar los elementos
de un vector.

12.1.2 Recorrido no lineal

En los ejemplos anteriores el índice usado para controlar el bucle nos señala
directamente al elemento a procesar en cada iteración. En ciertos casos el
elemento a procesar debe elegirse realizando ciertos cálenlos, y el contador de

 

 
 

  
    
   
    
  
  

320 Fundamentos de progra

 

iteraciones sirve fundamentalmente para contabilizar el avance del recorrido:
detectar el final del bucle.

Un ejemplo puede ser la construcción de un cuadrado mágico, en el que
suma de los números de cada fila, columna y diagonal principal es sie
la misma. Si el lado es impar, se puede construir rellenando las casillas
números correlativos, empezando por el centro de la fila superior y a
en diagonal hacia arriba y a la derecha. Al salir del cuadro por un lado
pasa a la casilla correspondiente del lado contrario. Si la siguiente casilla
avance diagonal ya está ocupada no se avanza, sino que se desciendo a la e
inmediatamente debajo para continuar el recorrido. Para un cuadrado de
3 el proceso sería el mostrado en la figura 12.1

 

 

 

 

 

 

 

 

1 1 1 1
3 3
2 2J|4 2
1 1|6 1[6][8]1]6][8]1]6
3|5 3|5 3|5|7/[3/5/7|[3|5|7
4] [2][4] [2][4[ [2][4[ [2][419[2

 

 

 

 

 

 

 

 

 

 

 

Figura 12.1 Recorrido no lineal: construcción de un cuadrado mágico.

El fragmento de código que rellena el cuadro de tamaño N, suponiendo que
previamente todas las casilla tienen valor cero, sería:

 

const intN=.
typedef int TMatriz[N] [N1;
T Matriz cuadro;

int fil, col;

    

for (int k 3
cuadro[fil][co1]
fil = (£ilsN-D) %N;
col = (col+1) % N;
if (cuadro[fil][col] != 0) 4

£il = (fil+2) %N;
col = (col+N-1) % N;
+
+
Esquemas típicos de operación con formaciones

 

12,2 Búsqueda secuencial

En las operaciones de búsqueda secuencial se examinan uno a uno los elementos de la colección para tratar de localizar los que cumplen una cierta
condición. Si realmente queremos encontrar todos los que existan, entonces la
búsqueda equivale a un recorrido como los mostrados en la sección anterior.
Como ejemplo, si queremos determinar el número de Apariciones de un cierto elemento buscado dentro de un vector v podremos utilizar el esquema de
recorrido siguiente:

¡typedef ... T_Elemento ...;

int Apariciones( TElemento buscado, const T_Elemento v[], int N ) (
«PRE: »
int veces = 0;

«INVARIANTE : veces =cardinal(v[k=0 .. ¿—1), v[k] = buscado)»
for (int i=0; iN; i++) (
i£ (vlil = buscado) (
vecest+;
,
,
return veces;
«POST : veces =cardinal(u[k=0 .. N—1], v[k] = buscado)»
)

Si no necesitamos localizar todos los elementos que cumplen la condición sino

sólo uno de ellos, si lo hay, entonces no necesitamos recorrer la colección en

su totalidad. El recorrido se debe detener en cuanto se encuentre el elemento

buscado, y por tanto sólo será un recorrido completo cuando no se encuentre

el elemento buscado dentro de la colección. Este planteamiento del problema

indica que no se puede utilizar directamente una sentencia for de C£ para la

operación de búsqueda.

iniciar operación

while (quedan elementos sin tratar y no se ha encontrado ninguno aceptable) £
elegir uno de ellos y ver si es aceptable

y

completar operación

Como en el apartado anterior, utilizaremos para las explicaciones un vector v
de una sola dimensión con un número N de elementos (los índices van de O a
N-1). El objetivo es localizar si hay algún elemento con un valor dado, y en
este caso indicar su posición. Si no hay ningún elemento igual al buscado se

 
   
 
   
    
   
     
    

322 Fundamentos de progr:

 

devuelve uma posición negativa como indicación de fallo de la búsqueda.
esquema de búsqueda secuencial se puede plantear como:

typedef TElemento .

   

int Indice( T_Elemento buscado, const T_Elemento v[], int N ) £
«PRE: »
int pos = 0;

«INVARIANTE: Ningún elemento v(0.

«INVARIANTE : buscado £ vÍ0..pos — 1]»

while (pos<N 48 v[pos]!=buscado) (
pos++;

os— 1] es el buscado»

  

He
if (pos>=N) (
pos = -1;
y
return pos;
«POST : pos >0— v[pos] = buscado A. pos <0= buscado E v(0..N — 1]»
de

Cuando la búsqueda es infructuosa la posición pos llega a tomar un valor i;
a N, que está fuera del margen superior del vector. La condición del bucle
no se cumple y el bucle finaliza, pero dicha condición incluye una refe
al elemento v[pos] que no existe. Afortunadamente, como se explicó en
tema 5, el operador 88 de C+ se evalúa “en cortocircuito”. Cuando la pri
condición (pos<N) ya es falsa no se continúa evaluando ninguna condición:
posterior dado que el resultado será necesariamente falso. Si se hubiese escrito
(v[pos] !=buscado £% pos<N) sí se podría intentar acceder al elemento v[N].
que no existe y provocar errores graves en el programa.

 

12.3 Inserción

El problema que se plantea aquí es insertar un nuevo elemento en una colección:
de elementos ordenados, manteniendo el orden de la colección. Se supone que
los elementos están almacenados en un vector, ocupando las posiciones desde
el principio, y que queda algo de espacio libre al final del vector (si el vector
> lleno no se podrían insertar muevos elementos)

   

La operación se puede realizar de forma iterativa, examinando los elementos
empezando por el final hasta encontrar uno que sea inferior o igual al que se
quiere insertar. Los elementos mayores que el que se quiere insertar se van
moviendo una posición hacia adelante, con lo que va quedando un hueco en
 
  
 
 
 
 
 
 
 
 
   
  
    
  
  
   
    
 
   
   
    

Esquemas típicos de operación con formaciones 323

 

'medio del vector. Al encontrar un elemento menor que el nuevo, se copia el
"muevo elemento en el hueco que hay en ese momento. La figura 12.2 muestra un
sjemplo de inserción en una colección de valores muméricos enteros ordenados
de manera creciente. El nuevo valor 10 debe insertarse entre el 8 y el 11.

w>of1ilslsalaii5s 21 |... M

wise 23

m>|1 5 8|1 15|23| --...
10>| 1 5 8 1 |15|23| ..... [ ]
17]

Figura 12.2 Inserción de un nuevo elemento.

 

 

 

 

 

 

 

 

 

 

Un esquema general del código de la operación sería:

Iniciar inserción

while ( ! Final 8£ ! Encontrado hueco ) £
Desplazar elemento

Pasar al siguiente elemento

y

Insertar nuevo elemento

A continuación se concreta este código para la inserción de un nuevo elemento
entre los N elementos de un vector, que ya están ordenados. Evidentemente,
después de la inserción, el vector tendrá un elemento más. Por tanto, el valor
de N siempre deberá ser menor que el tamaño del vector. En todo momento
el índice auxiliar j señala al punto en el que hay hueco:

typedef ... I_Elemento ...;
void Insertar( I_Elemento v[], int N, T_Elemento elemento ) (

«PRE: v[0..N —1] está ordenado»
int j=N;

 

«INVARIANTE : >
while (j > 0 88 elemento < v[j-11) (
v[j] = vijad;
d

 

elemento;

 
 
 

 

324 Fundamentos de programación

 

N] está ordenado y
ne los valores v[0..N —1] más “elemento”»

 

Es importante el orden en que se evalúan los términos de la condición del
bucle. Si se hubiese escrito (elemento < v[j-1] 88 j > 0) sería posible
intentar acceder al elemento v[-1], que no existe.

En este ejemplo se ha omitido escribir el invariante en medio del código, y

menos aún formalizarlo, por resultar muy prolijo. Dicho invariante, on lenguaje
natural, es:

«INVARIANTE: Los elementos delante del hueco están ordenados entre sé.
y los elementos detrás del hueco están ordenados entre sí y son mayores que
el nuevo, y los elementos delante del hueco son menores o iguales que los de
detrás del hueco, y la colección de valores delante y detrás del hueco coincide
con el contenido inicial del vector»

Por su parte la expresión variante es obvia:

«VARIANTE: Número de elementos delante del hueco» > «VARIANTE: ja

 

12.4 Ordenación por inserción directa

En este apartado se aborda una solución para la ordenación de datos almacenados en un vector. Existen diversos métodos de ordenación de vectores:
cuyo estudio cae fuera del alcance de este libro. El método de ordenación por
inserción directa es uno de los más sencillos y está basado en el esquema de
inserción mostrado en el apartado anterior. Por ejemplo, se trata de ordenar un vector v de diez elementos (índices de 0 a 9) y que inicialmente está
desordenado, tal como se muestra en la figura 12.3.

 

Figura 12.3 Vector inicial.

Para comenzar, el primer elemento (21) está ya ordenado consigo mismo. A.
continuación, extracmos el segundo elemento (5) y se genera un hueco, que
se puede utilizar para ampliar la parte del vector ya ordenada. El método
de ordenación consiste en insertar el elemento extraído en su lugar correspon
diente entre los elementos ya ordenados. Este proceso se repite con el tercero,
cuarto, quinto, ... y décimo elemento hasta quedar ordenado todo el vector.

 
  
   
 
  
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
 
  
  
  
  
   
   

Esquemas típicos de operación con formaciones 325

La secuencia de inserciones de los sucesivos elementos del vector se muestra
len la figura 12.4.

 

 

 

msotars: > [Blas Teisjslsl71218)
Insertar 3 IES IE 36] 7]2]45
Insertar 12
Insertar 65
Insertar 9
Insertar 36
Insertar 7
Insertar 2
Insertar 45
Final >[2]13]5[7]9 [12721136] 45] 65

 

 

Figura 12.4 Secnencia de inserciones para la ordenación

la secuencia se muestra con distinto fondo la posición del hueco inmediajente antes de la inserción del siguiente elemento. El final de la parte del
or ya ordenada se marca con una línea de mayor grosor. Además, los
¡eros ya ordenados también están en negrita. La inserción se realiza desde
posición anterior a la del elemento extraído.

continuación se muestra el código de una posible realización. La variavalor guarda el elemento extraído de la posición i. La ordenación total
vector se consigue mediante el recorrido de todos sus elementos, desde el
ido, para buscarles su hueco e insertarlos en él.

£ ... T_LElemento ...;

 
326 Fundamentos de progr

void Ordenar( T_Elemento v[], int N ) €
«PRE: »

T_Elemento valor;

int 3;

«INVARIANTE : v[0.i—1] está ordenado»
«INVARIANTE: Vk€ (1.4—1) ev[k] > v[k— 1)»

 

for (int i=1; i<N; d++) (
valor = v[il;
J-i;

while (j > 0 8% valor < v[j-11) £
v[jl = víjal;
d=;

J

vIj] = valor

J
«POST: v[0.N—1] está ordenado y contiene los valores v[0..N — 1)»
+

12.5 Búsqueda por dicotomía

   
 
 
 
 
    
     
  

Cuando los datos están ordenados la búsqueda resulta mucho mas rápi
Si comparamos el elemento a buscar con el que está justo en la mitad
los datos ordenados, podemos decidir si es ése el clemento que buscamos
debemos continuar buscando, pero sólo en la mitad derecha o sólo en la mit
izquierda.
El mismo proceso se puede repetir con la mitad elegida, comparando con
elemento que está en el centro de dicha mitad. En cada comparación,
búsqueda se reduce a comprobar si el dato buscado está entre la mitad
los anteriores. La búsqueda finaliza cuando el elemento se encuentra, o bi
cuando la ¿ona pendiente de examinar queda reducida a un sólo elemento.
(o ninguno) después de sucesivas divisiones en mitades. Esta búsqueda se
denomina búsqueda por dicotomía. El esquema general de búsqueda sigue:
siendo análogo al utilizado anteriormente. Sin embargo, ahora es necesario
cambiar la obtención del siguiente elemento a comparar:

iniciar operación

while (quedan elementos por examinar y no se ha encontrado ninguno aceplable) 4

elegir el elemento central y ver si es aceptable

completar operación
 
 
   
 
   
    
 
    
    
  
   
   
  
 
   
   
 
 
 
 
 
   

-mas típicos de operación con formaciones 327

 

'0 ejemplo, realizaremos la búsqueda por dicotomía de un valor buscado
un vector v de N elementos. Se necesitan dos variables para acotar el trozo
vector que todavía queda por comprobar y otra variable para señalar el
to medio de ambas. Estas variables las denominaremos izq , deh y mitad.
ién usaremos una variable pos para almacenar finalmente el resultado de
búsqueda, es decir, el lugar en el que se ha encontrado el elemento buscado,
bien un valor negativo (p. ej. -1) si el elemento buscado no se encuentra, El
ligo sería como sigue:

... TElemento ...;
Indice( T_Elemento buscado, const T_Elemento v[], int N ) £
'RE: v está ordenado»

int izq, dch, mitad, pos;
izq = 0; dch = N-1; pos = -:

 

«INVARIANTE : el elemento buscado, si existe, está en la zona vlizg..dch]»
«INVARIANTE : Vk€ (0..izg — 1) e (v[k] < buscado) A
Vk € (deh + 1..N — 1) e (v[k] > buscado)»
«VARIANTE: dch— izq +1»
while (pos < 0 4% izq <= dch) (
mitad = (izq + dch) / 2;
if (v[mitad] == buscado) (
pos = mitad;
) else if (ví[mitad] < buscado) (
dch = mitad - 1;
J else £
izq = mitad + 1;
3
3
return pos;
«POST: pos > 0 v[pos] = buscado A pos <0—= buscado $ v/0..N — 1)»
y

Inicialmente se busca en el vector completo vlizg..dch] = v[0..N-1]. La
variable auxiliar pos se inicializa al valor de fallo de búsqueda (-1), y permanece con dicho valor hasta que se encuentre el elemento buscado, si existe,
en cuyo caso señala a la posición encontrada. En cada etapa se examina el
elemento central de la zona de búsqueda, mitad=(izg+dch)/2), y si v[mitad]
no contiene el elemento buscado la zona v[izq. .dch] se reduce a, la mitad de
delante o a la de detrás. El bucle termina cuando se encuentra el valor buscado
o bien cuando la zona de búsqueda ya no contiene elementos (izq>dch).

La terminación se garantiza fácilmente. Como variante se puede utilizar el
tamaño de la zona de búsqueda dch-izq+1, que se reduce estrictamente a la
 

  
   
  
 
  
   
    
   
  
 
 
 
  
  
  
   
  
  

328 Fundamentos de progr:

 

mitad (cociente entero por defecto) en cada paso, y por tanto so reduce a
en un número finito de pasos.

La búsqueda por dicotomía se puede aplicar, por ejemplo, en el esquema
ordenación por inserción, para localizar el lugar en que hay que insertar
nuevo elemento.

12.6 Simplificación de las condiciones de contorno

La programación de operaciones con vectores, realizadas elemento a ele:
exige con frecuencia realizar un tratamiento especial de los elementos extre:
del vector o, en general, de los elementos del contorno de una formación.
continuación veremos algunas técnicas particulares para evitar la necesidad
detectar de manera explícita si se ha llegado a un elemento del contorno y,
realizar con él un tratamiento especial.

12.6.1 Técnica del centinela

Por ejemplo, en el procedimiento general de búsqueda es necesario compi
en cada iteración una condición doble: si no se ha alcanzado todavía el
del vector, y si se encuentra el elemento buscado. Repetimos aquí el esqr
de la sección 12.2:
iniciar operación
while (quedan elementos sin tratar y no se ha encontrado ninguno aceptable) £

elegir uno de ellos y ver sí es aceplable
y

completar operación

 

La doble condición del bucle de iteración complica cl código y supone
tiempo adicional en la ejecución de cada iteración. Si garantizamos que
dato buscado está dentro de la zona de búsqueda, antes o después se termi
encontrándolo y ya no será necesario comprobar explícitamente si se al
el final del vector.

La manera de asegurar esto es incluir el dato buscado en el vector antes
comenzar la búsqueda. El vector se amplía, según se muestra en la figura 1
con un elemento más situado al final (si se hace la búsqueda hacia adel
o situado al principio (si la búsqueda se hace hacia atrás). En ese elem:
adicional se copia el dato a buscar antes de iniciar la búsqueda para
actúe como centinela (C) y asegure que la búsqueda nunca acaba de f
infructuosa.
 
  
 
   
     
   
   
  
  
  
 
   
 
 
   
  
 
    
  
  

Esquemas típicos de operación con formaci 329

 

 

 

Figura 12.5 Vector con centinela situado al final.

Ahora, el esquema general de búsqueda se simplifica de la signiente forma:

¡iniciar operación (colocar el centinela)

le (no se ha encontrado un elemento aceptable) 4
elegir otro elemento y ver si es aceptable

3

«complelar operación (si se ha encontrudo el centinela, indicar fallo en la búsqueda)

Igual que en los ejemplos anteriores, nsaremos una variable pos para almacenar
finalmente el resultado de la búsqueda, es decir, el lugar en el que se ha
encontrado el elemento buscado, o bien un valor negativo (p. ej. -1) si el
“elemento buscado no se encuentra. El fragmento de programa sería como
sigue:

lef ... T_Elemento ...;

 

Indice( T_Elemento buscado, const T_Elemento v[], int N ) £
int pos = 0;

viN] = buscado; /* centinela */

while (v[pos]!=buscado) 4
pos++;

,

if (pos>=N) 4 /* lo que se encuentra es el centinela */
pos = -1;

+

return pos;

 

este ejemplo la búsqueda se hace hacia adelante. El centinela se coloca al
, detrás del último elemento del vector original, es decir, en la posición
Si al final de la búsqueda la variable pos tiene un valor igual a N, quiere
ir que la búsqueda ha sido infructuosa: el elemento encontrado ha sido el
inela, y no un elemento del vector original.

 

 

 

técnica del centinela se puede emplear en la ordenación por ins E
echando que cada muevo elemento a insertar entre los anteriores está ya
lo al final de la parte ordenada. Ahora la localización del lugar que le
“esponde y el movimiento de los elementos posteriores para hacer hueco se
 

330 Fundamentos de program:

 

   
  
  
 
 
   
   
    

hacen por separado, y la búsqueda entre los elementos anteriores se hace ha
adelante y no hacia atrás. La nueva redacción del programa es la siguiente:

typedef ... T_Elemento .

 

void Ordenar( T_Elemento v[], int N) 4
T_Elemento valor;
int j;

for (int i-l; ioN; i++) (
valor = v(il;
- Buscar la nueva posición del elemento, sin mover nada --*/
30%
while (valor > v[j)) £
d+
J
/*-— Mover elementos mayores y poner el elemento en su sitio --*/
for (int k=i-1; ko=j; k--) ( o
v[Kk+1] = vik];
,
v[jl = valor
J
y

 

 

 

Como se puede observar, la técnica del centinela simplifica la condición del
bucle para la operación de buscar la nueva posición del elemento.

12.6.2 Matrices orladas

Cuando se trabaja con matrices, también se pueden simplificar las condiciones
de contorno utilizando matrices orladas. Estas matrices se dimensionan com:
dos filas y dos columnas más de las necesarias tal como se muestra en la fi
12.6.

 

 

La matriz original la forman las filas 1 a M y las columnas 1 a N. Las filas y
columnas extra garantizan que todos los elementos de la matriz original tienen:
elementos vecinos en todas las direcciones. Antes de operar con la matriz se
inicializan las filas y columnas extra con un valor de contorno (C) que permita.
simplificar la operación de modo que el tratamiento de los elementos del borde
de la matriz original sea idéntico al de los demás.

  

Para ilustrar el uso de una matriz orlada supongamos que tenemos una imagen
en blanco y negro (escala de grises) de Ancho Xx Alto pixeles almacenada en
una matriz definida de la siguiente forma:
Esquemas típicos de operación con formaciones

 

¡const int Ancho ;  /* Anchura de la imagen */

¡const int Alto 5 /* Altura de la imagen */

¡const int Borde 5 /* Indicador de borde de la imagen */
¡const int Blanco 3  /* Nivel bajo de grises = blanco */
¡const int Negro /* Nivel alto de grises legro */

typedef int Imagen_t[Alto+2][Ancho+2];
¡Imagen_t imagen;

Los puntos de la imagen ocupan las columnas 1 a Ancho y las filas 1 a Alto.
¡Cada elemento de la matriz guarda el nivel de gris del correspondiente punto de
la imagen. Las columnas 0 y Ancho+1 y las filas O y Alto+1 son los elementos
extra del contorno. Para tratar cada punto de la imagen individualmente
basta hacer un recorrido completo, sin ninguna complicación. Por ejemplo,
para contrastar la imagen y reducir todos los puntos gris claro a blanco y
todos los gris oscuro a negro, bastará esc
for (int i=1; i<=Alto; i++) (
for (int j=1; ¡j<=Ancho; j++) £
if (imagen[i][j] <= nivel) £
imagen[i][3] = Blanco;
) else (
imagen[i][3] = Negro;

 
 

  
   
  
    
    
  
  
  
  

332 Fundamentos de progr:

 

En el fragmento de código anterior no se ha usado para nada el cont:
de la matriz. Supongamos ahora que queremos recortar la imagen, esto
eliminar aquellos puntos externos de la imagen que están en blanco,
dejando los puntos blancos que son interiores y están rodeados de pi
negros. El tratamiento de cada punto exige examinar al mismo tiempo
puntos contiguos. El programa se simplifica si se garantiza que todo pi
útil de la imagen tiene puntos contiguos en todas las direcciones, es decir,
hay situaciones excepcionales en los bordes.

Para ello se aprovecha el contorno de la matriz, es decir, la orla, inicializánde
con el valor que indicará los elementos del borde.

: (int i=0; i<=Alto+l; i+*) 4
|

 

imagen[i][0] = Borde
imagen[i][Ancho+1] = Borde;

3

for (int i=0; i<=ancho+l; i++) 4
imagen[0][i] = Borde;
imagen[Alto+1][i] = Borde;

 

  

J

Suponiendo que imagen está ya contrastada anteriormente y que su conto
está inicializado al valor de Borde, el recorte se realizaría mediante sucesi
recorridos de toda la matriz en los que los puntos blancos que tienen
punto Borde alrededor deben pasar también a puntos Borde. El proceso
recorte se termina cuando en un recorrido completo de toda la imagen no
ningún punto que cambie, El fragmento de programa que realiza el recorte es
el siguiente:

bool fin;

       

(Cimagen[i-11[3]

Cimagen[i][3-1] Borde) ||
Gimagen[i][j+1] == Borde) ||
(imagen[i+1][5] = Borde))) €
imagen[i][j] = Borde;
fin = false;

3
,

J
J while (! fin);
Esquemas típicos de operación con formaciones 333

 

Esta forma de operar se denomina de fuerza bruta, y puede ser poco eficiente,
pero es muy sencilla de programar.

Este ejemplo es un fragmento de uno de los programas completos que aparecen
en este tema.

12.7 Ejemplos de programas

A continuación se muestran varios programas completos con ejemplos de sus
respectivas ejecuciones.

12.7.1 Ejemplo: Sopa de letras

Con este programa se trata de realizar la búsqueda de una palabra dentro de
una matriz de caracteres. La búsqueda debe realizarse cn horizontal, vertical
y diagonal en ambos sentidos. Por tanto, se pueden establecer 8 direcciones
de búsqueda: norte, sur, este, oeste, noroeste, suroeste, noreste, sureste. En
la búsqueda se deben tener en cuenta los límites de la matriz. La función
Buscar comprucba si la palabra palabra de longitud letras coincide con los
caracteres de la matriz desde la posición: fila y columna, siguiendo la dirección rumbo. Esta función tiene en cuenta los límites de la matriz y devuelve
un resultado cierto o falso según se encuentre o no la palabra buscada.

 

Los demás procedimientos son auxiliares. El procedimiento IniciarSopa inicializa de forma aleatoria la matriz, mediante un recorrido de la misma. Cada
carácter se obtiene a partir de un número aleatorio entre 0 y 26, al que se
suma la posición del carácter 'a' dentro de la tabla ASCHL.

El procedimiento Cambiar, es el encargado de pasar de minúsenlas a mayúsculas la palabra encontrada. Este cambio se realiza mediante un recorrido
parcial de letras caracteros de la matriz desde la posición: fila y columa,
siguiendo la dirección rumbo.

El procedimiento EscribirSopa cs un recorrido total de la matriz en el que se
escriben por filas todos los caracteres de la matriz separados por un blanco.

En el programa principal se lee la palabra a buscar, toda en minúsculas, e
inmediatamente se realiza su búsqueda exhaustiva desde todas las posiciones
de la matriz y con todas las direcciones posibles. Si se encuentra, se cambia a
mayúsculas. El listado del programa es el siguiente:

 
 

 

334 Fundamentos de progr:

 

 

 

PA AAA

+ Programa: SopaDeLetras

* Descripción:
+ Este programa busca una palabra en una matriz

* de caracteres, en cualquier dirección, de forma
= semejante a como se hace en una sopa de letras
AA A A
tinclude <stáio.h>

finclude <stdlib.h>

finclude <time.h>

Hinclude <ctype.h>

const int Filas = 10; /* Filas de la sopa de letras */
const int Columnas = 20; /* Columnas de la sopa de letras */
const int Totalletras = 26; /* Total letras abecedario inglés */

typedef char TipoSopa[Filas][Columnas];
typedef char TipoPalabra[ Columnas];
typedef enum TipoRumbo (Norte, Sur, Este, Oeste,
Noroeste, Suroeste, Noreste, Sureste

 

const int PasoH[8]
const int PasoV[8]

10,0, 1, -1, -1, -1,
1-1, 1, 0,0, -1, 1, 
có
Procedimiento para inicializar de manera
aleatoria una sopa de letras
void IniciarSopa( TipoSopa sopa ) 4
srand( time(NULL) );
for (int f=0; f<Filas; £++) (
for (int c=0; c<Columnas; c++) [
sopa[f][c] = char(rand()XTotalLetras+tint('a*));

 

 

 

 

J

J
pa

 

Procedimiento para cambiar "letras” a mayúsculas
desde la posición (columna, fila) con el "rumbo" indicado

asma ooo======*/

 

 

void Cambiar( TipoSopa sopa, int letras,
int columna, int fila, TipoRumbo rumbo ) [

 
Esquemas típicos de operación con formaciones 335

for (int i-1; i<-letras; i++) (
sopa[fila][columa] = toupper(sopal fila] [columa]);
/*-—- Nueva fila y columa según el rumbo --*/
columna = columna + PasoH[rumbo];
fila = fila + PasoV[rumbo];

  

pas e
Función para buscar las "letras" de una "palabra
desde la posición (columa, fila), con el "rumbo" indicado,
en la "sopa" de letras

 

j */
bool Buscar( const TipoSopa sopa, const TipoPalabra palabra, int letras,
int columna, int fila, TipoRumbo rumbo ) (
int i = 0; /* contador de letras */

bool coincide = true; /* hay coincidencia */

 

/*-- Invariante: i = n* de letras examinadas
y coincide = "las i letras coinciden" --*/
while (i < letras 8% coincide 8 fila >= 0 48 fila < Filas 48
columna >= 0 88 columna < Columas) (
/*-- Se acepta coincidencia en mayúscula o minúscula --*/
coincide = palabra[i] == tolower(sopa[fila] [columa]);
if (coincide) (
de
/*— Nueva fila y columna según el rumbo --*/
columa = columna + Pasok[ rumbo];
fila = fila + PasoV[rumbo];
b
3
return i==letras;

,

 

Y Par nono

Procedimiento para escribir la sopa de letras

e

 

void EscribirSopa( const TipoSopa sopa ) (
print£( "wn" );
for (int i=0; i<Filas; i++) (
for (int j=0; j<Columnas; j+r) 4
print£( "%c ",sopalil(j] );

 

y
print£( "Ya" );
y
y
336 Fundamentos de programación:

 

 

Programa principal

 

int main(O) 4
TipoSopa sopa;
TipoPalabra palabra;
TipoRumbo rumbo;
int longitud;
char tecla; /* último caracter leído */
int encontradas;

    

/*-- Crear la sopa de letras al azar —
IniciarSopa( sopa );
EscribirSopa( sopa );

/*— Búsqueda de palabras --*/
do
print£( "Wn¿Palabra a Buscar? " );
/*-— Leer palabra a buscar, saltando blancos iniciales --*/
scanf( " %e", átecla ); /* primera letra */
longitud = 0;
while (islower(tecla)) £
palabra[ longitud] = tecla;
longitud++;
scanf( "Xe", átecla );
+

 

/*— Buscar desde todos los puntos posibles
y en todas las direcciones posibles --*/
encontradas = 0;
for (int ¡Fila iFila < Filas; iFila+r) (
for (int ¡Columna = 0; ¡Columna < Columnas; ¡Columa++) 4
for (int ¡Rumbo = int(Norte); ¡Rumbo <= int(Sureste); iRumbow+) £
rumbo = TipoRumbo(iRumbo);
if (Buscar( sopa, palabra, longitud, iColuma, iFila, rumbo) 4
/*-- Cuando se encuentra se cambia a mayúsculas --*/
Cambiar( sopa, longitud, iColumna, iFila, rumbo);
encontradas++;
,
E

 

 

F
+

/*-— Mostrar resultado --*/
if (encontradas > 0) 4
print£( "Wn%d coincidenciasin", encontradas );

 
¡as típicos de operación con formaciones

EscribirSopa( sopa );
J else [

print£( "YnNo encontrada" );
+

/*-- Repetir búsqueda --*/
print£f( "Wn¿Otra Palabra(S/N)? " );
do
scanf( " %c”, étecla );
tecla = toupper(tecla);
J while (tecla l= 'S' 8% tecla l= 'N');
) while (tecla != 'N');

    

337

 

ejecución del programa produce un resultado similar al siguiente:

 

PUAN<x<raa

w
1
i
f
j
u
i
z
a
b

psoznoszow

e
x
ile
j
y
d
s
Y
g
n

LORTOn pra
Oros p+nnz3."
»ovosorx<os
ENIFXNENDO
DRNA”
ADORO FE
DOon—Triuo ace
XAQTSAN Do
SaRn<ora xo
ENBOON Ono
PORRA Nono
<xonarm<oo
PERSONA
NERO” Ea
Prosa osz

     
 

¿Palabra a Buscar? pena

coincidencias

PURN<r<ro a

”
1
i
£
j
u
i
z
a
b

»suz=0oonz0.u
XQr<snnoaor<
AQRLO<o> ox
ENSTONUzZoOOo
PuU0R<RNomo
<r5o am m<o
Ss Hu <ornmzo
NEDRGO REO
Doro poz

f
x
1
j
y
d
s
y
g
n

orasr+onzso

3
j
r
a
e
o
k
n
a
d

¿Otra Palabra(S/N)? s

¿Palabra a Buscar? dos

 
 

 

338 Fundamentos de program:

 

No encontrada
¿Otra Palabra(S/N)? s
¿Palabra a Buscar? voy

1 coincidencias

tdwjapfuerwsyiooPspw
paljmsxebfkvhxeEpwun
fhirwwlyzfgqdbhNeygrl
yvfaeqajxuhiocAszfkor
jujecoybrftjizberabjj
jvuoicdoxdbrrv0Ydvyt
yziknwsmkyxhvcbierir
tgznqpyswrqzbimenmgn
ojaqbnggzxqbddzpxhue
wlbdaanamatpxtuiyhzp
¿Otra Palabra(S/N)? s
¿Palabra a Buscar? ir

3 coincidencias
tdwjapfuerwsyiooPspw
paljimsxebfkvhxeEpwun
fhIRwwlyzfqdbhNcygrl
yvfaeqjxuhiocAszfkor
jwjcocoybrftjizberabjj
jvuoicdoxdbrrvo0Ydvyt
yziknwsmkyxhvcbieRrIR
tgznqapyswrqzbimenmgqn
ojaqbngqzxqbddzpxhue
wlbdqanamatpxtuiyhzp

¿Otra Palabra(S/N)? n

12.7.2 Ejemplo: Imprimir fechas en orden
En este ejemplo se lee una colección de fechas, comprobando que son correctas,
y a continuación se imprimen, ordenadas cronológicamente.

Las fochas se leen de la entrada principal. Cada fecha de entrada compronde
tres valores, correspondientes al día, mes y año. El día y el año se dan en
Esquemas típicos de operación con formaciones 339

 

forma numérica. El mes puede darse como múmero o en letra y por ello se
utiliza un esquema union con dos campos alternativos: un número entero o
bien un vector de hasta 15 caracteres.

El año puede darse completo, con cuatro dígitos, o en forma abreviada, con
dos. En este último caso se entiende que es un año de nuestro siglo, y se le
suma 2000. La lectura de datos termina al introducir un valor numérico cero
para cl día.

Las fechas leídas se comprueban para garantizar que el día, mes y año forman
una combinación consistente. Las fechas erróneas se descartan.

Las fechas correctas se van almacenando en una tabla de fechas, que se mantiene ordenada en todo momento. Cada nueva fecha leída se inserta en la
posición que le corresponde, en orden cronológico. Al final se imprime toda la
colección de fechas, en el orden en que se han almacenado.

A continuación se presenta un ejemplo de ejecución del programa. Los datos
de entrada son:

 

10 Marzo 1972
30 feb 82

29 FEB 1900
u372

29 FEB 2000
28 diciem 1993
4 enero 91

15 error 89
10 10 10

o

El resultado obtenido a la salida es:

 

Fechas leídas:

10-Marzo-1972

30-Febrero-2082 ** incorrecta **
29-Febrero-1900 ** incorrecta **
11-Marzo-2072

29-Febrero-2000
28-Diciembre-1993

4-Enero-2091

15- -2089 ** incorrecta **
10-Octubre-2010

Fechas en orden:
10-Marzo-1972

 
 

340 Fundamentos de programación

 

28-Diciembre-1993
29-Febrero-2000
10-Octubre-2010
11-Marzo-2072
4-Enero-2091

El listado completo del programa es el siguiente:

 

 

AAA AAA AAA

Programa: Fechas

* Descripción:

* Programa que lee una serie de fechas, comprueba que son
* correctas, y las imprime en orden cronológico.

ARRAAAA RARA RARA ARALAR
Winclude <stdio.h>

include <ctype.h>

typedef struct fecha_t (
int dia;
int mes
int anno;

5

 

const int maxNombre = 15;
typedef char nombreMes_t[maxNombre];
typedef union dato_t (
int mesNumero;
nombreMes_t mesLetra;
»
typedef struct datoMes_t 4
bool esNumero;
dato_t dato;
h

const int maxFechas = 100;
typedef fecha_t listaFechas_t[maxFechas];

listaFechas_t lista; /* lista de fechas leídas */
int numFechas; /* número de fechas leídas */

typedef nombreMes_t listaNombres_t[13];

listaNombres_t nombres = (" ”, /* sin nombre cuando mes = 0 */
"Enero",  /* nombres de los meses */
"Febrero",

"Marzo",
Esquemas típicos de operación con formaciones 341

 

 

“Octubre”,
"Noviembre",

"Diciembre"

 

 

Narro

Comprobar si una fecha es correcta

    

bool EsCorrectal const fecha_t fecha ) £
if ((fecha.anno<=0) || (fecha.dia<=0)) £
return false;
y
switch (fecha.mes)
case 1:
case 3:
case 5:
case 7:
case 8:
case 10:
case 12:
return (fecha.dia <= 31);
break;
case 4:
case 6:
case 9:
case 11:
return (fecha.dia <= 30);
break;
case 2:
if (fecha. anno%4 0 88 fecha.annox100 != 0 ||
fecha, annox400 01
return (fecha.dia <= 29);
) else (
return (fecha.dia <= 28);

E

 

 

default ' 4
return false;
 

  

342 Fundamentos de programación:

 

Imprimir una fecha con el formato dd-nombremes-aaaa

 

==*/
void EscribirFecha ( const fecha_t fecha )
print£( "x2d-%s-%4d", fecha.dia, nombres[fecha.mes], fecha.anno );

 

 

 

 

y
/ aaa. ao
Leer un mes en número o letra
2 maana /
void LeerMes( datoMes_t € mes ) [
char c;
int k;
do (

scanf( " %c", Ec );  /* leer primer carácter */
) while (! isalnum(c)); /* ignorando puntuación */
if (isdigit(c)) /* mes como número */
mes.esNumero = true
mes.dato.mesNumero =
do (
mes.dato.mesNumero = mes.dato.mesNumero*10 + int(c)-int('0');
scanf( "%c", Ec );
] while (isdigit(c));
) else ( /* mes en letra */
nes.esNumero = false;
k=0;
do (
1£ (k<maxNombre) (
mes.dato.mesLetra[k] = c;

  

ke;
,
scanf( "%c", €e );
) while (isalpha(c));
y
J
ee

   

Convertir a número el mes en letra. Sólo se
comprueban los tres primeros caracteres.
Si no es correcto se devuelve cero.

 

int NumeroDelMes( const nombreMes_t nombre ) 4
int k;

 

 
 

Esquemas típicos de operación con formaciones 343

 

for (int mes=1; mes<=12; mes++) [
k=0;
while (toupper(nombre[k]) == toupper(nombres[mes][k])) 1
if (k >= 2) [ /* coinciden 3 caracteres */
return mes;
Ue
ke+;
)
J
return 0;
,

DA AO
Leer una fecha con el mes en número o letra.
Si el día es cero, se asume fin de los datos

rn cama /

void LeerFecha( fecha_t € fecha ) £
datoMes_t mes;

 

 
 

 

fecha.dia

scanf( "Xd", Sfecha.dia );

if (fecha.dia != 0) 4
LeerMes( mes );

 

if (mes.esNumero) (
fecha.mes = mes.dato.mesNumero;
) else £
fecha.mes = NumeroDelMes( mes.dato.mesLetra );
E
scanf( "%d", €fecha.anno );
if (fecha.anno < 100) £
fecha.anno = 2000 + fecha.anno;

 

Comparar dos fechas. Devuelve cierto si
la primera es posterior a la segunda

  
  

a]
bool EsPosterior( const fecha_t f1, const fecha_t f2 ) (
if (fl.anno != f2.anno) (
return (fl.anno > £2.anno);
) else if (fl.mes != f2.mes) [
return (fl.mes > f2.mes);
j else
return (f1.dia > f2.dia);

 
 

 

344 Fundamentos de progr:

 

 

 

 

 

 

y

J

Y Armas anno ===
Insertar una fecha, en PA en la lista de fechas
= raro rnnnrnnonnnsooo===*/

 

void InsertarFecha( const fecha_t f ) (
int izquierda, derecha, centro;

/*-- Poner la fecha como centinela, al final --*/
lista[numFechas] =
numFechas++;

/*-- Determinar la posición que le corresponde --*/
izquierda = 0;
derecha = numFechas-1;
while (izquierda < derecha) £
centro = (izquierda+derecha)/2;
if (EsPosterior( £, lista[centro] )) £
izquierda = centro+l;
) else [
derecha = centro;
y
J

/*-— Hacer sitio para la nueva fecha —-*/
for (int pos = numFechas-1; pos >= izquierda; pos--) (
lista[pos+1] = lista[pos];

/*— Colocar la fecha en su sitio --*/
lista[lizquierda] = f;

ft
Programa principal
int main() 4
fecha_t fecha; /* fecha leída */
bool seguir = true;

 

 

“Y

printf( "Fechas leídas:n" );

numFechas = 0;

LeerFecha( fecha );

seguir = (fecha.dia != 0);

while (seguir 48 numFechas < maxFechas) (
Esquemas típicos de operación con formaciones

345

 

Escribirrecha( fecha );

if (EsCorrecta(fecha)) (£
InsertarFecha( fecha );

J else £

print£( " ** incorrecta **" );

5]

printf( "“n” );

LeerFecha( fecha );

seguir = (fecha.dia != 0);

y

print£( "AnFechas en orden:in" );
for (int k=0; k<numFechas; k++) 1
EscribirFechal lista[k] );
printf( “An” );
y
,

 

12.7.3 Ejemplo: Recortar una imagen

Este programa es un ejemplo de utilización de una matriz orlada. El procedimiento Recortar ya fue explicado en el apartado dedicado a las matricos
orladas. El procedimiento Imprimir es simplemente un recorrido de la matriz
para imprimir la imagen contenida. El procedimiento LeerTmagen lee una
imagen de los datos de entrada, leyendo un carácter por cada punto.

El listado completo del programa es el siguiente:

 

par.

* Programa: Recorte

   

RARA ARRE E

* Descripcion:
* Este programa recorta una imagen digitalizada,
* es decir, delimita el contorno
RARA RARE ARRE

Finclude <stdio.h>

 

Aeran9erar/

/* anchura de la imagen */
/* altura de la imagen */

const int Ancho
¡Const int Alto

¡const int Borde
const int Blanco
const int Negro

40;

   

/* nivel alto de gris = negro

/* marca de borde de la imagen * ' */
/* nivel bajo de gris = blanco *.* */

os)

typedef int Imagen _t[Alto+2][Ancho+2]; /* matriz orlada */

 
 

346 Fundamentos de progra

 

/** Leer la imagen */
void LeerImagen( Imagen_t imagen ) 4
char c;

/*-- 1% Paso: Inicializar toda la imagen a "Borde" --*/
for (int i=0; i<Alto+2; i++) 4
for (int j=0; j<Ancho+2; j++) 4
imagen[iJ[j] = Borde;
$

/*-- 2% Paso: Leer los datos, punto a punto --*/

 

 

for (int i=1; i<=Alto; i++) €
for (int j=1; j<=Ancho; j++) 4
scanf( " %c", ke );

 

imagenli][j] = int(c) - int('0');

y

/** Contrastar la imagen */
void Contrastar( Imagen_t imagen, int nivel ) £
for (int i=1; i<=Alto; i++) (
for (int Ancho; j++) £
if (imagen[i][j] <= nivel) £
imagen(i][j] = Blanco;
) else [
imagen[i][j] = Negro;

 

)
$
y

/** Recortar la imagen */
void Recortar( Imagen t imagen ) £
bool seguir;

do £ /* fuerza bruta, marcar borde hasta que no cambie más */
seguir = false;
for (int i Alto; i++) 4
for (int Ancho; j++) 4
if (imagen[i][j] = Blanco 8% (

 

 
 

imagen[i-1][j] Borde ||
imagen[i][j-1] Borde ||
imagen[i][j+1] = Borde ||

 

 
Esquemas típicos de operación con formaciones 347

 

imagen[i+1][j] == Borde )
y 1
imagen[i][j] = Borde;
seguir = true;

J
3
3
) while (seguir);


/** Imprimir la imagen */
'woid Imprimir( const Imagen t imagen ) f
const char Punto[9] =(' 1, 0, ty A

 

for (int i=1; i<=Alto; i++) £
for (int j=1; j<=Ancho; j++) 4
print£( "%c", Punto[imagen[i)[31+1] );

 

7
print£( "a" );
y
y

/=* Programa principal */
ánt mainO (
Imagen_t imagen;

/*-—- Leer la imagen inicial --*/
LeerTmagení imagen );
print£( "Imagen inicia
Imprimir( imagen );

 

a)

/%-— Reducir la imagen a blanco y negro --*/
Contrastar( imagen, 3 );

print£( "WnImagen contrastada:in" );
Imprimir( imagen );

/*— Recortar la imagen, marcando el borde externo --*/
Recortar( imagen );

print£( "Imagen recortada: Wn" );

Imprimir( imagen );

 

A continuación se presenta un ejemplo de la ejecución de este programa. Los
datos de entrada contienen un carácter por cada punto de la imagen, y simulan
una rejilla. Una de las esquinas del borde derecho está rota. Los datos son:

 
348

  

Fundamentos de programación

 

 

0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212344
5432101234543210123454321012345432101233
4543212345454321234545432123454543212344
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432
0123454321012345432101234543210123454321
1234545432123454543212345454321234545432
2345434543234543454323454345432345434543
3454323454345432345434543234543454323454
4543212345454321234545432123454543212345
5432101234543210123454321012345432101234
4543212345454321234545432123454543212345
3454323454345432345434543234543454323454
2345434543234543454323454345432345434543
1234545432123454543212345454321234545432

El resultado de la ejecución del programa es el signiente:

 

 

Imagen inicial:
e e O e O
AAA A A
ARRE A AONO AX
AAA AAA

 

 

 

AA A CO
E

AL ACP. OL
PAR a o
ARAN RAE
ARA ANNA
AR AA A NAO
A
AREA
AAA REPO PA
AAA NOE
HA O OR Nc
Hr
HR O OA CO
AAA A
ARAGON PO AA
A OA NOA ONPE

     

 

 

 
   

  
 
 

 
 
  
 
 
 
   
 
   
  
 
 
   
 
   
   
   

Esquemas típicos de operación con formaciones

Imagen contrastada:

 
    

   
  
     

     

 

All
AR,
FALSA. ABRA
AAA AAA AAA

 

AAA

  

AAA AAA
AAA AAA AAA AR
RR A
AA AAA
AA
ARA
PARAR A
AAA AA

 

 

 

 

 

Inagen recortada:
add q +0. qq
Hit HANA caididid AARAA

ia

AARAAA RARA RARA AA

 

     
 
   

 

  

 

 

A, A a

AA MA. 148

ea A e.
FEA RAR AAA ARRE
BER ARE AAA ARA

      

AAN AER MAR ARA
Hb ANA. A
A AAA, MARA ARA

  

PARAR AMARA RARA ARAGAO
E
ABBA. AMARA
A
HEBIR
AAN ARA
PARAR RRA HARIAS RARA
did seta Hee Pd

      

 

 

349

 

 
350 Fundamentos de pro;

 

   

Como puede verse, la marca de borde exterior se ha ido propagando a
los puntos vecinos que estaban en blanco, hasta rellenar toda la zona
de la rejilla, incluyendo la malla abierta.
 

Tema 13

Punteros y variables dinámicas

En este tema se introducen estructuras de datos potencialmente ilimitadas.
Se justifica su interés y se describe en particular la estructura secuencia.

13.1 Estructuras de datos no acotadas

En los temas anteriores se han descrito las estructuras de datos que pueden
definirse en C+. Todas ellas tienen una característica en común: la capacidad
total (número de elementos componentes) se determina explícitamente al definirlas. Una estructura podrá usarse de manera que el número de componentes
que contengan información significativa sea variable, pero nunca mayor que el
tamaño total de la estructura.

Por ejemplo, en el tema anterior se ha presentado un programa para escribir en
orden una serie de fechas leídas como datos. El número de fechas leídas cambia
de una ejecución del programa a otra, pero la capacidad total del programa
viene limitada por el tamaño de la estructura definida para almacenar la lista
de fechas.

La fijación del tamaño máximo representa una solución de compromiso entre la
capacidad del programa y su eficiencia. Si el tamaño es relativamente pequeño
el programa tendrá una capacidad de tratamiento limitada. Si el tamaño se
fija a un valor muy grande, el programa será poco eficiente en el uso de la
memoria, pues necesitará espacio para toda la estructura de datos, aunque
sólo se aproveche una pequeña parte.

Tras el análisis anterior debe resultar evidente que sería útil disponer de estructuras de datos que no tuvieran un tamaño fijado de antemano, sino que

 
  
    
   
  
 
   
  
  
  
   
 
 
  
  
   
    
   

352 Fundamentos de programación

 

pudieran ir creciendo o reduciendo su tamaño en función de los datos particulares que se estén manejando en cada ejecución del programa. Estas estructuras
de datos se denominan, en general, estructuras dinámicas, y poseen la cual
dad de que su tamaño es potencialmente ilimitado, aunque, naturalmente, no:
podrá exceder la capacidad física del computador que ejecute el programa.

13.2 La estructura secuencia

La estructura secuencia puede definirse como un esquema de datos del tipo iterativo, pero con un número variable de componentes. La estructura secuencia:
resulta parecida a una formación con número variable de elementos.

 

En realidad existen diferentes esquemas secuenciales de datos. Aun teniendo
en común que el número de elementos pueda variar, hay varias formas posibles
de plantear las operaciones sobre secuencias. Para describir las distintas al
ternativas distinguiremos entre operaciones de construcción y de acceso. Com:
las primeras podremos añadir o eliminar componentes de la secuencia. Com
las segundas podremos obtener o modificar el valor de las componentes que
existen en un momento dado.

 

Las operaciones de construcción pueden incluir:

+ Añadir o retirar componentes al principio de la secnenc
+ Añadir o retirar componentes al final de la secuencia.
+ Añadir o retirar componentes en posiciones intermedias de la secuencia.

 

Las operaciones de acceso pueden ser:

Acceso secuencial: Las componentes deben tratarse una por una, en el orde.
en que aparecen en la secuencia.

Acceso directo: Se puede acceder a cualquier componente directamente i
cando su posición, como en una formación o vector.

En este tema se presentan varias estructuras de datos utilizables en C£ y
responden al esquema secuencia, con distintas posibilidades, según los casos.

En muchos casos, y en particular cuando el acceso es secuencial, el tratamiento
de una secuencia se realiza empleando un cursor. El cursor es una variable
que señala a un elemento de la secuencia. El acceso, inserción o eliminación de
componentes de la secuencia se hace actuando sobre el elemento señalado por
el cursor. Dicho clemento lo representaremos simbólicamente como cursor”,
empleando la flecha (1) como símbolo gráfico para designar el elemento de
información señalado por otro. Para actuar sobre el cursor se suelen plantesz.
las siguientes operaciones:
Punteros y variables dinámicas 353

+ Iniciar: Pone el cursor señalando al primer elemento.

+ Avanzar: El cursor pasa a señalar al siguiente clemento.

+ Fin: Es una función que indica sí el cursor ha llegado al final de la
secuencia,

El empleo de un cursor se ilustra en la figura 13.1.

  
 

 

Secuencia
Inciso i A
Finófaso Fama

Figura 13.1 Manejo de una secuencia mediante cursor.

Por el momento, ilustraremos el concepto de secuencia describiendo de forma.
“abstracta un programa para leer números enteros y escribirlos en orden, usando
ama secuencia ilimitada para almacenar los números leídos. Supondremos que
el final de los datos se indica mediante un valor cero. Los primeros pasos de
refinamiento del programa serían:

 

Leer múmeros e imprimirlos en orden —=>
Leer los números y almacenarlos en orden
Imprimir los números almacenados

Leer los números y almacenarlos en orden —>

Iniciar la secuencia, vacía

Leer un número

while (no es cero) £
Almacenar el número, en orden
Leer un número

 

Almacenar el número, en orden ——>
Buscar la posición que le corresponde
Insertarlo en su posición

Buscar la posición que le corresponde —>

| Iniciar cursor
while (no Fin 8% número > cursor!) 4
Avanzar cursor

+

 

 
354 Fundamentos de program:

 

Imprimir los números almacenados —>
Iniciar cursor
while (no Fin) 4
Imprimir cursor!
Avanzar cursor

y

   
    
   

En estos últimos refinamientos se ha usado la técnica del cursor para lo
zar la posición en la secuencia en que deberá insertarse el nuevo número,
para imprimir la secuencia de números. Obsérvese que se han empleado
operaciones básicas indicadas anteriormente: Iniciar el cursor al comie
Avanzar el eursor, y detectar si se llega al Fín de la secuencia. También se
usado cursor! para hacer referencia a la componente de la secuencia acces
en cada momento.

En este ejemplo se supone, además, que es posible insertar una mueva componente en medio de la secuencia. El desarrollo completo del programa en CE
se describe más adelante.

13.3 Variables dinámicas

Una manera de realizar estructuras de datos ilimitadas en C+ es mediante el
empleo de variables dinámicas. Una variable dinámica no se declara como.
tal, sino que se crea en el momento necesario, y se destruye cuando ya no.
se necesita. Las variables dinámicas no tienen nombre, sino que se designan
mediante otras variables llamadas punteros o referencias.

13.3.1 Punteros

En Ct los punteros o referencias son variables simples cuyo contenido es precisamente una referencia a otra variable. El valor de un puntero no es representable como múmero o texto. En su lugar usaremos una representación gráfica
en la que utilizaremos una flecha para enlazar una variable de tipo puntero
con la variable a la que hace referencia, tal como se indica en la figura 13.2.

Variable apuntada
Puntero

Figura 13.2 Puntero y su variable apuntada.
 
  
  
    
 
   
  
   
  

teros y variables dinámicas 355

 

Los punteros de C2 están tipados, al igual que los demás valores manejados
en el lenguaje. El tipo de un puntero especifica en realidad el tipo de variable
2 la que puede apuntar. La declaración es:

£ Tipo-de-variable*. Tipo-puntero;

Una vez declarado el tipo, se pueden declarar variables puntero de dicho tipo. Una variable puntero se puede usar para designar la variable apuntada
mediante la notación:

puntero

Por ejemplo:
“typedef int* Tp_Entero;

» *pe );

Estas sentencias asignan el valor 33 a la variable dinámica señalada por el
puntero pe, y luego la imprimen. Para que estas sentencias funcionen correctamente es necesario que exista realmente la variable apuntada. Si el puntero
mo señala realmente a una variable dinámica, el resultado de usar *puntero
será imprevisible.
Para poder detectar si un puntero señala realmente o no a otra variable, existe en Ct el valor especial NULL (que no es una palabra clave, sino que está
definido en la librería estándar stdlib.h y también en otras librerías). Este
valor es compatible con cualquier tipo de puntero, e indica que el puntero no
señala a ninguna parte. Por lo tanto debería ser asignado a cualquier puntero que sepamos que no señala a ninguna variable. Normalmente se usará
para inicializar las variables de tipo puntero al comienzo del programa. La
inicialización no es automática, sino que debe ser realizada expresamente por
el programador. Por ejemplo:
df (pe != NULL) (
*pe = 33;
print£( "%d

 

» pe);

En principio esta sentencia garantizaría que sólo se usa la variable apuntada
cuando realmente existe. En realidad eso no es del todo cierto, ya que sólo
una correcta disciplina en el uso de punteros permite asumir que sólo tienen
valor no nulo los punteros que realmente señalan a variables que existen. El
lenguaje Ct en sí mismo no puede garantizarlo (es una limitación inherente a C

 

 
   
  
   
   
      
     
  

356 Fundamentos de progra,

 

y C++). Por ejemplo, se puede destruir una variable dinámica pero conse:
punteros que la referenciaban, y que ahora señalan a algo inexistente.

13.3.2 Uso de variables dinámicas

Una variable de un programa se corresponde, en general, con una zona con
de la memoria que el compilador reserva para almacenar en ella el valor de
variable. Las variables normales de un programa tienen esa zona de me
reservada de antemano al empezar a ejecutarse el programa o subprogri
en que se declaran, y por tanto pueden ser usadas en cualquier momenta.
Conviene recordar que las variables declaradas en un subprograma sólo existes:
mientras se ejecutan las sentencias de esc subprograma.

Las variables dinámicas no tienen ese espacio de memoria. reservado de
mano, sino que se crean a partir de punteros en el momento en que se indique.
Además, una vez creadas siguen existiendo incluso después de que termine la
ejecución del subprograma donde se ercan. La forma más sencilla de crear una
variable dinámica es mediante el operador new:

typedef Tipo-de=variable* Tipo-puntero;

Tipo-puntero puntero;

 

puntero = new Tipo-de-variablez

El operador new crea una variable dinámica del tipo indicado y devuelve una
referencia que puede asignarse a un puntero de tipo compatible. Como en
cualquier otra asignación, el valor anterior del puntero se pierde. Tal como se
ha dicho antes, la variable dinámica no tiene nombre, y sólo se puede hacer
referencia a ella a través del puntero. Podemos representar gráficamente el
efecto de esta sentencia según se muestra en la figura 13.3

Antes

/ Después

  

P = new Tipo;

 

igura 13.3 Creación de una variable dinámica.

La variable dinámica se crea a base de reservarle el espacio necesario en una.
zona general de memoria gestionada dinámicamente. En principio no se puede
asumir que la variable recién creada tenga un valor conereto, igual que las
variables normales que se declaran sin un valor inicial explícito.

 
 
  
  
   
    
   
 
   
  
   
  
  
   
 
   
  
  

teros y variables dinámicas 357

 

variables dinámicas, una vez creadas, siguen existiendo hasta que se infique explícitamente que ya no son necesarias, en cuyo caso el espacio que
había reservado para ellas quedará otra vez disponible para crear nuevas
iables dinámicas. Para ello existe la sentencia delete, que permite destruir
variable dinámica a la que señala un puntero:

te puntero;
'a sentencia destruye la variable apuntada pero no garantiza que el puntero

le con un valor determinado. En particular no garantiza que tome valor

variable dinámica puede estar referenciada por más de un puntero. Esto
e cuando se copia un puntero en otro. Por ejemplo:

int* Tp_Entero;
tero pl, p2;

new int;
pl;

¡camente en la figura 13.4 se muestra el resultado de copiar un puntero
otro.

Antes Después

pi

 

p2

p2 = pl;
Figura 13.4 Copia de un puntero en otro.

 

Tanto la variable p1 como p2 quedan señalando a la misma variable dinámica.

Un problema delicado al manejar variables dinámicas es que pueden quedar
'perdidas, sin posibilidad de hacer referencia a ellas. Esto ocurre en el siguiente
ejemplo:

int* Tp_Entero;

ntero pl, p2;

new int;
new int;
pl;

lp2

En la figura 13.5 sc muestra gráficamente el resultado.
 

358 Fundamentos de progr:

 

Antes Después

«e

p2 = pl;
Figura 13.5 Variable dinámica perdida.

     
 

En este caso la variable creada mediante p2 = new int; queda perdida, si
posibilidad de ser usada, ya que las variables dinámicas no tienen nombre,
el único puntero que la señalaba ha cambiado su valor, perdiendo el anteri
Además el espacio ocupado por la variable dinámica sigue reservado, lo
es totalmente imútil y representa una pérdida de la capacidad de mem
disponible (en inglés se denomina memory leak).

13.4 Realización de secuencias mediante punteros

Los punteros son un elemento de programación de muy bajo nivel. Los ler
gunjes de programación simbólicos deberían evitar su empleo, sustituyéndolo
por mecanismos más potentes de declaración de estructuras de datos, que
permitiesen definir directamente estructuras dinámicas ilimitadas.

Desgraciadamente, muchos lenguajes están diseñados pensando en que su come
pilación no sea demasiado complicada. Las estructuras de datos con tamaño
variable presentan algunas complicaciones para ser manejadas de manera efciente, y os frecuente que los lenguajes de programación no incorporen directamente esquemas de datos de tamaño variable. Esta limitación facilita el
trabajo de compilación, ya que todas las variables tendrán un tamaño fijo que
puede ser calculado por el compilador, y determinar así el espacio de memoria
que ha de reservarso para cada una.

Ch no dispone de esquemas de datos de tamaño variable. Dichos esquemas
pueden ser realizados indirectamente por el programador mediante el uso de
punteros. Al hacerlo convendrá tener cuidado, y emplearlos de una manera
precisa, traduciendo a punteros los mecanismos de definición de alto nivel que
deberían estar disponibles.

La definición simbólica de una estructura ilimitada basándose cn esquemas
con número fijo de elementos será, normalmente, recursiva. Una definición
Punteros y variables dinámicas 359

 

recursiva es aquella en que se hace referencia a sí misma. Sería deseable que
una secuencia ilimitada se pudiese definir de manera recursiva, sin necesidad
de punteros, de una forma parecida a la siguiente:

 

typedef struct Tipo-secuencia [
bool vacia; /* indica si es la secuencia vacía */
Tipo-componente primero; /* sólo si no es vacia */
Tipo-secuencia resto; /* sólo si no es vacía */  /* ERROR */

 

Esta definición nos dice que una secuencia ilimitada de componentes es una de
dos cosas posibles: o bien una secuencia vacía, o bien una primera componente
seguida de la secuencia formada por el resto de las componentes.

Lamentablemente esta forma de definición recursiva no es admisible en CE.
Para definir una secuencia ilimitada tendremos que recurrir al empleo de variables dinámicas y punteros. Una manera de hacerlo es usar punteros para
enlazar cada elemento de la secuencia con el siguiente tal y como se muestra
en la figura 13.6.

 
 
 

secuencia

primero

  
   

primero

primero

Figura 13.6 Secuencia enlazada mediante punteros.

Cada elemento de la secuencia se materializa como un registro con dos campos:
el primero contiene el valor de una componente, y el segundo es un puntero
que señala al siguiente. El último elemento tendrá el puntero al siguiente con
valor NULL. La secuencia completa es accesible a través de un puntero que
señala al comienzo de la misma.

Aplicando este esquema con punteros sí es posible definir una secuencia ilimitada en CE. La siguiente definición trata de ser lo más parecida posible a la
definición recursiva propuesta antes:
typedef struct Tipo-nodo (

Tipo-componente primero;

Tipo-nodo * resto;

 

typedef Tipo-nodo * Tipo-secuencia;

 
 

360 Fundamentos de programación:

 

Esta pareja de definiciones es válida en C£, aunque tiene una característica
excepcional: se usa el identificador Tipo_nodo antes de haber sido de
completamente. Esto sólo es posible hacerlo en declaraciones de punteros
la anterior. Gracias a esa posibilidad se puede realizar mediante punteros alga
equivalente a uma definición recursiva de un esquema de datos.

Una vez definidos los tipos de la secuencia y sus componentes se podrán de
clarar variables de dichos tipos y operar con ellos:

Tipo-componente valor;
Tipo-secuencia secuencia, siguiente;

 

if (secuencia != NULL) (
(*secuencia).primero = valor;
siguiente = (*secuencia) .resto;

y

La combinación del operador de desreferenciación de puntero (*) y la selección
de campo de registro (.) es incómoda de escribir, porque requiere paréntesis,
y difícil de leer. Por esta razón C£ permite combinar ambos en un operador
único con una grafía más amigable (->). Las sentencias anteriores se pueden
reescribir de la forma siguiente, mucho más fácil de leer:
if (secuencia NULL) 4

secuencia->primero = valor;

siguiente = secuencia->resto;

 

 

3

13.4.1 Operaciones con secuencias enlazadas

Describiremos la manera de realizar algunas operaciones típicas sobre secuen=
cias enlazadas con punteros. En ellas supondremos la existencia de un cursor.
que va señalando a las componentes una tras otra. El cursor será simplemente
un puntero. Como ejemplos de operaciones desarrollaremos algunos fragmen=
tos de un programa para leer números enteros e imprimirlos en orden, así como
para quitar luego de la lista ordenada los números que se indiquen.

DEFINICIÓN - La definición de la secuencia será:

typedef struct TipoNodo 1
int valor;
TipoNodo * siguiente;
»
typedef TipoNodo * TipoSecuencia;
TipoSecuencia secuencia;

 
  
 
   
   
  
  
  
    
   
   
   
 
 
 
 
 
 
 
  
   
 
 
 
 
 
 
   

Punteros y variables dinámicas 361

 

RECORRIDO - El recorrido de toda la secuencia se consigue mediante un
bucle de acceso a elementos y avance del cursor. Puesto que la secuencia tiene
'un número indefinido de elementos, no se usará un bucle con contador. En
'este caso usaremos 1n esquema while . Como ejemplo describimos la escritura
e los valores de la secuencia.

£ TipoNodo * TipoPuntNodo;
¡poPuntNodo cursor;

¡cursor = secuencia;

lle (cursor != NULL) (

printf( "%5d", cursor->valor );
cursor = cursor->siguiente;

y

BÚSQUEDA - La búsqueda en una secuencia enlazada ha de hacerse de
forma secuencial. La búsqueda es parecida al recorrido, pero la condición de
terminación cambiará. De hecho habrá una doble condición de terminación:
que se localice el elemento buscado, y/o que se agote la secuencia. Á continuación se presenta la búsqueda de la posición en que ha de insertarse un nuevo
número en la secuencia ordenada. La posición será la que ocupe el primer
“valor igual o mayor que el que se quiere insertar.

lánt numero; — /* valor a buscar */

¡TipoPuntNodo cursor, anterior;

 

cursor = secuencia;

anterior = NULL;

while (cursor != NULL ££ cursor->valor < numero) (
anterior = cursor;
cursor = cursor->siguiente;

3

Al salir del bucle cursor queda señalando al punto en que deberá insertarse
el nuevo elemento, y anterior señala al elemento que lo precede. Esto resulta
útil para realizar luego operaciones de inserción o borrado, como se verá a
continuación.

INSERCIÓN - La inserción de un nuevo elemento se consigue creando una
variable dinámica para contenerlo, y modificando los punteros para enlazar
dicha variable dentro de la secuencia. El caso más sencillo es el de insertar un
nuevo elemento detrás de uno dado. La representación gráfica se muestra en
la figura 13.7

En la figura, el nuevo elemento creado tiene un fondo diferente, además se
han marcado con línea discontinua los enlaces creados o modificados por estas

 
 

   
 
   
  

362 Fundamentos de program:

 

e

  

anterior — nuevo

Figura 13,7 Inserción en una secuencia de punteros,

operaciones. El orden de las operaciones a realizar resulta esencial para
no se produzca la pérdida de ninguna variable dinámica y por ello, en la figura.
también se ha detallado el orden de los pasos a realizar. El código en Ct serás

int numero;  /* valor a insertar */
TipoPuntNodo cursor, anterior, nuevo;

nuevo = new TipoNodo; /* 19 paso */
nuevo->valor = numero;

nuevo->siguiente = anterior->siguiente; /* 2% paso */
anterior->siguiente = nuevo; /* 32 paso */

BORRADO - Para borrar un elemento hay que quitar el nodo que lo contiene,
enlazando directamente el anterior con el siguiente tal como se indica en la
figura 13.8. Es la operación inversa de la inserción. Si el nodo que contenía
el elemento ya no es necesario hay que destruirlo explícitamente. También en
este caso es importante seguir el orden que se detalla en la figura 13.8.

e

 

anterior. cursor

Figura 13.8 Borrado en una secuencia de punteros

Igual que antes, en la figura 13.8 se han marcado con línea discontinua los
enlaces modificados por las operaciones de borrado. Además, el elemento
borrado aparece con un fondo diferente. Para hacer el código más robusto se
ha forzado el cursor a valor nulo, ya que de no hacerlo así quedaría apuntando
Punteros y variables dinámicas 363

 

a un lugar que ya no existe (marcado con una X en la figura). El código en
Ct será:

'TipoPuntNodo cursor, anterior;

'anterior->siguiente = cursor->siguiente;
delete cursor;
cursor = NULL;

“Estos ejemplos de inserciones y borrados corresponden al caso general y operan
con elementos en medio de la secuencia. Si la inserción o borrado debe hacerse
al principio de la secuencia el código es algo diferente, ya que no hay elemento
anterior, pero es igualmente sencillo.

 

13.42. Ejemplo: Leer números y escribirlos en orden

Reuniendo los fragmentos de código anteriores se puede escribir ya este ejemplo. Aquí se ha tenido en cuenta el caso especial de insertar o borrar al
principio de la secuencia. Esta situación se detecta porque no existe elemento
anterior, y el puntero al elemento anterior queda con valor NULL después de

la búsqueda.

El resto del código del programa es esencialmente idéntico a los fragmentos
desarrollados en los ejemplos anteriores. La mayor parte del código añadido
corresponde a la lectura de los datos y la escritura de los resultados. El listado
del programa completo es el siguiente:

 

PARAR

* Programa: Secuencia

* Descripción:

* Programa que lee una serie de números enteros,

= los almacena en una secuencia enlazada, en orden,
* y los imprime. Después se pueden borrar de

* manera selectiva.
NA

include <stdio.h>

typedef struct TipoNodo (
int valor;
TipoNodo * siguiente;
5
typedef TipoNodo * TipoSecuencia;
typedef TipoNodo * TipoPuntNodo;

 
 

 

 

364 Fundamentos de progr:

int main() £
int nunero;
TipoSecuencia secuencia;
TipoPuntNodo cursor, anterior, nuevo;

/*-- Leer los datos y almacenarlos --*/
print£( "Datos leidos:in" );
secuencia = NULL;
scanf( "%d", fmumero );  /* primer dato */
while (numero ot

print£( " Xd", numero );

  
 

/*-- Buscar posición para el nuevo número --*/
/* 'anterior' señalará al nodo detrás del

cual hay que insertar el nuevo valor */
cursor = secuenci;
anterior = NULL;
while (cursor NULL £8 cursor->valor < numero) [

anterior = cursor;

cursor = cursor->siguiente;

J

 

  

/*— Crear nodo con el nuevo número --*/
nuevo = new TipoNodo;
nuevo->valor = numero;

/*— Insertar el nodo en la secuencia --*/
if (anterior == NULL) (
/*— Insertar al comienzo de la secuencia
nuevo->siguiente = secuencia;
secuencia = nuevo;
) else £
/*-- Insertar detrás del anterior --*/
nuevo->siguiente = anterior>siguiente;
anterior->siguiente = nuevo;
,
scan£( "%d", gnumero );  /* siguiente dato */
y
print£( "a" );

 

/*— Mostrar la lista ya ordenada --*/
printf£( "InDatos ordenadosin" );
cursor = secuencia;
while (cursor != NULL) (

print£( "X5d", cursor->valor );

  

 

 
teros y variables dinámicas 365

 

  
   
   
  
 

cursor = cursor->siguiente;
,
print£( "Ya" );

/*— Bucle de búsqueda y borrado de números --*/
printf( "WnDatos a borrar:Wn" );

scanf( "%d", Emumero );  /* primer dato */
mile (numero != 0) £

/*-- Buscar posición del número a borrar --*/
cursor = secuencia;
anterior = NULL;
while (cursor != NULL 8 cursor->valor != numero) 4
anterior = cursor;
cursor = cursor->siguiente;

3

 

 

/*-- Borrar el número encontrado --*/
if (cursor != NULL) [ /* el múnero está en la lista */
if (anterior != NULL) [
anteriorsiguiente = cursor->siguiente;
) else £
secuencia = cursor->siguiente;
5
delete cursor;
print£( " xd borradon", numero );
cursor = secuencia;

 

while (cursor NULL) 4
print£( "X5d", cursor->valor );
cursor = cursor->siguiente;
y
print£( "Ya" );
J else ( /* el número no está en la lista */
printf£( ” %d no encontradoWn"”, numero );
y

scanf( "Xd", Enumero );  /* siguiente dato */
3

 

ejecución del programa utilizando los siguientes datos de ejemplo:

 

   

34256471330
115670

¡porciona los siguientes resultados:
  

366 Fundamentos de progr:

 

 

 

Datos leídos:
12 34 2 56 47 133

Datos ordenados
1.2 4 7 12 33 34 56

Datos a borrar:
4 borrado

1. 2 7 12 33 34 56
11 no encontrado

1 borrado

2 7 12 33 34 56
56 borrado

2 7 RQ 3 3
7 borrado

2 12 33 34

13.5 Punteros y paso de argumentos

  
 

El manejo de punteros cuando se utilizan como argumentos de un subprogr:
tiene ciertas peculiaridades que requieren un estudio más detallado.

13.5.1 Paso de punteros como argumentos

Como cualquier otro dato, un puntero puede pasarse como argumento a un
subprograma. Así, la operación de imprimir la lista de números enteros del
ejemplo anterior podría redactarse como procedimiento que reciba como argumento la secuencia enlazada. Tal como se veía, una secuencia enlazada se
maneja a partir del puntero al primer elemento, El código del procedimiento
y un ejemplo de cómo invocarlo serí

 

 

  

void Imprimirlista( TipoSecuencia lista ) £
TipoPuntNodo cursor = lista;

while (cursor != NULL) (
print£( "X5d", cursor->valor );
cursor = cursor->siguiente;
J
printf£( "Ya" );
+
  
 
  
  
  
 
 
 
   
   
 
 
 
   
 
  
  
   
 
 
  
  
   
    
   
  
  

 

Punteros y variables dinámic. 367

 

TipoSecuencia secuenci

 

ImprimirLista( secuencia );

Por defecto, los datos de tipo puntero se pasan como argumentos por valor.
Es lo que ocurre en el ejemplo anterior. Si se desea usar un subprograma
para modificar datos de tipo puntero, entonces habrá que pasar el puntero
por referencia. Por ejemplo, si planteamos como subprograma la operación de
búsqueda en una secuencia enlazada podríamos escribir:

void Buscar( TipoSecuencia lista, int numero,
TipoPuntNodo £ cursor, TipoPuntNodo £ anterior ) £

cursor = lista;

anterior = NULL;

while (cursor != NULL 8%: cursor->valor != numero) £
anterior = cursor;
cursor = cursor->siguiente;

 

3
3

¡TipoSecuencia secuencia;
'TipoPuntNodo encontrado, previo;
int dato;

Buscar( secuencia, dato, encontrado, previo );

En la llamada a Buscar la variable secuencia no podrá ser modificada, ya
¿que el argumento lista se pasa por valor. Por el contrario, las variables de
'tipo puntero encontrado y previo serán modificadas por el subprograma para
lejar el resultado de la búsqueda.

     

3.5.2 Paso de argumentos mediante punteros

general el valor de un puntero en sí mismo no es significativo, sino que
puntero es sólo un medio para designar la variable apuntada. Desde un
ito de vista conceptual el paso de un puntero como argumento puede ser
siderado equivalente a pasar como argumento la variable apuntada.

ejemplo, si queremos pasar como argumento una variable dinámica poderecurrir a un puntero como elemento intermedio para designarla. Esto
'esenta una dificultad añadida para entender cómo funciona un determinafragmento de código, y de hecho representa un peligro potencial de cometer
'erminados errores de codificación.

 
  
  
  
   
  
     

368 Fundamentos de program:

 

La dificultad reside en cl hecho de que pasar un puntero por valor no ex
que el subprograma pueda modificar la variable apuntada. Por ejemplo:

typedef int* Tp_Entero;

void Imprimir( Tp_Entero val ) (
printf( "%d", *val );
3

void Incrementar( Tp_Entero val ) (
*val = *val + 1;
3

Tp Entero pl;
pl = new int;

Imprimir( pl
Incrementar( pl );

 

Tanto el procedimiento de Imprimir como el de Incrementar reciben un puntero pasado por valor. El primero no modifica la variable apuntada pero el
segundo sí. Al establecer la analogía entre cl paso como argumento del puntero y el paso como argumento de la variable apuntada, la distinción entre paso
por valor y por referencia se pierde. El paso por valor de un puntero equivale
al paso por referencia de la variable apuntada.

En realidad los punteros se usan implícitamente para pasar argumentos por
referencia. Cuando se declara un argumento pasado por referencia, lo que hace
realmente el compilador es pasar un puntero a la variable externa usada como
argumento actual en la llamada. Dado el subprograma:
void Duplicar( int € valor ) £

valor = 2 * valor;
,

El código interno generado por el compilador es equivalente a:
typedef int * P_int;

void Duplicar( P_int p_valor ) (
*p_valor = 2 * (*p_valor);

3

De hecho la notación $ para indicar el paso de argumento por referencia es
una mejora de C++ respecto a C. En lenguaje C hay que usar siempre un
puntero explícito para pasar argumentos por referencia. Por supuesto, hace
  
 
 
    
  
   
   
  
 
 
 
 
 
 
   
   
   
   
   
    
 
   

Punteros y variables dinámicas 369

falta entonces un operador especial para obtener el valor de un puntero a una
variable (estática) y usarlo en la llamada al subprograma. En lenguaje C ese
operador corresponde también al símbolo £, como se muestra a continuac
int numero;

 

Duplicar( Enumero );

Ahora debe quedar clara la manera de invocar ciertas funciones estándar de C,
tal como scan£(). A lo largo de todo este libro han ido apareciendo sentencias
de lectura como la siguiente:

Iscan£( "xd", gnumero );

Lo que se está haciendo en esta llamada es pasar como argumento un puntero
que señala a la variable numero, a través del cual se puede modificar su valor.
Hay que hacer notar que el puntero en sí se está pasando por valor, y eso es
equivalente a pasar el dato apuntado por referencia.

 

En bastantes casos cuando se trabaja con variables dinámicas, que sólo son
accesibles a través de punteros, resulta natural usar un puntero explícito para
pasar como argumento la variable dinámica apuntada. Insistiremos en que el
paso del puntero equivale a pasar la variable apuntada siempre por referencia.
En C£ para pasar la variable apuntada por valor hay que hacerlo de la manera
convencional, como en el siguiente ejemplo de código:

'typedef int* Tp Entero;

 

id Imprimir int val ) 4 /* paso por valor */
print£( "%d", val );
y

id Incrementar( Tp_Entero val ) 4 /” paso por referencia */
*val = *val + 1;

¡Imprimir( *pl );
icrementar( pl );

NOTA: En lenguaje C++ existe la posibilidad de programar algo equivalente al pa¡so por valor, pero usando un puntero explícito como intermediario. Esto se consigne
'usando adecuadamente el cualificador const en puntos determinados de la declaración del tipo puntero y/o del argumento. Lamentablemento la semántica de estas

strucciones es extraordinariamente compleja y confusa, por lo que se ha optado
¡por no incluirlas en el subconjunto C£.
370 Fundamentos de progri

 

13.5.3 Ejemplo: Leer números y escribirlos en orden

Como ejemplo del uso de punteros como argumentos se reescribe a con
ción el mismo ejemplo de manejo de ima secuencia de múmeros, pero def
ahora como subprogramas algunas de las operaciones sobre la secuencia.
listado del nuevo programa es el siguiente:

 

 

 

PARAR AAA

* Programa: Secuencia2
* Descripción:

* — Programa que lee una serie de números enteros,

* los almacena en una secuencia enlazada, en orden,
* y los imprime, Después se pueden borrar de
* — manera selectiva.

RARA ARALAR ENANA

*tinclude <stdio.h>

typedef struct TipoNodo (

int valor;

TipoNodo * siguiente;
typedef TipoNodo * TipoSecuencia;
typedef TipoNodo * TipoPuntNodo;

/** Insertar un nuevo número en una secuencia ordenada */
void InsertarEnOrden( TipoSecuencia £ secuencia, int numero ) £
TipoPuntNodo cursor, anterior, muevo;

/*-- Buscar posición para el nuevo número --*/

/* 'anterior' señalará al nodo detrás del
cual hay que insertar el nuevo valor */

cursor = secuencia;

anterior = NULL;

while (cursor != NULL 88 cursor->valor < numero) £
anterior Cursor;
cursor = cursor->siguiente;

Ñ

/*-- Crear nodo con el nuevo número --*/
nuevo = new TipoNodo;
nuevo->valor = numero;

/*-- Insertar el nodo en la secuencia --*/
if (anterior == NULL) (

 

 
Punteros y variables dinámicas 371

 

/*— Insertar al comienzo de la secuencia —-*/
nuevo->siguiente = secuencia;
secuencia = nuevo;
Y else [
/*— Insertar detrás del anterior --*/
nuevo->siguiente = anterior->siguiente;
anterior->siguiente = nuevo;
y
y

 

/** Quitar todas la apariciones de un número de una secuencia de números */
'woid Eliminar( TipoSecuencia € secuencia, int numero, bool 4 encontrado ) 1
TipoPuntNodo cursor, anterior, aux;

encontrado = false;
cursor = secuencia;
anterior = NULL;
while (cursor != NULL) 4
aux = cursor->siguiente;
if (cursor->valor == numero) £ /* encontrado, borrarlo */
encontrado = true;
if (anterior != NULL) (
anterior->siguiente = cursor->siguiente;
) else (
secuencia
J
delete cursor;
j else (  /* no encontrado */
anterior = cursor;

 

 

cursor->siguiente;

J
cursor = aux;
y
3

/** Imprimir una secuencia de números */
void Imprimir( TipoSecuencia secuencia ) (
TipoPuntNodo cursor;

cursor = secuencia;

while (cursor != NULL) £
print£( "%5d", cursor->valor
cursor = cursor->siguiente;

y

print£( "Ya"

 

 

 

 
372 Fundamentos de progr:

 

TipoSecuencia secuencia;
bool borrado;

/*-— Leer los datos y almacenarlos --*/

printf( "Datos leídos:1n" );

secuencia = NULL;

scanf( "Xd", gnumero );  /* primer dato */
while (numero != 0) €

Lo print£f( " %d", numero );

InsertarEnOrden( secuencia, numero );

scanf( "Xd", gmumero );  /* siguiente dato */

 

print£( "a" );

 

/*— Mostrar la lista ya ordenada —
print£f( "YnDatos ordenadosin" );
Imprimir( secuencia );

/*— Bucle de búsqueda y borrado de números --*/
printf( "WnDatos a borrar:Xn” );
scan£( "Xd", Snumero );  /* primer dato */
while (numero != 0) (
Eliminar( secuencia, numero, borrado );
if ( borrado) £
printf£( ” %d borradoin", numero );
Imprimir( secuencia );
) else £
print£( " %d no encontradoWn", numero );

 

scanf( "%d", ánumero );  /* siguiente dato */
y

 

 

| y

 

   

| El programa funcionará igual que antes. Por lo tanto se reproducirá el ejemplo
| de funcionamiento con los mismos datos y resultados que se mostraron antes.

13.6 Punteros y vectores en € y C++

En C/C++ existe una estrecha relación entre las formaciones y los punteros. Sin embargo desde un punto de vista metodológico esta relación resulta
bastante confusa, disminuye la claridad y aumenta la ambigiiedad de los programas. Por esta razón, en este libro y en el lenguaje Ct se ha tratado de

  
 

Punteros y variables dinámicas 373

 

separar ambos conceptos de manera expresa. Lamentablemente, en el lenguaje
Ci no ha sido posible incorporar restricciones sintácticas capaces de impedir
el manejo de punteros como formaciones debido al carácter semántico de esta
relación. Por ello, es en el Manual de Estilo donde se incorpora una rogla de
obligado cumplimiento que prohíbe el uso de punteros como formaciones.

En las siguientes secciones se explica la analogía que existe en C/C++ entre
los punteros y las formaciones, mostrando algunas de las posibilidades y consecuencias de este hecho. La razón de estas explicaciones cs aclarar algunas
de las irregularidades que presenta el lenguaje Ct en el manejo de las formaciones. Por tanto, en estas siguientes secciones se muestran operaciones que
están expresamente prohibidas y que no se deben utilizar en los programas.

13.6.1 Nombres de vectores como punteros

Cuando se ha declarado una variable de tipo vector el nombre de dicha variable
equivale en gran medida a un puntero que apunta al comienzo del vector. El
siguiente fragmento de código es perfectamente válido en C/C++:

typedef int* Tp_Entero;
typedef int Tv_Entero[5];

void Incrementar( Tp_Entero val ) £ /* paso por referencia */
*val = *val + 1;

J

void ImprimirVector( const int v[], int nv) (f
for (int k<nV; k++) 4
print£( "*10d", vIk] »;

 

,
print£( "a" );
J

Tp_Entero pl;
Tv_Entero vl = (10, 20, 30, 40, 50);

pl = vi; /* vector como puntero */

Increnentar( pl );
ImprimirVector( pl, 5); /* puntero como vector */

Incrementar( v1 ); /* vector como puntero */
ImprimirVector( vl, 5 );

 
374 Fundamentos de programación

 

Incrementar( 8v1[0] );
ImprimirVector( 8v1[0], 5); /* puntero como vector */

El nombre del vector vl equivale al valor de un puntero que señala al comienzo,
es decir, al primer elemento v1[0]. Por lo tanto puede ser asignado a una
variable puntero del tipo equivalente. En sentido contrario, un puntero de ese
tipo puede ser usado como argumento al invocar un subprograma que requiera
un vector. Tras la asignación p1 = vl en el ejemplo, cada una de las parejas
de sentencias Incrementar(); ImprimirVector(); realizan la misma acción:
incrementar cl valor del primer elemento y luego imprimir los 5 elementos del
vector.

La analogía alcanza incluso a poder utilizar el puntero como base para indexar
un elemento del vector. Tras ejecutar pl = v1 las expresiones siguientes son
equivalentes:

  

p113] — equivalea — v1[3]

Y aún más, en la declaración de un puntero se puede crear e inicializar un
vector al que apunte:

typedef char * TipoPalabra;
TipoPalabra nombre = "Juan Antonio";

A pesar de lo anterior una variable puntero es claramente distinta de una
variable vector. La asignación de un puntero a un vector

 

[v1 = pi;

  

no es aceptada por el compilador y provoca un mensaje de error

13.6.2 Paso de vectores como punteros

Tras las explicaciones anteriores debe quedar elaro por qué el paso de vectores como argumentos se trata de manera diferente al paso como argumento
de otros tipos de valores. Repetimos aquí algunos fragmentos de código del
tema Y:

const int NumeroElementos = 10;
typedef int TipoVector[NuneroElementos];

void LeerVector( TipoVector v ) f...) /* paso por referencia */

 

void EscribirVector( const TipoVector w ) (f...) /* paso por valor */

 
teros y variables dinámicas 375

 

  
  
  
   
 
 
    
  
  
   
   
  
  
  
  
  
  
  
  
   
  
  

Las cabeceras de los subprogramas son en realidad equivalentes a las siguientes:

lef int* TipoPuntero;
LeerVector( TipoPuntero pv ) £...+ /* paso por referencia */
'woid Escribirvector( const TipoPuntero pv ) 4...) /* paso por valor */

Tal como se ha dicho antes en este tema, el paso por valor de un puntero
equivale al paso por referencia de la variable apuntada. El cualificador const
delante de un argumento formal de tipo puntero indica al compilador que ese
valor de tipo puntero no debe ser usado para modificar la variable a la que
apunta.

13.6.3. Matrices y vectores de punteros

Si un puntero es análogo a un vector, entonc
a una matriz, es decir, a un vector de vector
de declaraci

 

un vector de punteros es análogo
.. Veamos primero un ejemplo
1 y uso de una matriz de enteros con 10 filas de 15 elementos:
|typedef int TipoFila[15];

[typedef TipoFila TipoMatriz[10];

 

  

|
|TipoMatriz matriz;
|

[matriz[3][5] = 27;

Y ahora un ejemplo similar usando un vector de punteros:
typedef int * TipoPuntero;

typedef TipoPuntero TipoMatriz[10];

TipoMatriz matriz;

matriz[3][5] = 27;

Este segundo ejemplo es sintácticamente correcto, pero sólo es realmente válido
si los punteros señalan a vectores de enteros. Para que la analogía sea total es
necesario crear dinámicamente cada fila de la matriz a partir de cada elemento
del vector de punteros:

for (int k=0; k<=10; k++) £

matriz[k] = new TipoFila;

 

 

y
376 Fundamentos de pr

 

   
    
  
   

La figura 13.9 muestra la diferencia entre una matriz propiamente dicha.
decir, un vector de filas, y su estructura análoga en forma de vector de pi
afilas. En ambos casos un elemento se designa como matriz[fila] [col
pero la organización de los datos en memoria es claramente diferente.

 

Figura 13.9 Matriz y vector de punteros a filas.

De hecho la segunda alternativa no exigo que todas las filas tengan cl misma
tamaño, Esto permite, por ejemplo, construir “diccionarios” en forma de
vectores de palabras que son a su vez vectores de caracteres, pero cada anna de
un tamaño diferente:

typedef char * TipoPalabra;
typedef TipoPalabra TipoDiccionario[7];

TipoDiccionario nombreDias = (
"Lunes"
"Martes",

"Miércoles",
"Jueves",

 

   
 

"sábado",
"Domingo"

»

En el lenguaje C/C++ el manejo de punteros permite realizar otras estruc
turas y operaciones más complejas y sofisticadas pero que habitualmente dan
lugar a programas enrevesados y muy difíciles de comprender. Dichas operaciones, además de quedar fuera del alcance de esta asignatura, también
estarían expresamente prohibidas en Ct.

 
Tema 14

Tipos abstractos de datos

En este tema se da una introducción a los tipos abstractos de datos (T'ADs),
como adelanto de lo que es la programación orientada a objetos, que excedo del
ámbito de este libro. Se introduce el concepto de tipo abstracto y las técnicas
para programarlos como tipos registro (struct) en Ct.

Aunque los tipos struct de (++ son en realidad clases, en Ct se plantean
de manera algo restringida, como un mecanismo relativamente sencillo para
la programación de tipos abstractos

14.1 Concepto de tipo abstracto de datos (TAD)

En programación tradicional, se identificaba el concepto de tipo de dato con el
del conjunto de valores que pueden tomar los datos de ese tipo. De hecho esta
idea se la aplicado más a la forma de representación de los valores que a. los
valores en sí. Por ejemplo, si tenemos que operar con valores correspondientes
a los meses del año, lo podremos hacer representándolos mediante números
(1 al 12) o bien mediante cadenas de caracteres (ENE, FEB, ote.), entre
otras posibilidades. Estas representaciones se asocian con diferentes tipos de
datos. En Ct oscribiríamos:

| typedef int TipoMes;

 

 

o bien:
[typedef char TipoMes[4]; /* 3 caracteres + carácter nulo al final */

Un enfoque más moderno de la programación trata de asociar la idea de tipo
de datos con la clase de valores, abstractos, que pueden tomar los datos. Esto

 
 

 

378 Fundamentos de programaci

 

  

quiere decir que la representación o codificación particular de los valores mo
cambia, de hecho, el tipo del dato considerado. Un paso adelante en este
sentido ha sido la introducción de los tipos enumerados, en los que se definen
colecciones de valores, abstractos, asociados a identificadores utilizables dentro
del programa.

Como ya se ha dicho, los valores de los tipos enumerados no son valores n=
méricos, ni cadenas de caracteres, aunque pueden transformarse en esas otras
formas de representación usando apropiadamente los mecanismos del lenguaje.
Por ejemplo:

typedef emum TipoMes ( Enero, Febrero, ... Diciembre );
TipoMes mes;

print£( "%d", int(mes)+1 );

En el enfoque actual de la programación se identifican los tipos de datos de
forma completamente abstracta, llegando a la idea de tipo abstracto de datos
(TAD). Esto quiere decir que un programa que use ese tipo de datos no debería necesitar ningún cambio por el hecho de modificar la representación o
codificación de los valores de ese tipo. Si analizamos con cuidado qué necesita
un programa para poder usar datos de un tipo, encontraremos que hace falta:

+ Hacer referencia al tipo en sí, mediante un nombre, para poder definir
variables, subprogramas, ete

+ Hacer referencia a algunos valores particulares, generalmente como constantes con nombre.

+ Invocar operaciones de manipulación de los valores de ese tipo, bien
usando operadores en expresiones aritméticas o bien mediante subprogramas.

El conjunto de todos estos elementos constituye el tipo abstracto de datos
(TAD):

Un tipo abstracto de datos (TAD) es una agrupación de una colección de
valores y una colección de operaciones de manipulación.

Es importante comprender que estas colecciones son cerradas, es decir sólo
se deben poder usar los valores abstractos y las operaciones declaradas para
ese tipo. Además los detalles de cómo se representan los valores y cómo se
implementan las operaciones pueden estar ocultos para quien utiliza el tipo
abstracto. Esto no ocurría enando se asociaba el tipo de valor con su forma
de representación. Por ejemplo, si representamos los meses del año mediante
números, podremos usar el número 33, aunque no sca ningún mes válido, al
Tipos abstractos de datos 379

 

igual que podremos multiplicar los números de dos meses, aunque esto no
tenga ningún sentido.

La programación orientada a objetos, ampliamente usada en la actualidad,
se basa esencialmente en el uso de tipos abstractos de datos, con algunas
modificaciones. La terminología cambia bastante: sc habla de clases y objetos
en lugar de tipos y datos, y de métodos en lugar de operaciones. Por otra
parte se añade el concepto de herencia para facilitar la definición de nuevas
clases a partir de otras ya existentes, reutilizando elementos ya definidos.

 

Este tema se limita a introducir el concepto de tipo abstracto de datos, que es
perfectamente suficiente para desarrollar una buena metodología de desarrollo
de programas. La programación orientada a objetos se deja para un estudio
posterior.

14.2 Realización de tipos abstractos en Ct

Cuando se utiliza un lenguaje de programación orientado a objetos el mecanismo de clases del que dispone es perfectamente adecuado para programar tipos
abstractos de datos, ya que de hecho las clases son implícitamente TADs. Eso
ocurre, por ejemplo con C++.

Sin embargo, el subconjunto denominado C+ que se usa en este libro no contempla la definición de clases como tales, sino que se limita a presentar una
forma algo más limitada de programar tipos abstractos de datos. Para ello se
aprovecha el hecho de que los tipos registro (struct) se tratan en C++ como
equivalentes a clases.

14.2.1 Definición de tipos abstractos como tipos registro
(struct)

Hasta ahora se ha visto que los tipos registro permiten definir estructuras con
varios campos de datos con nombre y tipo individual, Ahora añadiremos la
posibilidad de incluir también otros elementos, en particular subprogramas,
y distinguir entre elementos públicos y privados. De esta manera se pueden
definir tipos abstractos de datos, ya que:

 

+ Los campos de datos sirven para almacenar el contenido de inform:
del dato abstracto.
+ Los subprogramas permiten definir operaciones sobre esos datos.

 
 

380 Fundamentos de pr

 

   
    
   
   
   

+ La posibilidad de declarar ciertos elementos como privados permite
tar detalles de implementación, y dejar visible sólo la interfaz del
abstracto.

Para ello las reglas de sintaxis de la declaración de un tipo registro se

de la siguiente forma:

Tipo_struct 33= typedef struct Identificador
1 Lista_de_items [ private: Lista_de_items ] 3 ;

= ltem ; (tem; )

 

 

Lista_de_items

 

Item 33= Campo | Cabecera_ subprograma

 

Campos_igual_tipo | Campo_puntero | Campo_ array
Identificador_de_tipo Lista_de identificas
Identificador_de_tipo * Identificador

Campo

 

Campos_igual_tipo

 

Campo_puntero

 

Campo_array *3= Identificador de tipo Identificador Dimensiones

Como ejemplo se muestra una declaración del tipo abstracto TipoPunto,
rrespondiente a un punto en el plano euclídeo. Cada punto se representa
sus coordenadas cartesianas, y se le asocian subprogramas para leer y escri
puntos (sus coordenadas), y para calcular la distancia entre dos puntos.
typedef struct TipoPunto (

float /* Coordenada X */

float /* Coordenada Y */

 

/** Leer un punto con formato "(x,y)" */
void Leer();
/** Escribir un punto con formato “(x,y)" */
void Escribir();
/** Calcular la distancia de un punto a otro */
float Distancia( TipoPunto p );

»

Como puede verso, los subprogramas correspondientes a las operaciones sobre
el tipo abstracto se declaran simplemente por su cabecera, porque lo que se
declara aquí es sólo la interfaz del tipo. La notación para referirse a las operaciones es la misma que para los campos de datos, usando el punto (.) como
operador de cualificación. El esquema de esta notación y un ejemplo de uso
som:

variable. campo Referencia a campo de datos
variable. operacióní argumentos ) Referencia a operación
Tipos abstractos de datos 381

 
 
  
  
   
  
   
   
   
  
 
  
   
 
   
 
   
  
 
 
    
  
 
 
  
  

Punto p, q;

int£( "%f”, p.Distancia( q) );

¡Como complemento de la declaración de la interfaz se necesita además definir
la implementación de las operaciones. Esta implementación se hace fuera de
la declaración del tipo registro, usando la notación Tipo: : Operación como
"nombre del subprograma. El código de implementación sería:

¡include <stdio.h>
finclude <math.h>

  

 

/* Excepción en lectura */
typedef enum TipoPuntoError £ PuntoNoLeido 3;

/** Leer un punto con formato "(x,y)" */
void TipoPunto: :Leer() (
int campos;

campos = scanf( " (%£ , %£ )", Ex, dy );
if (campos < 2) £ /” comprobar que se han leído dos valores */
throw PuntoNoLeido;
$
3

/%* Escribir un punto con formato "(x,y)" */
void TipoPunto::Escribir() (
printf( "(%f, X£)", x, y );

/** Calcular la distancia de un punto a otro %/
float TipoPunto: :Distancia( TipoPunto p ) (
float deltaX, deltaY;

 

deltaX =x - p.x;

deltaY = y - p.y;

return sqrt( deltaX*deltaX + deltaY*deltaY );
,

Como se ve, en el código de implementación se puede hacer referencia a los
campos de la estructura directamente por su nombre, sin necesidad de cuali
 
   
 
   
 
   
 
 
 
 
 
    
 
    
   

382 Fundamentos de programación:

ficación. Se sobreentiende que se refieren a la propia variable sobre la quese
invoca la operación.

Adicionalmente en este ejemplo se ha utilizado el subprograma scanf come.
función, y no como procedimiento (en O y C++ no hay diferencia entre ambos.
tipos de subprograma). Se aprovecha el resultado de la llamada, que es el
número de valores efectivamente leídos, para comprobar si hay errores en la
lectura o se alcanza el final de los datos.
NM NOTA: Las operaciones definidas en los módulos de librería estándar de C quedas

fuera del lenguaje Ct en sí. Por lo tanto esas operaciones estándar podrán nsarse com
la misma libertad que en lenguaje C

Una vez definido el tipo abstracto se puede escribir código que lo use. Por
ejemplo, se puede escribir un programa que lea segmentos definidos por sus
puntos extremos, y calcule e imprima sus longitudes:

itinclude <stdio.h>

 

/* Definición del tipo abstracto PUNTO */
/* ... aquí se incluye el código anterior ... */

/** Programa principal */

int main() 4
TipoPunto a, b;
bool seguir = true;

   

while (seguir) £
ty t

a.Leer(

b.Leer(

printf( "Segmento: " );

a.Escribir();

printf( »

b. Escribir();

printf( " Longitud: %£in", a.Distancia( b ) );

catch (TipoPuntoError e) (

seguir = false;

 

 

3
3
J

El programa se plantea como un bucle indefinido que va leyendo pares de
puntos y calcula e imprime la longitud del segmento que definen. El programa
termina cuando se produce una excepción en la lectura de un punto, bien
porque se termina el fichero de datos de entrada o porque aparece un dato que
Tipos abstractos de datos 383

 

no es una representación válida de un punto (x, y), con los paréntesis y la
coma de separación

Combinando los fragmentos de código anteriores podemos mostrar ya el programa completo:

 

JARA

* Programa: Segmentos
.

+ Este programa lee una serie de segmentos, dados
* — por sus extremos, y calcula sus longitudes.
A
finclude <stdio.h>

finclude <nath.h>

Interfaz del tipo abstracto PUNTO

 

e

   

typedef struct TipoPunto (
float x; /* Coordenada X */
float y; /* Coordenada Y */

/* Leer un punto con formato "(x,y)" */
void LeerQ);
/* Escribir un punto con formato "(x,y)" */
void Escribir();
/* Calcular la distancia de un punto a otro */
float Distancia( TipoPunto p );

+

/* Excepción en lectura */
typedef enun TipoPuntoError [ PuntoNoLeido );

 

Pm

 

Implementación del tipo abstracto PUNTO

 

/** Leer un punto con formato "(x,y)" */
void TipoPunto: :Leer() £
int campos;

 

campos = scan£( " (%g , Mg)", 8X, 8y );
if (campos < 2) (
throw PuntoNoLeido;
,
3

 

 
 

 

384 Fundamentos de programación

 

/** Escribir un punto con formato "(x,y)" */
void TipoPunto::Escribir() f

print£( "(%g, %g)", x, y);
Y

/** Calcular la distancia de un punto a otro */
float TipoPunto::Distancia( TipoPunto p ) f
float deltaX, deltaY;

deltaX =x - P.X;

deltaY = y - p.y;

return sqrt( deltaX*deltaX + deltaY*deltaY );
F

yn

 

Programa principal

 

int main()
TipoPunto a, b;
bool seguir = true;

while (seguir) (
try (

a.Leer();

b.Leer();

printf( "Segmento: " );

a.Escribir();

print£( >;

b. Escribir();

printf( " Longitud: %gWn", a.Distancia( b ) );

catch (TipoPuntoError e) (

seguir = false;

 

 

Ejemplo de datos de entrada:

 

 

(0, 9 (3, 0)
(1,2(3,4)

(5,
DG, 0...)

AD aD
No hay más puntos
Tipos abstractos de datos 385

 

Resultados obtenidos:

 

Segmento: (0, 4) (3, 0) Longitud: 5
Segmento: (1, 2) (3, 4) Longitud: 2.82843
Segmento: (5, 0) (6, 0) Longitud: 1
Segmento: (-1, 1) (1, 1) Longitud: 2

14.2.2 Ocultación

Para que un tipo sea realmente abstracto haría falta que los detalles de implementación no fueran visibles. Los subprogramas, como mecanismo de abstracción, ya ocultan los detalles de la realización de las operaciones. Sin embargo
queda la cuestión de cómo ocultar la manera de representar los valores del
tipo abstracto.

En el ejemplo anterior al definir el TipoPunto se tienen visibles los campos
de información de sus coordenadas, que pueden ser consultadas y modificadas
por el código que usa el tipo. En este caso no se presenta ningún problema
por eso, ya que cualquier pareja de coordenadas define un punto válido.

No ocurre lo mismo con otros tipos de datos. Por ejemplo, si se almacena el
valor de una fecha como la tupla mumérica (día, mes, año) no se puede admitir
cualquier combinación de valores. La fecha (20, 7, 2009) es correcta, pero
(7, 20, 2009) no lo es, y menos aún (50, -3, 54321). Si se quiere definir el tipo
fecha como tipo abstracto será necesario ocultar los detalles de representación
interna de los valores, de manera que sólo se puedan construir fechas usando
operaciones que garanticen la corrección de los valores del tipo.

 

 

Para permitir esta ocultación los tipos struct admiten la posibilidad de declarar ciertos elementos componentes como privados, usando la palabra clave
private para delimitar una zona de declaraciones privadas dentro de la estructura. La interfaz básica del TipoFecha podría ser:

typedef struct TipoFecha (
/* Dar valor a un dato fecha */
void Poner( int dia, int mes, int anno );

/* Obtener el contenido de un dato fecha */
int Dial
int Mes(
int Anno();

 

private:

int dia, mes, anno;

5
 
   
 
   
        
  
  

386 Fundamentos de progr

 

Como contrapartida a ocultar los elementos internos de representación de
fechas, ha sido necesario añadir operaciones explícitas para asignar valor y
cuperar el contenido de una fecha. Estas operaciones son las más básicas.
aplicaciones informáticas que operan con datos de tipo fecha son enorme
frecuentes. En ellas se realizan operaciones muy diversas, de manera que

interfaz de un tipo fecha de uso general debería incl E
Citaremos sólo algunas posibilidades, como ejemplo

 

r decenas de operacion

typedef struct TipoFecha 1

void Leer();
void Escribir( const char formato[] );

int DiasHasta( TipoFecha £ );
void Incrementar( int dias );

bool EsAnterior( TipoFecha £ );
bool EsIgual( TipoFecha £ );
bool EsCorrecta();

TipoDiaSemana DiaSemana();
:

 

14.2.3 Ejemplo: Imprimir fechas en orden

Como ejemplo se presenta aquí una nueva versión del programa de leer fechas
e imprimirlas en orden, que ya apareció en el tema 12. Ahora se define el tipo
fecha como tipo abstracto de datos y se simplifica la lectura del mes para no
hacer el código demasiado largo.

 

PA AAA
* Programa: Fechas2

+ Descripción:

+ Programa que lee una serie de fechas,

+ comprueba que son correctas, y las

imprime en orden cronológico.
AAA AAA
*include <stdio.h>

*include <ctype.h>

*include <stdlib.h>
Tipos abstractos de datos 387

 

¡Y tama
Tipo abstracto FECHA

   

 

 

typedef struct TipoFecha ([

bool Leer();

void Escribir();

bool EsCorrecta();

bool EsPosterior( TipoFecha f );

private:
int dia, mes, anno;
+

Jara".

Lista de fechas

const int maxFechas = 100
typedef TipoFecha listaFechas_t[maxFechas];

 

 

 

listaFechas_t lista; /* lista de fechas leídas, en orden */
int nunFechas; /* número de fechas leídas */

Jtamaammamnaas

 

Nombres de los meses

const int maxNombre = 15;

typedef char TipoNombreMes[maxNombre] ;
typedef TipoNombreMes listaNombres_t[13];

 

 

mt

 

 

listaNombres_t nombres = ("?", /* sin nombre cuando mes = 0 */
"Enero", — /* nombres de los meses */
"Febrero",

"Marzo",

"Abril",

"Mayo",
“Junio'
"Julio",
"Agosto",
"Septiembre",
“Octubre”,
"Noviembre",
"Diciembre"

»

 
  

 

 
388 Fundamentos de progr:

 

Implementación de operaciones con FECHAS

 

 

 

*/

/*= Comprobar fecha correcta */
bool TipoFecha: :EsCorrecta() 1

if ( dia<=0 || mes<=0 || anno<=0) £
return false;

,
switch (mes) (
case 1:

(dia <= 31);

(dia <= 30);

 

case 2:
if (anno%4 == 0 48 annoX100 !=0 ||
anno%400 == 0) (
return (dia <= 29);
J else [
return (dia <- 28);
Y
break;
default:
return false;
3
3

/** Escribir fecha día-mes-año */
void TipoFecha: :Escribir() 4

print£( "*2d-%s-%4d", dia, nombres[mes], anno );
,

 

/** Leer mes en número o en letra completo o abreviado */
void LeerMes( int € mes ) (

 

 
 

Tipos abstractos de datos 389

 

TipoNombreMes nombre;
bool encontrado;

scan£( "%s", nombre ); /* leer mes como texto */
if (isdigit(nombre[0])) £  /* mes en múmero */
mes = atoi( nombre );
) else ( /* nes en letra */
mes = 13;
encontrado = false;
while (mes > 0 4% !lencontrado) (
mes--;
encontrado = /* coinciden 3 caracteres */
nombres[mes][0] == toupper(nombre[0]) 8%
nombres[mes][1] == tolower(nombre[1]) 8%
nombres[mes][2] == tolower(nombre[2]);
Y
J
3

/** Leer fecha "dia mes año” con el mes en número
o letra y el año con dos o cuatro cifras.
Devuelve 'true' si ha podido leer */

bool TipoFecha::Leer()

dia = 0;

scanf( "Xd", dia );

if (dia == 0) 4
return false;

 

, Sanno );
if (anno < 100) £
anno = anno + 2000;
y
return true;
y

/** Comparar dos fechas */
bool TipoFecha: :EsPosterior( TipoFecha f ) (
if (anno != f.anno) £
return (anno > f.anno);
+
if (mes != f.mes) (
return (mes > f.mes);
+
return (dia > f.dia);
y
 

 

390 Fundamentos de progra

 

/** Insertar una fecha en la lista ordenada */
void InsertarFecha( TipoFecha f ) 4
int izquierda, derecha, centro;

/*-- Poner la fecha como centinela, al final (evita
que añadir al final sea un caso especial) --*/

lista[numFechas] = £;

numFechas++;

/*-- Determinar la posición que le corresponde --*/
izquierda = 0;
derecha = numFechas-1;
while (izquierda < derecha) (
centro = (izquierda+derecha)/2;
if (f.EsPosterior( lista[centro] )) (
izquierda = centro+1;
) else [
derecha = centro;
y
Y

/*-- Hacer sitio para la nueva fecha --*/

for (int ind = nunFechas-1; ind >= izquierda; ind--) (
listalind+1] = lista[ind];

,

/*-- Colocar la fecha en su sitio --*/
listalizquierda] = £;

e

 

Programa principal

 

int mainO €
TipoFecha fecha;
bool seguir;

print£( "Fechas leídas:n" );

numFechas = 0;

seguir = fecha.Leer();

while (seguir 88 numFechas < maxFechas)
fecha.Escribir();
if (fecha.EsCorrecta()) £

InsertarFecha( fecha );

) else £
Tipos abstractos de datos 391

 

printf( " ** incorrecta **” );

print£( "a" );
seguir = fecha.Leer();
3

print£( "WFechas en orden: Wa" );
; KanunFechas; kt+) (

  

 

Ejemplo de datos de entrada:

 

 

10 Marzo 1972
30 feb 82

29 FEB 1900
1m372

29 FEB 2000
28 diciem 1993
4 enero 91

15 error 89
10 10 10

o

Resultados obtenidos:

 

Fechas leídas:

10-Marzo-1972

30-Febrero-2082 ** incorrecta **
29-Febrero-1900 ** incorrecta **
11-Marzo-2072

29-Febrero-2000
28-Diciembre-1993

4-Enero-2091

15-?-2089 ** incorrecta **
10-Octubre-2010

Fechas en orden:
10-Marzo-1972
28-Diciembre-1993
29-Febrero-2000
10-Octubre-2010
11-Marzo-2072
4-Enero-2091

 
392 Fundamentos de programación

 

14.3 Metodología basada en abstracciones

La técnica de programación estructurada, basada en refinamientos sucesivos,
puede ampliarse para contemplar la descomposición modular de un programa.
La metodología de desarrollo será esencialmente la misma que se ha presentado
en el tema 8, referente al desarrollo usando abstracciones en forma de subprogramas (abstracciones funcionales). La diferencia es que ahora disponemos
también de un nuevo mecanismo de abstracción, que son los tipos abstractos
de datos.

Igualmente son de aplicación las técnicas generales de desarrollo: descendente
o ascendente, que pueden plantearse no sólo con abstracciones funcionales sino
también con abstracciones de datos. En cualquier caso el desarrollo deberá
atender tanto a la organización de las operaciones como a la de los datos sobre
las que operan, de manera que habrá que ir realizando simultáncamente las
siguientes actividades:

 

 

+ Identificar las operaciones a realizar, y refinarlas.
+ Identificar las estructuras de información, y refinarlas.

Como se verá, puede establecerse una analogía entre ambas

14.3.1 Desarrollo por refinamiento basado en abstracciones

Comenzaremos por recordar lo que se decía en tema 8 sobre el desarrollo
descendente con abstracciones funcionales: en cada etapa de refinamiento de
una operación hay que optar por una de las alternativas siguientes:

+ Considerar la operación como operación terminal, y codificarla mediante
sentencias del lenguaje de programación.

+ Considerar la operación como operación compleja, y descomponerla en
otras más sencillas.

+ Considerar la operación como operación abstracta, y especificarla, escribiendo más adelante el subprograma que la realiza.

Ahora podemos reformular estas opciones para las estructuras de datos a utilizar:
+ Considerar el dato como un dato elemental, y usar directamente un tipo
predefinido del lenguaje para representarlo.
+ Considerar el dato como un dato complejo, y descomponerlo en otros
más sencillos (como registro, unión o formación).
+ Considerar el dato como un dato abstracto y especificar su interfaz, dejando para más adelante los detalles de su implementación.

 
 

Tipos abstractos de datos 393

 

Aplicaremos estas técnicas de refinamiento a un programa que construya y
dibuje de manera aproximada una de las llamadas Curvas-C. Estas curvas, que
son realmente líneas poligonales realizables sobre una cuadrícula, se definen
recursivamente. Hay toda una familia de Curvas-C, que so designan mediante
un número de orden, empezando por cero:

+ C(0) es un trazo recto de longitud unidad.
+ C(n), para n>0, equivale a dibujar dos veces C(n-1), con un giro de 90?
a la derecha entre ambas.

Las primeras curvas de la familia se muestran en la figura 14.1.
Orden o 3

1 2
0

Figura 14.1 Familia de Curvas
 

Para resolver el problema tendremos en enenta que el procedimiento printf
disponible para escribir resultados exige ir imprimiendo las líneas una a una,
de arriba a abajo. Por lo tanto es preciso componer el dibujo completo antes de
imprimirlo, La acción principal se descompone inicialmente en una secuencia
de acciones sencillas, tal como:

Imprimir Curva O >
Iniciar la página en blanco
Componer el dibujo de la curva
Imprimir la página.

Componer el dibujo de la curva —

if (el orden es 0) £
Trazar un segmento unidad

) else i£ (el orden es > 0) £
Componer la curva de orden anterior
Girar a la derecha
Componer la curva de orden anterior
Girar a la izquierda

y

Hasta aquí la descomposición funcional inicial. Ahora toca identificar las estructuras de datos necesarias para mantener la información necesaria y poder
implementar las operaciones. La descripción anterior ya contiene implícitamente algunas decisiones sobre cómo almacenar y componer el dibujo. En

 

 
 

 

  
    
   
  
 
 
   
  

394 Fundamentos de progri

concreto se está asumiendo la técnica de gráficos de tortuga empleada em
lenguaje LOGO. Esta técnica consiste en disponer de un agente capaz de
moviéndose sobre el plano al tiempo que deja un trazo o rastro de su
miento. A este agente le llamaremos “tortuga”, y se le puede ordenar
avance y que gire.

  

En cuanto a la posibilidad de componer el dibujo completo antes de impri:
se asume que la tortuga se mueve sobre un “papel” que almacena los trazos
hace una función de memoria o registro gráfico. Corresponde a lo que en
refinamientos anteriores se ha denominado página.

 

 

Pasaremos ahora a identificar las acciones a realizar con la tortuga y el
De los refinamientos anteriores podemos deducir que se necesitarán al menos
las operaciones siguientes:

Para la tortuga

- Avanzar la tortuga un paso

- Girar la tortuga a la derecha

- Girar la tortuga a la izquierda
Para el papel

- Iniciar el papel en blanco

- Registrar un trazo horizontal

- Registrar un trazo vertical

- Imprimir el contenido del papel

Estas operaciones se realizan, on general, sobre el tipo de dato al que corresponden, excepto la operación de avanzar la tortuga, que ha de registrar al
mismo biempo el trazo sobre el papel, bien sea horizontal o vertical, dependiendo de su orientación en ese momento.

Ahora ya se dispone de una idea clara de la organización del programa, que
usaría las siguientes abstracciones:

+ Un subprograma para generar recursivamente la Curva-C de un orden
dado.
+ Un tipo abstracto de datos que implemente el agente de dibujo, es decir,
la tortuga.
+ Un tipo abstracto de datos que implemente el registro del dibujo, es
decir, el papel.
Con un poco de experiencia se pneden prever las operaciones complementarias
y los datos internos que serán necesarios para desarrollar el programa comple
to. En este caso pasaremos a presentar sin más unas posibles interfaces de las
abstracciones reconocidas hasta el momento:
 

Tipos abstractos de datos 395

pao

* Procedimiento: Curval
A LLL

void CurvaC( int orden, TipoTortuga € t, TipoPapel £ p );

 

PORRA
* Tipo abstracto: Papel
A ARALAR AR ERARAAERE/
typedef struct TipoPapel (

void PonerEnBlanco();

void MarcarHorizontal( int x, int y );

void MarcarVertical( int x, int y );

void Imprimir(O);
private:

/* matriz con los trazos horizontales y verticales */

=

 

A OLLE

Tipo abstracto: Tortuga
A LOSADA ELLE

£

 

typedef enum TipoRumbo ( Este, Norte, Oeste, Sur );

typedef struct TipoTortuga (
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel € p );
void GirarDerecha();
void GirarIzquierda();
private:
/* posición y orientación de la tortuga */

»

14.4 Ejemplo: Dibujar una Curva-C

Aquí se presenta el programa completo correspondiente al ejemplo introducido
en la sección anterior. El programa responde a la descomposición obtenida por
refinamientos sucesivos, y en él se han completado las interfaces de los módulos
con los elementos auxilias

 

necesarios.

Tal como se apuntaba, se hace uso de tipos struct para definir la Tortuga y el
Papel como tipos abstractos de datos. Sus estados se almacenan en estructuras
de datos que se manejan internamente como datos privados
  
   
   
  
    
   
 

396 Fundamentos de pt

 

La realización del tipo Papel limita arbitrariamente su tamaño a una e
cula de 19 líneas de 32 casillas. Cada casilla registra el trazo vertical en
borde izquierdo y el trazo horizontal en su borde inferior. Para imprimir
dibujo de manera aproximada cada casilla se imprimo con dos caracteres.
este tamaño el resultado del ejemplo puede incluirse fácilmente en cl texto
este libro. Los trazos horizontales y verticales se aproximan con el guión
() y la barra vertical (1).

Según se muestra en la figura 14.2, el origen de coordenadas es el ext
inferior izquierdo. Los rumbos se miden en sentido antihorario, emp:
por la orientación a la derecha, es decir, tal como se miden habitualmente
ángulos en la geometría del plano.

7] N
A
a ria += os Q-e
5 v
(0.0) de Ss

Figura 14.2 Composición del dibujo sobre una cuadrícula.

La posición inicial de la tortuga se ha establecido para conseguir que entre.
dentro del papel la Curva-C del orden más alto posible para el tamaño fijado.
El programa es robusto en cuanto que:

+ Ignora los intentos de dibujar curvas de orden negativo.

+ Sise manda dibujar una curva que ocupa más espacio del disponible la
composición de la curva se sigue haciendo correctamente pero los trazos
fuera del papel no se registran.

El código desarrollado es, en general, bastante sencillo y puede ser leído sim
grandes dificultades. El único detalle algo complicado es el cálenlo de los
rumbos, que exige convertir los valores enumerados a enteros en el rango 0-3,
y viceversa. El listado completo es el siguiente:

 

 

AAA RARA ARANA RARA RAR RARA RARA

* Programa: DibujarC

* Descripción:
* Este programa lee como dato el orden de una curva C, y a

* — continuación la dibuja en forma de texto en pantalla
PIAR RIRAA RA RRALAAA NARA ARALAR RARA ARRE A AIDA RR OREA RA ANNA 4

 
Tipos abstractos de datos 397

 

include <stdio.h>

 

Parámetros globales
const int ANCHO = 32; /* cuadrícula en */
const int ALTO = 19;  /* la pantalla */

   

  

   

 

Tipo abstracto PAPEL
EE O
typedef struct TipoPapel [
void PonerEnBlanco();
void MarcarHorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();
private:
bool Dentro( int x, int y );
char marcasH[ANCHO] [ALTO];
char marcasV[ANCHO] [ALTO] ;
+

 

 

bool TipoPapel::Dentro( int x, int y ) f
return (x >= 0 88 x < ANCHO 88 y >= 0 88 y < ALTO);
7

void TipoPapel::PonerEnBlanco() £
for (int x=0; x<ANCHO; x++) 4
for (int y-D; y<ALTO; y++) 4
marcasH[x][y] =
marcasV[x] [y] Es
y
J

  

J

void TipoPapel: :Marcarllorizontal( int x, int y ) (
if (Dentro( x, y ») t
marcash[x] [y] =

 

)

void TipoPapel::MarcarVertical(int x, int y ) (
Af (Dentro x, y ))
marcasV[x] [y] = *

 

 

 
398 Fundamentos de progr

void TipoPapel::Imprimir() 4
for (int y=ALTO-1; y>=0; y--) (
for (int x=0; x<ANCHO; x++) (
print£( "xcxc", marcasV[x][y], marcasH[x][y]);

  

3
printf( "a" );

   

 

 

Tipo abstracto TORTUGA

 

pa =*/
typedef enum TipoRumbo [ Este, Norte, Oeste, Sur );

typedef struct TipoTortuga 1
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel £ p );
void GirarDerecha();
void GirarIzquierda();
private:
ánt Xx, yv;
TipoRumbo sentido;
»

void TipoTortuga::Poner( int x, int y, TipoRumbo rumbo ) f
e

yy
sentido = rumbo;

 

| 3

void TipoTortuga::Avanzar( TipoPapel € p ) f
switch (sentido) (
| case Norte:
| p.MarcarVertical( xx, yy );
YY
break.
case Sur;
YY--5
p.MarcarVertical( xx, yy );
break;
case Este:
p.MarcarHorizontal( xx, yy );
xx
break;
case Oeste:

 

 

 

 

 
Tipos abstractos de datos

399

 

 

2
p.MarcarHorizontal( xx, yy );
break;

+
E

void TipoTortuga: :GirarDerecha() £
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */
y

void TipoTortuga::GirarIzquierda() £
sentido = TipoRumbo( (int(sentido)+1) % 4 );
3

 

Función CURVA-C

 

“Y

if (orden == 0) (
t.Avanzar( p );

) else if (orden > 0) (
CurvaC( orden — 1, t, p );
t.GirarDerecha();

CurvaC( orden - 1, t, p );
t.GirarTzquierdaO);

 

Programa principal

 

int main() (
int orden;
TipoTortuga tt;
TipoPapel pp;

printf( "Orden: " );
scan£( "%d", Sorden );

pp.PonerEnBlanco();
/* posición imicial de conveniencia */
tt.Poner( 8, 3, Este
CurvaC( orden, tt, pp );
Pp. Imprimir();

 

 

void CurvaC( int orden, TipoTortuga € t, TipoPapel € p ) 4

 

 

 
Fundamentos de progr:

400

 

del programa:

jecución

Ejemplo de ej

 

Orden: 8

 

 

 

 
Tema 15

Módulos

En este tema sc da una introducción a la programación modular, en especial
basada en el empleo de tipos abstractos de datos.

Se introduce el concepto de módulo, en general, y su realización en C£, en
particular. Se discuten brevemente las características necesarias para compilar
módulos por separado, de forma segura, y la manera de conseguirlo en este
lenguaje.

Finalmente se extiende la metodología de desarrollo de programas con la posibilidad de descomposición en módulos separados, estableciendo las recomendaciones del desarrollo modular basado en abstracciones.

 

15.1 Concepto de módulo

En programación, un módulo es, en general, un fragmento de programa utilizado en algún momento para la construcción del programa completo. Lo
que distingue a un módulo propiamente dicho de un fragmento arbitrario del
programa es el hecho de que en algún momento de la construcción haya sido
reconocido como tal, y por tanto que se haya desarrollado o refinado de forma
relativamente independiente del resto del programa. Podríamos definir:

Módulo: Fragmento de programa desarrollado de forma independiente.

El desarrollo independiente debe serlo en el máximo grado posible. Atendien=
do a las técnicas de preparación de programas en lenguajes de programación
simbólicos, diremos que un módulo debería ser compilado y probado por separado, y no tratarse de un simple fragmento de texto dentro de un único
programa fuente.

 
 

402 Fundamentos de programación

 

La razón de exigir compilación por separado para los distintos módulos de
un programa obedece a la necesidad de limitar la complejidad de aquello que
está siendo elaborado por una persona en un momento dado. Si el módulo se
va a compilar por separado, la persona que lo desarrolle podrá concentrarse
en él, prescindiendo en parte de cómo se utiliza ese módulo desde el resto
del programa. De la misma forma, quien escriba el resto del programa no
se preocupará de los detalles de cómo está codificado el módulo, sino sólo de
cómo hay que usarlo.

El concepto de módulo, por tanto, está íntimamente ligado a la idea de abstracción. Un módulo debe definir un elemento abstracto (o varios relacionados
entre sí) y debe ser usado desde fuera con sólo saber qué hace el módulo, pero
sin necesidad do conocer cómo lo hace.

15.1.1 Especificación y realización

Igual que en cualquier otro elemento abstracto, en un módulo podemos distinguir dos puntos de vista, correspondientes a su especificación y a su realización.
Tal como se ha indicado con anterioridad, la primera visión nos dice qué hace
el módulo, y la segunda nos dice cómo lo hace.

La especificación de un módulo que contenga la definición de una serie de
elementos abstractos consistirá, fundamentalmente, en el conjunto de las especificaciones de cada uno de ellos, por separado, más una indicación de los
posibles efectos de unos sobre otros cuando se usan de forma combinada.

La realización del módulo consistirá en la realización de cada uno de los elementos abstractos contenidos en dicho módulo.

La especificación del módulo es todo lo que se necesita para poder usar los
elementos definidos en él. Esta especificación constituye la interfaz (en inglés
interface) entre el módulo (incluida su realización) y el programa que lo usa.

La independencia entre la realización de un módulo y el programa que lo usa se
incrementa si la realización de un elemento abstracto no es visible desde donde
se usa. Esta característica se denomina ocultación, y ha sido ya desarrollada
en los temas 7 y 14 para las funciones, procedimientos y tipos abstractos de
datos.

Referida a los módulos, la ocultación consiste en que el programa que usa un
elemento de un módulo sólo tiene visible la información de la interfaz, pero no
la de la realización.
Módulos 403

 

15.1.2 Compilación separada

Los lenguajos de programación que permiten programar usando módulos pueden emplear diversas técnicas para definirlos e invocar los elementos definidos
en ellos. Tal como se ha comentado antes, es importante que los módulos
puedan compilarse por separado. Esto quiere decir que los lenguajes de programación deben permitir escribir un programa complicado como un conjunto
de varios ficheros fuente distintos, cada uno de los cuales pueda compilarse de
manera más o menos independiente de los demás.

Por otra parte, para que el uso de los elementos de un módulo sea correcto,
habrá que hacerlo de acuerdo con la interfaz establecida. La interfaz debe ser
tenida en cuenta al compilar un programa que use elementos de un módulo
separado. Por el contrario, la realización del módulo debe permanecer invisible
para el programa que lo usa con objeto de mantener la deseable ocultación de
los detalles de los elementos abstractos contenidos en él.

    

En la figura 15.1 se representa gráficamente la visibilidad deseable entre un
módulo y el programa que lo usa.

Programa Módulo

(Visible)

 

Realización (oculta)

Figura 15.1 Visibilidad de un módulo.

Resumiendo:
Compilación separada: El programa está formado por varios ficheros fuente,
cada uno de los cuales se compila por separado.

Compilación segura: Al compilar un fichero fuente el compilador comprueba
que el uso de elementos de otros módulos es consistente con la interfaz.

Ocultación: Al compilar un fichero fuente el compilador no usa información
de los detalles de realización de los elementos de otros módulos.

Entre las técnicas empleadas por lenguajes de programación de uso frecuente
en lo que respecta a compilación separada, tenemos situaciones tales como las
siguientes:
 

 

404 Fundamentos de programación

(a) El fichero del programa y del módulo se tratan de forma totalmente separada, sin visibilidad de la interfaz (lenguaje FORTRAN y las primeras
versiones del lenguaje C).

(b) La parte necesaria de la interfaz se copia o importa manualmente en

el programa que la usa. La compilación de los ficheros del programa y

del módulo se hace con total independencia (lenguaje C ANSI con pro
totipos, C++, y algunas versiones del lenguaje Pascal, con la directiva

EXTERN o USE).

La interfaz del módulo y su realización se escriben en ficheros separados.

El mismo fichero de interfaz se usa tanto al compilar la realización del

módulo como al compilar el programa que lo usa (lenguajes Modula-2 y

Ada).

(d) La interfaz del módulo y su realización se combinan en un solo fichero
fuente. Al compilar el programa que lo usa el compilador lee el fichero
fuente del módulo, pero sólo utiliza los elemento de la interfaz (lenguajes
Oberon y Java).

(e

En los lenguajes que usan la técnica (a) no hay compilación segura. En los
mencionados en (b) la seguridad es mayor, pero aún hay posibilidad de errores
si no coincide la interfaz del módulo con la copia usada en el programa. Con
los lenguajes que usan las técnicas (c) y (d) la compilación es completamente
segura.

El lenguaje Ct está basado en C++ y comparte sus características en cuanto
a compilación separada y compilación segura.

15.1.3 Descomposición modular

La posibilidad de compilar módulos de forma separada permite repartir el
trabajo do desarrollo de un programa, a base de realizar su descomposición
modular. Los diferentes módulos pueden ser encargados a programadores diferentes, y gracias a ello todos pueden trabajar al mismo tiempo.

De esta forma se pueden desarrollar en un tiempo razonable los grandes programas correspondientes a las aplicaciones de hoy día, que totalizan cientos
de miles o millones de sentencias.

La descomposición modular de un programa puedo reflejarso en un diagrama
de estructura, tal como el de la figura 15.2. En este diagrama so representa
cada módulo como un rectángulo, con el nombre del módulo en su interior, y
se usan líneas para indicar las relaciones de uso entre ellos.

En este ejemplo el módulo A usa elementos de los módulos B y C, y el módulo
B usa elementos de C y D. Los módulos C y D no usan ningún otro módulo.
 

Módulos 405

 

 

Figura 15.2 Ejemplo de diagrama de estructura.

Las líneas que indican relaciones de uso pueden llevar punta de flecha si es
necesario indicar expresamente cuál ! sentido de la relación. Normalmente
no es necesario, pues, como en este caso, un módulo que usa otro se dibuja
encima de él, de manera que las líncas de uso se interpretan siempre de arriba
a abajo, estableciendo al mismo tiempo una jerarquía entre módulos.

 

 

El objetivo de la ingeniería de software es facilitar el desarrollo de una aplicación de forma organizada, de manera que muchas personas puedan colaborar
simultáneamente en un mismo proyecto. Para que la descomposición en módulos sea adecuada, desde ese punto de vista, conviene que los módulos resulten
tan independientes unos de otros como sca posible. Esta independencia se
analiza según dos criterios, denominados acoplamiento y cohesión.

 

El acoplamiento entre módulos indica cuántos elementos distintos o características de uno o varios módulos han de ser tenidos en cuenta a la vez
al usar un módulo desde otro. Este acoplamiento debe reducirse a un
mínimo.

La cohesión indica el grado de relación que existe entre los distintos elementos
de un mismo módulo, y debe ser lo mayor posible. Esto quiere decir
que dos elementos íntimamente relacionados deberían ser definidos en el
mismo módulo, y que un mismo módulo no debe incluir elementos sin
relación entre sí.

15.2 Módulos en Ct

Un programa descompuesto en módulos se escribe como un conjunto de ficheros fuente relacionados entre sí, y que pueden compilarse por separado. Cada
fichero fuente constituye así una unidad de compilación.

 
 

 

406 Fundamentos de programación

 

Lamentablemente hay que decir que los lenguajes Co C++ (y por tanto
Ci) no incorporan ninguna estructura sintáctica para realizar programación
modular. Las descomposición de un programa en partes se hace solamente a
nivel físico combinando ficheros, y no a nivel lógico, usando estructuras bien
definidas. Por esa razón se debe imponer una cierta disciplina de codificación
que permita mantener la organización modular del programa dentro de unos
límites aceptables de esfuerzo de comprensión y mantenibilidad.

Las siguientes secciones indican la manera de redactar programas compuestos
por varios módulos, señalando la forma de hacer corresponder los módulos lógicos con ficheros físicos de código fuente, y la manera de compilar el programa
en su conjunto.

15.2.1 Proceso de compilación simple

Un fichero fuente es un fichero de texto que contiene el código de una unidad de
compilación, es decir, es posible invocar el compilador dándole como entrada
sólo ese fichero fuente.

La compilación de un fichero fuente produce un fichero objeto que contiene la
traducción del código Cé a instrucciones de máquina, tal como se representa
en el ejemplo de la figura 15.3. Por convenio, los ficheros fuente en C* tienen la
extensión .cpp (la misma usada habitualmente en C++) y los ficheros objeto
la extensión .o. Como regla de disciplina modular en Ct se exige que el
nombre del fichero objeto sea el mismo que el del fichero fuente.

 

 

Figura 15.3 Proceso de compilación simple.

IEUNOTA: El lenguaje CE es un subconjunto estricto del lenguaje C++. No existe
un compilador específico para Ct. Los ficheros fuente en C£ se compilarán con un
compilador de C++.

En general un fichero objeto no se puede ejecutar directamente. Se necesita un
paso adicional de montaje para obtener un programa o fichero ejecutable. En
MS-Windows los ficheros ejecutables tienen la extensión .exe (en UNIX/Linux
no suelen tener extensión). Si el programa ejecutable se ha generado a partir
de un solo fichero fuente, debe tener también el mismo nombre.

En C y C++ es frecuente que el montador y el compilador sean una misma
herramienta, o al menos que se invoquen como si lo fueran. En casos sencillos
como éste es posible realizar la compilación y montaje como una sola operación.
Módulos A07

 

En esta primera visión simplificada del proceso de compilación y montaje se
ha omitido mencionar explícitamente las librerías estándar o de sistema. Más
adelante se mostrará cómo se usan durante ese proc

 

 

15.2.2 Módulo principal

Cuando se descompone un programa on C£ en varios módulos uno de ellos
ha de ser el programa principal o módulo principal. Este módulo será el que
contenga la función mainO). La ejecución del programa completo equivale a
la ejecución de dicha función principal. Por supuesto, la función principal
puede invocar durante su ejecución operaciones definidas en otros módulos.
Repetiremos aquí el primer ejemplo de programa completo mostrado en este
libro, y que corresponde también al ejemplo de la figura 15.3:

/** Programa: Hola */

/* Este programa escribe Hola */

 

ttinclude <stdio.h>

int mainO 4
print£("Holain");
y

Todos los ejemplos de programas completos desarrollados hasta ahora se componían exclusivamente de un módulo principal. Para ser precisos habrá que
decir que en estos ejemplos se usaban otros módulos de las librerías estándar,
tal como stdio, pero puede considerarse que estos módulos de sistema. no son
parte del programa o aplicación desarrollada.

  

La manera de escribir un módulo principal ya ha sido expuesta en los temas
anteriores. Sólo falta indicar que el fichero fuente de ese programa principal
debe tener el nombre que se dará finalmente al programa ejecutable y tener la
extensión .cpp, tal como se ha indicado anteriormente.

   

15.2.3. Módulos no principales

Los módulos de la aplicación que no contienen una función main() no permiten
generar un programa ejecutable por sí solos. Los elementos que contienen están
destinados a ser usados por el programa principal u otros módulos. Al escribir
el código de estos módulos no principales hay que distinguir claramente entre
los elementos públicos, que deben sor visibles desde fuera del módulo para
408 Fundamentos de programación

 

poder usarlos, y los elementos privados, que sólo necesitan ser visibles en el
interior del módulo.

La distinción entre los elementos públicos y los privados se hace repartiendo
el código del módulo en dos ficheros fuente separados: un fichero de interfaz
o fichero de cabecera, y “mn fichero de implementación. El siguiente ejemplo
muestra el código de un módulo que ofrece facilidades para imprimir series de
valores numéricos tabulando en varias columnas. El fichero de interfaz es:

 

 

AA LOA

* Interfaz de módulo: Tabulacion

Este módulo contiene los elementos para
imprimir series de números en varias columnas

Kpragma once

2. «

  

  

extern int numColumnas; — /* número de columnas *:
extern int anchoColuma; /* ancho de cada una */

 

/%-— Iniciar la impresión --*/
void Iniciar( char titulo(] );

/% Imprime un número, tabulando */
void Imprimir( int nunero );

/* Completa la impresión de la última línea */
void Terminar();

 

A continuación se presenta el correspondiente fichero de implementación. En
este ejemplo de código se ha aprovechado una característica especial del procedimiento printf que permite indicar el ancho de un campo como argumento
además dol valor a imprimir, usando un asterisco como especificador del ancho
en el formato.

 

ARANA DADA

* Módulo: Tabulacion

»

* Este módulo contiene los elementos para

* imprimir series de núneros en varias columas
AAA A ARA AAA
+include <stdio.h>

Jinclude <string.h>

+include "Tabulacion.h"

 
 

Módulos 409

 

int numColumnas = 4 /* número de columnas */
nt anchoColumna = 10; /* ancho de cada una */

static int columna = 1;  /* columna actual */

/"— Iniciar la impresión --*/

void Iniciar( char titulo[] ) 4
Terminar(); /* la serie anterior, por si acaso */
print£( "%sin", titulo );
columna = 1;

 

)

 

/*— Imprime un múnero, tabulando --*/
void Imprimir( int numero ) £
if (columna > numColumnas) £
print£( a" y;
columna = 1;
B
print£( "td", anchoColuma, numero );
columa++;

,

/*— Completar la impresión de la última línea --*/
void Terminar(Q) 1
if ( columna > 1) 4
print£( "a" );
,

columna =

 

+

 

El código contiene nuevos elementos de C+ (*pragma once, extern, static)
que se explican más adelante.

Una. buena disciplina de nombres exige que ambos ficheros tengan el mismo
nombre que el nombre lógico del módulo, El fichero de interfaz tendrá la extensión .h y el de implementación la extensión .cpp. Por lo tanto los nombres
de los ficheros fuente en este ejemplo deben ser:

+ Interfaz: Tabulacion.h
» Implementación: Tabulacion.cpp

En Ct no existe el concepto de nombre de módulo a nivel de sintaxis del
lenguaje. El nombre lógico Tabulacion usado en el ejemplo aparece solamente
en comentarios de documentación del código. La directiva Hinclude sirve
para hacer referencia a un fichero fuente desde otro, y tiene como parámetro
el nombre del fichero físico "Tabulacion.h", incluyendo la extensión.

 
 

410 Fundamentos de programación:

 

15.2.4 Uso de módulos

Para usar los elementos públicos definidos en un módulo hay que incluir la:
interfaz de ese módulo en el código donde se vaya a utilizar. Esto se consigue
con la directiva +include que ya se ha empleado en otros ejemplos para usar”
las librerías estándar. La novedad ahora es que los nombres de los ficheros de:

la propia aplicación deben escribirse entre comillas (*.

.") y no entre ángulos

(<....>). Con esto se indica al compilador que debe buscar dichos ficheros en
donde reside el código fuente de la aplicación y no donde está instalada la

herramienta de compilación. Ejemplo:

 

AAA ba

* Programa: Serie

* Este programa imprime la serie de números
* del 1 al 20 en varias columnas
AA e

include "Tabulacion.h"

 

int main() €

Iniciar( "-- Columnas por defecto --" );
for (int k = 1; k <= 20; k++) (
Imprimir(k);

  

 

y
Terminar();
nunColumnas =
anchoColuma = 13;
Iniciar( "-- 3 columas de 13 caracteres —
for (int k = 1; k <= 20; ke) £
Imprimir (do;

Terminar (O);

 

  

numColumnas =
anchoColumna = 5;
Iniciar( "-- 6 columnas de 5 caracteres --" );
for (int k k <= 20; k++) £
Imprimir(k);
y
Terminar();

 
Módulos 411

 

Este programa imprime una serie de números correlativos, usando el módulo
de tabulación anterior, y con varias configuraciones de columnas. El resultado
es:

 

— Columnas por defecto —

1 2 3 4
5 6 7 8
9 10 u 2
13 14 15 16
17 18 19 20
— 3 columnas de 13 caracteres -d 2 3
4 5 6
7 8 9
10 u 12
13 14 15
16 17 18
19 20

— 6 columnas de 5 caracteres -——
1.2. 3 4 5 6
7 8 9 10 1 22
13 14 15 16 17 18
19 20

15.2.5 Declaración y definición de elementos públicos

En los ejemplos de programas de los temas anteriores los distintos elementos
creados por el programador se definían completamente en un punto determinado del código. En los programas modulares, en los que hay elementos de un
módulo que se usan en otros, es preciso distinguir a veces entre la declara:
y la definición de un elemento.

 

En la declaración de un elemento hay que especificar lo necesario para que
el compilador pueda compilar correctamente el código que nsa dicho
elemento.

En la definición de un elemento hay que especificar lo necesario para que el
compilador genere el código del propio elemento.

En el caso de los elementos públicos de los módulos, la declaración debe ponerse en el fichero de interfaz, y la definición en el fichero de implementación. En
algunos casos la declaración contiene toda la información posible, y no hace
falta una definición complementaria. La siguiente tabla recoge un resumen de
cómo se declaran y definen en Ci las distintas clases de elementos sintácticos

 

 
412 Fundamentos de programación

 

 

 

 

 

 

 

 

Declaración (fichero.h) Definición (fichero.cpp)
typedef TipoNuevo ... (no aplicable)
const Tipo constante = valor; —| (no aplicable)
extern Tipo variable; Tipo variable = valor;
Tipo Subprograma(argumentos) L|
Tipo Subprogramaargumentos); |... código ... |
y

 

 

 

 

+ Los tipos y constantes se especifican totalmente cn el fichero de interfaz.
No hay declaración y definición separadas.

+ Las variables se definen de la manera habitual en el fichero de implementación, incluyendo la especificación de valor inicial en su caso. Con ello
el compilador reserva espacio para dicha variable en el módulo que la define. En el fichero de interfaz se pone además una declaración que indica
el tipo y nombre de la variable, sin indicar valor inicial, y precedida de la
palabra clave extern. Esta declaración permite al compilador generar
código de las sentencias que usan dicha variable en otros módulos sin
reservar espacio para ella, ya que formará parte efectiva del código del
módulo que la define. La conexión entre las referencias a la variable y
su ubicación real se resuelve durante la fase de montaje, posterior a la
compilación.

+ Los subprogramas se definen de la manera habitual en el fichero de implementación y permiten al compilador generar el código objeto del subprograma. En el fichero de interfaz se pone además una declaración en
forma de prototipo o cabecera de subprograma sólo con el tipo, nombre
y argumentos. Esta cabecera permite al compilador generar el código
de las sentencias de llamada al subprograma. La conexión entre las lla.madas al subprograma y su código real se resuelve durante la fase de
montaje, posterior a la compilación.

 

 

 

  

 

15.2.6 Conflicto de nombres en el ámbito global

El ámbito más externo en la jerarquía de bloques del programa principal y
de todos los módulos de una aplicación constituye un espacio de nombres
global y único, en el que no debe haber nombres repetidos. Esto exige una
clara disciplina para evitar conflictos debidos al intento de usar el mismo
identificador en módulos diferentes al definir elementos distintos. Por ejemplo,
si dos módulos diferentes definen cada umo una operación de inicialización, y
ambos le dan ol nombre Iniciar(), se obtendrá un error al tratar de compilar
y/o montar un programa que use ambos módulos.

 
Módulos 413

IM UNOTA: En C++ cs posible a veces definir subprogramas diferentes con el mismo
nombre, si se distinguen claramente por su tipo y número de argumentos. Esta
facilidad se denomina “sobrecarga” (overload). En Ct no se admite dicha posibilidad.

Una técnica sencilla para evitar en lo posible los conflictos de nombres públicos
globales es asignar a cada módulo un prefijo diferente que se habrá de usar
en los nombres de todos sus elementos públicos. De esta manera no hay
que atender a cada nombre particular para evitar conflictos, sino que basta
controlar que no haya prefijos repetidos. En el ejemplo anterior del módulo
de tabulación se podría haber empleado el prefijo TAB en los nombres de las
operaciones públi

parres

 
  

Tabulacion (TAB)

Aa

* Interfaz de módul
erre

kpragma once

 

 

extern int TAB_nunColumnas; — /* número de columnas */
extern int TAB_anchoColumna; /* ancho de cada una */

/*-- Iniciar la impresión --*/
void TAB_iniciar( char titulo[] );

/* Imprime un número, tabulando */
void TAB_imprimir( int nunero );

/* Completa la impresión de la última línea */
void TAB_terminar();

IEUNOTA: El estándar actual del lenguaje C introduce el mocanismo de “espacios de
nombres” (namespaces) que tieno posibilidades similares al empleo de prefijos, pero
de forma más organizada (y también algo más complicada de usar)

El ámbito global más externo incluye también los elementos privados, que no
figuran en la interfaz de los módulos. Afortunadamente en este caso el lenguaje
Ci ofrece un mecanismo que evita los conflictos de nombres repetidos, ya que
es posible especificar elementos en el ámbito más externo que sólo sean visibles
en el fichero fuente donde se definen. Para ello basta poner la palabra clave
static delante de la definición del elemento. Esto es lo que se ha hecho en
el ejemplo de tabulación con la variable auxiliar que almacena el estado del
proceso de impresión en varias columnas:

AAA AAA

* Módulo: Tabulacion

AAA

static int columna /* columna actual */

 
414 Fundamentos de programación:

 

Con esta definición es posible reutilizar el nombre columa para elem
globales de otros módulos, sin que haya conflicto entre ellos.

15.2.7 Unidades de compilación en Ct

Los ficheros fuente de los tipos mencionados pueden ser considerados unidades
de compilación, en el sentido de que es posible invocar la compilación de
cada uno de ellos por separado. Por lo tanto tendremos como unidades de:
compilación:

+ El módulo principal: programa.cpp

+ El fichero de interfaz de un módulo: modulo.h

+ El fichero de implementación de un módulo: modulo.cpp

En realidad a la hora de preparar una aplicación sólo se mandan compilar real
mente los ficheros con extensión .cpp, que son los que generan código objeta.
Los fichero de interfaz con extensión .h no se mandan compilar por sí mismos,
ya que en principio no generan código objeto. De hecho algunos compiladores
de C y C++ rechazan la compilación de este tipo de ficheros, incluso aunque
el código que contienen sea perfectamente aceptable y compilable como fichero
con extensión .cpp.

 

Lo que ocurre es que los ficheros de interfaz son parte efectiva de la compilación
de los ficheros de implementación. El significado de la directiva Kinclude es
equivalente a copiar en ese punto el contenido del fichero fuente indicado. Esta
copia o inclusión se hace sobre la marcha durante la compilación, en una fase
inicial de la misma denominada preproceso. La figura 15.4 muestra cómo se
preprocesa un módulo o programa de nombre Á que usa otro de nombre B.

 

Figura 15.4 Expansión de la directiva tinclude durante el preproceso,

Finalmente se enumeran aquí las reglas de sintaxis correspondientes a la estructura general de cada una de las unidades de compilación mencionadas:

 

Unidad_de_compilación
Programa_principal | Módulo_interfaz | Módulo_implementación

 
Módulos 415

 

Programa_principal 33= [ Include Y É, Declaración global Y
int main() Bloque

Módulo_interfaz +3= Prayma_onceÍ Include Y Á, Declaración interfaz Y

£ Include Y A Declaración _global Y

 

Módulo_implementación
Include
*include <Nombre_módulo.h> | +include "Nombre_módulo.h"

Pragma_once 33= fpragma once

 

 

Declaración global
Declaración _de_constante |

de_tipo |
[ static ] Declaración _de_variable |
[ static ] Subprograma

Declaración interfaz

 

 

Declaración_de_constante |
Declaración _de_tipo |
Declaración_de_variable_externa |
Cabecera_subprograma +;
Declaración de variable externa 33
extern Identificador_de_tipo Lista_de_identificadores ;

 

15.2.8 Compilación de programas modulares. Proyectos

El proceso de compilación y montaje de un programa cuyo código fuente está
repartido entre varios módulos requiere una cadena de operaciones, tal como
se indica en la figura 15.5 para el ejemplo del programa de tabulación.

 

Tabulacion.o

Figura 15.5 Compilación y montajo de un programa modular.

 

Es importante observar que el fichero de interfaz Tabulacion.h se incluye
tanto en el programa principal Serie.cpp como en el propio fichero de implementación Tabulación.cpp. Eso es necesario para asegurar una compilación

 
 

416 Fundamentos de programación

 

segura al poder detectarse posibles errores de codificación que hagan inconsistente la definición de los elementos de un módulo con el uso que se hace de
ellos desde otras partes del programa.

La generación del programa ejecutable final exige:

 

1. Compilar los módulos uno a uno, generando el correspondiente fichero
objeto (.0) a partir del fuente (.cpp). Cada compilación individual
usa también los ficheros de interfaz (.h) mencionados en las directivas
+include del módulo.

2, Montar el programa ejecutable combinando todos los ficheros objeto de
los módulos.

Los entornos de programación modernos simplifican la tarea de recompilar
los módulos después de editar alguno o varios de ellos. Para eso disponen de
un mecanismo de proyectos, consistente en disponer de un fichero con información de los ficheros fuente que forman parte de la aplicación. A partir de
ahí el entorno automatiza la generación o actualización de los ficheros objeto y el ejecutable final, que se invoca en conjunto como una operación única
denominada habitualmente “construir” (en inglés build).

La información mínima que debe contener el fichero de descripción de un
proyecto será:

+ Nombre del proyecto (= nombre del programa ejecutable)
+ Lista de ficheros fuente de implementación .cpp (incluyendo el programa
principal)

 

Opcionalmente se puede disponer también de otros datos útiles, tales como

+ Lista de ficheros de interfaz .h

+ Forma de invocar al compilador, con opciones particulares para ese proyecto

= eto.

15.3 Desarrollo modular basado en abstracciones

La organización de un programa en módulos puede hacerse aplicando diferentes criterios, en función de cada caso concreto. En general será adecuado
cualquier criterio que conduzca a módulos con buena cohesión y bajo acoplamiento. El reconocimiento de abstracciones en el desarrollo de una aplicación
es al mismo tiempo una ayuda para elegir una organización modular adecuada,

 
 

Módulos 417

 

15.3.1 Implementación de abstracciones como módulos

En la mayoría de los casos los tipos abstractos de datos identificados en ua
aplicación son buenos candidatos para ser codificados como módulos independientes, y lo mismo ocurre con las abstracciones funcionales de cierta complejidad. Por lo tanto el desarrollo basado en abstracciones lleva implícita una
posible descomposición natural del programa en módulos. Esto ocurre de forma obligada en algunos lenguajes con una estricta orientación a objetos, por
ejemplo Java.

 

 

Para ilustrar esta idea se repite aquí el ejemplo de dibujar una Curva-C introducido en el tema 14, pero dedicando ahora un módulo separado a cada
abstracción principal.

 

 

par

 

SARA CORREA AAA TARA
* Interfaz de módulo: Papel

.

* Este módulo define el tipo abstracto PAPEL, capaz de

*% — almacenar un dibujo formado por trazos en una cuadrícula
AAA AER ERERRARAEAAA A

Hpragna once

const int ANCHO = 32; /* cuadrícula en */
const int ALTO = 19; — /* la pantalla */

typedef struct TipoPapel (
void PonerEnBlanco();
void MarcarHorizontal( int x, int y );
void MarcarVertical( int x, int y );
void Imprimir();
private:
bool Dentro( int x, int y );
char marcasH[ANCHO] [ALTO];
char marcasV[ ANCHO] [ALTO
E

 

 

 

AAA AAA EA RRRRAA
* Módulo: Papel

.

* Este módulo define el tipo abstracto PAPEL, capaz de

* almacenar un dibujo formado por trazos en una cuadrícula
Rene NOAA ARI A O IRRAredaarerenraaniarrraararo 10d)
*include <stdio.h>

*tinclude "Papel.h"

 
418 Fundamentos de programación

 

Dentro( int x, int y ) 1
0 88 x < ANCHO 8% y >= 0 88 y < ALTO);

 
 

 

void TipoPapel::PonerEnBlanco()
for (int x=0; x<ANCHO; x++*) €
for (int y-0; YSALTO: ye) £
marcasH[x] [y] = ' ';
marcasV[x] [y] =
y
+
Y

void TipoPapel::MarcarHorizontal( int x, int y ) £
if (Dentro( x, y )) 1
marcasH[x][y] = *_*;
J

 

void TipoPapel::Marcarvertical(int x, int y ) (
if (Dentro( x, y )) e
marcasV[x]1[y]
7
+

 

 

void TipoPapel::Imprimir() 4
for (int y=ALTO-1; y>=0; y--) £

 

 

 

 

 

for (int x=0; x<ANCHO; x++) (
print£( "%c%c", marcasV[x][y], marcasHLx] lyD)5
+
print£( "a" );
+
+
PARARAARAARARRA RARA BEAR R NARRAR RARA RARA READER RARA RARA

* Interfaz de módulo: Tortuga
*

* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
AA A A A A

Hpragma once
Hinclude "Papel.h"

typedef enum TipoRumbo í Este, Norte, Oeste, Sur );

 
Módulos 419

typedef struct TipoTortuga 1
void Poner( int x, int y, TipoRumbo rumbo );
void Avanzar( TipoPapel € p );
void GirarDerecha();
void CirarIzquierda();
private:
intoax, yy;
TipoRumbo sentido;
=

 

PEA AAA AAA
* Módulo: Tortuga
%

Este módulo define el tipo abstracto TORTUGA, capaz de
ir trazando una trayectoria mediante avances y giros
AAA AAA AA

include "Tortuga.h"

void TipoTortuga: :Poner( int x, int y, TipoRumbo rumbo ) (
x= Xi
yr. ys
sentido = rumbo;

)

void TipoTortuga::Avanzar( TipoPapel 4 p ) (

switch (sentido) (

case Norte:
p.MarcarVertical( xx, yy );
YY;
break;

case Sur:
YY;
p.MarcarVertical( xx, yy );
break;

case Este:
p.MarcarHorizontal( XxX, yy );
a;
break;

case Deste:
e;
p.MarcarHorizontal( xx, yy );
break;

+

$

 
420 Fundamentos de programación

 

void TipoTortuga: :GirarDerecha() 4
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */

 

void TipoTortuga::GirarIzquierda() (
sentido = TipoRumbo( (int(sentido)+1) % 4 );
y

 

 

 

AAA

* Interfaz de módulo: CurvaC

 

 

+ Este módulo contiene la función que genera una Curva-C
arre 2. mes /
*pragma once

*include "Tortuga.h"

*include "Papel.h"

 

void CurvaC( int orden, TipoTortuga 8 t, TipoPapel £ p );

 

 

PORRA

* Módulo: CurvaC
*

 

 

 

+ Este módulo contiene la función que genera una Curva-C
parra ta

include "CurvaC.h"

 

void CurvaC( int orden, TipoTortuga € t, TipoPapel 4 p ) (
if (orden 01
t.Avanzar( p );
) else if (orden > 0) £
CurvaC( orden - 1, t, p);
t.GirarDerecha();
CurvaC( orden - 1, t, p);
t.GirarTzquierda();
y

 

3

 

 

 

ARRE ERRDODRREDDERRODLDERARDDROR
* Programa: DibujarC

*

* Descripción:

* Este programa lee como dato el orden de una curva C, y a

* — continuación la dibuja en forma de texto en pantalla
FASORLORRDODEDORLEODREREDALELaLONBDDDERERDEDOOELDADAEREDbOR/
Módulos 421

 

ftinclude <stdio.h>
ttinclude "CurvaC.h"
ttinclude "Tortuga.h”
include "Papel.h"

int mainO) £
int orden;
TipoTortuga tt;
TipoPapel pp;

print£( "Orden: " );
scanf( "%d”, Gorden );

pp.PonerEnBlanco();

/* posición inicial de conveniencia */
tt.Poner( 8, 3, Este );

CurvaC( orden, tt, pp );

Pp. Imprimir(

 

 

Como puede verse, los ficheros de interfaz contienen obviamente la declara
ción de la interfaz del elemento abstracto, y los ficheros de implementación
contienen la realización del elemento. En el caso de la abstracción funcional
CurvaC la interfaz es simplemente la cabecera del subprograma.

En el caso de los tipos abstractos de datos Tortuga y Papel, la interfaz incluye
no sólo el tipo struct que lo define, sino también los complementos necesarios.
En la interfaz de la abstracción Tortuga se ha incluido la definición del tipo
enumerado TipoRumbo, y en la del Papel se incluyen las constantes de tamaño.

 

 

Figura 15.6 Estructura modular del programa de dibujar una Curva-C,

 

 
 

422 Fundamentos de programación

 

La figura 15.6 muestra la estructura del programa, indicando las relaciones de
dependencia (de uso) de unos módulos respecto a otros. Las flechas indican
que un módulo utiliza directamente elementos de otro.

   

En el diagrama, cada módulo se representa, en general, como un rectángulo.
Además, los módulos que corresponden a tipos abstractos de datos se han
representado de manera similar a la usada en los diagramas de clases UML,
imarcando una banda superior con el nombre del módulo. Se puede aumentar
la analogía con la notación UML enumerando en la banda inferior los elementos
públicos del módulo, como se muestra en la figura 15.7:

Poner PonerEnBianco

Avanzar MarcarHorizontal
GirarDerecha Marcarvertical
Girarizquierda Imprimir

 

Figura 15.7 Representación gráfica de la interfaz de los módulos.

15.3.2 Dependencias entre ficheros. Directivas

Las relaciones de uso entre módulos se corresponden, en principio, con las
directivas finclude usadas en un fichero fuente para hacer visibles los elementos de otro, y que pueden aparecer en el fichero .cpp y/o en el .h. La
recomendación

 

+ Un fichero xxx.h debe incluir otros yyy.h que use directamente.

+ Un fichero xxx.cpp debe incluir su propio xoxx.h y otros yyy.h que use
directamente. Pero no hace falta hacerlo explícitamente si ya los incluye
su xxx.h.

En el ejemplo anterior hay dependencias indirectas. Por ejemplo, el módulo
principal DibujarC usa elementos de Tortuga dircctamente y también indirectamente a través de CurvaC. Si no se toman precauciones el preprocesador
incluirá el código de Tortuga.h dos veces, y se tendrán errores por duplicación
de definiciones. La directiva £pragma once sirve precisamente para evitar esa
duplicación.

IENOTA: La diroctiva Hpragma once no es estándar en C++. En su Ingar la reccta
habitual es similar a la siguiente (para un fichero x00x.h):

| ifadef oo

| define xooch_

 

 

Este esquema de código es algo más seguro pero bastante más complejo, y por ello se
ha decidido no incluirlo en el subconjunto
Módulos 423

 

15.3.3 Datos encapsulados

En cste tema y el anterior se ha visto cómo al definir un tipo abstracto de
datos hay que declarar luego variables de ese tipo para trabajar con ellas. En
algunos casos concretos resulta que sólo es necesario una única variable del
tipo abstracto. Si es así, existe la posibilidad de encapsular dicha variable en
un módulo y evitar la declaración explícita del tipo. La facilidad de ocultación
que provee la programación modular es suficiente para conseguir la abstracción
del dato, de forma que sólo sean visibles las operaciones que lo manipulan pero
no los detalles de su implementación.

La siguiente tabla compara los esquemas generales de código correspondientes
a la declaración y uso de un tipo abstracto de datos y a un dato encapsulado
En ambos casos se usa un módulo separado para el elemento abstracto.

 

 

 

 

 

 

 

 

 

 

“Tipo abstracto Dato encapsulado
Interfaz
typedef struct Tipo (
void Operacioni();
void Operación2(); void Operacion1();
DENate: void Operacion2();
UnTipo valorInterno; po ;
void Operación3();
H
Implementación
Dal static UnTipo valorInterno;
vola Tipo static void Operacion3() 4
3 )
'wald:1300 void Operacion1() £
valorInterno ...
> valorInterno ..
a 5 3
void Tipo: :0peracion2O (| oia operacion2O (
valorInterno ...
valorInterno ...
3
y
Uso
Tipo dato;
Operacion1();
dato.Operacion1();

 

 

 

 
424 Fundamentos de programación

Conviene recordar que los nombres de variables y subprogramas definidos en
el nivel más externo de un fichero fuente son globales, por defecto. Para que
scan tratados como identificadores locales al fichero deben ser marcados como
static.

Como puede verse el segundo esquema es más sencillo, ya que ni el tipo ni el
dato son visibles, Eso es posible por la limitación de que sólo hay un dato del
tipo abstracto. El dato encapsulado aparece simplemente como una colección
de operaciones que manipulan la misma variable interna, oculta.

Podemos ilustrar esta técnica recodificando el ejemplo modular de dibujar
una Curva-C, convirtiendo ahora el Papel en un dato encapsulado. Puesto
que cambia el código de la interfaz, hay que retocar también el código de los
demás módulos que lo usan

 

RD DOORS bSRDbbbEbbbe

* Interfaz de módulo: Papel2

* Este módulo encapsula un único ejemplar de dato abstracto
* de tipo PAPEL, capaz de almacenar un dibujo formado

* por trazos en una cuadrícula

fpragma once

 

remera]

void PonerEnBlanco();

void Marcarilorizontal( int x, int y );
void Marcarvertical( int x, int y );
void Imprimir();

 

 

 

DA

 

paraa

* Módulo: Papel2
* Este módulo encapsula un único ejemplar de dato abstracto
* de tipo PAPEL, capaz de almacenar un dibujo formado

por trazos en una cuadrícula

RARA RARA RRA

 

*include <stdio.h>
include "Papel2.h"

 

pa */

 

—- Elementos privados -
const imt ANCHO
const int ALTO = 1:

 

32; /* cuadrícula en */
/* la pantalla */

 

typedef char MatrizMarcas[ANCHO] [ALTO] ;
Módulos 425

 

static MatrizMarcas marcasH;
static MatrizMarcas marcasV;

static bool Dentro( int x, int y ) (
return (x >= 0 88 x < ANCHO €k y >= 0 88 y < ALTO);

y

 

*/

void PonerEnBlanco() £

 

for (int x=0; x<ANCHO; x++) £
for (int y=0; y<ALTO; y++) (
marcasH[x] [y] =" ';
marcasV[x] [y] =' *;
J
$
J

void Marcarkorizontal( int x, int y ) 4
if (Dentro( x, y )) £
marcasH[x] [y] = '_';
y
,

void MarcarVertical(int x, int y ) £
if (Dentro( x, y )) 4
marcasV[x][y] = *1';
2
J

void Imprimir() 4
for (int y=ALTO-1; y>-0; y--) (
for (int x=0; x<ANCHO; x+*) £
print£( "%cxc", marcasV[x][y], marcasH[x][y]);

y
print£( "Ya" );
y
,

 

 

 

JARA DEAR

* Interfaz de módulo: Tortuga2
»

* Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
RAR ARRRARARRA RARA RARA RARA ANA RARA AAA RRA
 

426 Fundamentos de programación

 

kpragma once
typedef enum TipoRumbo [ Este, Norte, Oeste, Sur );

typedef struct TipoTortuga í
void Poner( int x, int y, TipoRumbo rumbo );
void AvanzarQ);
void GirarDerecha();
void GirarTzquierda() ;
private:
int xa yy;
TipoRumbo sentido;
10

 

 

 

 

 

AAA

   

pr AA

* Módulo: Tortuga?
+ Este módulo define el tipo abstracto TORTUGA, capaz de

* ir trazando una trayectoria mediante avances y giros
AAA A ARA AAA ARA AA
Hinclude "Tortuga2.h"

*include "Papel2.h"

void TipoTortuga::Poner( int x, int y, TipoRumbo rumbo ) £
0
YY = Y;
sentido = rumbo;

$

void TipoTortuga: :Avanzar() (
switch (sentido) (
case Norte:
MarcarVertical( xx, yy );

case Sur:
NN
MarcarVertical( xx, yy );
break;
case Este:
MarcarHorizontal( XX, yy );
axe;
break
case Oeste:
e

 
 

Módulos 427

 

MarcarHorizontal( xx, yy );
break;
3
»

void TipoTortuga: :GirarDerecha() (
sentido = TipoRumbo( (int(sentido)-1+4) % 4 );
/* +4 evita rumbo negativo */

y

void TipoTortuga::GirarIzquierda() £
sentido = TipoRumbo( (int(sentido)+1) % 4 );
,

 

 

AAA

* Interfaz de módulo: CurvaC2
*

* Este módulo contiene la función que genera una Curva-C
ARARAR RARA RO ARAR AR RARARA A RRAA RNA ANA NRANAAR RARA AAA ARE

Kpragma once
+include "Tortuga2.h"

void CurvaC( int orden, TipoTortuga € t );

 

 

AAA A
* Módulo: CurvaC2
*

* Este módulo contiene la función que genera una Curva-C
AAA ARA

include "CurvaC2.h"

void CurvaC( int orden, TipoTortuga € t ) 4
if (orden == 0) £
t.Avanzar();
) else if (orden > 0) £
CurvaC( orden - 1, t );
t.GirarDerecha();
CurvaC( orden - 1, t );
t.GirarIzquierda() ;
+
,

 

Con estos cambios, el programa principal y un ejemplo de su ejecución quedan
como sigue:
428 Fundamentos de programación

 

 

AAA AAA NO

Programa: DibujarC2

E

* Descripción:

+ Este programa lee como dato el orden de una curva C, y a
+ continuación la dibuja en forma de texto en pantalla
*tinclude <stdio.h>
*tinclude "CurvaC2.h"
finclude "Tortuga2.h"
finclude "Papel2.h"

 

 

A

int mainQ) (
int orden;
TipoTortuga tt;

print£( "Orden: " );

scanf( "% gorden );

PonerEnBlancoO) ;

/* posición inicial de conveniencia */
tt.Poner( 8, 3, Este );

CurvaC( orden, tt );

ImprimirO ;

 

 

 

Orden: 6

 

 
Módulos 429

 

Ahora han desaparecido todas la referencias a la única variable que había del
tipo TipoPapel, tanto en su declaración como en su nso como argumento.
Además han quedado ocultas las definiciones de las constantes de tamaño del
papel, que son realmente detalles de implementación, lo cual puede resultar
ventajoso.

Por otra parte, las modificaciones en el código no han cambiado en modo
alguno el funcionamiento global del programa, que se sigue utilizando exactamento igual que antes. La modificación del código de un programa para
reorganizarlo sin cambiar su funcionalidad se denomina refuctorización.

15.3.4 Reutilización de módulos

Los expertos en desarrollo de software suelen considerar que la descomposición
modular basada en abstracciones es una buena metodología para desarrollar
módulos con bastantes posibilidades de ser reutilizados en el futuro. Los ele1mentos abstractos de una aplicación pueden ser de utilidad en otras aplicaciones del mismo campo de actividad, especialmente si se procura que dichos
elementos abstractos correspondan a clementos reales significativos, como ocurre en los ejemplos anteriores con la tortuga y el papel, que podrán reutilizarse
para componer otros dibujos con trazos rectos sobre una cuadrícula.

 

Los módulos que definen abstracciones relacionadas entre sí pueden agruparse
en una biblioteca o librería (en inglés library) que se pone a disposición de
quienes desarrollan aplicaciones en un campo determinado. Por ejemplo, se
pueden combinar módulos que operen con fechas, horas, calendarios de diferentes culturas, políticas de cambio de horario verano/invierno, ete. Todos
estos módulos constituirán una biblioteca de utilidad para quienes desarrollen
aplicaciones que manejen datos de tiempo oficial.

Un caso extremo de reutilización se tiene en los módulos “estándar” que acompañan a muchos lenguajes de programación. Estos módulos contienen elementos de uso general, que resultan útiles en un porcentaje muy elevado de
programas de todo tipo.

 

 

Como ejemplo de reutilización de Tortuga y Papel se presentan un par de
programas que dibujan otras figuras. Se incluye el listado de cada uno y un
ejemplo de su ejecución

 

El primer ejemplo dibuja una espiral cuadrada de un tamaño dado:

 
 

430 Fundamentos de programación

 

Tamaño: 15

 

 

PARA A

+ Programa: Espiral
* Descripción:

+ Este programa dibuja una figura espiral cuadrada, del

* tamaño que se indique como dato
AAA ea]
tinclude <stdio.h>

Hinclude "Tortuga.h"

+include "Papel.h"

/*%* Avanzar N pasos */
void AvanzarN( TipoTortuga € t, TipoPapel € p, int pasos ) £
for (int k-1; k<=pasos; k++) [
t.Avanzar( p );
+
,

 

/** Programa principal */
int mainO) €
int lado;
TipoTortuga tt;
TipoPapel pp;

 
Módulos 431

 

 

print£( "Tamañ

scanf( "%d", lado

pp-PonerEnBlanco();

tt.Poner( 0, 0, Este );

for (int k=lado; ko=1; k--) £
AvanzarN( tt, pp, k );
tt.GirarTzquierda();
AvanzarN( tt, pp, k);
tt.GirarTzquierda();

+

pp. Imprimir();

 

 

El segundo ejemplo dibuja una serie de cajas adosadas de los tamaños que se
indiquen. El final de los datos se indica mediante un tamaño cero.

 

 

Ancho y alto: 3 17
Ancho y alto: 9 4
Ancho y alto: 7 12
Ancho y alto: 7 7
Ancho y alto: 0.0

 
 

 

432 Fundamentos de programación

 

PORRA RARE

* Programa: Cajas
*

 

* Descripció
* Este programa dibuja una serie de cajas adosadas, de los

* — tamaños que se indiquen como datos

AAA AA LALA /
include <stdio.h>

include "Tortuga.h"

*tinclude "Papel.h'

/** Avanzar N pasos */
void AvanzarN( TipoTortuga £ t, TipoPapel £ p, int pasos ) £
for (int k=1; ko=pasos; ke*) 1
t.Avanzar( p );
,
+

/** Programa principal */
int mainO) 4
int ancho, alto;
TipoTortuga tt;
TipoPapel pp;

pp-PonerEnBlanco() ;
tt.Poner( 0, 0, Este );
do (
print£( "Ancho y alto: " );
ancho
alto = 0:
scan£( "%d%d”, gancho, galto );
if (ancho > 0 88 alto > 0) 4
AvanzarN( tt, pp, ancho );
tt.CirarIzquierda();
AvanzarN( tt, pp, alto );
tt.Cirarlzquierda();
AvanzarN( tt, pp, ancho );
tt.Girarlzquierda();
AvanzarN( tt, pp, alto );
tt.Girarizquierda();
AvanzarN( tt, pp, ancho );
y
) while (ancho > 0 84 alto > 0);
pp-Imprimir();

  

 

3

 
Ejercicios sin resolver - TIT

 

A continuación se enuncian un tercer bloque de ejercicios sin resolver. Todos
ellos deben ser realizados en CE utilizando la metodología explicada durante
el libro. Los enunciados de los ejercicios son los siguientes:

1. Realizar un programa que simule un cajero automático de monedas. Los
tipos de monedas que dispone el cajero son de 10, 20 y 50 céntimos de
euro y 1 y 2 euros. Inicialmente el cajero tiene 100 monedas de cada tipo,

 

que se van consumiendo para proporcionar las cantidades solicitadas. El
cajero debe obtener la cantidad solicitada con los tipos de moneda que
tenga en cada momento, tratando siempre de utilizar las monedas de
mayor valor.

2. Realizar una función que a partir de dos puntos del plano pasados como
argumentos, devuelva cierto cuando el primero esté mas alejado del origen de coordenadas que el segundo y falso en caso contrario. Utilizando
la función anterior realizar un programa que ordene en un vector hasta
10 puntos según su distancia al origen.

3. Realizar un programa que analice un texto terminado con un punto (.)
y extraiga del mismo las siguientes palabras:

+ Palabra más larga.

+ Palabra más corta.

+ Palabra con más vocales.

+ Palabra con más consonantes.

4. Realizar un tipo abstracto de datos (TAD) para manejar datos enteros
en forma de lista con los valores ordenados de menor a mayor y que
disponga de las siguientes operaciones básicas:

+ Iniciar la lista vacía.

+ Comprobar si la lista está vacía.
+ Retirar el primer número de la lista.

+ Insertar un número en la lista ordenada.

+ Conocer el número de elementos de la lista.

 

 

 
Apéndice A

Sintaxis de C+

 

En este apéndice se recogen de forma precisa todas las reglas sintácticas que
definen el lenguaje Ct, utilizando la notación BNF (Backus-Naur Form). En
las reglas se utilizan los siguientes metasímbolos:

 

Metasímbolo de definición. Indica que el elemento a su izquierda puede
desarrollarse sogún el esquema de la derecha.

|. Metasímbolo de alternativa. Indica que puede elegirse uno y sólo uno de
los elementos separados por este metasímbolo.

 

£ ) Metasímbolos de repetición. Indican que los elementos inchridos dentro
de ellos se pueden repetir cero o más veces.

 

  

[ ] Metasímbolos de opción. Indican que los elementos incluidos dentro de
ellos pueden ser utilizados o no.

 

( ) Metasímbolos de agrupación. Agrupan los elementos incluidos en su
interior.

Estos metasímbolos se escriben con el tipo de letra especial indicado para
distinguirlos de los paréntesis, corchetes, etc. que forman parte del lenguaje
C+/-. También se emplearán distintos estilos de letra para distinguir los
elementos simbólicos siguientes:

 

 

 

Elemento_no_terminal: Este estilo se emplea para escribir el nombre de nn
elemento gramatical que habrá de ser definido por alguna regla. Cual
quier elemento a la izquierda del metasímbolo será no terminal y
aparecerá con este estilo.

 

 

Elemento_terminal: Este estilo se emplea para representar los elementos
que forman parte del lenguaje Ct, es decir, que constituyen el texto de

 
 

436 Fundamentos de programación

 

un programa. Si aparecen en una regla deberán escribirse exactamente
como se indica.

La mayoría de las reglas ya han sido introducidas a lo largo del texto. Pese a
todo y con la idea de ofrecer uma guía de referencia del lenguaje, se ha preferido
realizar una definición conjunta de todas las reglas del lenguaje desde la regla
más global hasta la más particular. Estas reglas, agrupadas por los principales
elementos del lenguaje, son las siguientes:

A.l Unidad de compilación

 

1 Unidad de compilación
Programa_ principal | Módulo_interfaz | Módulo_implementación

2  Programa_principal :3= É Include Y É Declaración global Y
int main() Bloque

3 Módulo interfaz *

 

Pragma_once [, Include Y [ Declaración interfaz Y
£ Iolude Y 4 Declaración global Y

 

4 Módulo implementación $

A.2 Directivas de programa

5 Include :i=

+include <Nombre módulo.h> | +include "Nombre médulo.h"
= fipragma once

 

6  Pragma onc

 

A.3 Declaraciones globales

 

T Declaración global *
¡_de_constante |
Declaración. de. tipo |

[ static ] Declaración de_variable |
[ static ] Subprograma.

 

Declarac:
Sintaxis de C+ 437

 

A.4 Declaraciones de interfaz

 

8 Declaración_interfaz 33
Declaración de_ constante |
Declaración _de_tipo |
extern Lista_de_variadles |
Cabecera_subprograma ;

A.5 Constantes

 

9 Declaración de constante Constante_ simple
| Constante_cadena | Constante estructurada

0 Constante_simple 33= const Identificador_de_tipo
Identificador = Expresión ;

11 Constante_cadena ++= const char
Identificador [ ] = Cadena_ de caracteres ;

2 Constante estructurada 333 const Identificador_de_ tipo
Identificador Dimensiones = Inicio_estructurado ;

 
 
 

 

Expresión constante 1 É [ Expresión constante 1 )
= £ Lista_estructurada Y

13 Dimensiones

  

4 Inicio_estructurado

 

Lista_de_valores | Lista_de inicios

 

5 Lista estructurada
16 Lista_de valores 33= Expresión constante [ , Espresión_constante )

17 Lista_de inicios 33= Inicio estructurado Í , Inicio estructurado )

A.6 Tipos

   

18 Declaración_de_ tipo
Tipo_sinónimo | Tipo_enum | Tipo_array |
Tipo_struct | Tipo_unión | Tipo_puntero

19 Tipo_sinónimo *3= typedef Identificador_de_tipo Identificador ;

 

20 Tipo_enum + typedef enum Identificador
f Lista de identificadores Y ;
21 Lista_de identificadores 33= IdentificadorÍ , Identificador )

22 Tipo_array 33= typedef Identificador_de_tipo
Identificador Dimensiones ;

 

 
 

 

438 Fundamentos de programación

 

 

23 Tipo struct 33= typedef struct Identificador
1 Lista de items [ private: Lista de items ]) ;

21 Tipo unión 33= typedef union Identificador £ Lista_de campos Y 5

 
 

25 Tipo puntero :3= typedef Identificador_de_tipo * Identificador ;

Htem ; [Item ; y

 

26 Lista de items
27 Lista_de_campos 33= Campo ; É Campo ; Y
28 Tem 33= Campo | Cabecera_subprogruma

29 Campo 33= Campos igual tipo | Campo_puntero | Campo_arruy
30 Campos igual tipo 33% Identificador_de_tipo Lista_de_id
Identificador_de_tipo * Identificador

Identificador_de_tipo Identificador Dimensiones

    

 

ificadores

 

31 Campo_puntero

 

32 Campo_array

A.7 Variables

 

33 Declaración de variable
imple | Variable _estructurada | Lista_de_variables
34 Variable_simple *
Identificador_de_tipo Identificador [ = Expresión ] ;
35 Variable estructurada $
Identificador_de
36 Lista_de_variables
Identificador_de_tipo Lista_de_identificadores ;

 

 

 

¡po Identificador [ = Inicio_ estructurado ] ;

  

A.8 Subprogramas

 

= Cabecera función | Cabecera. procedimiento
Identificador_de_tipo
] rientificador ( Lista_de_ argumentos )

37 Cabecera_subprograma
38 Cabecera función
[ dentificador
39 Cabecera_procedimiento :3= void
[ luentificador :: ] Identificador ( Lista_de argumentos )

  

   

 

40 Listo_de argumentos Argumento Í , Argumento )

 

41 Argumento 33= const Identificador_de_tipo Identificador [ 1111
Identificador_de tipo [ 8 ] Identificador [ 1 3]

42 Subprograma 33= Cahecera_subprograma Bloque
Sintaxis de C+ 439

 

A.9 Bloque de código

 

43 Bloque 33= ( Secuencia_de_ declaraciones Secuencia_de_sentencias y

É Declaración _de_bloque )

45 Secuencia_de sentencias 333 ( Sentencia Y

 

 

44 Secuencia_ de declaracione:

A.10 Declaraciones de bloque

46 Declaración de bloque 3
Declaración de constante |
Declaración de_tipo
Declaración de_ variable

 

A.11 Sentencias ejecutables

47 Sentencia 333
Asignación | Incremento | Decremento |
If_else | Switch |
While | Do_wnile |
For_creciente | For_creciente_menor | For_decreciente |
Llamada_a_ procedimiento
Continue | Return |
Delete |
Throw | Try |
Sentencia_nula
1 Secuencia de sentencias Y

 

48 Asignación 33= Identificador_general = Expresión ;

49 Incremento 33= Identificador_general ++ ;

 

 

50 Decremento + Identificador_general — ;
51 If els £ ( Expresión ) 4 Secuencia_de_sentencias y

else if ( Expresión ) £ Secuencia_de_sentencias 3 )
else ( Secuencia de sentencias Y

 

52 Switch +22 switch ( Expresión ) € Lista_de_casos Y
53 Lista de casos 33=
CasoÉ Caso ) [ default : Secuencia_de_sentencias ]
 

440 Fundamentos de programación

 

 
 
 
 

= Lista_de_ opciones Secuencia_de_sentencias break ;
= case Opción : [ case Opción : )
Expresión constante

57 While

58 Do_while do £ Secuencia_de sentencias ) while ( Expresión ) ;
59 For creciente for (int Identificador = Expresión ;
Identificador <= Expresión ; Identificador ++ )
f Secuencia_de_sentencias Y
60 For_creciente_menor or (int Identificador = Expresión ;
Identificador < Expresión ; Identificador ++ )
1 Secuencia _de sentencias 3
61 For decreciente for (int Identificador = Expresión ;
Identificador >= Expresión ; Identificador -- )
£ Secuencia_de_sentencias 3
62 Llamada a procedimiento *
Identificador_general ( Lista_de_expresiones ) ;
63 Continue :1= continue ;
64 Return +
65 Delete *

ihile ( Expresión ) f Secuencia_de_sentencias )

 

 

 

 

 

 

 

   
 
  

= return [ Expresión ] ;

delete Identificador ;

66 Throw throw Expresión ;

67 Try 352 try £ Secuencia_de_sentencias )
[ catch ( 1dentificador_de_tipo Identificador )
4 Secuencia_de_sentencias 3 ]

68 Sentencia_nula

 

 

 

A.12 Expresiones

69 Lista _de_ezpresiones 333 [ Expresión [ , Expresión ) ]
70 Expresión Expresión _ORÁ Operador_OR Expresión _OR Y
71 Expresión_OR 33= Expresión _AND
€ Operador_AND Expresión _AND Y
72 Expresión AND 335 Expresión igualdad
[ Operador_igualdad Expresión igualdad ]

 

 

73. Expresión_igualdad 33= Expresión numérica
Operador_comparación Expresión numérica
Sintaxis de C+

 

78
79
80
81
82
83

85
86
87
88
89
90

91

 

Expresión numérica 33= Término É Operador_sumador Término Y
Término *3= FactorÁ Operador multiplicador Factor Y

Factor 33= + Factor | - Factor | + Factor | * Factor | 8: Factor |
Fuetor_cualificado

 

 

Factor_cualificado 333 Elemento |
Factor_euolificado . Elemento
Factor cualificado [ Expresión ] |
Factor_cualificado -> Elemento

Operador _OR 5
Operador _AND 33= 88
Operador igualdad

 

 

Operador comparación 33= > | >= | <| <=

*|/1x%

   

Operador_sumador

Operador_multiplicador

.13 Elementos básicos

Elemento 33
Valor_entero | Valor real | Carácter | Cadena. de caracteres |
Identificador | new Identificado:
Identificador ( Lista de expresiones ) |
Identificador_de_tipo ( Expresión ) |
( Expresión )

 

 

 

[+ | -] Secuencia_dígitos
Dígito | Dígito Y

Valor_entero

 

Secuencia dígitos

Dígito :3=o|1l213la1s]ó6l718l9
Valor_real 333 Valor_entero . [ Secuencia_dígitos ] [ Escala ]

Escala +

 

E Valor_entero
Identificador_yeneral 333 [ * ] tdentificador

€... Identificador | [ Expresión 1 | -> Identificador Y
Identificador_de_tipo 333

int | char | float | boo1 | saentificador

 
442 Fundamentos de programación

 

 

Identificador 333 Letra Í Letra | Guión | Dígito y

28

dra 31=

Letra 333
eslelolele o
nlolrla elo

 

e1al8 elelzlnlililxlrIm1
njolpla rlslilulvlwIxIylz
94 Guión 335 _

 

   

 

   

95 Cadena
96 Carácter

le caractere: ...caracteres normales o escapes.

 

 

“carácter normal o Yescape*

A.14 Índice de reglas BNF

Argumento, 41
Asignación, 48

Bloque, 43
Cabecera_función, 38
Cabecera_procedimiento, — 39
Cabecera_subprograma, — 37
Cadena_de_caracieres, 95
Campo, 29
Campo_array, 32

Campo puntero, 31
Campos_igual_tipo, 30
Carácter, 96

Caso, 54
Constante_cadena, 11
Constante_estructurada, 12
Constante simple, 10
Continue, 63
Declaración _de_bloque, 46
Declaración _de_constante, 9
Declaración de_tipo, 18
Declaración _de_variable, 33
Declaración global, 7
Declaración interfaz, 8
Decremento, 50

Delete, 65

Dimensiones, 13
 

Sintaxis de C+

443

 

Do_while, 58

Dígito, 87
Elemento, 84
Escala, 89

Expresión, 70
Expresión AND, 72
Expresión _OR, TL
Expresión igualdad, 73
Expresión numérica, 74
Factor, 76
Factor_cualificado, 77
For_creciente, 59

 

 

For_ereciente_menor, 60
For_decreciente, — 61
Guión, 94

Identificador, 92
Identificador_de_tipo, 91
Identificador general, 90
If_else, 51

Include, 5
Incremento, 49
Inicio_estructurado, 14
Tem, 28

Letra, 93
Lista_de_argumentos, 40
Lista_de campos, 27
Lista_de_casos, 53
Lista_de_capresiones, 69
Lista_de identificadores, 21
Lista_de inicios, 17
Lista de_items, 26
Lista_de_opciones, — 55
Lista_de_valores, 16
Lista de variables, 36
Lista_estructurada, 15

 

Llamada_a_ procedimiento, 62

Módulo implementación, 4
Módulo_interfaz, 3
Opción, 56
Operador_AND, 79

 
 

444 Fundamentos de programación

Operador OR, 78
Operador comparación, — 81
Operador_igualdad, 80
Operador multiplicador, 83
Operador _sumador, 82
Pragma_once, 6
Programa principal, 2
Return, 64
Secuencia de declaraciones, 44
Secuencia_de_sentencias, 45
Secuencia dígitos, 86
Sentencia, — 47
Sentencia_nula, 68
Subprograma, — 42

Switch, — 52

Throw, 66

Tipo_array, 22
Tipo_enurm, 20

Tipo puntero, 25
Tipo_sinónimo, 19
Tipo_strucl, 23
Tipo_unión, 24

Try, 67

Término, 75
Unidad de compilación, 1
Valor_entero, 85
Valor_real, 88
Variable_ estructurada, — 35
Variable_simple, 34
While, 57

 
Apéndice B

Manual de Estilo

Este apéndice constituye el Manual de Estilo básico para la realización de
programas en Ct. El objetivo de un manual de estilo es recopilar un conjunto
de buenas prácticas de programación para establecer una forma sistemática en
la claboración de todos los programas. A lo largo del libro se han presentado
algunas de las normas de programación y en este apéndice se han recopilado
para facilitar la elaboración de los programas con una mayor calidad, facilitar
su mantenimiento y ovitar ambigiiedades.

Hay que tener en cuenta que en cualquier desarrollo de software pueden intervenir decenas o incluso centenares de programadores y es absolutamente
necesario disponer de un manual de estilo para que todos los que participan
en el proyecto tengan un estilo de programación único, uniforme y asumible
por todos. El estilo debe ser fruto de la experiencia en el desarrollo de proyectos anteriores y para que su empleo sea efectivo y generalizado es necesario
disponer de las herramientas adecuadas para verificar que todos los programas
siguen el estilo establecido. Así, una norma se considera Obligatoria cuando
se debe cumplir siempre y además se dispone de una adecuada herramienta
de verificación de su cumplimiento. Una norma es Recomendable cuando es
aconseja su utilización pero la verificación sistemática no es posible en todos
los casos.

Como caso especial, se han incluido como reglas de estilo algunas que son
realmente restricciones de CE respecto a C++, y que obviamente no son comprobadas por el compilador de C++ usado para compilar los programas en
CH

En este apéndice se han agrupado las normas en cinco grandes apartados que
se describen a continuación.

 

 
 

446 Fundamentos de programación

 

B.1 Aspectos generales

En este apartado se agrupan las normas que se deben aplicar en cualquier
punto de un programa con carácter general.

B.1.1 Sintaxis

+ Obligatoria: Cualquier programa debe ajustarse estrictamente a la sintaxis do Ct que se detalla en el apéndice A.

+ Obligatoria: En cualquier bloque de programa todas las declaraciones
se deben agrupar en la parte declarativa que siempre precederá a la parte
ejecutiva compuesta por una secuencia de sentencias. Por tanto, nunca
se pueden mezclar declaraciones y sentencias ejecutables.

B.1.2 Encolumnado

+ Obligatoria: Siempre se debe utilizar el mismo indentado en el encolumnado de todos los programas de un mismo proyecto.

» Obligatoria: El indentado máximo será de 4 espacios en blanco y el
mínimo de 2 espacios en blanco.

» Recomendable: Es aconsejable utilizar un indentado de 2 espacios en
blanco.

 

B.1.3 Comentarios

Obligatoria: El programa deberá tener al menos un comentario de
cabecera de programa que incluya el nombre del programa y del autor,
una breve descripción de lo que hace y la fecha de su última modificación.
NOTA: En la mayoría de los ejemplos del libro no se incluye esta
cabecera por la limitación de espacio y porque casi siempre resultaría
redundante ya que la descripción se detalla en las explicaciones del texto.
Obligatoria: Se utilizará un comentario de cabecera de sección para documentar cada una de las partes importantos del programa y separarlas
convenientemente.

Recomendable: Es aconsejable utilizar comentarios-orden y comentarios al margen siempre que se requiera cualquier aclaración adicional
sobre los refinamientos empleados o el significado de algún elemento del
programa.

Obligatoria: Las sentencias relativas a un comentario-orden se agruparán mediante llaves £. . .) para realizar un indentado con las sentencias
del comentario-orden agrupadas.
Manual de Estilo 447

 

B.1.4 Identificadores

+ Obligatoria: Los identificadores deben ser nombres que reflejen su uti
lidad sin que sea necesario ningún comentario adicional sobre su signifi
cado.

Obligatoria: Nunca se utilizarán identificadores formados sólo por le
tras mayúsculas (salvo que se trate de siglas u otra abreviatura de uso

común).

Obligatoria: Los identificadores compuestos realizados por concate
nación de palabras se realizarán intercalando una letra mayúscula al

comenzar la nueva palabra o bien separando las palabras por el guión

bajo (_).

Obligatoria: Los identificadores de un tipo de dato serán siempre iden
tificadores compuestos que comenzarán con el prefijo Tipo.

Recomendable: Es aconsejable que los identificadores de constante y

subprograma comiencen por una letra mayúscula.

Recomendable: Es aconsejable que los identificadores de variable co
miencen por una letra minúscula.

+ Recomendable: Es aconsejable que los identificadores de funciones
scan nombres (del valor resultante).

+ Recomendable: Es aconsejable que los identificadores de procedimientos sean verbos o nombres de acciones.

 

B.2 Declaraciones

+ Obligatoria: Cuando las declaraciones de un bloque de programa no
superen el tamaño de una página, el orden de las declaraciones será
siempre: Constantes, Tipos, Variables y finalmente Subprogramas.

+ Recomendable: Cuando las declaraciones de un bloque de programa
tengan cierta complejidad y la aplicación estricta de la regla anterior
pueda disminuir la claridad, es aconsejable agrupar las declaraciones por
aquellos clementos significativos del programa que estén relacionadas entre sí. En este caso, aunque no existe un orden riguroso para declarar
constantes, variables, tipos y subprogramas sí que es aconsejable que las
declaraciones de un mismo elemento conserven entre sí el orden establecido en la regla anterior. Como se ha visto en el tema 14, los tipos
abstractos de datos son una forma adecuada adecuada de agrupar todas
las declaraciones relativas a un elemento significativo del programa.
 

l 448 Fundamentos de programación

B.2.1 Constantes

+ Recomendable: Es aconsejable agrupar todas las declaraciones de las
constantes globales de un programa en un punto único para que su parametrización resulte clara y evidente.

+ Recomendable: Es aconsejable no utilizar directamente valores constantes numéricos o literales cn las sentencias ejecutables de un programa
(salvo casos triviales). Resulta preferible definirlos como constantes con
nombre.

B.2.2 Tipos de datos

+ Obligatoria: Todos los nuevos tipos de datos del programa se deben
definir con un typedef. No se permite la existencia de tipos anónimos.

+ Obligatoria: La declaración de un nuevo tipo sinónimo o puntero se
realizará siempre en una sola línea de código.

B.2.2.1 Formato para tipo enumerado

+ Recomendable: Siempre que sea posible es aconsejable que la declaración de un tipo enumerado se realice en una única línea de programa
utilizando el siguiente formato:

| typedef enum TipoNuevo (Valor, Valor, . . . , Valor)
+ Obligatoria: Cuando el número de elementos del tipo enumerado sea

amplio o en general resulte aconsejable utilizar más de una. línea de
programa en la declaración, el formato utilizado sera el siguiente:

 

TipoNuevo (

Valor, Valor, . . . . . Valor,
Valor, Valor, . . . . . Valor,
Valor, Valor, . . . . . Valor

y

B.2.2.2. Formato para tipo formación

+ Obligatoria: La declaración de un tipo formación se realizará siempre
en una única línea de programa utilizando el siguiente formato:

| typedef TipoFlemento TipoNuevo [Dimension] [Dimension]. ...
 

Manual de Estilo 449

 

+ Recomendable: Es aconsejable que el valor de cada Dimension que
fija el tamaño de la formación se declarare previamente como constante
con nombre.

B.2.2.3. Formato para tipo registro (struct)

+ Obligatoria: La declaración de un tipo registro (struct) nunca se realizará en una única línea de programa. El formato utilizado sera el
siguiente:
typedef struct TipoNuevo (

TipoCampo NombreCampo;
TipoApuntado * NombreCampo;
TipoCampo NombreCampo;

y

Obligatoria: Todos los tipos TipoCampo son identificadores de tipo que
tienen que haber sido declarados previamente.

Obligatoria: Cuando un campo es de tipo puntero (+), el tipo de dato
al que apunta TipoApuntado también tiene que haber sido declarado
previamente o bien ser el propio nuevo tipo TipoNuevo que se está defi
niendo. Los campos de tipo puntero son el único caso de tipo anónimo.
permitido.

  

 

B.2.2.4 Formato para tipo registro variante (union)

» Obligatoria: La declaración de un tipo registro variante (union) nunca
se realizará en una única línea de programa. El formato utilizado sera
el siguiente:
typedef union TipoNuevo (

TipoCampo NombreCampo;
TipoApuntado * NombreCampo;
TipoCampo NombreCampo;

 

 

,
+ Obligatorias Todos los tipos TipoCampo son identificadores de tipo que
tienen que haber sido declarados previamente.

+ Obligatoria: Cuando un campo es de tipo puntero (*), el tipo de dato
al que apunta Tipoapuntado también tiene que haber sido declarado

 
450 Fundamentos de programación

 

previamente o bien ser el propio nuevo tipo TipoNuevo que se está definiendo. Los campos de tipo puntero son el único caso de tipo anónimo
permitido.

B.2.3 Variables

+ Obligatoria: En la declaración de variables sólo se puede utilizar un
identificador de tipo válido predefinido o declarado previamente. Dicho
de otra manera no se pueden declarar variables de tipo anónimo.

+ Obligatoria: Cuando se inicializa una variable sólo está permitida la
declaración de esa variable de manera individual. Por tanto, no está
permitido realizar inicializaciones de ninguna variable cuando se declaran
como una lista de variables del mismo tipo.

+ Obligatoria: Cuando se realiza la asignación de un resultado de tipo
distinto al tipo de la variable es obligatorio realizar siempre uma conyersión explícita del resultado al tipo de la variable.

+ Recomendable: Es aconsejable realizar la in
en la misma declaración.

 

lización de la variable

B.2.4 Subprogramas

+ Recomendable: Dentro del bloque de un subprograma no se deben
realizar ninguna asignación a nn argumento pasado por valor. Cualquier
asignación a un argumento formal pasado por valor sólo tiene efecto
dentro del bloque del subprograma y no se transmite al argumento real
después de finalizar la ejecución del subprograma por lo que resulta
confuso y se debe evitar.

+ Recomendable: Salvo que sea imprescindible no es recomendable utilizar redefinición de elementos.

+ Recomendable: No se debe utilizar doble referencia salvo que el subprograma se diseñe pensando en esta posibilidad.

+ Obligatoria; La declaración de la cabecera de un subprograma se realizará en una sola línca siempre que lo permitan el número de argumentos
y la longitud de los identificadores y además no se requiera ningún comentario adicional para explicar el significado de cada argumento. En
este caso la cabecera se formateará como se indica en los siguientes apartados:

Función

TipoResultado NombreFuncion (Lista de argumentos) 4
Bloque de la función
Manual de Estilo 451

 

bp
Procedimiento

void NombreProcemiento (Lista de argumentos) £
Bloque del procedimiento
)

Recomendable: Cuando la cabecera resulte poco clara en una única
línea por el excesivo número de argumentos, la necesidad de explicar
el significado de cada argumento o cualquier otro motivo, la cabecera
se formateará con un solo argumento por línea según se indica en los
siguientes apartados:

 

 

Función

TipoResultado NombreFuncion (
TipoArgumento NombreArgumento, /% paso por valor =/
TipoArgumento $ NombreArgumento, /* paso por referencia */
const TipoArgumento NombreArgumento, /* vector por valor */
TipoArgumento NombreArgumento, /* vector por refer. */

14
Bloque de la función

y

Procedimiento

void NombreProcemiento (
TipoArgumento NombreArgumento, /* paso por valor */
TipoArgumento £ NombreArgumento, /* paso por referencia */
const TipoArgumento NombreArgumento, /* vector por valor */
TipoArgumento NombreArgumento, /* vector por refer. */

Ji
Bloque del procedimiento

y

B.2.5 Tipos abstractos de datos

+ Obligatoria: Un tipo abstracto de dato siempre se declarará mediante
un tipo registro (struct) con funciones y/o procedimientos encapsulados
dentro del struct. El formato de declaración será el siguiente:

typedef struct TipoNuevo (
TipoCampo NombreCampo;
 

 

452 Fundamentos de programación

 

TipoCampo * NombreCampo;

void NombreProcedimiento (Argumentos);
TipoResultado NombreFuncion (Argumentos);

private:
TipoCampo NombreCampo;
TipoCampo * NombreCampo;

void NombreProcedimiento (Argumentos);
TipoResultado NombreFuncion (Argumentos);

pa

+ Obligatoria: En primer lugar se agruparán todos los elementos publi
cos. A continuación se declararán los elementos privados precedidos de
la palabra clave private:

+ Obligatoria: La declaración de los campos del tipo abstracto de datos
se realizará de la misma forma que cualquier otro registro.

+ Obligatoria: Para la doclaración de las funciones y/o procedimientos
se utilizarán las mismas normas de los subprogramas.

B.3 Sentencias

+ Recomendable: Para visualizar la separación entre las declaraciones y
el comienzo de las sentencias del programa es aconsejable dejar al menos
una línea cn blanco.

+ Recomendable: Es aconsejable que en una misma línea de programa
sólo se escriba una única sentencia acabada en punto y coma.

+ Obligatoria: El formato de las sentencias enya sintaxis se define en función de cualquier sentencia del lenguaje de una manera recursiva nunca
so puede escribir en una única línea de programa. Más concretamente,
el formato que se debe utilizar dependiendo del tipo de sentencia es el
siguiente:

Selección IF

if (Condicion) £
Sentencias

Y else if (Condicion) £
Sentencias

) else if (Condicion) £
Manual de Estilo 453

 

Y else (
Sentencias

y

Selección SWITCH

switch ( Expresion ) 4
case valor:
Sentencias
break;
case valor:
case valor:
Sentencias
break;

defaul:
Sentencias

 

y

Bucle WHILE

while (Condicion) £
Sentencias

J

Bucle DO

do £
Sentencias
) while (Condicion);

Bucle FOR incremental

for (int indice-ValorInicial; indice <= ValorFinal; indice+) £
Sentencias

,

Bucle FOR decremental

for (int indice=ValorInicial; indice >= ValorFinal: indice--) £
Sentencias

3

Bucle FOR incremental menor

for (int indice=ValorInicial; indice < ValorFinal; indice++) [
Sentencias

 

$
 

454 Fundamentos de programación

 

Bloque TRY-CATCH para manejo de excepciones

[try
Sentencias

Jj catch (Tipo excepcion)
Sentencias

3

 

+ Obligatoria: La variable indice de un bucle FOR puede ser utilizada
dentro del bucle pero nunca debe ser modificada, pues se perdería el
control automático de las repeticiones.

B.4 Expresiones

+ Obligatoria: Hay que tener en cuenta que en la evaluación de las expresiones complejas el orden por defecto que se sigue viene fijado por
nivel de prioridad que tienen asignadas las distintas operaciones. Si no
se utilizan paréntesis, el orden de evaluación de los 7 niveles de prioridad
es el siguiente:

Operador Unario: 1-8
Operador Multiplicativo: —* 7%
Operador Aditivo: >
Operador de Comparación: > >= < <=
Operadores de Igualdad:
Operador AND lógico:
Operador OR lógico:

>

noma

 

+ Recomendable: Es aconsejable utilizar paréntesis adicionales para evitar cualquier ambigúedad o dificultad de interpretación de la expresión.
Por ejemplo, cuando se combinen operadores de comparación y lógicos

+ Recomendable: No es aconsejable utilizar paréntesis adicionales en
aquellas expresiones que, aprovechando los niveles de prioridad por defecto del lenguaje, estén ampliamente consensuadas y no planteen ninguna duda en su interpretación.

+ Obligatoria: No está permitido realizar expresiones aritméticas entre
operandos de distintos tipos. Siempre es obligatorio realizar una con
n explícita de tipos para precisar la operación aritmética que se
quicre realizar. Esta regla trata de evitar resultados inesperados provocados por las conversiones numéricas por defecto.

+ Obligatoria: No está permitida ninguna forma de comparación entre
elementos de distintos tipos.

  

 

 

   

  
Manual de Estilo 455

 

+ Obligatoria: Los operadores lógicos (88 y ||) sólo se pueden utilizar
con elementos de tipo SI(cierto)/NO(falso).

B.5 Punteros

+ Obligatoria: Está prohibido utilizar los punteros como formaciones.

B.6 Módulos

+ Obligatoria: El fichero fuente del módulo principal debe tener el
nombre que el programa ejecutable final, y la extensión .cpp.
Obligatoria: Por cada módulo no principal debe haber dos ficheros
fuente, con el mismo nombre que el nombre lógico del módulo y extensiones .h (interfaz) y .cpp (implementación).

Obligatoria: Cada fichero de interfaz de un módulo no principal

(modulo.h) debe comenzar con la directiva Kpragma once.

Obligatoria: Cada fichero de implementación de un módulo no

principal (modulo.cpp) debe incluir su propio fichero de interfaz

(*include "modulo.h")

Obligatoria: Las constantes y tipos públicos de un módulo deben de
clararse solamente en el fichero de interfaz (modulo.h).

Obligatoria: Las variables y subprogramas públicos deben definirse

completamente en el fichero de implementación (modulo.cpp) y además

deben declararse en el fichero de interfaz (modulo.h).

Obligatoria: La declaración de cada variable pública en el fichero de

interfaz debe ir precedida de la palabra clave extern y no debe incluir

especificación de valor inicial.

Obligatoria: La declaración de cada subprograma público en el fiche
ro de interfaz debe consistir solamente en su cabecera (tipo, nombre y

argumentos).

Obligatoria: La definición de cada variable global y subprograma no

públicos en el fichero de implementación de un módulo no principal debe

ir precedida de la palabra clave static.

+ Recomendable: Conviene que los nombres de todos los elementos públicos de un módulo comiencen por un mismo prefijo corto y con valor
nemotécnico que identifique el módulo al que corresponden. Esto es importante en aplicaciones con muchos módulos o en el caso de librerías de
módulos reutilizables.

 
 

 

 
Apéndice C
Notación lógico-matemática

En este apéndice se describe la notación utilizada en las especificaciones formales que aparecen en algunos puntos de este libro para anotar y razonar
sobre la corrección de ciertos fragmentos de código. La notación empleada es
esencialmente la notación matemática habitual, con ciertas simplificaciones y
adaptaciones para hacerla más asequible a los lectoros de este libro.

En lo que sigue, se usan los siguientes nombres para designar elementos genéricos del tipo que se indie:

 

a be; valores numéricos

p q: valores lógicos

e: elemento genérico (valor de cualquier tipo)

¡ 3 kz índice (valor entero)

eu: colecciones (conjuntos o vectores)

P(x...): predicado (expresión lógica que depende de ciertos argumentos)

 

 

C.1 Operadores numéricos

Las operaciones aritméticas habituales:

 

 

 

 

 

 

 

 

 

a+b| Suma a más b

a—b | Diferencia a menos b

ax b | Producto a rmultiplicado por b

a/b | Cociente a dividido por b

—a | Cambio de signo | menos a

Le Sumatorio suma de los elementos de c

 

 
458 Fundamentos de programación

 

También se usarán funciones matemáticas de todo tipo que se supongan ya
definidas: máximo(x, y, ...), factorial x1, etc.

C.2 Operadores de comparación

Igualdad y relación de orden:

 

 

 

 

 

 

a>b | mayor a es estrictamente mayor que b
a=>b | mayor o gual | a es mayor o igual que b

a<b | menor a es estrictamente menor que b
a <b | menor o igual | a es menor o igual que 5

a=5 | igual a es igual a b

ab | diferente a es distinto de b

 

 

 

 

 

C.3 Operadores lógicos

Operadores de la lógica booleana:

 

pAq | conjunción | p y además q

PY a | disyunción | po q o ambos

=p | negación [nop

P— 4 | implicación | si es cierto p también es cierto q

 

 

 

 

 

 

 

 

Formas abreviadas:

 

ALLER as<bAb<ecAc<..
a<b<eS<... | conjunción | (y también para otras combinaciones
de operadores de comparación)

 

 

 

 

 

C.4 Colecciones

Se usa la misma notación para colecciones no ordenadas (conjuntos) y ordenadas (vectores, listas o secuencias). Cuando sea oportuno se usarán los
conjuntos como vectores, y viceversa.

 

conjunto de elementos e

 

fe €c, P(e)) | comprensión de un conjunto universal c,
que cumplen la propiedad P
vli] elemento de vector | ¿-simo elemento de v (v;)

 

 

 

 

 

cardinal(c) cardinal número de elementos de €

 
Notación lógico-matemática

Formas abreviadas:

 

   

 

i<k<j
iSksj

colección de valores correlativas
2 a desde i hasta j, ambos inclusive
dj rango o intervalo [950 1 :
(si ¿ es mayor que j, entonces
denota el conjunto vacío)
: a e = conjunto de valores correlativos k

rango o intervalo | desde ¿ hasta ¿

(incluidos o no los extremos)

 

(oli), Peli) | comprensión

colección de elementos de y que
cumplen la propiedad P.

 

[IP] comprensión

colección de elementos de v cuyos
índices cumplen la propiedad P

 

sección

 

 

 

colección de elementos de v cuyos
índices son los elementos de e

 

 

 

Las llaves de la expresión de un conjunto mediante (elemento, propiedad) se
pueden omitir si la expresión ya va entre paréntesis o corchetes.

C.5 Cuantificadores

Universal y existencial:

 

Ve € ce Ple) | para todo

todos los elementos de c cumplen la
propiedad P.

 

Se E ce Ple) | existe

 

 

 

al menos un elemento de e cumple la
propiedad P

 

 

C.6 Expresiones condicionales

Expresión con formas alternativas dependiendo de alguna condición:

 

c=>A|B si, en otro caso

si se cumple e se evalúa A,
en otro caso se evalúa B

 

el > Elle2> E2|...JE

 

 

si, o bien si, ....
en otro caso

si se cumple cl se evalúa ET,
si se cumple e2 se evalúa E2,
..., en otro caso se evalúa El

 

 

 

Es equivalente a las sentencias IF-THEN-ELSE, pero para expresiones en lugar

de acciones.

 
Bibliografía

ACERA GARCÍA, Miguel Ángel: C/C++. Edición revisada y actualizada
2010. Anaya Multimedia, 2009

BALCAZAR, José Luis: Programación metódica. McGraw-Hill, 2001.

CEBALLOS SIERRA, Francisco Javier: C/C++ Curso de programación. Tercora edición. Editorial RA-MA, 2007.

DEITEL, Harvey M. y DEITEL, Paul J.: Como programar C++. PrenticeHall Mexico, 2003.

GARCÍA-BERMEJO, José Rafaol: Programa
Educacion. 2008

 

ión. estructurada en C. Pearson

JOYANES AGUILAR, Luis: Programación en C++. Algoritmos, estructuras
de datos y objetos. Segunda edición. McGraw-Hill, 2006.

KERNIGHAN, Brian W. y RITCHIE, Dennis M.: El lenguaje de programación
C. Segunda edición. Prentice-Hall Iberoamericana. 1991.

PEÑA MARÍ, Ricardo: Diseño de programas. Formalismo y abstracción.
Torcera edición. Pearson Educacion, 2005.

STROUSTRUP, Bjarne: El lenguaje de programación C++. Addison-Wosley
Iberoamericana, 2002.
Índice analítico

abstracción, 20, 181, 220, 239, 385,
402
de datos, 417, 423
funcional, 184, 186, 392, 417
acceso directo, 352
acceso secuencial, 352
acción, 20, 98, 181
abstracta, 186
compuesta, 20
parametrizada, 159, 186
primitiva, 20
acoplamiento, 405
agregado, 238
argumentos
formales, 155, 157, 161
reales, 157, 161
arquitectura Von Neumann, 16
array, 228, 289
aserciones, 137
autodecremento, 62, 110, 111
antoincremento, 62, 110

bases de datos relacionales, 303
biblioteca, 429

bloque de código, 154, 155, 165, 182
bucle, 100

buenas prácticas, 23, 445

búsqueda por dicotomía, 326
búsqueda secuencial, 321

cabecera de función, 154, 155
cabecera de programa, 82
cabecera de sección, 82

cabecera de subprograma, 165, 182,
412
cadena de caracteres, 31, 235
campos, 240
caracteres de control, 31
casos generales, 167
casos minimales, 167
centinela, 315, 328
charset, 37
claridad, 6
clase, 379
codepoint, 37
cohesión, 405
comentario, 46
comentarios al margen, 83
comentarios-orden, 82
compilación segura, 403, 416
compilación separada, 403
compilador, 9
complejidad algorítmica, 143
componentes, 227
comportamiento asintótico, 146
computador, 4
condiciones, 98
constante, 27, 54
con nombre, 54, 89
literal, 54
local, 155
simbólica, 54
contorno, 328
corrección, 6, 135, 315
corrección parcial, 136
 

464

Fundamentos de programación

 

corrección total, 136
cuerpo de función, 155
enrsor, 352

cálculo-A, 13

código de máquina, 7
cómputo, 3

dato, 27

dato abstracto, 392

dato complejo, 392

dato clemental, 392
declaración, 411

definición, 411

definición de tipos, 219
depuración, 135

desarrollo ascendente, 206
desarrollo descendente, 188, 392
descomposición modular, 404
diagramas de flujo, 98
diccionario, 303

directivas para el compilador, 45
discriminante, 298

doble referencia, 173

efectos secundarios, 169
eficiencia, 7, 142
eficiencia en tiempo, 143
ejecutar, 3
elección de nombres, 85
elemento

global, 165

local, 165
elementos privados, 408
elementos públicos, 407
encolumnado, 80
ensayo, 135
especificación, 182, 186, 402
especificación formal, 137, 183, 315
especificación informal, 183
esquema, 21, 76

de iteración, 121

de recorrido, 316

de selección, 120

secuencial, 76

típico de operación, 315
estructuras dinámicas, 352
evaluación en cortocircuito, 103
expresión

abstracta, 184

aritmética, 39, 103

condicional, 101

constante, 56

lógica, 102

parametrizada, 155, 185

fichero
de cabecera, 408
de implementación, 408
de interfaz, 408
fuente, 405
flujo de control, 98
formación, 227, 289, 299
fuerza bruta, 333
función, 154, 181
estándar, 158
predefinida, 157
pura, 169, 186

glifo, 37
gráficos de tortuga, 394

hardware, 4
herencia, 379

identificadores, 51
implementación, 182
ingeniería de software, 5, 23
inicializar, 60

inserción, 322

instrucción, 17

interfaz, 182, 402

intérprete, 10

invariante, 140, 141, 315, 317
Índice analítico

465

 

iteración, 21, 99, 100, 109, 110, 299
juego de caracteres, 31

lenguaje
de máquina, 7
de programación, 8
ensamblador, 21
fuente, 9
objeto, 9
lenguaje Ct, 25
librería, 429
librerías estándar, 158

mantisa, 30
Manual de Estilo, 23, 26, 41, 46, 52,
60, 63, 68, 80, 101, 105, 111,
163, 230, 241, 261, 373, 445

matrices, 288

orladas, 315, 330, 345
mayúsculas (en nombres), 88
metasímbolo, 27, 435
metodología de programación, 23
minúsculas (en nombres), 88
modelo abstracto de cómputo, 11
modelo de flujo de datos, 11
modelo de terminación, 213
máquina, 1

automática, 2

de programa almacenado, 4

no automática, 2

programable, 2

virtual, 1, 4, 10
método, 379
módulo, 206, 401

de librería, 42, 64

estándar, 162

principal, 407

notación BNF, 26, 435
notación UML, 422

objeto, 379
ocultación, 165, 183, 402, 403
operación, 181

abstracta, 188, 392

compleja, 188, 392

de escritura, 42

de lectura, 64

terminal, 188, 392
operador, 33, 39
operador unario, 103
operando, 39
orden de evaluación, 104
ordenación por inserción directa, 324
orientada a objetos, 379
overflow, 123

palabras clave, 53
palabras reservadas, 53
parámetros del programa, 89
paso de argumentos
por referencia, 162, 163
por valor, 162, 163
plataforma, 33
postcondición, 137, 315, 316
precondición, 137, 315, 316
predicados, 226
preproceso, 414
problemas intratables, 146
procedimiento, 42, 154, 159
estándar, 162
puro, 187
procesador, 20
procesadores de lenguajes, 9
programa, 2
fuente, 9
objeto, 9
principal, 154, 407
robusto, 210
programación, 5
a la defensiva, 211
declarativa, 15
 

466

Fundamentos de programación

 

estructurada, 21, 76, 97, 255, 258,
261, 263

funcional, 11, 12

imperativa, 11, 17

lógica, 11, 15

orientada a objetos, 11
prototipo, 412
proyectos, 416
punteros, 354

  
 

realización, 182, 186, 402

recorrido de matrices, 318

recursividad, 167, 359. 393, 394, 452

red de operadores, 13

redefinición de elementos, 171, 172

reducción, 12

reescritura, 13

refactorización, 429

ro s, 354

refinamientos sucesivos, 76, 98, 101,
152

registro, 239

registros con variantes, 298

regla de producción, 27

relación, 303

representación (de un valor), 28

reutilización, 199

  

secuencia, 21, 98, 99, 106, 299, 352
secuencia de escape, 31
selección, 21, 99, 100, 106, 299
selección en cascada, 108
semántica, 182

sentencia, 17

sentencia de asignación, 61
seudofunciones, 158
shadowing, 171

signatura, 166

sintaxis, 182

software, 4

string, 31, 235

 

subproblema, 151
subprograma, 151

tabla, 303
tamaño del problema, 143
terminación, 214
tipado fuerte, 62
tipo, 28
abstracto de datos, 28, 206, 378,
392
anónimo, 230, 241
booleano, 226
char, 37
definido, 32
enumerado, 222
escalar, 226
estructurado, 227
float, 35
int, 33
ordinal, 222
predefinido, 32
sinónimo, 220
vector, 229
transparencia referencial, 169, 185
tratamiento de la información, 3
tupla, 227, 238, 239, 299

unidad de compilación, 405, 406
unión, 295, 299

valor, 27
carácter, 31
entero, 29
real, 30
variable, 17, 56
dinámica, 354
local, 155
variante, 137, 141, 295, 315-317
vectores abiertos, 286
visibilidad, 165

 
